# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')

# Import the low-level C/C++ module
if __package__ or '.' in __name__:
    from . import _cmf_core
else:
    import _cmf_core

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _cmf_core.SWIG_PyInstanceMethod_New
_swig_new_static_method = _cmf_core.SWIG_PyStaticMethod_New

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if name == "thisown":
        return self.this.own(value)
    if name == "this":
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if not static:
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if name == "thisown":
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_SwigPyIterator
    value = _swig_new_instance_method(_cmf_core.SwigPyIterator_value)
    incr = _swig_new_instance_method(_cmf_core.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_cmf_core.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_cmf_core.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_cmf_core.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_cmf_core.SwigPyIterator_copy)
    next = _swig_new_instance_method(_cmf_core.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_cmf_core.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_cmf_core.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _cmf_core:
_cmf_core.SwigPyIterator_swigregister(SwigPyIterator)

class vector_int(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_cmf_core.vector_int_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_cmf_core.vector_int___nonzero__)
    __bool__ = _swig_new_instance_method(_cmf_core.vector_int___bool__)
    __len__ = _swig_new_instance_method(_cmf_core.vector_int___len__)
    __getslice__ = _swig_new_instance_method(_cmf_core.vector_int___getslice__)
    __setslice__ = _swig_new_instance_method(_cmf_core.vector_int___setslice__)
    __delslice__ = _swig_new_instance_method(_cmf_core.vector_int___delslice__)
    __delitem__ = _swig_new_instance_method(_cmf_core.vector_int___delitem__)
    __getitem__ = _swig_new_instance_method(_cmf_core.vector_int___getitem__)
    __setitem__ = _swig_new_instance_method(_cmf_core.vector_int___setitem__)
    pop = _swig_new_instance_method(_cmf_core.vector_int_pop)
    append = _swig_new_instance_method(_cmf_core.vector_int_append)
    empty = _swig_new_instance_method(_cmf_core.vector_int_empty)
    size = _swig_new_instance_method(_cmf_core.vector_int_size)
    swap = _swig_new_instance_method(_cmf_core.vector_int_swap)
    begin = _swig_new_instance_method(_cmf_core.vector_int_begin)
    end = _swig_new_instance_method(_cmf_core.vector_int_end)
    rbegin = _swig_new_instance_method(_cmf_core.vector_int_rbegin)
    rend = _swig_new_instance_method(_cmf_core.vector_int_rend)
    clear = _swig_new_instance_method(_cmf_core.vector_int_clear)
    get_allocator = _swig_new_instance_method(_cmf_core.vector_int_get_allocator)
    pop_back = _swig_new_instance_method(_cmf_core.vector_int_pop_back)
    erase = _swig_new_instance_method(_cmf_core.vector_int_erase)

    def __init__(self, *args):
        r"""
        __init__(vector_int self) -> vector_int
        __init__(vector_int self, vector_int other) -> vector_int
        __init__(vector_int self, std::vector< int >::size_type size) -> vector_int
        __init__(vector_int self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> vector_int
        """
        _cmf_core.vector_int_swiginit(self, _cmf_core.new_vector_int(*args))
    push_back = _swig_new_instance_method(_cmf_core.vector_int_push_back)
    front = _swig_new_instance_method(_cmf_core.vector_int_front)
    back = _swig_new_instance_method(_cmf_core.vector_int_back)
    assign = _swig_new_instance_method(_cmf_core.vector_int_assign)
    resize = _swig_new_instance_method(_cmf_core.vector_int_resize)
    insert = _swig_new_instance_method(_cmf_core.vector_int_insert)
    reserve = _swig_new_instance_method(_cmf_core.vector_int_reserve)
    capacity = _swig_new_instance_method(_cmf_core.vector_int_capacity)
    __swig_destroy__ = _cmf_core.delete_vector_int

# Register vector_int in _cmf_core:
_cmf_core.vector_int_swigregister(vector_int)

class vector_double(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_cmf_core.vector_double_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_cmf_core.vector_double___nonzero__)
    __bool__ = _swig_new_instance_method(_cmf_core.vector_double___bool__)
    __len__ = _swig_new_instance_method(_cmf_core.vector_double___len__)
    __getslice__ = _swig_new_instance_method(_cmf_core.vector_double___getslice__)
    __setslice__ = _swig_new_instance_method(_cmf_core.vector_double___setslice__)
    __delslice__ = _swig_new_instance_method(_cmf_core.vector_double___delslice__)
    __delitem__ = _swig_new_instance_method(_cmf_core.vector_double___delitem__)
    __getitem__ = _swig_new_instance_method(_cmf_core.vector_double___getitem__)
    __setitem__ = _swig_new_instance_method(_cmf_core.vector_double___setitem__)
    pop = _swig_new_instance_method(_cmf_core.vector_double_pop)
    append = _swig_new_instance_method(_cmf_core.vector_double_append)
    empty = _swig_new_instance_method(_cmf_core.vector_double_empty)
    size = _swig_new_instance_method(_cmf_core.vector_double_size)
    swap = _swig_new_instance_method(_cmf_core.vector_double_swap)
    begin = _swig_new_instance_method(_cmf_core.vector_double_begin)
    end = _swig_new_instance_method(_cmf_core.vector_double_end)
    rbegin = _swig_new_instance_method(_cmf_core.vector_double_rbegin)
    rend = _swig_new_instance_method(_cmf_core.vector_double_rend)
    clear = _swig_new_instance_method(_cmf_core.vector_double_clear)
    get_allocator = _swig_new_instance_method(_cmf_core.vector_double_get_allocator)
    pop_back = _swig_new_instance_method(_cmf_core.vector_double_pop_back)
    erase = _swig_new_instance_method(_cmf_core.vector_double_erase)

    def __init__(self, *args):
        r"""
        __init__(vector_double self) -> vector_double
        __init__(vector_double self, vector_double other) -> vector_double
        __init__(vector_double self, std::vector< double >::size_type size) -> vector_double
        __init__(vector_double self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vector_double
        """
        _cmf_core.vector_double_swiginit(self, _cmf_core.new_vector_double(*args))
    push_back = _swig_new_instance_method(_cmf_core.vector_double_push_back)
    front = _swig_new_instance_method(_cmf_core.vector_double_front)
    back = _swig_new_instance_method(_cmf_core.vector_double_back)
    assign = _swig_new_instance_method(_cmf_core.vector_double_assign)
    resize = _swig_new_instance_method(_cmf_core.vector_double_resize)
    insert = _swig_new_instance_method(_cmf_core.vector_double_insert)
    reserve = _swig_new_instance_method(_cmf_core.vector_double_reserve)
    capacity = _swig_new_instance_method(_cmf_core.vector_double_capacity)
    __swig_destroy__ = _cmf_core.delete_vector_double

# Register vector_double in _cmf_core:
_cmf_core.vector_double_swigregister(vector_double)

class vector_size_t(object):
    r"""Proxy of C++ std::vector< size_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_cmf_core.vector_size_t_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_cmf_core.vector_size_t___nonzero__)
    __bool__ = _swig_new_instance_method(_cmf_core.vector_size_t___bool__)
    __len__ = _swig_new_instance_method(_cmf_core.vector_size_t___len__)
    __getslice__ = _swig_new_instance_method(_cmf_core.vector_size_t___getslice__)
    __setslice__ = _swig_new_instance_method(_cmf_core.vector_size_t___setslice__)
    __delslice__ = _swig_new_instance_method(_cmf_core.vector_size_t___delslice__)
    __delitem__ = _swig_new_instance_method(_cmf_core.vector_size_t___delitem__)
    __getitem__ = _swig_new_instance_method(_cmf_core.vector_size_t___getitem__)
    __setitem__ = _swig_new_instance_method(_cmf_core.vector_size_t___setitem__)
    pop = _swig_new_instance_method(_cmf_core.vector_size_t_pop)
    append = _swig_new_instance_method(_cmf_core.vector_size_t_append)
    empty = _swig_new_instance_method(_cmf_core.vector_size_t_empty)
    size = _swig_new_instance_method(_cmf_core.vector_size_t_size)
    swap = _swig_new_instance_method(_cmf_core.vector_size_t_swap)
    begin = _swig_new_instance_method(_cmf_core.vector_size_t_begin)
    end = _swig_new_instance_method(_cmf_core.vector_size_t_end)
    rbegin = _swig_new_instance_method(_cmf_core.vector_size_t_rbegin)
    rend = _swig_new_instance_method(_cmf_core.vector_size_t_rend)
    clear = _swig_new_instance_method(_cmf_core.vector_size_t_clear)
    get_allocator = _swig_new_instance_method(_cmf_core.vector_size_t_get_allocator)
    pop_back = _swig_new_instance_method(_cmf_core.vector_size_t_pop_back)
    erase = _swig_new_instance_method(_cmf_core.vector_size_t_erase)

    def __init__(self, *args):
        r"""
        __init__(vector_size_t self) -> vector_size_t
        __init__(vector_size_t self, vector_size_t other) -> vector_size_t
        __init__(vector_size_t self, std::vector< size_t >::size_type size) -> vector_size_t
        __init__(vector_size_t self, std::vector< size_t >::size_type size, std::vector< size_t >::value_type const & value) -> vector_size_t
        """
        _cmf_core.vector_size_t_swiginit(self, _cmf_core.new_vector_size_t(*args))
    push_back = _swig_new_instance_method(_cmf_core.vector_size_t_push_back)
    front = _swig_new_instance_method(_cmf_core.vector_size_t_front)
    back = _swig_new_instance_method(_cmf_core.vector_size_t_back)
    assign = _swig_new_instance_method(_cmf_core.vector_size_t_assign)
    resize = _swig_new_instance_method(_cmf_core.vector_size_t_resize)
    insert = _swig_new_instance_method(_cmf_core.vector_size_t_insert)
    reserve = _swig_new_instance_method(_cmf_core.vector_size_t_reserve)
    capacity = _swig_new_instance_method(_cmf_core.vector_size_t_capacity)
    __swig_destroy__ = _cmf_core.delete_vector_size_t

# Register vector_size_t in _cmf_core:
_cmf_core.vector_size_t_swigregister(vector_size_t)

SHARED_PTR_DISOWN = _cmf_core.SHARED_PTR_DISOWN

get_parallel_threads = _cmf_core.get_parallel_threads
set_parallel_threads = _cmf_core.set_parallel_threads
class cubicspline(object):
    r"""


    Interpolates points with a cubic spline interpolation.

    Code is modified
    after:http://ganeshtiwaridotcomdotnp.blogspot.de/2009/12/c-c-code-
    cubic- spline-interpolation.html

    C++ includes: spline.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(cubicspline self, cmf::math::num_array const & x, cmf::math::num_array const & y) -> cubicspline
        cubicspline(const cmf::math::num_array &x, const cmf::math::num_array
        &y) 
        """
        _cmf_core.cubicspline_swiginit(self, _cmf_core.new_cubicspline(*args, **kwargs))
    generate = _swig_new_instance_method(_cmf_core.cubicspline_generate)
    size = _swig_new_instance_method(_cmf_core.cubicspline_size)
    __call__ = _swig_new_instance_method(_cmf_core.cubicspline___call__)
    __swig_destroy__ = _cmf_core.delete_cubicspline

# Register cubicspline in _cmf_core:
_cmf_core.cubicspline_swigregister(cubicspline)

class point(object):
    r"""


    2D-Point Class.

    Used as location property anywhere in the text Calculation of
    distances

    +,-,-=,*= Operators overloaded

    C++ includes: geometry.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = property(_cmf_core.point_x_get, _cmf_core.point_x_set, doc=r"""x : double""")
    y = property(_cmf_core.point_y_get, _cmf_core.point_y_set, doc=r"""y : double""")
    z = property(_cmf_core.point_z_get, _cmf_core.point_z_set, doc=r"""z : double""")

    def __init__(self, *args):
        r"""
        __init__(point self) -> point
        __init__(point self, point p) -> point
        __init__(point self, double x_, double y_, double z_=0.0) -> point
        point(double x_,
        double y_, double z_=0.0)

        Creates a point from two doubles. 
        """
        _cmf_core.point_swiginit(self, _cmf_core.new_point(*args))
    distanceTo = _swig_new_instance_method(_cmf_core.point_distanceTo)
    z_weight_distance = _swig_new_instance_method(_cmf_core.point_z_weight_distance)
    distance3DTo = _swig_new_instance_method(_cmf_core.point_distance3DTo)
    distance = _swig_new_static_method(_cmf_core.point_distance)
    distance_max = _swig_new_instance_method(_cmf_core.point_distance_max)
    azimuth = _swig_new_instance_method(_cmf_core.point_azimuth)
    angleToXAxis = _swig_new_instance_method(_cmf_core.point_angleToXAxis)
    sum = _swig_new_instance_method(_cmf_core.point_sum)
    length = _swig_new_instance_method(_cmf_core.point_length)
    __add__ = _swig_new_instance_method(_cmf_core.point___add__)
    __iadd__ = _swig_new_instance_method(_cmf_core.point___iadd__)
    __sub__ = _swig_new_instance_method(_cmf_core.point___sub__)
    __isub__ = _swig_new_instance_method(_cmf_core.point___isub__)
    __mul__ = _swig_new_instance_method(_cmf_core.point___mul__)
    __imul__ = _swig_new_instance_method(_cmf_core.point___imul__)

    def __truediv__(self, *args):
        return _cmf_core.point___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv__(self, *args):
        return _cmf_core.point___itruediv__(self, *args)
    __idiv__ = __itruediv__


    __eq__ = _swig_new_instance_method(_cmf_core.point___eq__)
    __ne__ = _swig_new_instance_method(_cmf_core.point___ne__)
    __len__ = _swig_new_instance_method(_cmf_core.point___len__)
    __rmul__ = _swig_new_instance_method(_cmf_core.point___rmul__)
    __rdiv__ = _swig_new_instance_method(_cmf_core.point___rdiv__)

    def __getitem__(self,index) :
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(self)))]
        if index==0 :
            return self.x
        elif index==1 :
            return self.y
        elif index==2 :
            return self.z
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __setitem__(self,index,value) :
        if index==0 :
            self.x=value
        elif index==1 :
            self.y=value
        elif index==2 :
            self.z=value
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z
    def __repr__(self):
        return 'cmf.point(%g,%g,%g)' % (self.x,self.y,self.z)

    __swig_destroy__ = _cmf_core.delete_point

# Register point in _cmf_core:
_cmf_core.point_swigregister(point)
cvar = _cmf_core.cvar
PI = cvar.PI
point_distance = _cmf_core.point_distance

dot = _cmf_core.dot
distance = _cmf_core.distance
class point_vector(object):
    r"""


    Holds three arrays x,y and z for fast access of point coordinates.

    C++ includes: geometry.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    X = property(_cmf_core.point_vector_X_get, _cmf_core.point_vector_X_set, doc=r"""X : cmf::math::num_array""")
    Y = property(_cmf_core.point_vector_Y_get, _cmf_core.point_vector_Y_set, doc=r"""Y : cmf::math::num_array""")
    Z = property(_cmf_core.point_vector_Z_get, _cmf_core.point_vector_Z_set, doc=r"""Z : cmf::math::num_array""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(point_vector self, ptrdiff_t size) -> point_vector
        point_vector(ptrdiff_t size)

        Create a point vector of a specific size. 
        """
        _cmf_core.point_vector_swiginit(self, _cmf_core.new_point_vector(*args, **kwargs))
    get = _swig_new_instance_method(_cmf_core.point_vector_get)
    set = _swig_new_instance_method(_cmf_core.point_vector_set)
    size = _swig_new_instance_method(_cmf_core.point_vector_size)
    __swig_destroy__ = _cmf_core.delete_point_vector

# Register point_vector in _cmf_core:
_cmf_core.point_vector_swigregister(point_vector)


import datetime
import struct

minimum = _cmf_core.minimum
maximum = _cmf_core.maximum
minmax = _cmf_core.minmax
mean = _cmf_core.mean
geo_mean = _cmf_core.geo_mean
harmonic_mean = _cmf_core.harmonic_mean
piecewise_linear = _cmf_core.piecewise_linear
boltzmann = _cmf_core.boltzmann
sign = _cmf_core.sign
square = _cmf_core.square
JULIANDAY_0_1_1900 = _cmf_core.JULIANDAY_0_1_1900

class Time(object):
    r"""


    A time class, used to pass around current modelling times.

    Timespans and dates in cmf are used with a special object, called
    Time. An extra class has the advantage, that the user does not have to
    remember, which unit of time he or she uses or what time unit is
    accepted by a specific function of the model. Arithmetic and boolean
    operators are supported by Time. Internally the time classes stores
    the time as integer milliseconds, therefore rounding issues will only
    appear at very small time ranges. Absolute time (like dates) are
    represented as milliseconds gone by from Dec, 31st 1899. Microsoft
    Excel dates are represented as days from that time, using floating
    point numbers, therefore it is very simple to convert Excel time
    representations to cmf time.

    Another object is Date, which is doesn't provide the operators, but
    has a nice printed version and some special date functions, like day
    of year (DOY) and provides access to the current hour of day and so
    on, which only applyto dates and not to time spans. You can convert
    Time to Date an vice versa. The printing is not culture aware and uses
    the European representation. If you use the Python standard library
    datetime, conversion between Python time and cmf time is possible

    Creating absolute time values (dates) Creating time spans

    In principle, there are three ways to create time spans. One is to use
    one of the static functions, another is to multiply an existing time
    span (like one of the build in constants) or to substrate two absolute
    times.

    Available constants  : 4.1 seconds

    : 2.3 hours (138 min)

    : 2.3 hours (138 min)

    : 60 hours (2.5 days)

    : 7 days

    : 365/12 days (30.4167 days)

    : 365 days

    Available operators:

    time + time = time, time - time = time

    time * float = time ,time / float = time

    time/time=float

    >, <, ==, !=

    Conversions

    Converting to python datetime

    Converting to numbers

    t.AsMilliseconds()

    t.AsSeconds()

    t.AsMinutes()

    t.AsHours()

    t.AsDays()

    t.AsYears()

    Creating time ranges

    C++ includes: time.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ms_per_day = _cmf_core.Time_ms_per_day
    

    def __init__(self, *args):
        r"""
        __init__(Time self, int day, int month, int year, int hour=0, int minute=0, int second=0, int ms=0) -> Time
        __init__(Time self, Date date) -> Time
        __init__(Time self, Time t) -> Time
        __init__(Time self) -> Time
        __init__(Time self, long long milliseconds) -> Time
        Time(long long
        milliseconds) 
        """
        _cmf_core.Time_swiginit(self, _cmf_core.new_Time(*args))
    AsDays = _swig_new_instance_method(_cmf_core.Time_AsDays)
    AsHours = _swig_new_instance_method(_cmf_core.Time_AsHours)
    AsMinutes = _swig_new_instance_method(_cmf_core.Time_AsMinutes)
    AsSeconds = _swig_new_instance_method(_cmf_core.Time_AsSeconds)
    AsMilliseconds = _swig_new_instance_method(_cmf_core.Time_AsMilliseconds)
    AsDate = _swig_new_instance_method(_cmf_core.Time_AsDate)
    to_string = _swig_new_instance_method(_cmf_core.Time_to_string)
    is_not_0 = _swig_new_instance_method(_cmf_core.Time_is_not_0)
    DOY = _swig_new_instance_method(_cmf_core.Time_DOY)
    __add__ = _swig_new_instance_method(_cmf_core.Time___add__)
    __sub__ = _swig_new_instance_method(_cmf_core.Time___sub__)
    __iadd__ = _swig_new_instance_method(_cmf_core.Time___iadd__)
    __isub__ = _swig_new_instance_method(_cmf_core.Time___isub__)
    __mod__ = _swig_new_instance_method(_cmf_core.Time___mod__)
    __mul__ = _swig_new_instance_method(_cmf_core.Time___mul__)
    __imul__ = _swig_new_instance_method(_cmf_core.Time___imul__)

    def __itruediv__(self, *args):
        return _cmf_core.Time___itruediv__(self, *args)
    __idiv__ = __itruediv__


    __imod__ = _swig_new_instance_method(_cmf_core.Time___imod__)

    def __truediv__(self, *args):
        return _cmf_core.Time___truediv__(self, *args)
    __div__ = __truediv__


    times_in = _swig_new_instance_method(_cmf_core.Time_times_in)
    __lt__ = _swig_new_instance_method(_cmf_core.Time___lt__)
    __gt__ = _swig_new_instance_method(_cmf_core.Time___gt__)
    __le__ = _swig_new_instance_method(_cmf_core.Time___le__)
    __ge__ = _swig_new_instance_method(_cmf_core.Time___ge__)
    __eq__ = _swig_new_instance_method(_cmf_core.Time___eq__)
    __ne__ = _swig_new_instance_method(_cmf_core.Time___ne__)

    def __repr__(self):
        if self>year*40:
            return self.AsDate().to_string()
        else:
            return self.to_string()

    def __nonzero__(self):
        return self.is_not_0()

    def __rmul__(self,other):
        return self*other

    def __radd__(self,other):
        return self + other

    def AsPython(self):
        """Deprecated function name, use as_datetime as equivalent"""
        d=self.AsDate()
        return datetime.datetime(d.year, d.month, d.day, d.hour, d.minute, d.second, d.ms*1000)

    def __getstate__(self):
        return self.AsMilliseconds()

    def __setstate__(self, data):
        self.__init__(data)

    def as_datetime(self):
        d=self.AsDate()
        return datetime.datetime(d.year,d.month,d.day,d.hour,d.minute,d.second,d.ms*1000)

    def as_timedelta(self):
        return datetime.timedelta(milliseconds=self.AsMilliseconds())

    year   = property(lambda self: self.AsDate().year)
    month  = property(lambda self: self.AsDate().month)
    day    = property(lambda self: self.AsDate().day)
    hour   = property(lambda self: self.AsDate().hour)
    minute = property(lambda self: self.AsDate().minute)
    second = property(lambda self: self.AsDate().second)
    ms     = property(lambda self: self.AsDate().ms)

    __swig_destroy__ = _cmf_core.delete_Time

# Register Time in _cmf_core:
_cmf_core.Time_swigregister(Time)
Debug = cvar.Debug
__compiledate__ = cvar.__compiledate__
Pi = cvar.Pi

class Date(object):
    r"""


    An absolute time, not for calculation. Date and Time are
    interchangable.

    C++ includes: time.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    year = property(_cmf_core.Date_year_get, _cmf_core.Date_year_set, doc=r"""year : int""")
    month = property(_cmf_core.Date_month_get, _cmf_core.Date_month_set, doc=r"""month : int""")
    day = property(_cmf_core.Date_day_get, _cmf_core.Date_day_set, doc=r"""day : int""")
    hour = property(_cmf_core.Date_hour_get, _cmf_core.Date_hour_set, doc=r"""hour : int""")
    minute = property(_cmf_core.Date_minute_get, _cmf_core.Date_minute_set, doc=r"""minute : int""")
    second = property(_cmf_core.Date_second_get, _cmf_core.Date_second_set, doc=r"""second : int""")
    ms = property(_cmf_core.Date_ms_get, _cmf_core.Date_ms_set, doc=r"""ms : int""")

    def __init__(self, *args):
        r"""
        __init__(Date self, int _day, int _month, int _year, int _hour=0, int _minute=0, int _second=0, int _ms=0) -> Date
        __init__(Date self, Time time) -> Date
        Date(const Time &time)

        Creates a new date from time (based on the 31.12.1899, like in
        Excel(TM)) 
        """
        _cmf_core.Date_swiginit(self, _cmf_core.new_Date(*args))
    ToTime = _swig_new_instance_method(_cmf_core.Date_ToTime)
    DOY = _swig_new_instance_method(_cmf_core.Date_DOY)
    to_string = _swig_new_instance_method(_cmf_core.Date_to_string)

    def __repr__(self):
        return self.to_string()

    def __getstate__(self):
        return Date.ToTime().__getstate__()

    def __setstate__(self, data):
        t = cmf.Time(data)
        self.__init__(t)

    def AsPython(self):
        return datetime.datetime(self.year,self.month,self.day,self.hour,self.minute,self.second,self.ms*1000)

    def as_datetime(self):
        return datetime.datetime(self.year,self.month,self.day,self.hour,self.minute,self.second,self.ms*1000)

    __swig_destroy__ = _cmf_core.delete_Date

# Register Date in _cmf_core:
_cmf_core.Date_swigregister(Date)

class timeseries(object):
    r"""


    A timeseries is a list of values, equally distributed over time.

    To create one, one have to provide as start date and a step size. The
    end time is calculated from the number of values. Values queried for
    times before the start time are returned as the first item, values
    after the end time equal the last item. A timeseries with only one
    item reacts like a scalar value.

    Creating a time series

    With this technique it is simple to read files or databases to fill
    timeseries.<b> Using a timeseries</b>

    C++ includes: timeseries.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    set_begin = _swig_new_instance_method(_cmf_core.timeseries_set_begin)
    set_step = _swig_new_instance_method(_cmf_core.timeseries_set_step)
    interpolationpower = _swig_new_instance_method(_cmf_core.timeseries_interpolationpower)
    set_interpolationpower = _swig_new_instance_method(_cmf_core.timeseries_set_interpolationpower)
    add = _swig_new_instance_method(_cmf_core.timeseries_add)
    is_empty = _swig_new_instance_method(_cmf_core.timeseries_is_empty)
    clear = _swig_new_instance_method(_cmf_core.timeseries_clear)
    adress = _swig_new_instance_method(_cmf_core.timeseries_adress)
    as_array = _swig_new_instance_method(_cmf_core.timeseries_as_array)
    copy = _swig_new_instance_method(_cmf_core.timeseries_copy)
    size = _swig_new_instance_method(_cmf_core.timeseries_size)
    count_values = _swig_new_instance_method(_cmf_core.timeseries_count_values)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(timeseries self, Time begin=cmf::math::Time(), Time step=day, int interpolationmethod=1, size_t count=0) -> timeseries
        timeseries(const cmf::math::timeseries &ts) 
        """
        _cmf_core.timeseries_swiginit(self, _cmf_core.new_timeseries(*args, **kwargs))
    from_array = _swig_new_static_method(_cmf_core.timeseries_from_array)
    from_scalar = _swig_new_static_method(_cmf_core.timeseries_from_scalar)
    from_file = _swig_new_static_method(_cmf_core.timeseries_from_file)
    get_t = _swig_new_instance_method(_cmf_core.timeseries_get_t)
    get_i = _swig_new_instance_method(_cmf_core.timeseries_get_i)
    set_t = _swig_new_instance_method(_cmf_core.timeseries_set_t)
    set_i = _swig_new_instance_method(_cmf_core.timeseries_set_i)
    get_slice = _swig_new_instance_method(_cmf_core.timeseries_get_slice)
    set_slice = _swig_new_instance_method(_cmf_core.timeseries_set_slice)
    remove_nodata = _swig_new_instance_method(_cmf_core.timeseries_remove_nodata)
    __iadd__ = _swig_new_instance_method(_cmf_core.timeseries___iadd__)
    __isub__ = _swig_new_instance_method(_cmf_core.timeseries___isub__)
    __imul__ = _swig_new_instance_method(_cmf_core.timeseries___imul__)

    def __itruediv__(self, *args):
        return _cmf_core.timeseries___itruediv__(self, *args)
    __idiv__ = __itruediv__


    __add__ = _swig_new_instance_method(_cmf_core.timeseries___add__)
    __sub__ = _swig_new_instance_method(_cmf_core.timeseries___sub__)
    __mul__ = _swig_new_instance_method(_cmf_core.timeseries___mul__)

    def __truediv__(self, *args):
        return _cmf_core.timeseries___truediv__(self, *args)
    __div__ = __truediv__


    __neg__ = _swig_new_instance_method(_cmf_core.timeseries___neg__)
    inv = _swig_new_instance_method(_cmf_core.timeseries_inv)
    reduce_min = _swig_new_instance_method(_cmf_core.timeseries_reduce_min)
    reduce_max = _swig_new_instance_method(_cmf_core.timeseries_reduce_max)
    reduce_sum = _swig_new_instance_method(_cmf_core.timeseries_reduce_sum)
    reduce_avg = _swig_new_instance_method(_cmf_core.timeseries_reduce_avg)
    floating_avg = _swig_new_instance_method(_cmf_core.timeseries_floating_avg)
    floating_max = _swig_new_instance_method(_cmf_core.timeseries_floating_max)
    floating_min = _swig_new_instance_method(_cmf_core.timeseries_floating_min)
    mean = _swig_new_instance_method(_cmf_core.timeseries_mean)
    min = _swig_new_instance_method(_cmf_core.timeseries_min)
    max = _swig_new_instance_method(_cmf_core.timeseries_max)
    log = _swig_new_instance_method(_cmf_core.timeseries_log)
    log10 = _swig_new_instance_method(_cmf_core.timeseries_log10)
    power = _swig_new_instance_method(_cmf_core.timeseries_power)
    exp = _swig_new_instance_method(_cmf_core.timeseries_exp)
    begin = property(_cmf_core.timeseries_begin_get, doc=r"""
    begin : cmf::math::Time
    cmf::math::Time
    begin() const

    First date of measurement. 
    """)
    step = property(_cmf_core.timeseries_step_get, doc=r"""
    step : cmf::math::Time
    cmf::math::Time
    step() const

    Time between the measurements. 
    """)
    end = property(_cmf_core.timeseries_end_get, doc=r"""
    end : cmf::math::Time
    cmf::math::Time
    end() const

    Last date of measurements. 
    """)
    __len__ = _swig_new_instance_method(_cmf_core.timeseries___len__)

    def __repr__(self):
       return "cmf.timeseries(%s:%s:%s,count=%i)" % (self.begin,self.end,self.step,self.size())

    def extend(self,list) :
        """ Adds the values of a sequence to the timeseries"""
        for item in list :
            self.add(float(item))

    def __getitem__(self,index):
        if isinstance(index,int):
            return self.get_i(index)
        elif isinstance(index,slice):
            if index.step:
                return self.get_slice(index.start,index.stop,index.step)
            else:
                return self.get_slice(index.start,index.stop)
        else:
            return self.get_t(index)

    def __setitem__(self,index,value):
        if isinstance(index,int):
            self.set_i(index,value)
        elif isinstance(index,slice):
            if index.step:
                raise ValueError("Slices must be continous, when used for setting")
            else:
                if not isinstance(value,timeseries):
                    value=timeseries(value)
                self.set_slice(index.start,index.stop,value)
        else:
            self.set_t(index,value)

    def __iter__(self):
        for i in range(self.size()):
            yield self.get_i(i)

    def interpolate(self,begin,end,step):
        """ Returns a generator returning the interpolated values at the timesteps """
        if step>self.step():
            ts=self.reduce_avg(begin,step)
        else:
            ts=self
        for t in timerange(step,end,step):
            yield ts[t]

    def __radd__(self,other):
        return self + other

    def __rmul__(self,other):
        return self + other

    def __rsub__(self,other):
        res=-self
        res+=other
        return res

    def __rdiv__(self,other):
        res=self.inv() 
        res*=other
        return res

    def iter_time(self):
        """
        Returns an iterator to iterate over each timestep
        """
        for i in range(len(self)):
            yield self.begin + self.step * i

    def to_buffer(self):
        """Returns a binary buffer filled with the data of self"""
        return struct.pack('qqqq{}d'.format(self.size()), self.size(), self.begin.AsMilliseconds(),self.step.AsMilliseconds(),self.interpolationpower(), *self)

    def to_file(self,f):
        """ Saves a timeseries in a special binary format.
        The format consists of 4 integers with 64 bit, indicating the milliseconds after the 31.12.1899 00:00 of the beginning of the timeseries, the milliseconds of the time step,
        the interpolation power and the number of values. The following 64 bit floats, are the values of the timeseries
        """
        if isinstance(f,str):
            f=open(f,'wb')
        elif not hasattr(f,'write'):
            raise TypeError("The file f must be either an object providing a write method, like a file, or a valid file name")
        f.write(self.to_buffer())

    def __getstate__(self):
        return dict(size=len(self),
                    begin=self.begin.AsMilliseconds(),
                    step=self.step.AsMilliseconds(),
                    interpolationpower=self.interpolationpower(),
                    values=self.as_array()
                    )

    def __setstate__(self, data):
        begin = ms * data['begin']
        step = ms * data['step']
        self.__init__(begin, step, data['interpolationpower'])
        self.extend(data['values'])

    def to_pandas(self):
        """
        Returns the timeseries as a pandas Series object
        :return: A pandas.Series object with the timesteps as index
        """
        import pandas as pd
        import numpy as np

        return pd.Series(data=self.as_array(),index=(t.AsPython() for t in self.iter_time()))

    @classmethod
    def from_sequence(cls, begin, step, sequence, interpolation_mode=1):
        res=cls(begin,step,interpolation_mode)
        res.extend(sequence)
        return res

    @classmethod
    def from_buffer(cls,buf):
        import numpy as np
        header_length=struct.calcsize('qqqq') 
        header=struct.unpack('qqqq',buf[:header_length])
        res=cls(header[1]*ms,header[2]*ms,header[3])
        res.extend(np.fromstring(buf[header_length:], dtype=float))
        return res

    @classmethod
    def from_file(cls,f):
        """ Loads a timeseries saved with to_file from a file 
        Description of the file layout:
        byte: 
        0   Number of (int64)
        8   Begin of timeseries (in ms since 31.12.1899 00:00) (int64)
        16  Step size of timeseries (in ms) (int64)
        24  Interpolation power (int64)
        32  First value of timeseries (float64)
        """
        if isinstance(f,str):
            f=open(f,'rb')
        elif not hasattr(f,'read'):
            raise TypeError("The file f must either implement a 'read' method, like a file, or must be a vild file name")
        header_length=struct.calcsize('qqqq') 
        header=struct.unpack('qqqq',f.read(header_length))
        res=cls(header[1]*ms,header[2]*ms,header[3])
        res.extend(struct.unpack('%id' % header[0],f.read(-1)))
        return res

    __swig_destroy__ = _cmf_core.delete_timeseries

# Register timeseries in _cmf_core:
_cmf_core.timeseries_swigregister(timeseries)
ms = cvar.ms
sec = cvar.sec
min = cvar.min
h = cvar.h
day = cvar.day
week = cvar.week
year = cvar.year
month = cvar.month
never = cvar.never
timeseries_from_array = _cmf_core.timeseries_from_array
timeseries_from_scalar = _cmf_core.timeseries_from_scalar
timeseries_from_file = _cmf_core.timeseries_from_file

nash_sutcliffe = _cmf_core.nash_sutcliffe

def AsCMFtime(date):
    """Converts a python datetime to cmf.Time"""
    return Time(date.day, date.month, date.year, date.hour, date.minute, date.second, date.microsecond / 1000)

def timerange(start,end,step=day):
    """Creates a generator of cmf.Time, similar to the Python range function"""
    for x in range(0, int((end - start) / step)):
        yield start + step * x


class integratable(object):
    r"""


    integratable is a functionality for different classes for integrating
    values over time.

    Main usage of an integratable is the calculation of average fluxes
    over time e.g. 

    .. math::


        \\int_{t_0}^{t_{end}}q\\left(t,V_i,V_j\\right)dt 

    C++ includes: statevariable.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    integrate = _swig_new_instance_method(_cmf_core.integratable_integrate)
    reset = _swig_new_instance_method(_cmf_core.integratable_reset)
    sum = _swig_new_instance_method(_cmf_core.integratable_sum)
    avg = _swig_new_instance_method(_cmf_core.integratable_avg)
    __swig_destroy__ = _cmf_core.delete_integratable

# Register integratable in _cmf_core:
_cmf_core.integratable_swigregister(integratable)

class integratable_list(object):
    r"""


    A list of cmf::math::integratable objects.

    Todo TODO: Complete collection interface (getitem with slicing etc.)

    C++ includes: statevariable.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    append = _swig_new_instance_method(_cmf_core.integratable_list_append)
    remove = _swig_new_instance_method(_cmf_core.integratable_list_remove)
    __getitem = _swig_new_instance_method(_cmf_core.integratable_list___getitem)
    size = _swig_new_instance_method(_cmf_core.integratable_list_size)
    avg = _swig_new_instance_method(_cmf_core.integratable_list_avg)
    sum = _swig_new_instance_method(_cmf_core.integratable_list_sum)
    reset = _swig_new_instance_method(_cmf_core.integratable_list_reset)
    integrate = _swig_new_instance_method(_cmf_core.integratable_list_integrate)

    def __init__(self, *args):
        r"""
        __init__(integratable_list self) -> integratable_list
        __init__(integratable_list self, integratable_list for_copy) -> integratable_list
        integratable_list(const integratable_list &for_copy) 
        """
        _cmf_core.integratable_list_swiginit(self, _cmf_core.new_integratable_list(*args))
    __len__ = _swig_new_instance_method(_cmf_core.integratable_list___len__)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __getitem__(self,index):
        if isinstance(index,slice):
            return [self.__getitem(i) for i in range(*index.indices(len(self)))]
        else:
            try:
                it=iter(index)
                return [self.__getitem(i) for i in it]
            except:
                return self.__getitem(index)

    __swig_destroy__ = _cmf_core.delete_integratable_list

# Register integratable_list in _cmf_core:
_cmf_core.integratable_list_swigregister(integratable_list)

class StateVariable(object):
    r"""


    Abstract class state variable.

    Simple exponential system class header implementing a state variable:

    C++ includes: statevariable.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    dxdt = _swig_new_instance_method(_cmf_core.StateVariable_dxdt)
    get_abs_errtol = _swig_new_instance_method(_cmf_core.StateVariable_get_abs_errtol)
    to_string = _swig_new_instance_method(_cmf_core.StateVariable_to_string)
    __swig_destroy__ = _cmf_core.delete_StateVariable
    state = property(_cmf_core.StateVariable_state_get, _cmf_core.StateVariable_state_set, doc=r"""state : real""")

    def __repr__(self): 
        return self.to_string()


# Register StateVariable in _cmf_core:
_cmf_core.StateVariable_swigregister(StateVariable)

class StateVariableOwner(object):
    r"""


    An abstract class, that owns one or more state variables, that can add
    them to a vector of state variables in a certain order.

    C++ includes: statevariable.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    get_states = _swig_new_instance_method(_cmf_core.StateVariableOwner_get_states)
    __swig_destroy__ = _cmf_core.delete_StateVariableOwner

# Register StateVariableOwner in _cmf_core:
_cmf_core.StateVariableOwner_swigregister(StateVariableOwner)

class StateVariableList(StateVariableOwner):
    r"""Proxy of C++ cmf::math::StateVariableList class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    append = _swig_new_instance_method(_cmf_core.StateVariableList_append)
    extend = _swig_new_instance_method(_cmf_core.StateVariableList_extend)
    __iadd__ = _swig_new_instance_method(_cmf_core.StateVariableList___iadd__)
    size = _swig_new_instance_method(_cmf_core.StateVariableList_size)
    __swig_destroy__ = _cmf_core.delete_StateVariableList
    __len__ = _swig_new_instance_method(_cmf_core.StateVariableList___len__)

    def __init__(self, *args, **kwargs):
        r"""__init__(StateVariableList self) -> StateVariableList"""
        _cmf_core.StateVariableList_swiginit(self, _cmf_core.new_StateVariableList(*args, **kwargs))

# Register StateVariableList in _cmf_core:
_cmf_core.StateVariableList_swigregister(StateVariableList)

class Adsorption(object):
    r"""


    Abstract class to use adsorption process for tracers on surfaces.

    Use the derived classes to use a certain isotherm

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    freesolute = _swig_new_instance_method(_cmf_core.Adsorption_freesolute)
    totalsolute = _swig_new_instance_method(_cmf_core.Adsorption_totalsolute)
    copy = _swig_new_instance_method(_cmf_core.Adsorption_copy)
    __swig_destroy__ = _cmf_core.delete_Adsorption

# Register Adsorption in _cmf_core:
_cmf_core.Adsorption_swigregister(Adsorption)

class NullAdsorption(Adsorption):
    r"""


    A class for tracers without interaction with the storage container.
    freesolute returns xt.

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    copy = _swig_new_instance_method(_cmf_core.NullAdsorption_copy)
    __swig_destroy__ = _cmf_core.delete_NullAdsorption

    def __init__(self, *args, **kwargs):
        r"""__init__(NullAdsorption self) -> NullAdsorption"""
        _cmf_core.NullAdsorption_swiginit(self, _cmf_core.new_NullAdsorption(*args, **kwargs))

# Register NullAdsorption in _cmf_core:
_cmf_core.NullAdsorption_swigregister(NullAdsorption)

class LinearAdsorption(Adsorption):
    r"""


    This class calculates the adsorption equilibrium between sorbat and
    sorbent using the linear (Henry) isotherme.

    Linear (Henry) isotherme:



    .. math::

        \\frac{x_{ad}}{m} = K c

    where  :math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}` is the total tracer
    mass

    :math:`x_{free}` is the dissolved tracer mass

    :math:`m` is the mass of the sorbent in the same unit as the tracer mass

    :math:`K` is the Henry sorption coefficient

    :math:`c = \\frac{x_{free}}{V}` is the concentration of the tracer in
    tracer mass per m3

    CMF stores in a solute storage the total mass of a tracer and needs to
    calculate the free tracer mass. Calculating :math:`x_{free}` from :math:`x_{tot}`
    gives from the eq. above: 

    .. math::

        x_{free} = x_{tot} \\frac{V}{K m +
        V}

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    K = property(_cmf_core.LinearAdsorption_K_get, _cmf_core.LinearAdsorption_K_set, doc=r"""K : real""")
    m = property(_cmf_core.LinearAdsorption_m_get, _cmf_core.LinearAdsorption_m_set, doc=r"""m : real""")

    def __init__(self, *args):
        r"""
        __init__(LinearAdsorption self, real K, real m) -> LinearAdsorption
        __init__(LinearAdsorption self, LinearAdsorption other) -> LinearAdsorption
        LinearAdsorption(const LinearAdsorption &other) 
        """
        _cmf_core.LinearAdsorption_swiginit(self, _cmf_core.new_LinearAdsorption(*args))
    copy = _swig_new_instance_method(_cmf_core.LinearAdsorption_copy)
    __swig_destroy__ = _cmf_core.delete_LinearAdsorption

# Register LinearAdsorption in _cmf_core:
_cmf_core.LinearAdsorption_swigregister(LinearAdsorption)

class FreundlichAdsorbtion(Adsorption):
    r"""


    This class calculates the adsorption equilibrium between sorbat and
    sorbent using the Freundlich isotherme.

    Freundlich isotherme:



    .. math::

        \\frac{x_{ad}}{m} = K c^n

    where  :math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}` is the total tracer
    mass

    :math:`x_{free}` is the dissolved tracer mass

    :math:`m` is the mass of the sorbent in the same unit as the tracer mass

    :math:`K` is the Freundlich sorption coefficient

    :math:`c = \\frac{x_{free}}{V}` is the concentration of the tracer in
    tracer mass per m3

    :math:`n` is the Freundlich exponent

    CMF stores in a solute storage the total mass of a tracer and needs to
    calculate the free tracer mass. The eq. above can not be rearanged to
    get :math:`x_{free}` from :math:`x_{tot}`. Instead, the value is iterated
    usingregula falsi. If n is near to 1, using LinearAdsorption will
    speed up your calculations.Todo Check if an analytical solution is
    available The simplest physically based adsorption model by Langmuir (
    LangmuirAdsorption) has also a analytical solution and is hence
    calculated faster then Freundlich.

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    K = property(_cmf_core.FreundlichAdsorbtion_K_get, _cmf_core.FreundlichAdsorbtion_K_set, doc=r"""K : real""")
    n = property(_cmf_core.FreundlichAdsorbtion_n_get, _cmf_core.FreundlichAdsorbtion_n_set, doc=r"""n : real""")
    m = property(_cmf_core.FreundlichAdsorbtion_m_get, _cmf_core.FreundlichAdsorbtion_m_set, doc=r"""m : real""")
    epsilon = property(_cmf_core.FreundlichAdsorbtion_epsilon_get, _cmf_core.FreundlichAdsorbtion_epsilon_set, doc=r"""epsilon : real""")
    maxiter = property(_cmf_core.FreundlichAdsorbtion_maxiter_get, _cmf_core.FreundlichAdsorbtion_maxiter_set, doc=r"""maxiter : int""")

    def __init__(self, *args):
        r"""
        __init__(FreundlichAdsorbtion self, real K, real n, real m, real epsilon=1e-12, int maxiter=100) -> FreundlichAdsorbtion
        __init__(FreundlichAdsorbtion self, FreundlichAdsorbtion other) -> FreundlichAdsorbtion
        FreundlichAdsorbtion(const FreundlichAdsorbtion &other) 
        """
        _cmf_core.FreundlichAdsorbtion_swiginit(self, _cmf_core.new_FreundlichAdsorbtion(*args))
    copy = _swig_new_instance_method(_cmf_core.FreundlichAdsorbtion_copy)
    __swig_destroy__ = _cmf_core.delete_FreundlichAdsorbtion

# Register FreundlichAdsorbtion in _cmf_core:
_cmf_core.FreundlichAdsorbtion_swigregister(FreundlichAdsorbtion)

class LangmuirAdsorption(Adsorption):
    r"""


    This class calculates the adsorption equilibrium between sorbat and
    sorbent using the Langmuir isotherme.

    Langmuir Adsorption:



    .. math::

        \\frac{x_{ad}}{m} = q = \\frac{K c}{1 + K c}

    where
    :math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}`
    is the total tracer mass

    :math:`x_{free}` is the dissolved tracer mass

    :math:`m` is the mass of the sorbent in the same unit as the tracer mass

    :math:`K` is the Langmuir sorption coefficient

    :math:`c = \\frac{x_{free}}{V}` is the concentration of the tracer in
    tracer mass per m3

    CMF stores in a solute storage the total mass of a tracer and needs to
    calculate the free tracer mass. The analytical solution for :math:`x_{free}`
    from :math:`x_{tot}` is implemented in freesolute and derived usingsympy. If
    you really want to see it, look in the code.

    http://en.wikipedia.org/wiki/Langmuir_equation

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    K = property(_cmf_core.LangmuirAdsorption_K_get, _cmf_core.LangmuirAdsorption_K_set, doc=r"""K : real""")
    m = property(_cmf_core.LangmuirAdsorption_m_get, _cmf_core.LangmuirAdsorption_m_set, doc=r"""m : real""")

    def __init__(self, *args):
        r"""
        __init__(LangmuirAdsorption self, real K, real m) -> LangmuirAdsorption
        __init__(LangmuirAdsorption self, LangmuirAdsorption other) -> LangmuirAdsorption
        LangmuirAdsorption(const LangmuirAdsorption &other) 
        """
        _cmf_core.LangmuirAdsorption_swiginit(self, _cmf_core.new_LangmuirAdsorption(*args))
    copy = _swig_new_instance_method(_cmf_core.LangmuirAdsorption_copy)
    __swig_destroy__ = _cmf_core.delete_LangmuirAdsorption

# Register LangmuirAdsorption in _cmf_core:
_cmf_core.LangmuirAdsorption_swigregister(LangmuirAdsorption)

class solute(object):
    r"""


    A structure to identify a solute.

    C++ includes: Solute.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        r"""
        __init__(solute self, solute copy) -> solute
        solute(const
        solute &copy) 
        """
        _cmf_core.solute_swiginit(self, _cmf_core.new_solute(*args, **kwargs))
    __eq__ = _swig_new_instance_method(_cmf_core.solute___eq__)
    __lt__ = _swig_new_instance_method(_cmf_core.solute___lt__)
    __gt__ = _swig_new_instance_method(_cmf_core.solute___gt__)
    __le__ = _swig_new_instance_method(_cmf_core.solute___le__)
    __ge__ = _swig_new_instance_method(_cmf_core.solute___ge__)
    __ne__ = _swig_new_instance_method(_cmf_core.solute___ne__)
    Name = property(_cmf_core.solute_Name_get, _cmf_core.solute_Name_set, doc=r"""Name : std::string""")
    Unit = property(_cmf_core.solute_Unit_get, _cmf_core.solute_Unit_set, doc=r"""Unit : std::string""")
    Uptake = property(_cmf_core.solute_Uptake_get, _cmf_core.solute_Uptake_set, doc=r"""Uptake : double""")
    Id = property(_cmf_core.solute_Id_get, doc=r"""Id : q(const).size_t""")
    __repr__ = _swig_new_instance_method(_cmf_core.solute___repr__)
    __swig_destroy__ = _cmf_core.delete_solute

# Register solute in _cmf_core:
_cmf_core.solute_swigregister(solute)

class solute_vector(object):
    r"""


    Manages the solutes of the model.

    C++ includes: Solute.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    size = _swig_new_instance_method(_cmf_core.solute_vector_size)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(solute_vector self, std::string str) -> solute_vector
        solute_vector(std::string str)

        Creates a solute vector from solute names, separated by whitespace.
        E.g. solutes= solute_vector("dO18 dH2") 
        """
        _cmf_core.solute_vector_swiginit(self, _cmf_core.new_solute_vector(*args, **kwargs))
    get_solute = _swig_new_instance_method(_cmf_core.solute_vector_get_solute)
    __getitem__ = _swig_new_instance_method(_cmf_core.solute_vector___getitem__)
    __len__ = _swig_new_instance_method(_cmf_core.solute_vector___len__)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __repr__(self):
        return str([s.Name for s in self])

    __swig_destroy__ = _cmf_core.delete_solute_vector

# Register solute_vector in _cmf_core:
_cmf_core.solute_vector_swigregister(solute_vector)

class SoluteTimeseries(object):
    r"""


    A map of concentration time series for solutes.

    C++ includes: Solute.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    conc = _swig_new_instance_method(_cmf_core.SoluteTimeseries_conc)
    size = _swig_new_instance_method(_cmf_core.SoluteTimeseries_size)

    def __init__(self, *args):
        r"""
        __init__(SoluteTimeseries self) -> SoluteTimeseries
        __init__(SoluteTimeseries self, solute_vector solutes, Time begin, Time step) -> SoluteTimeseries
        __init__(SoluteTimeseries self, SoluteTimeseries sts) -> SoluteTimeseries
        SoluteTimeseries(const cmf::water::SoluteTimeseries &sts) 
        """
        _cmf_core.SoluteTimeseries_swiginit(self, _cmf_core.new_SoluteTimeseries(*args))
    __getitem__ = _swig_new_instance_method(_cmf_core.SoluteTimeseries___getitem__)
    __setitem__ = _swig_new_instance_method(_cmf_core.SoluteTimeseries___setitem__)
    __len__ = _swig_new_instance_method(_cmf_core.SoluteTimeseries___len__)
    __swig_destroy__ = _cmf_core.delete_SoluteTimeseries

# Register SoluteTimeseries in _cmf_core:
_cmf_core.SoluteTimeseries_swigregister(SoluteTimeseries)

class SoluteStorage(StateVariable):
    r"""


    A class for the storage of any tracer.

    The state is the amount (mol, kg etc. see cmf::water) of the tracer in
    the storage.

    The derivative function is given by: 

    .. math::


        \\frac{dX}{dt}&=&\\sum_{f=1}^{F}\\left( q_f [X]_f\\right) +
        X_{in} - r^-X \\left[\\frac{mol}{day}\\right]\\\\ F&=&
        \\mbox{Number of fluxes in water storage} \\\\ q_f&=&
        \\mbox{Water flux in } \\frac{m^3}{day} \\\\
        \\left[X\\right]_f &=& \\mbox{Concentration of solute X in flux
        }q_f \\mbox{ in } \\frac{mol}{m^3} \\\\ X_{in} &=&
        \\mbox{Absolute source or sink term} \\frac{mol}{day} \\\\ r^-
        &=& \\mbox{Decay rate} \\frac 1{day} \\\\ V &=&
        \\mbox{Volume of water in water storage }\\left[m^3\\right]




    C++ includes: SoluteStorage.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    set_adsorption = _swig_new_instance_method(_cmf_core.SoluteStorage_set_adsorption)
    decay = property(_cmf_core.SoluteStorage_decay_get, _cmf_core.SoluteStorage_decay_set, doc=r"""decay : real""")
    source = property(_cmf_core.SoluteStorage_source_get, _cmf_core.SoluteStorage_source_set, doc=r"""source : real""")
    Solute = property(_cmf_core.SoluteStorage_Solute_get, doc=r"""Solute : r.q(const).cmf::water::solute""")
    conc = property(_cmf_core.SoluteStorage_conc_get, _cmf_core.SoluteStorage_conc_set, doc=r"""conc : real""")

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoluteStorage

# Register SoluteStorage in _cmf_core:
_cmf_core.SoluteStorage_swigregister(SoluteStorage)

class flux_node(object):
    r"""


    Base class for everything that can be connected by fluxes.

    Flux nodes can be WaterStorages, flux end points, sinks, sources and
    bridges to other model domains (e.g. Ponded water to river system).
    The base class can be used where a simple routing, potentially with
    mixing, is needed.

    C++ includes: flux_node.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    node_id = property(_cmf_core.flux_node_node_id_get, doc=r"""node_id : q(const).int""")
    is_storage = _swig_new_instance_method(_cmf_core.flux_node_is_storage)
    Name = property(_cmf_core.flux_node_Name_get, _cmf_core.flux_node_Name_set, doc=r"""Name : std::string""")
    to_string = _swig_new_instance_method(_cmf_core.flux_node_to_string)
    __swig_destroy__ = _cmf_core.delete_flux_node
    __eq__ = _swig_new_instance_method(_cmf_core.flux_node___eq__)
    RecalcFluxes = _swig_new_instance_method(_cmf_core.flux_node_RecalcFluxes)
    connection_to = _swig_new_instance_method(_cmf_core.flux_node_connection_to)
    remove_connection = _swig_new_instance_method(_cmf_core.flux_node_remove_connection)
    flux_to = _swig_new_instance_method(_cmf_core.flux_node_flux_to)
    flux3d_to = _swig_new_instance_method(_cmf_core.flux_node_flux3d_to)
    get_3d_flux = _swig_new_instance_method(_cmf_core.flux_node_get_3d_flux)
    waterbalance = _swig_new_instance_method(_cmf_core.flux_node_waterbalance)
    __call__ = _swig_new_instance_method(_cmf_core.flux_node___call__)
    conc = _swig_new_instance_method(_cmf_core.flux_node_conc)
    position = property(_cmf_core.flux_node_position_get, _cmf_core.flux_node_position_set, doc=r"""position : cmf::geometry::point""")
    is_empty = _swig_new_instance_method(_cmf_core.flux_node_is_empty)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(flux_node self, project _project, point location=cmf::geometry::point()) -> flux_node
        flux_node(cmf::project &_project, cmf::geometry::point
        location=cmf::geometry::point()) 
        """
        _cmf_core.flux_node_swiginit(self, _cmf_core.new_flux_node(*args, **kwargs))
    project = property(_cmf_core.flux_node_project_get, doc=r"""project : cmf::project""")
    potential = property(_cmf_core.flux_node_potential_get, _cmf_core.flux_node_potential_set, doc=r"""potential : real""")
    connections = property(_cmf_core.flux_node_connections_get, doc=r"""connections : cmf::water::connection_list""")

    def __repr__(self): return self.to_string()
    def fluxes(self,t):
        return [(con.q(self,t),con[self]) for con in self.connections]
    @property
    def connected_nodes(self):
        return [con[self] for con in self.connections]


# Register flux_node in _cmf_core:
_cmf_core.flux_node_swigregister(flux_node)

count_node_references = _cmf_core.count_node_references
get_higher_node = _cmf_core.get_higher_node
get_lower_node = _cmf_core.get_lower_node
class waterbalance_integrator(integratable):
    r"""


    The waterbalance_integrator is an integratable for precise output of
    the average water balance of a flux_node over time.

    It can be added to a solver (any cmf::math::Integrator), which is than
    calling the integrate method at each substep.

    C++ includes: flux_node.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    integration_t = _swig_new_instance_method(_cmf_core.waterbalance_integrator_integration_t)
    t0 = _swig_new_instance_method(_cmf_core.waterbalance_integrator_t0)
    __get_node = _swig_new_instance_method(_cmf_core.waterbalance_integrator___get_node)
    __set_node = _swig_new_instance_method(_cmf_core.waterbalance_integrator___set_node)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(waterbalance_integrator self, cmf::water::flux_node::ptr node) -> waterbalance_integrator
        waterbalance_integrator(cmf::water::flux_node::ptr node) 
        """
        _cmf_core.waterbalance_integrator_swiginit(self, _cmf_core.new_waterbalance_integrator(*args, **kwargs))

    node = property(_cmf_core.waterbalance_integrator___get_node,
                    _cmf_core.waterbalance_integrator___set_node)

    __swig_destroy__ = _cmf_core.delete_waterbalance_integrator

# Register waterbalance_integrator in _cmf_core:
_cmf_core.waterbalance_integrator_swigregister(waterbalance_integrator)

class flux_connection(object):
    r"""


    The connections in cmf hold the processes for the calculation of
    fluxes between water storages and model boundaries.

    Todo Elaborate on this Represents a connection between flux_nodes,
    where water fluxes occur.

    C++ includes: flux_connection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    left_node = _swig_new_instance_method(_cmf_core.flux_connection_left_node)
    right_node = _swig_new_instance_method(_cmf_core.flux_connection_right_node)
    kill_me = _swig_new_instance_method(_cmf_core.flux_connection_kill_me)
    refresh = _swig_new_instance_method(_cmf_core.flux_connection_refresh)
    connection_id = property(_cmf_core.flux_connection_connection_id_get, doc=r"""connection_id : q(const).int""")
    __eq__ = _swig_new_instance_method(_cmf_core.flux_connection___eq__)
    get_target = _swig_new_instance_method(_cmf_core.flux_connection_get_target)
    exchange_target = _swig_new_instance_method(_cmf_core.flux_connection_exchange_target)
    q = _swig_new_instance_method(_cmf_core.flux_connection_q)
    conc = _swig_new_instance_method(_cmf_core.flux_connection_conc)
    type = property(_cmf_core.flux_connection_type_get, doc=r"""type : q(const).std::string""")
    get_tracer_filter = _swig_new_instance_method(_cmf_core.flux_connection_get_tracer_filter)
    set_tracer_filter = _swig_new_instance_method(_cmf_core.flux_connection_set_tracer_filter)
    to_string = _swig_new_instance_method(_cmf_core.flux_connection_to_string)
    short_string = _swig_new_instance_method(_cmf_core.flux_connection_short_string)
    is_waterbalance_source = _swig_new_instance_method(_cmf_core.flux_connection_is_waterbalance_source)
    __swig_destroy__ = _cmf_core.delete_flux_connection


    def __repr__(self):
        return self.to_string()

    def __getitem__(self,index):
        return self.get_target(index)

    def __iter__(self):
        yield self.get_target(0)
        yield self.get_target(1)

    def __contains__(self,cmp):
        return cmp==self[0] or cmp==self[1]


# Register flux_connection in _cmf_core:
_cmf_core.flux_connection_swigregister(flux_connection)

replace_node = _cmf_core.replace_node
class connection_list(object):
    r"""


    A self sorting list of connections.

    C++ includes: flux_connection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    append = _swig_new_instance_method(_cmf_core.connection_list_append)
    extend = _swig_new_instance_method(_cmf_core.connection_list_extend)
    contains = _swig_new_instance_method(_cmf_core.connection_list_contains)
    remove = _swig_new_instance_method(_cmf_core.connection_list_remove)
    do_action = _swig_new_instance_method(_cmf_core.connection_list_do_action)
    size = _swig_new_instance_method(_cmf_core.connection_list_size)
    at = _swig_new_instance_method(_cmf_core.connection_list_at)
    begin = _swig_new_instance_method(_cmf_core.connection_list_begin)
    end = _swig_new_instance_method(_cmf_core.connection_list_end)
    __swig_destroy__ = _cmf_core.delete_connection_list
    __len__ = _swig_new_instance_method(_cmf_core.connection_list___len__)
    __contains__ = _swig_new_instance_method(_cmf_core.connection_list___contains__)


    def __repr__(self):
        return repr(list(self)) + "<cmf.connection_list>"

    def __getitem__(self,index):
        return self.at(index)

    def __iter__(self):
        for i in range(len(self)):
            yield self.at(i)


    def __init__(self, *args, **kwargs):
        r"""__init__(connection_list self) -> connection_list"""
        _cmf_core.connection_list_swiginit(self, _cmf_core.new_connection_list(*args, **kwargs))

# Register connection_list in _cmf_core:
_cmf_core.connection_list_swigregister(connection_list)

class flux_integrator(integratable):
    r"""


    The flux_integrator is an integratable for precise output of average
    fluxes over time.

    It can be added to solver (any cmf::math::Integrator), which is then
    calling the integrate method at each substep.

    C++ includes: flux_connection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    integration_t = _swig_new_instance_method(_cmf_core.flux_integrator_integration_t)
    t0 = _swig_new_instance_method(_cmf_core.flux_integrator_t0)
    invert = property(_cmf_core.flux_integrator_invert_get, _cmf_core.flux_integrator_invert_set, doc=r"""invert : bool""")
    connection = _swig_new_instance_method(_cmf_core.flux_integrator_connection)

    def __init__(self, *args):
        r"""
        __init__(flux_integrator self, flux_connection connection) -> flux_integrator
        __init__(flux_integrator self, cmf::water::flux_node::ptr left, cmf::water::flux_node::ptr right) -> flux_integrator
        flux_integrator(cmf::water::flux_node::ptr left,
        cmf::water::flux_node::ptr right)

        Creates a flux_integrator from the endpoints of a connection. Throws
        if there is no connection between the endpoints. 
        """
        _cmf_core.flux_integrator_swiginit(self, _cmf_core.new_flux_integrator(*args))
    __swig_destroy__ = _cmf_core.delete_flux_integrator

# Register flux_integrator in _cmf_core:
_cmf_core.flux_integrator_swigregister(flux_integrator)

class linear_scale(object):
    r"""


    A linear scaling functor, with slope and displacement.

    C++ includes: boundary_condition.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    displacement = property(_cmf_core.linear_scale_displacement_get, _cmf_core.linear_scale_displacement_set, doc=r"""displacement : real""")
    slope = property(_cmf_core.linear_scale_slope_get, _cmf_core.linear_scale_slope_set, doc=r"""slope : real""")
    __call__ = _swig_new_instance_method(_cmf_core.linear_scale___call__)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(linear_scale self, real _slope=1, real _displacement=0) -> linear_scale
        linear_scale(real _slope=1, real _displacement=0)

        Creates a linear scale (by default it is a unity scale, :math:`a=1; b=0`) 
        """
        _cmf_core.linear_scale_swiginit(self, _cmf_core.new_linear_scale(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_linear_scale

# Register linear_scale in _cmf_core:
_cmf_core.linear_scale_swigregister(linear_scale)

class DirichletBoundary(flux_node):
    r"""


    Dirichlet (constant head) boundary condition.

    This boundary condition can be used either as a pure sink boundary
    condition or as a conditional source / sink boundary condition. The
    constant head of the boundary condition is interpreted and handled by
    the connections of the boundary condition. Not head aware connections,
    should not be used, since they are ignoring the constant head.

    C++ includes: boundary_condition.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    set_conc = _swig_new_instance_method(_cmf_core.DirichletBoundary_set_conc)
    is_source = property(_cmf_core.DirichletBoundary_is_source_get, _cmf_core.DirichletBoundary_is_source_set, doc=r"""is_source : bool""")
    RecalcFluxes = _swig_new_instance_method(_cmf_core.DirichletBoundary_RecalcFluxes)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(DirichletBoundary self, project _p, real potential, point Location=cmf::geometry::point()) -> DirichletBoundary
        DirichletBoundary(cmf::project &_p, real potential,
        cmf::geometry::point Location=cmf::geometry::point()) 
        """
        _cmf_core.DirichletBoundary_swiginit(self, _cmf_core.new_DirichletBoundary(*args, **kwargs))

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_DirichletBoundary

# Register DirichletBoundary in _cmf_core:
_cmf_core.DirichletBoundary_swigregister(DirichletBoundary)

class NeumannBoundary(flux_node):
    r"""


    A Neumann boundary condition (constant flux boundary condition)

    The flux is a timeseries, but can be used as a scalar. To scale the
    timeseries to the specific conditions of this boundary condition the
    linear_scale flux_scale can be used.

    C++ includes: boundary_condition.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    get_flux = _swig_new_instance_method(_cmf_core.NeumannBoundary_get_flux)
    set_flux = _swig_new_instance_method(_cmf_core.NeumannBoundary_set_flux)
    flux_scale = property(_cmf_core.NeumannBoundary_flux_scale_get, _cmf_core.NeumannBoundary_flux_scale_set, doc=r"""flux_scale : cmf::water::linear_scale""")
    concentration = property(_cmf_core.NeumannBoundary_concentration_get, _cmf_core.NeumannBoundary_concentration_set, doc=r"""concentration : cmf::water::SoluteTimeseries""")
    __call__ = _swig_new_instance_method(_cmf_core.NeumannBoundary___call__)
    connect_to = _swig_new_instance_method(_cmf_core.NeumannBoundary_connect_to)

    def __init__(self, *args):
        r"""
        __init__(NeumannBoundary self, project _project, timeseries _flux, SoluteTimeseries _concentration=cmf::water::SoluteTimeseries(), point loc=cmf::geometry::point()) -> NeumannBoundary
        __init__(NeumannBoundary self, project _project, point loc=cmf::geometry::point()) -> NeumannBoundary
        NeumannBoundary(cmf::project &_project, cmf::geometry::point
        loc=cmf::geometry::point()) 
        """
        _cmf_core.NeumannBoundary_swiginit(self, _cmf_core.new_NeumannBoundary(*args))
    create = _swig_new_static_method(_cmf_core.NeumannBoundary_create)

    def __repr__(self): 
        return self.to_string()


    flux = property(get_flux,set_flux, doc="The flux over the boundary condition")

    __swig_destroy__ = _cmf_core.delete_NeumannBoundary

# Register NeumannBoundary in _cmf_core:
_cmf_core.NeumannBoundary_swigregister(NeumannBoundary)
NeumannBoundary_create = _cmf_core.NeumannBoundary_create

class NeumannFlux(flux_connection):
    r"""


    Connection between Neumann-boundary and a flux node.

    This flux_connection is created, when connecting a Neumann boundary
    condition with a state variable using Neumann::connect_to

    C++ includes: boundary_condition.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(NeumannFlux self, std::shared_ptr< cmf::water::NeumannBoundary > left, cmf::water::flux_node::ptr right) -> NeumannFlux
        NeumannFlux(std::shared_ptr< NeumannBoundary > left,
        cmf::water::flux_node::ptr right) 
        """
        _cmf_core.NeumannFlux_swiginit(self, _cmf_core.new_NeumannFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_NeumannFlux

# Register NeumannFlux in _cmf_core:
_cmf_core.NeumannFlux_swigregister(NeumannFlux)

class WaterStorage(StateVariable, StateVariableOwner, flux_node):
    r"""


    A state variable for the storage of water.

    A class for the storage of water. The state is the volume of water
    stored in :math:`m^3` The derivative function is given by:


    .. math::

         \\frac{dV}{dt}&=&\\sum_{f=1}^{F} q_f \\\\
        F&=& \\mbox{Number of fluxes in water storage} \\\\ q_f&=&
        \\mbox{Water flux in } \\frac{m^3}{day} \\\\




    Todo Check the head based state mode

    C++ includes: WaterStorage.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(WaterStorage self, project project, std::string const & Name="", double InitialState=0, double scale=1) -> WaterStorage
        WaterStorage(cmf::project &project, const std::string &Name="",
        double InitialState=0, double scale=1)

        creates a water storage (abstract class)

        Parameters:
        -----------

        project:  The project the waterstorage belongs to

        Name:  Name of the water storage

        InitialState:  Initial water content in m3

        scale:  A kind of "standard size" in m3 of the water storage to
        scale tolerances, default 1m3 
        """
        _cmf_core.WaterStorage_swiginit(self, _cmf_core.new_WaterStorage(*args, **kwargs))
    from_node = _swig_new_static_method(_cmf_core.WaterStorage_from_node)
    Solute = _swig_new_instance_method(_cmf_core.WaterStorage_Solute)
    conc = _swig_new_instance_method(_cmf_core.WaterStorage_conc)
    cast = _swig_new_static_method(_cmf_core.WaterStorage_cast)
    create = _swig_new_static_method(_cmf_core.WaterStorage_create)
    volume = property(_cmf_core.WaterStorage_volume_get, _cmf_core.WaterStorage_volume_set, doc=r"""volume : real""")
    statevariable = property(_cmf_core.WaterStorage_statevariable_get, _cmf_core.WaterStorage_statevariable_set, doc=r"""statevariable : char""")

    def __repr__(self): 
        return self.to_string()

    __getitem__ = _swig_new_instance_method(_cmf_core.WaterStorage___getitem__)
    __swig_destroy__ = _cmf_core.delete_WaterStorage

# Register WaterStorage in _cmf_core:
_cmf_core.WaterStorage_swigregister(WaterStorage)
WaterStorage_from_node = _cmf_core.WaterStorage_from_node
WaterStorage_cast = _cmf_core.WaterStorage_cast
WaterStorage_create = _cmf_core.WaterStorage_create

class waterbalance_connection(flux_connection):
    r"""


    Routes the sum of all other fluxes to a target.



    .. math::

         q_{1,0} = \\sum_{i=2}^N{q_{1,i}(V_1,V_i,t)}

    where:
    :math:`q_{i,j}` is the flux between the two node i and j. Subscript 0 is the
    right node, subscript 1 is the left node and 2..N are the nodes
    connected to the left node, except for the right node

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(waterbalance_connection self, cmf::water::flux_node::ptr source, cmf::water::flux_node::ptr target) -> waterbalance_connection
        waterbalance_connection(flux_node::ptr source, flux_node::ptr target)

        """
        _cmf_core.waterbalance_connection_swiginit(self, _cmf_core.new_waterbalance_connection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_waterbalance_connection

# Register waterbalance_connection in _cmf_core:
_cmf_core.waterbalance_connection_swigregister(waterbalance_connection)

class external_control_connection(flux_connection):
    r"""


    Flux from one node to another, controlled by the user or an external
    program, by changing the flux constant.

    It is easy to create negative volumes in water storages with this
    connection, which can be hazard to the solver, since most connections
    rely on a positive volume in a storage. Handle with care!

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flux = property(_cmf_core.external_control_connection_flux_get, _cmf_core.external_control_connection_flux_set, doc=r"""flux : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(external_control_connection self, cmf::water::flux_node::ptr source, cmf::water::flux_node::ptr target, real flux_value=0) -> external_control_connection
        external_control_connection(flux_node::ptr source, flux_node::ptr
        target, real flux_value=0) 
        """
        _cmf_core.external_control_connection_swiginit(self, _cmf_core.new_external_control_connection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_external_control_connection

# Register external_control_connection in _cmf_core:
_cmf_core.external_control_connection_swigregister(external_control_connection)

set_flux = _cmf_core.set_flux
can_set_flux = _cmf_core.can_set_flux
class kinematic_wave(flux_connection):
    r"""


    Calculates flux out of a storage as a linear function of its volume to
    a power.

    Deprecated  kinematic_wave is superseeded by LinearStorageConnection
    and PowerLawConnection



    .. math::

         q = \\frac 1 {t_r} {\\left(\\frac{V - V_{residual}}{V_0}
        \\right)^\\beta} 

    where:  :math:`V_{residual} [m^3]` The volume of
    water not flowing out (default = 0)

    :math:`V_0` The reference volume to scale the exponent (default = 1m3/day)

    :math:`\\beta` A parameter to shape the response curve. In case of
    :math:`\\beta \\neq 1`, :math:`t_r` is not a residence time, but just a
    parameter.

    :math:`t_r [days]` The residence time of the water in this storage in days

    WARNING:   :math:`\\beta < 0.5` may lead to numerical troubles and have a
    dubious hydrological meaning. Please avoid.

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    residencetime = property(_cmf_core.kinematic_wave_residencetime_get, _cmf_core.kinematic_wave_residencetime_set, doc=r"""residencetime : real""")
    exponent = property(_cmf_core.kinematic_wave_exponent_get, _cmf_core.kinematic_wave_exponent_set, doc=r"""exponent : real""")
    residual = property(_cmf_core.kinematic_wave_residual_get, _cmf_core.kinematic_wave_residual_set, doc=r"""residual : real""")
    V0 = property(_cmf_core.kinematic_wave_V0_get, _cmf_core.kinematic_wave_V0_set, doc=r"""V0 : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(kinematic_wave self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real residencetime, real exponent=1.0, real residual=0.0, real V0=1.0) -> kinematic_wave
        kinematic_wave(WaterStorage::ptr source, flux_node::ptr target, real
        residencetime, real exponent=1.0, real residual=0.0, real V0=1.0)

        Creates a kinematic wave connection.



        .. math::

             q = \\frac 1 {t_r} {\\left(\\frac{V - V_{residual}}{V_0}
            \\right)^\\beta} 

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        residencetime:   :math:`t_r [days]` The residence time of the water in this
        storage

        exponent:   :math:`\\beta [-]` An empirical exponent to shape the flux
        function (default = 1 (linear function))

        residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
        (default = 0)

        V0:   :math:`V_0` The reference volume to scale the exponent 
        """
        _cmf_core.kinematic_wave_swiginit(self, _cmf_core.new_kinematic_wave(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_kinematic_wave

# Register kinematic_wave in _cmf_core:
_cmf_core.kinematic_wave_swigregister(kinematic_wave)

class LinearStorageConnection(flux_connection):
    r"""


    Calculates flux out of a storage as a linear function of its volume.

    This connection serves the same purpose as the old kinematic_wave
    connection, but the parameters are easier to explain



    .. math::

         q = \\frac{V - V_{residual}}{t_r} 

    where:  :math:`V` The actual
    volume of water stored in source

    :math:`V_{residual} [m^3]` The volume of water not flowing out (default = 0)
    :math:`t_r` is the residence time in the source.

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    residencetime = property(_cmf_core.LinearStorageConnection_residencetime_get, _cmf_core.LinearStorageConnection_residencetime_set, doc=r"""residencetime : real""")
    residual = property(_cmf_core.LinearStorageConnection_residual_get, _cmf_core.LinearStorageConnection_residual_set, doc=r"""residual : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(LinearStorageConnection self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real residencetime, real residual=0.0) -> LinearStorageConnection
        LinearStorageConnection(WaterStorage::ptr source, flux_node::ptr
        target, real residencetime, real residual=0.0)

        Creates a linear storage connection or Nash-box.



        .. math::

             q = \\frac{V - V_{residual}}{t_r}} 

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        residencetime:   :math:`t_r [days]` The residence time of the water in this
        storage

        residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
        (default = 0) 
        """
        _cmf_core.LinearStorageConnection_swiginit(self, _cmf_core.new_LinearStorageConnection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_LinearStorageConnection

# Register LinearStorageConnection in _cmf_core:
_cmf_core.LinearStorageConnection_swigregister(LinearStorageConnection)

class PowerLawConnection(flux_connection):
    r"""


    Calculates flux out of a storage as a linear function of its volume to
    a power.

    This connection serves the same purpose as the old kinematic_wave
    connection, but the parameters are easier to explain.



    .. math::

         q = Q_0 {\\left(\\frac{V - V_{residual}}{V_0}
        \\right)^\\beta} 

    where:  :math:`V` The actual volume of water
    stored in source

    :math:`V_{residual} [m^3]` The volume of water not flowing out (default = 0)

    :math:`V_0` A reference volume to scale the outflux. One can see :math:`V_0` as
    the inflection point of the outflow curve

    :math:`\\beta` A parameter to shape the response curve. :math:`Q_0` is the
    outflow from the source in :math:`\\frac{m^3}{day}`, when :math:`V = V_0`.

    WARNING:   :math:`\\beta < 0.5` may lead to numerical troubles and have a
    dubious hydrological meaning. Please avoid.

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Q0 = property(_cmf_core.PowerLawConnection_Q0_get, _cmf_core.PowerLawConnection_Q0_set, doc=r"""Q0 : real""")
    beta = property(_cmf_core.PowerLawConnection_beta_get, _cmf_core.PowerLawConnection_beta_set, doc=r"""beta : real""")
    residual = property(_cmf_core.PowerLawConnection_residual_get, _cmf_core.PowerLawConnection_residual_set, doc=r"""residual : real""")
    V0 = property(_cmf_core.PowerLawConnection_V0_get, _cmf_core.PowerLawConnection_V0_set, doc=r"""V0 : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PowerLawConnection self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real Q0, real V0, real beta=1.0, real residual=0.0) -> PowerLawConnection
        PowerLawConnection(WaterStorage::ptr source, flux_node::ptr target,
        real Q0, real V0, real beta=1.0, real residual=0.0)

        Creates a power law connection.

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        Q0:  Reference flow :math:`Q_0 = q(V_0)` Outflow when the source storage
        equals the reference volume

        V0:  Reference volume :math:`V_0` The reference volume to scale the exponent

        beta:   :math:`\\beta [-]` An empirical exponent to shape the flux
        function (default = 1 (linear function))

        residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
        (default = 0) 
        """
        _cmf_core.PowerLawConnection_swiginit(self, _cmf_core.new_PowerLawConnection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_PowerLawConnection

# Register PowerLawConnection in _cmf_core:
_cmf_core.PowerLawConnection_swigregister(PowerLawConnection)

class ExponentialDeclineConnection(flux_connection):
    r"""


    A conceptual TOPmodel inspired connection.



    .. math::

         q = Q_0 \\cdot e^{(V-V_0)/m} 

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Q0 = property(_cmf_core.ExponentialDeclineConnection_Q0_get, _cmf_core.ExponentialDeclineConnection_Q0_set, doc=r"""Q0 : real""")
    m = property(_cmf_core.ExponentialDeclineConnection_m_get, _cmf_core.ExponentialDeclineConnection_m_set, doc=r"""m : real""")
    V0 = property(_cmf_core.ExponentialDeclineConnection_V0_get, _cmf_core.ExponentialDeclineConnection_V0_set, doc=r"""V0 : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ExponentialDeclineConnection self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real Q0, real V0, real m) -> ExponentialDeclineConnection
        ExponentialDeclineConnection(WaterStorage::ptr source,
        flux_node::ptr target, real Q0, real V0, real m)

        creates the exponential decline connection 
        """
        _cmf_core.ExponentialDeclineConnection_swiginit(self, _cmf_core.new_ExponentialDeclineConnection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ExponentialDeclineConnection

# Register ExponentialDeclineConnection in _cmf_core:
_cmf_core.ExponentialDeclineConnection_swigregister(ExponentialDeclineConnection)

class ConstraintLinearStorageConnection(flux_connection):
    r"""


    Calculates flux out of a storage as a linear function of its volume,
    constraint by the volume stored in the target storage.



    .. math::

         q = \\frac {1}{t_r} \\left({V_{l} - V_{l,min}}\\right)
        \\cdot \\left(\\frac{V_{r,max}-V_{r}}{V_{r,max}}\\right)

    where:  :math:`V_l` The actual volume stored by the left water storage

    :math:`V_{l,min} [m^3]` The volume of water not flowing out (default = 0)

    :math:`\\beta` A parameter to shape the response curve. In case of
    :math:`\\beta \\neq 1`, :math:`t_r` is not a residence time, but just a
    parameter.

    :math:`t_r [days]` The residence time of the water in this storage in days

    :math:`V_{r,max}` The capacity of the right water storage in m3

    :math:`V_{r}` The actual volume of the right water storage

    :math:`\\gamma` A shape parameter for the target capacity constriction

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    residencetime = property(_cmf_core.ConstraintLinearStorageConnection_residencetime_get, _cmf_core.ConstraintLinearStorageConnection_residencetime_set, doc=r"""residencetime : real""")
    Vlmin = property(_cmf_core.ConstraintLinearStorageConnection_Vlmin_get, _cmf_core.ConstraintLinearStorageConnection_Vlmin_set, doc=r"""Vlmin : real""")
    Vrmax = property(_cmf_core.ConstraintLinearStorageConnection_Vrmax_get, _cmf_core.ConstraintLinearStorageConnection_Vrmax_set, doc=r"""Vrmax : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ConstraintLinearStorageConnection self, cmf::water::WaterStorage::ptr source, cmf::water::WaterStorage::ptr target, real residencetime=1.0, real Vlmin=0.0, real Vrmax=1.0) -> ConstraintLinearStorageConnection
        ConstraintLinearStorageConnection(WaterStorage::ptr source,
        WaterStorage::ptr target, real residencetime=1.0, real Vlmin=0.0, real
        Vrmax=1.0)

        Creates a linear storage connection, constrained by the fill level of
        the source 

        .. math::

             q = \\frac 1 {t_r} {\\left(\\frac{V -
            V_{residual}}{V_0} \\right)^\\beta} 

        .

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        residencetime:   :math:`t_r [days]` The residence time of the water in this
        storage

        Vlmin:   :math:`V_{l,min} [m^3]` The volume of water not flowing out
        (default = 0)

        Vrmax:   :math:`V_{r,max}` Capacity of the target water storage in m3 
        """
        _cmf_core.ConstraintLinearStorageConnection_swiginit(self, _cmf_core.new_ConstraintLinearStorageConnection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ConstraintLinearStorageConnection

# Register ConstraintLinearStorageConnection in _cmf_core:
_cmf_core.ConstraintLinearStorageConnection_swigregister(ConstraintLinearStorageConnection)

class bidirectional_kinematic_exchange(flux_connection):
    r"""


    A conceptual flux between two storages that can be positive as well as
    negative.

    The state of the right node is not monitored, hence negative volumes
    of the right node can occur! Deprecated Behaviour unclear, will be
    removed 

    .. math::

         q = q_{spill}^*-q_{suc}^* \\\\ q_{spill}^* =
        q_{spill}
        \\left(\\frac{V-V_{spill,min}}{V_{spill,min}}\\right)^{\\beta_{spill}}
        \\\\ q_{suc}^* = q_{suc}
        \\left(\\frac{V_{suc,max}-V}{V_{suc,max}}\\right)^{\\beta_{suc}}


    where:  :math:`q` is the flow to the target

    :math:`q_{spill}^*` is the actual spill flow to the target

    :math:`q_{spill}` is the spill flow at :math:`V = 2V_{spill}`

    :math:`q_{suc}^*` is the actual suction flow from the target

    :math:`q_{suc}` is the sucked flow from the target when :math:`V=0.0`

    :math:`\\beta` is a shape forming exponent for spill and suction flow.

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Vmaxsuc = property(_cmf_core.bidirectional_kinematic_exchange_Vmaxsuc_get, _cmf_core.bidirectional_kinematic_exchange_Vmaxsuc_set, doc=r"""Vmaxsuc : real""")
    Vminspill = property(_cmf_core.bidirectional_kinematic_exchange_Vminspill_get, _cmf_core.bidirectional_kinematic_exchange_Vminspill_set, doc=r"""Vminspill : real""")
    qspill = property(_cmf_core.bidirectional_kinematic_exchange_qspill_get, _cmf_core.bidirectional_kinematic_exchange_qspill_set, doc=r"""qspill : real""")
    qsuc = property(_cmf_core.bidirectional_kinematic_exchange_qsuc_get, _cmf_core.bidirectional_kinematic_exchange_qsuc_set, doc=r"""qsuc : real""")
    beta_suc = property(_cmf_core.bidirectional_kinematic_exchange_beta_suc_get, _cmf_core.bidirectional_kinematic_exchange_beta_suc_set, doc=r"""beta_suc : real""")
    beta_spill = property(_cmf_core.bidirectional_kinematic_exchange_beta_spill_get, _cmf_core.bidirectional_kinematic_exchange_beta_spill_set, doc=r"""beta_spill : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(bidirectional_kinematic_exchange self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real Vminspill, real Vmaxsuc, real qspill, real qsuc, real beta_spill, real beta_suc) -> bidirectional_kinematic_exchange
        bidirectional_kinematic_exchange(WaterStorage::ptr source,
        flux_node::ptr target, real Vminspill, real Vmaxsuc, real qspill, real
        qsuc, real beta_spill, real beta_suc)

        Creates a kinematic wave connection.

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        Vmaxsuc:  Suction starts below this threshold volume of source

        Vminspill:  Spilling starts above this threshold volume of source

        qspill:  Spill flow at 2*Vminspill in m3/day

        qsuc:  Suction flow at V=0 m3

        beta_suc:  beta_spill:  Exponent for spill / suction flow 
        """
        _cmf_core.bidirectional_kinematic_exchange_swiginit(self, _cmf_core.new_bidirectional_kinematic_exchange(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_bidirectional_kinematic_exchange

# Register bidirectional_kinematic_exchange in _cmf_core:
_cmf_core.bidirectional_kinematic_exchange_swigregister(bidirectional_kinematic_exchange)

class constraint_kinematic_wave(flux_connection):
    r"""


    Calculates flux out of a storage as a linear function of its volume to
    a power, constraint by the volume stored in the target storage.

    Deprecated Will be replaced by ConstraintLinearStorageConnection,
    without beta and gamma. 

    .. math::

         q = \\frac 1 {t_r}
        {\\left(\\frac{V_{l} - V_{residual}}{V_0} \\right)^\\beta}
        \\left(\\frac{V_{r,max}-V_{r}}{V_{r,max}}\\right)^\\gamma

    where:  :math:`V_l` The actual volume stored by the left water storage

    :math:`V_{residual} [m^3]` The volume of water not flowing out (default = 0)

    :math:`V_0` The reference volume to scale the exponent (default = 1m3/day)

    :math:`\\beta` A parameter to shape the response curve. In case of
    :math:`\\beta \\neq 1`, :math:`t_r` is not a residence time, but just a
    parameter.

    :math:`t_r [days]` The residence time of the water in this storage in days

    :math:`V_{r,max}` The capacity of the right water storage in m3

    :math:`V_{r}` The actual volume of the right water storage

    :math:`\\gamma` A shape parameter for the target capacity constriction

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    residencetime = property(_cmf_core.constraint_kinematic_wave_residencetime_get, _cmf_core.constraint_kinematic_wave_residencetime_set, doc=r"""residencetime : real""")
    beta = property(_cmf_core.constraint_kinematic_wave_beta_get, _cmf_core.constraint_kinematic_wave_beta_set, doc=r"""beta : real""")
    residual = property(_cmf_core.constraint_kinematic_wave_residual_get, _cmf_core.constraint_kinematic_wave_residual_set, doc=r"""residual : real""")
    V0 = property(_cmf_core.constraint_kinematic_wave_V0_get, _cmf_core.constraint_kinematic_wave_V0_set, doc=r"""V0 : real""")
    Vrmax = property(_cmf_core.constraint_kinematic_wave_Vrmax_get, _cmf_core.constraint_kinematic_wave_Vrmax_set, doc=r"""Vrmax : real""")
    gamma = property(_cmf_core.constraint_kinematic_wave_gamma_get, _cmf_core.constraint_kinematic_wave_gamma_set, doc=r"""gamma : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(constraint_kinematic_wave self, cmf::water::WaterStorage::ptr source, cmf::water::WaterStorage::ptr target, real residencetime=1.0, real exponent=1.0, real residual=0.0, real V0=1.0, real Vrmax=1.0, real gamma=1.0) -> constraint_kinematic_wave
        constraint_kinematic_wave(WaterStorage::ptr source, WaterStorage::ptr
        target, real residencetime=1.0, real exponent=1.0, real residual=0.0,
        real V0=1.0, real Vrmax=1.0, real gamma=1.0)

        Creates a kinematic wave connection.



        .. math::

             q = \\frac 1 {t_r} {\\left(\\frac{V - V_{residual}}{V_0}
            \\right)^\\beta} 

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        residencetime:   :math:`t_r [days]` The residence time of the water in this
        storage

        exponent:   :math:`\\beta [-]` An empirical exponent to shape the flux
        function (default = 1 (linear function))

        residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
        (default = 0)

        V0:   :math:`V_0` The reference volume to scale the exponent

        Vrmax:   :math:`V_{r,max}` Capacity of the target water storage in m3

        gamma:   :math:`\\gamma` Target capacity constriction curve shape 
        """
        _cmf_core.constraint_kinematic_wave_swiginit(self, _cmf_core.new_constraint_kinematic_wave(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_constraint_kinematic_wave

# Register constraint_kinematic_wave in _cmf_core:
_cmf_core.constraint_kinematic_wave_swigregister(constraint_kinematic_wave)

class TechnicalFlux(flux_connection):
    r"""


    Produces a constant but changeable flux from a source to a target, if
    enough water is present in the source.



    .. math::

         q=\\begin{cases}0 & V_{source}\\le V_{min}\\\\ q_0
        \\frac{V_{source} - V_{min}}{t_{decr} q_{0} - V_{min}} & V_{source}
        \\le t_{decr} q_{0}\\\\ q_{0} & \\end{cases}

    This is similar to a neumann boundary, however this is not a boundary
    condition, but water is taken from the source (left) water storage and
    limited by that water storage.

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    MaxFlux = property(_cmf_core.TechnicalFlux_MaxFlux_get, _cmf_core.TechnicalFlux_MaxFlux_set, doc=r"""MaxFlux : real""")
    MinState = property(_cmf_core.TechnicalFlux_MinState_get, _cmf_core.TechnicalFlux_MinState_set, doc=r"""MinState : real""")
    FluxDecreaseTime = property(_cmf_core.TechnicalFlux_FluxDecreaseTime_get, _cmf_core.TechnicalFlux_FluxDecreaseTime_set, doc=r"""FluxDecreaseTime : cmf::math::Time""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(TechnicalFlux self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real maximum_flux, real minimal_state=0, Time flux_decrease_time=h) -> TechnicalFlux
        TechnicalFlux(cmf::water::WaterStorage::ptr source,
        cmf::water::flux_node::ptr target, real maximum_flux, real
        minimal_state=0, cmf::math::Time flux_decrease_time=cmf::math::h)

        Produces a constant but changeable flux from a source to a target, if
        enough water is present in the source.

        Parameters:
        -----------

        source:  The source of the water

        target:  The target of the water

        maximum_flux:  The requested flux :math:`q_{0}`

        minimal_state:  Minimal volume of stored water in source

        flux_decrease_time:  ( cmf::math::Time) 
        """
        _cmf_core.TechnicalFlux_swiginit(self, _cmf_core.new_TechnicalFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_TechnicalFlux

# Register TechnicalFlux in _cmf_core:
_cmf_core.TechnicalFlux_swigregister(TechnicalFlux)

class generic_gradient_connection(flux_connection):
    r"""


    A generic node-to-node gradient based connection.

    This connection is similar to the Darcy-connection, but there are no
    restrictions concerning the type of nodes. However, the left side
    needs to be a water storage 

    .. math::

         q = K A
        \\frac{\\Psi_{l}-\\Psi_{r}}{d} 

    where:  :math:`q`: the resulting
    flux in :math:`m^3/day`

    :math:`K`: the conductivity of the connection

    :math:`A`: the area of the connection cross section

    :math:`\\Psi`: The hydraulic head of the (l)eft, resp. (r)ight node of the
    connection

    :math:`d`: The topographic length of the connection in m

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    K = property(_cmf_core.generic_gradient_connection_K_get, _cmf_core.generic_gradient_connection_K_set, doc=r"""K : real""")
    A = property(_cmf_core.generic_gradient_connection_A_get, _cmf_core.generic_gradient_connection_A_set, doc=r"""A : real""")
    d = property(_cmf_core.generic_gradient_connection_d_get, _cmf_core.generic_gradient_connection_d_set, doc=r"""d : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(generic_gradient_connection self, cmf::water::WaterStorage::ptr left, cmf::water::WaterStorage::ptr right, real K, real d=1.0, real A=1.0) -> generic_gradient_connection
        generic_gradient_connection(cmf::water::WaterStorage::ptr left,
        cmf::water::WaterStorage::ptr right, real K, real d=1.0, real A=1.0)

        Creates a generic gradient based flux, if enough water is present in
        the source.

        Parameters:
        -----------

        left:  The left node of the connection

        right:  The right node of the connection

        K:  the conductivity of the connection in m/day

        d:  the topographic lenght of the connection in m

        A:  the area of the connection cross section in m2 
        """
        _cmf_core.generic_gradient_connection_swiginit(self, _cmf_core.new_generic_gradient_connection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_generic_gradient_connection

# Register generic_gradient_connection in _cmf_core:
_cmf_core.generic_gradient_connection_swigregister(generic_gradient_connection)

class statecontrol_connection(flux_connection):
    r"""


    Calculates a flux to or from a water storage to hold it's state at a
    more or less constant level.



    .. math::

         q=\\frac{h_1 - h_{target}}{t_c [days]} 

    where:  :math:`q` the
    resulting flux in m3/day

    :math:`h_1` the reference state

    :math:`h_{target}` the state of the target (right) node

    :math:`t_c` the time to reach the target state

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    reaction_time = property(_cmf_core.statecontrol_connection_reaction_time_get, _cmf_core.statecontrol_connection_reaction_time_set, doc=r"""reaction_time : cmf::math::Time""")
    target_state = property(_cmf_core.statecontrol_connection_target_state_get, _cmf_core.statecontrol_connection_target_state_set, doc=r"""target_state : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(statecontrol_connection self, cmf::water::WaterStorage::ptr controlled_storage, cmf::water::flux_node::ptr other_end, real target_state, Time reaction_time) -> statecontrol_connection
        statecontrol_connection(cmf::water::WaterStorage::ptr
        controlled_storage, cmf::water::flux_node::ptr other_end, real
        target_state, cmf::math::Time reaction_time)

        Creates a flux connection to control the state of a storage.

        Parameters:
        -----------

        controlled_storage:  Water storage, to be controlled

        other_end:  source of missing water or target of excessive water

        target_state:  State the controlled storage should hold (
        :math:`h_{target}`)

        reaction_time:  Time to reach state ( :math:`t_c`) 
        """
        _cmf_core.statecontrol_connection_swiginit(self, _cmf_core.new_statecontrol_connection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_statecontrol_connection

# Register statecontrol_connection in _cmf_core:
_cmf_core.statecontrol_connection_swigregister(statecontrol_connection)

class node_list(StateVariableOwner):
    r"""


    A collection of nodes for fast access of the waterbalance.

    In setups with many storages and rather fast computations, the speed
    of data access for output generation can take a high portion of the
    total run time. To accelerate data access, one can use the node_list
    object

    Todo Add a get_volume / set_volume function pair, to complement
    get_potential / set_potential

    C++ includes: collections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    size = _swig_new_instance_method(_cmf_core.node_list_size)

    def __init__(self, *args):
        r"""
        __init__(node_list self) -> node_list
        __init__(node_list self, node_list forcopy) -> node_list
        node_list(const cmf::water::node_list &forcopy)

        Copy the node_list. 
        """
        _cmf_core.node_list_swiginit(self, _cmf_core.new_node_list(*args))
    __iadd__ = _swig_new_instance_method(_cmf_core.node_list___iadd__)
    __add__ = _swig_new_instance_method(_cmf_core.node_list___add__)
    __get = _swig_new_instance_method(_cmf_core.node_list___get)
    __getslice = _swig_new_instance_method(_cmf_core.node_list___getslice)
    append = _swig_new_instance_method(_cmf_core.node_list_append)
    remove = _swig_new_instance_method(_cmf_core.node_list_remove)
    global_water_balance = _swig_new_instance_method(_cmf_core.node_list_global_water_balance)
    water_balance = _swig_new_instance_method(_cmf_core.node_list_water_balance)
    conc = _swig_new_instance_method(_cmf_core.node_list_conc)
    set_solute_source = _swig_new_instance_method(_cmf_core.node_list_set_solute_source)
    get_fluxes_to = _swig_new_instance_method(_cmf_core.node_list_get_fluxes_to)
    get_fluxes3d_to = _swig_new_instance_method(_cmf_core.node_list_get_fluxes3d_to)
    get_fluxes3d = _swig_new_instance_method(_cmf_core.node_list_get_fluxes3d)
    get_positions = _swig_new_instance_method(_cmf_core.node_list_get_positions)
    __swig_destroy__ = _cmf_core.delete_node_list
    potentials = property(_cmf_core.node_list_potentials_get, _cmf_core.node_list_potentials_set, doc=r"""potentials : cmf::math::num_array""")

    def __getitem__(self,index):
        if isinstance(index,slice):
            return self.__getslice(*index.indices(self.size())) 
        else:
            try:
                it = iter(index)
                return node_list(self.__get(i) for i in it)
            except:
                return self.__get(index)

    def __len__(self):
        return self.size()       
    def __iter__(self):
        for i in range(self.size()):
            yield self[i]
    def __repr__(self):
        if len(self): return "[%i nodes: %s ... %s]" % (len(self),self[0], self[-1])
        else: return "[empty node list]"
    def extend(self,sequence):
        """Extends the node list with the sequence (any iterable will do) """
        for o in sequence:
            self.append(o)
    @staticmethod
    def from_sequence(sequence):
        """Returns a new node list populated from the sequence (any iterable will do) """
        nl=node_list()
        nl.extend(sequence)
        return nl


# Register node_list in _cmf_core:
_cmf_core.node_list_swigregister(node_list)

class NeumannBoundary_list(object):
    r"""


    Provides fast access to Neumann boundaries for flux update.

    If many Neumann boundary conditions are present in a project, a fast
    data exchange to update the fluxes might be needed.

    With this specialized list a num_array can be passed to the boundary
    conditions for a fast flux update If a multiple system layout for the
    cmf setup is chosen, we might have a node_list Dirichlet boundary
    conditions (dbc), a corresponding NeumannBoundary_list (nbc) of
    Neumann boundaries and a node_list containing the storages connected
    with the NeumannBoundary_list (storages). The fast data exchange is
    written in Python as:

    C++ includes: collections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    get = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_get)
    get_fluxes = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_get_fluxes)
    append = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_append)
    size = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_size)

    def __init__(self, *args):
        r"""
        __init__(NeumannBoundary_list self) -> NeumannBoundary_list
        __init__(NeumannBoundary_list self, node_list copy) -> NeumannBoundary_list
        __init__(NeumannBoundary_list self, NeumannBoundary_list copy) -> NeumannBoundary_list
        NeumannBoundary_list(const NeumannBoundary_list &copy) 
        """
        _cmf_core.NeumannBoundary_list_swiginit(self, _cmf_core.new_NeumannBoundary_list(*args))
    to_node_list = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_to_node_list)
    global_water_balance = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_global_water_balance)
    water_balance = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_water_balance)
    fluxes = property(_cmf_core.NeumannBoundary_list_fluxes_get, _cmf_core.NeumannBoundary_list_fluxes_set, doc=r"""fluxes : cmf::math::num_array""")

    def __getitem__(self,index):
        return self.get(index)
    def __len__(self):
        return self.size()       
    def __iter__(self):
        for i in range(self.size()):
            yield self[i]
    def extend(self,sequence):
        """Extends the list of Neumann boundaries with the sequence (any iterable will do) """
        for o in sequence:
            self.append(o)
    @staticmethod
    def from_sequence(sequence):
        """Returns a new list of Neumann boundaries populated from the sequence (any iterable will do) """
        nl=NeumannBoundary_list()
        nl.extend(sequence)
        return nl

    __swig_destroy__ = _cmf_core.delete_NeumannBoundary_list

# Register NeumannBoundary_list in _cmf_core:
_cmf_core.NeumannBoundary_list_swigregister(NeumannBoundary_list)

class SystemBridge(flux_node):
    r"""


    A SystemBridge is an advanced feature for tuning of the calculation
    time.

    A SystemBridge can be used to replace an existing connection between
    nodes. It is created using the system_bridge function. After
    installation, the two nodes can more safely be added to different
    integrator systems. One node (called upper) is connected with the
    system bridge with the connection formerly connecting the nodes, the
    second node (called lower) is connected to the system bridge with as a
    Neumann boundary condition. The flux equals the average flux of the
    connection upper <-> SystemBridge. Therefore, the downward flux needs
    to be integrated over time by the solver the upper node belongs to.
    Use as an upper system (system upper node is belonging to) the faster
    reacting system. For the connection between upper and SystemBridge,
    the SystemBridge reacts as an Dirichlet boundary condition, providing
    the potential of the lower node.

    The following example code creates a system bridge between the nodes
    upper and lower. To integrate the flux over each timestep
    automatically, the systembridge is added to the solver of upper, as an
    integratable

    C++ includes: system_bridge.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get_upper_node = _swig_new_instance_method(_cmf_core.SystemBridge_get_upper_node)
    get_lower_node = _swig_new_instance_method(_cmf_core.SystemBridge_get_lower_node)
    get_down_flux = _swig_new_instance_method(_cmf_core.SystemBridge_get_down_flux)
    down_flux_integrator = _swig_new_instance_method(_cmf_core.SystemBridge_down_flux_integrator)
    __swig_destroy__ = _cmf_core.delete_SystemBridge

# Register SystemBridge in _cmf_core:
_cmf_core.SystemBridge_swigregister(SystemBridge)

class SystemBridgeConnection(flux_connection):
    r"""


    Connects a system bridge with its lower node. Is created automatically
    when creating a SystemBridge.

    C++ includes: system_bridge.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_SystemBridgeConnection

# Register SystemBridgeConnection in _cmf_core:
_cmf_core.SystemBridgeConnection_swigregister(SystemBridgeConnection)

system_bridge = _cmf_core.system_bridge

def integrate_over(item,solver=None):
    """Returns a suitable cmf.integratable implementation for item, if available.
    The created integratable is integrated by solver, if given"""
    try:
        it = iter(item)
    except:
        it=None
    if it:
        res = integratable_list()
        for i in it:
            integ = integrate_over(i,solver)
            res.append(integ)
        return res
    elif isinstance(item,flux_node):
        res = waterbalance_integrator(item)
    elif isinstance(item,flux_connection):
        res = flux_integrator(item)
    else:
        raise TypeError("""Only the waterbalance of flux_nodes and the flux of flux_connections
            are integratable. Received: """ + str(item))
    if isinstance(solver,Integrator):
        solver.integratables.append(res)
    return res

vapour_pressure = _cmf_core.vapour_pressure
vpd_from_rH = _cmf_core.vpd_from_rH
rH_from_vpd = _cmf_core.rH_from_vpd
watts_to_MJ = _cmf_core.watts_to_MJ
MJ_to_watts = _cmf_core.MJ_to_watts
extraterrestrial_radiation = _cmf_core.extraterrestrial_radiation
global_radiation = _cmf_core.global_radiation
Pressure = _cmf_core.Pressure
class Weather(object):
    r"""


    A structure holding meteorological information, excluding
    precipitation

    C++ includes: Weather.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    T = property(_cmf_core.Weather_T_get, _cmf_core.Weather_T_set, doc=r"""T : double""")
    Tmax = property(_cmf_core.Weather_Tmax_get, _cmf_core.Weather_Tmax_set, doc=r"""Tmax : double""")
    Tmin = property(_cmf_core.Weather_Tmin_get, _cmf_core.Weather_Tmin_set, doc=r"""Tmin : double""")
    Tground = property(_cmf_core.Weather_Tground_get, _cmf_core.Weather_Tground_set, doc=r"""Tground : double""")
    Windspeed = property(_cmf_core.Weather_Windspeed_get, _cmf_core.Weather_Windspeed_set, doc=r"""Windspeed : double""")
    e_a = property(_cmf_core.Weather_e_a_get, _cmf_core.Weather_e_a_set, doc=r"""e_a : double""")
    e_s = property(_cmf_core.Weather_e_s_get, _cmf_core.Weather_e_s_set, doc=r"""e_s : double""")
    sunshine = property(_cmf_core.Weather_sunshine_get, _cmf_core.Weather_sunshine_set, doc=r"""sunshine : double""")
    Rs = property(_cmf_core.Weather_Rs_get, _cmf_core.Weather_Rs_set, doc=r"""Rs : double""")
    Ra = property(_cmf_core.Weather_Ra_get, _cmf_core.Weather_Ra_set, doc=r"""Ra : double""")
    daylength = property(_cmf_core.Weather_daylength_get, _cmf_core.Weather_daylength_set, doc=r"""daylength : double""")
    instrument_height = property(_cmf_core.Weather_instrument_height_get, _cmf_core.Weather_instrument_height_set, doc=r"""instrument_height : double""")
    Rn = _swig_new_instance_method(_cmf_core.Weather_Rn)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Weather self, double T=15.0, double Tmax=17.0, double Tmin=13.0, double rH=70.0, double wind=2.0, double sunshine=0.5, double Rs=15, double Ra=30, double daylength=12) -> Weather
        Weather(double T=15.0, double Tmax=17.0, double Tmin=13.0, double
        rH=70.0, double wind=2.0, double sunshine=0.5, double Rs=15, double
        Ra=30, double daylength=12)

        Creates a "weather" from given data.

        Parameters:
        -----------

        T:  actual Temperature in deg C

        Tmax:  daily maximum Temperature in deg C

        Tmin:  daily minimum Temperature in deg C

        rH:  actual relative humidity in % [0..100]

        wind:  actual wind speed in m/s

        sunshine:  actual fraction of sunshine duration per potential sunshine
        duration in h/h

        Rs:  actual incoming shortwave global radiation in MJ/(m2 day)

        Ra:  actual extraterrestrial shortwave global radiation in MJ/(m2 day)

        daylength:  length of the day in h 
        """
        _cmf_core.Weather_swiginit(self, _cmf_core.new_Weather(*args, **kwargs))
    to_string = _swig_new_instance_method(_cmf_core.Weather_to_string)
    set_snow_threshold = _swig_new_static_method(_cmf_core.Weather_set_snow_threshold)
    get_snow_threshold = _swig_new_static_method(_cmf_core.Weather_get_snow_threshold)
    __iadd__ = _swig_new_instance_method(_cmf_core.Weather___iadd__)
    __imul__ = _swig_new_instance_method(_cmf_core.Weather___imul__)
    __add__ = _swig_new_instance_method(_cmf_core.Weather___add__)
    __mul__ = _swig_new_instance_method(_cmf_core.Weather___mul__)

    def __repr__(self):
        return "cmf.Weather(Tmin=%0.2f,Tmax=%0.2f)" % (self.Tmin,self.Tmax)
    def __str__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_Weather

# Register Weather in _cmf_core:
_cmf_core.Weather_swigregister(Weather)
Weather_set_snow_threshold = _cmf_core.Weather_set_snow_threshold
Weather_get_snow_threshold = _cmf_core.Weather_get_snow_threshold

class Meteorology(object):
    r"""


    An abstract class, for objects generating Weather records at a
    specific time.

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_cmf_core.Meteorology___call__)
    get_weather = _swig_new_instance_method(_cmf_core.Meteorology_get_weather)
    copy = _swig_new_instance_method(_cmf_core.Meteorology_copy)
    get_instrument_height = _swig_new_instance_method(_cmf_core.Meteorology_get_instrument_height)
    __swig_destroy__ = _cmf_core.delete_Meteorology

# Register Meteorology in _cmf_core:
_cmf_core.Meteorology_swigregister(Meteorology)

class ConstantMeteorology(Meteorology):
    r"""


    A primitive implementation of the Meteorology interface.

    Holds a Weather record and returns it for any date

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    weather = property(_cmf_core.ConstantMeteorology_weather_get, _cmf_core.ConstantMeteorology_weather_set, doc=r"""weather : cmf::atmosphere::Weather""")

    def __init__(self, *args):
        r"""
        __init__(ConstantMeteorology self) -> ConstantMeteorology
        __init__(ConstantMeteorology self, Weather w) -> ConstantMeteorology
        __init__(ConstantMeteorology self, ConstantMeteorology other) -> ConstantMeteorology
        ConstantMeteorology(const cmf::atmosphere::ConstantMeteorology &other)

        Copy constructor. 
        """
        _cmf_core.ConstantMeteorology_swiginit(self, _cmf_core.new_ConstantMeteorology(*args))
    copy = _swig_new_instance_method(_cmf_core.ConstantMeteorology_copy)
    __swig_destroy__ = _cmf_core.delete_ConstantMeteorology

# Register ConstantMeteorology in _cmf_core:
_cmf_core.ConstantMeteorology_swigregister(ConstantMeteorology)

class MeteoStation(object):
    r"""


    A meteorological station holding timeseries to create Weather records.

    In order to calculate ETpot with cmf a big amount of meteorological
    data is needed, more data than usually available. The MeteoStation
    class can estimate missing data from a minimal set. As more data, as
    one provides, the better the calculation of ETpot becomes. The minimal
    data needed is Tmin and Tmax (daily) and precipitation. To calculate
    the global radiation (although measured global radiation could be
    inserted), the position of meteorological station in geographic
    coordinates has to be set.

    A meteorological station is created by
    cmf::atmosphere::MeteoStationList::add_station . Usage from python:

    There are two modes for the meteorology: daily=true and daily=false.
    If daily=true, Radiation is given as a daily mean value. If
    daily=false, Radiation is given as an hourly mean value, which shows
    the dial ETpot variation but results in erronous results if the
    timestep is daily.

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Latitude = property(_cmf_core.MeteoStation_Latitude_get, _cmf_core.MeteoStation_Latitude_set, doc=r"""Latitude : double""")
    Longitude = property(_cmf_core.MeteoStation_Longitude_get, _cmf_core.MeteoStation_Longitude_set, doc=r"""Longitude : double""")
    Timezone = property(_cmf_core.MeteoStation_Timezone_get, _cmf_core.MeteoStation_Timezone_set, doc=r"""Timezone : double""")
    x = property(_cmf_core.MeteoStation_x_get, _cmf_core.MeteoStation_x_set, doc=r"""x : double""")
    y = property(_cmf_core.MeteoStation_y_get, _cmf_core.MeteoStation_y_set, doc=r"""y : double""")
    z = property(_cmf_core.MeteoStation_z_get, _cmf_core.MeteoStation_z_set, doc=r"""z : double""")
    Name = property(_cmf_core.MeteoStation_Name_get, _cmf_core.MeteoStation_Name_set, doc=r"""Name : std::string""")
    get_position = _swig_new_instance_method(_cmf_core.MeteoStation_get_position)
    daily = property(_cmf_core.MeteoStation_daily_get, _cmf_core.MeteoStation_daily_set, doc=r"""daily : bool""")
    InstrumentHeight = property(_cmf_core.MeteoStation_InstrumentHeight_get, _cmf_core.MeteoStation_InstrumentHeight_set, doc=r"""InstrumentHeight : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(MeteoStation self, MeteoStation other) -> MeteoStation
        MeteoStation(const cmf::atmosphere::MeteoStation &other)

        Copy c'tor. 
        """
        _cmf_core.MeteoStation_swiginit(self, _cmf_core.new_MeteoStation(*args, **kwargs))
    get_data = _swig_new_instance_method(_cmf_core.MeteoStation_get_data)
    use_for_cell = _swig_new_instance_method(_cmf_core.MeteoStation_use_for_cell)
    SetSunshineFraction = _swig_new_instance_method(_cmf_core.MeteoStation_SetSunshineFraction)
    T = property(_cmf_core.MeteoStation_T_get, _cmf_core.MeteoStation_T_set, doc=r"""T : cmf::math::timeseries""")
    Tmax = property(_cmf_core.MeteoStation_Tmax_get, _cmf_core.MeteoStation_Tmax_set, doc=r"""Tmax : cmf::math::timeseries""")
    Tmin = property(_cmf_core.MeteoStation_Tmin_get, _cmf_core.MeteoStation_Tmin_set, doc=r"""Tmin : cmf::math::timeseries""")
    Tground = property(_cmf_core.MeteoStation_Tground_get, _cmf_core.MeteoStation_Tground_set, doc=r"""Tground : cmf::math::timeseries""")
    Windspeed = property(_cmf_core.MeteoStation_Windspeed_get, _cmf_core.MeteoStation_Windspeed_set, doc=r"""Windspeed : cmf::math::timeseries""")
    rHmean = property(_cmf_core.MeteoStation_rHmean_get, _cmf_core.MeteoStation_rHmean_set, doc=r"""rHmean : cmf::math::timeseries""")
    rHmin = property(_cmf_core.MeteoStation_rHmin_get, _cmf_core.MeteoStation_rHmin_set, doc=r"""rHmin : cmf::math::timeseries""")
    rHmax = property(_cmf_core.MeteoStation_rHmax_get, _cmf_core.MeteoStation_rHmax_set, doc=r"""rHmax : cmf::math::timeseries""")
    Tdew = property(_cmf_core.MeteoStation_Tdew_get, _cmf_core.MeteoStation_Tdew_set, doc=r"""Tdew : cmf::math::timeseries""")
    Sunshine = property(_cmf_core.MeteoStation_Sunshine_get, _cmf_core.MeteoStation_Sunshine_set, doc=r"""Sunshine : cmf::math::timeseries""")
    Rs = property(_cmf_core.MeteoStation_Rs_get, _cmf_core.MeteoStation_Rs_set, doc=r"""Rs : cmf::math::timeseries""")
    T_lapse = property(_cmf_core.MeteoStation_T_lapse_get, _cmf_core.MeteoStation_T_lapse_set, doc=r"""T_lapse : cmf::math::timeseries""")

    def TimeseriesDictionary(self):
        return {"Tmin":self.Tmin,
                "Tmax":self.Tmax,
                "Tdew":self.Tdew,
                "T":self.T,
                "rHmean":self.rHmean,
                "rHmax":self.rHmax,
                "rHmin":self.rHmin,
                "Sunshine":self.Sunshine,
                "Windspeed":self.Windspeed,
                "Rs" : self.Rs}
    def __repr__(self):
        return "cmf.MeteoStation(%s,lat=%0.5g,lon=%0.5g,z=%6.1f)" % (self.Name,self.Latitude,self.Longitude,self.z)

    __swig_destroy__ = _cmf_core.delete_MeteoStation

# Register MeteoStation in _cmf_core:
_cmf_core.MeteoStation_swigregister(MeteoStation)

class MeteoStationReference(Meteorology):
    r"""


    A reference to a meteorological station.

    Returns the weather at a given time for its place using
    MeteoStation::T_lapse

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    get_station = _swig_new_instance_method(_cmf_core.MeteoStationReference_get_station)
    get_position = _swig_new_instance_method(_cmf_core.MeteoStationReference_get_position)

    def __init__(self, *args):
        r"""
        __init__(MeteoStationReference self, cmf::atmosphere::MeteoStation::ptr station, point location) -> MeteoStationReference
        __init__(MeteoStationReference self, MeteoStationReference copy) -> MeteoStationReference
        MeteoStationReference(const MeteoStationReference &copy) 
        """
        _cmf_core.MeteoStationReference_swiginit(self, _cmf_core.new_MeteoStationReference(*args))
    copy = _swig_new_instance_method(_cmf_core.MeteoStationReference_copy)
    __swig_destroy__ = _cmf_core.delete_MeteoStationReference

# Register MeteoStationReference in _cmf_core:
_cmf_core.MeteoStationReference_swigregister(MeteoStationReference)

class MeteoStationList(object):
    r"""


    A list of meteorological stations.

    Can find the nearest station for a position and calculate the
    temperature lapse

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __len__ = _swig_new_instance_method(_cmf_core.MeteoStationList___len__)
    __getitem__ = _swig_new_instance_method(_cmf_core.MeteoStationList___getitem__)
    calculate_Temp_lapse = _swig_new_instance_method(_cmf_core.MeteoStationList_calculate_Temp_lapse)
    add_station = _swig_new_instance_method(_cmf_core.MeteoStationList_add_station)
    remove_station = _swig_new_instance_method(_cmf_core.MeteoStationList_remove_station)

    def __init__(self, *args):
        r"""
        __init__(MeteoStationList self) -> MeteoStationList
        __init__(MeteoStationList self, MeteoStationList copy) -> MeteoStationList
        MeteoStationList(const MeteoStationList &copy)

        Copy c'tor. 
        """
        _cmf_core.MeteoStationList_swiginit(self, _cmf_core.new_MeteoStationList(*args))
    reference_to_nearest = _swig_new_instance_method(_cmf_core.MeteoStationList_reference_to_nearest)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __repr__(self):
        return "list of %i cmf meteorological stations" % len(self)

    __swig_destroy__ = _cmf_core.delete_MeteoStationList

# Register MeteoStationList in _cmf_core:
_cmf_core.MeteoStationList_swigregister(MeteoStationList)

class IDW_Meteorology(Meteorology):
    r"""


    Regionalizes meteorological measurements using a simple inverse
    distance weighted (IDW) method.

    See:  IDW

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(IDW_Meteorology self, point position, MeteoStationList stations, double z_weight, double power) -> IDW_Meteorology
        __init__(IDW_Meteorology self, IDW_Meteorology copy) -> IDW_Meteorology
        IDW_Meteorology(const IDW_Meteorology &copy)

        Copy c'tor. 
        """
        _cmf_core.IDW_Meteorology_swiginit(self, _cmf_core.new_IDW_Meteorology(*args))
    copy = _swig_new_instance_method(_cmf_core.IDW_Meteorology_copy)
    __swig_destroy__ = _cmf_core.delete_IDW_Meteorology

# Register IDW_Meteorology in _cmf_core:
_cmf_core.IDW_Meteorology_swigregister(IDW_Meteorology)

class aerodynamic_resistance(object):
    r"""


    Abstract class. Child classes can be used to calculate aerodynamic
    resistances against turbulent heat fluxes.

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    get_aerodynamic_resistance = _swig_new_instance_method(_cmf_core.aerodynamic_resistance_get_aerodynamic_resistance)
    __swig_destroy__ = _cmf_core.delete_aerodynamic_resistance

# Register aerodynamic_resistance in _cmf_core:
_cmf_core.aerodynamic_resistance_swigregister(aerodynamic_resistance)

class RainSource(flux_node):
    r"""


    An abstract class for different types of rainfall sources.

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_cmf_core.RainSource___call__)
    get_intensity = _swig_new_instance_method(_cmf_core.RainSource_get_intensity)

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_RainSource

# Register RainSource in _cmf_core:
_cmf_core.RainSource_swigregister(RainSource)

class ConstantRainSource(RainSource):
    r"""


    A simple implementation of RainSource.

    Returns intensity for any time step.

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    intensity = property(_cmf_core.ConstantRainSource_intensity_get, _cmf_core.ConstantRainSource_intensity_set, doc=r"""intensity : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ConstantRainSource self, project _project, point location, real _intensity) -> ConstantRainSource
        ConstantRainSource(cmf::project &_project, cmf::geometry::point
        location, real _intensity)

        Creates a new ConstantRainSource.

        Consider using Cell::set_rainfall for internal creation of a constant
        rain source, instead of direct use

        Parameters:
        -----------

        _project:  The project the rain source is belonging to.

        location:  The location of the rain source

        _intensity:  The constant rainfall intensity in mm/day 
        """
        _cmf_core.ConstantRainSource_swiginit(self, _cmf_core.new_ConstantRainSource(*args, **kwargs))
    set_conc = _swig_new_instance_method(_cmf_core.ConstantRainSource_set_conc)

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_ConstantRainSource

# Register ConstantRainSource in _cmf_core:
_cmf_core.ConstantRainSource_swigregister(ConstantRainSource)

class TimeseriesRainSource(RainSource):
    r"""


    A rainsource with a timeseries.

    Simpler to use than a rainfall station if there are only few cells in
    the project

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    data = property(_cmf_core.TimeseriesRainSource_data_get, _cmf_core.TimeseriesRainSource_data_set, doc=r"""data : cmf::math::timeseries""")
    concentrations = property(_cmf_core.TimeseriesRainSource_concentrations_get, _cmf_core.TimeseriesRainSource_concentrations_set, doc=r"""concentrations : cmf::water::SoluteTimeseries""")
    __swig_destroy__ = _cmf_core.delete_TimeseriesRainSource

# Register TimeseriesRainSource in _cmf_core:
_cmf_core.TimeseriesRainSource_swigregister(TimeseriesRainSource)

class RainfallStation(object):
    r"""


    RainfallStation describes a rainfall timeseries in mm/day at a certain
    place.

    Use RainfallStationReference or IDWRainfall to distribute the data
    into space

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    Location = property(_cmf_core.RainfallStation_Location_get, _cmf_core.RainfallStation_Location_set, doc=r"""Location : cmf::geometry::point""")
    create = _swig_new_static_method(_cmf_core.RainfallStation_create)
    id = property(_cmf_core.RainfallStation_id_get, doc=r"""id : q(const).size_t""")
    name = property(_cmf_core.RainfallStation_name_get, doc=r"""name : q(const).std::string""")
    data = property(_cmf_core.RainfallStation_data_get, _cmf_core.RainfallStation_data_set, doc=r"""data : cmf::math::timeseries""")
    __repr__ = _swig_new_instance_method(_cmf_core.RainfallStation___repr__)
    concentration = property(_cmf_core.RainfallStation_concentration_get, _cmf_core.RainfallStation_concentration_set, doc=r"""concentration : cmf::water::SoluteTimeseries""")
    use_for_cell = _swig_new_instance_method(_cmf_core.RainfallStation_use_for_cell)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(RainfallStation self, RainfallStation copy) -> RainfallStation
        RainfallStation(const RainfallStation &copy)

        copy c'tor 
        """
        _cmf_core.RainfallStation_swiginit(self, _cmf_core.new_RainfallStation(*args, **kwargs))
    __call__ = _swig_new_instance_method(_cmf_core.RainfallStation___call__)
    __swig_destroy__ = _cmf_core.delete_RainfallStation

# Register RainfallStation in _cmf_core:
_cmf_core.RainfallStation_swigregister(RainfallStation)
RainfallStation_create = _cmf_core.RainfallStation_create

class RainfallStationList(object):
    r"""


    A list of rainfall stations.

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __len__ = _swig_new_instance_method(_cmf_core.RainfallStationList___len__)
    __getitem__ = _swig_new_instance_method(_cmf_core.RainfallStationList___getitem__)
    add = _swig_new_instance_method(_cmf_core.RainfallStationList_add)
    remove = _swig_new_instance_method(_cmf_core.RainfallStationList_remove)

    def __repr__(self):
        return repr(list(self))
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]


    def __init__(self, *args, **kwargs):
        r"""__init__(RainfallStationList self) -> RainfallStationList"""
        _cmf_core.RainfallStationList_swiginit(self, _cmf_core.new_RainfallStationList(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_RainfallStationList

# Register RainfallStationList in _cmf_core:
_cmf_core.RainfallStationList_swigregister(RainfallStationList)

class RainfallStationReference(RainSource):
    r"""


    References a single RainfallStation to provide rainfall intensity
    data.

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    from_nearest_station = _swig_new_static_method(_cmf_core.RainfallStationReference_from_nearest_station)
    from_station_id = _swig_new_static_method(_cmf_core.RainfallStationReference_from_station_id)

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_RainfallStationReference

# Register RainfallStationReference in _cmf_core:
_cmf_core.RainfallStationReference_swigregister(RainfallStationReference)
RainfallStationReference_from_nearest_station = _cmf_core.RainfallStationReference_from_nearest_station
RainfallStationReference_from_station_id = _cmf_core.RainfallStationReference_from_station_id

class IDWRainfall(RainSource):
    r"""


    A RainSource using a spatially interpolated rainfall intensity from
    all stations.

    Interpolation method is inverse distance weighted (IDW)

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    create = _swig_new_static_method(_cmf_core.IDWRainfall_create)

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_IDWRainfall

# Register IDWRainfall in _cmf_core:
_cmf_core.IDWRainfall_swigregister(IDWRainfall)
IDWRainfall_create = _cmf_core.IDWRainfall_create

class Vegetation(object):
    r"""


    Holds the vegetation parameters for the calculation of ET and
    fractionating rainfall. Not every ET method uses all parameters.

    C++ includes: StructVegetation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    LAI = property(_cmf_core.Vegetation_LAI_get, _cmf_core.Vegetation_LAI_set, doc=r"""LAI : double""")
    Height = property(_cmf_core.Vegetation_Height_get, _cmf_core.Vegetation_Height_set, doc=r"""Height : double""")
    albedo = property(_cmf_core.Vegetation_albedo_get, _cmf_core.Vegetation_albedo_set, doc=r"""albedo : double""")
    snow_albedo = property(_cmf_core.Vegetation_snow_albedo_get, _cmf_core.Vegetation_snow_albedo_set, doc=r"""snow_albedo : double""")
    CanopyCapacityPerLAI = property(_cmf_core.Vegetation_CanopyCapacityPerLAI_get, _cmf_core.Vegetation_CanopyCapacityPerLAI_set, doc=r"""CanopyCapacityPerLAI : double""")
    RootDepth = property(_cmf_core.Vegetation_RootDepth_get, _cmf_core.Vegetation_RootDepth_set, doc=r"""RootDepth : double""")
    RootContent = property(_cmf_core.Vegetation_RootContent_get, _cmf_core.Vegetation_RootContent_set, doc=r"""RootContent : double""")
    fraction_at_rootdepth = property(_cmf_core.Vegetation_fraction_at_rootdepth_get, _cmf_core.Vegetation_fraction_at_rootdepth_set, doc=r"""fraction_at_rootdepth : double""")
    StomatalResistance = property(_cmf_core.Vegetation_StomatalResistance_get, _cmf_core.Vegetation_StomatalResistance_set, doc=r"""StomatalResistance : double""")
    CanopyClosure = property(_cmf_core.Vegetation_CanopyClosure_get, _cmf_core.Vegetation_CanopyClosure_set, doc=r"""CanopyClosure : double""")
    CanopyPARExtinction = property(_cmf_core.Vegetation_CanopyPARExtinction_get, _cmf_core.Vegetation_CanopyPARExtinction_set, doc=r"""CanopyPARExtinction : double""")
    LeafWidth = property(_cmf_core.Vegetation_LeafWidth_get, _cmf_core.Vegetation_LeafWidth_set, doc=r"""LeafWidth : double""")
    RootLength = _swig_new_instance_method(_cmf_core.Vegetation_RootLength)
    RootFraction = _swig_new_instance_method(_cmf_core.Vegetation_RootFraction)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Vegetation self, double _LAI=2.88, double _Height=0.12, double _RootDepth=0.25, double _StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1, double _CanopyCapacityPerLAI=0.1, double _fraction_at_rootdepth=1.0) -> Vegetation
        Vegetation(double
        _LAI=2.88, double _Height=0.12, double _RootDepth=0.25, double
        _StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
        double _CanopyCapacityPerLAI=0.1, double _fraction_at_rootdepth=1.0)

        """
        _cmf_core.Vegetation_swiginit(self, _cmf_core.new_Vegetation(*args, **kwargs))
    __repr__ = _swig_new_instance_method(_cmf_core.Vegetation___repr__)
    __swig_destroy__ = _cmf_core.delete_Vegetation

# Register Vegetation in _cmf_core:
_cmf_core.Vegetation_swigregister(Vegetation)

class CellConnector(object):
    r"""


    A helper class to connect cells with flux_connection objects. This is
    generated by flux_connection classes, intended to connect cells.

    C++ includes: cell.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(CellConnector self, cmf::upslope::connectorfunction connector) -> CellConnector
        CellConnector(connectorfunction connector) 
        """
        _cmf_core.CellConnector_swiginit(self, _cmf_core.new_CellConnector(*args, **kwargs))
    __call__ = _swig_new_instance_method(_cmf_core.CellConnector___call__)
    connect = _swig_new_instance_method(_cmf_core.CellConnector_connect)
    __swig_destroy__ = _cmf_core.delete_CellConnector

# Register CellConnector in _cmf_core:
_cmf_core.CellConnector_swigregister(CellConnector)

class Cell(StateVariableOwner):
    r"""


    This class is the basic landscape object.

    It is the owner of water storages, and the upper and lower boundary
    conditions of the system (rainfall, atmospheric vapor, deep
    groundwater)

    C++ includes: cell.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = property(_cmf_core.Cell_x_get, _cmf_core.Cell_x_set, doc=r"""x : double""")
    y = property(_cmf_core.Cell_y_get, _cmf_core.Cell_y_set, doc=r"""y : double""")
    z = property(_cmf_core.Cell_z_get, _cmf_core.Cell_z_set, doc=r"""z : double""")
    get_position = _swig_new_instance_method(_cmf_core.Cell_get_position)
    m3_to_mm = _swig_new_instance_method(_cmf_core.Cell_m3_to_mm)
    mm_to_m3 = _swig_new_instance_method(_cmf_core.Cell_mm_to_m3)
    InvalidateSatDepth = _swig_new_instance_method(_cmf_core.Cell_InvalidateSatDepth)
    vegetation = property(_cmf_core.Cell_vegetation_get, _cmf_core.Cell_vegetation_set, doc=r"""vegetation : cmf::upslope::vegetation::Vegetation""")
    set_aerodynamic_resistance = _swig_new_instance_method(_cmf_core.Cell_set_aerodynamic_resistance)
    set_weather = _swig_new_instance_method(_cmf_core.Cell_set_weather)
    set_rainfall = _swig_new_instance_method(_cmf_core.Cell_set_rainfall)
    get_rainfall = _swig_new_instance_method(_cmf_core.Cell_get_rainfall)
    __set_rain_source = _swig_new_instance_method(_cmf_core.Cell___set_rain_source)
    __get_rain_source = _swig_new_instance_method(_cmf_core.Cell___get_rain_source)
    set_uptakestress = _swig_new_instance_method(_cmf_core.Cell_set_uptakestress)
    __get_evaporation = _swig_new_instance_method(_cmf_core.Cell___get_evaporation)
    __get_transpiration = _swig_new_instance_method(_cmf_core.Cell___get_transpiration)
    get_surfacewater = _swig_new_instance_method(_cmf_core.Cell_get_surfacewater)
    surfacewater_as_storage = _swig_new_instance_method(_cmf_core.Cell_surfacewater_as_storage)
    add_storage = _swig_new_instance_method(_cmf_core.Cell_add_storage)
    remove_storage = _swig_new_instance_method(_cmf_core.Cell_remove_storage)
    storage_count = _swig_new_instance_method(_cmf_core.Cell_storage_count)
    get_storage = _swig_new_instance_method(_cmf_core.Cell_get_storage)
    get_canopy = _swig_new_instance_method(_cmf_core.Cell_get_canopy)
    get_snow = _swig_new_instance_method(_cmf_core.Cell_get_snow)
    snow_coverage = _swig_new_instance_method(_cmf_core.Cell_snow_coverage)
    albedo = _swig_new_instance_method(_cmf_core.Cell_albedo)
    surface_water_coverage = _swig_new_instance_method(_cmf_core.Cell_surface_water_coverage)
    heat_flux = _swig_new_instance_method(_cmf_core.Cell_heat_flux)
    Tground = property(_cmf_core.Cell_Tground_get, _cmf_core.Cell_Tground_set, doc=r"""Tground : real""")
    leave_wetness = _swig_new_instance_method(_cmf_core.Cell_leave_wetness)
    Id = property(_cmf_core.Cell_Id_get, _cmf_core.Cell_Id_set, doc=r"""Id : ptrdiff_t""")
    get_WKB = _swig_new_instance_method(_cmf_core.Cell_get_WKB)
    set_WKB = _swig_new_instance_method(_cmf_core.Cell_set_WKB)
    get_weather = _swig_new_instance_method(_cmf_core.Cell_get_weather)
    layer_count = _swig_new_instance_method(_cmf_core.Cell_layer_count)
    get_layer = _swig_new_instance_method(_cmf_core.Cell_get_layer)
    add_layer = _swig_new_instance_method(_cmf_core.Cell_add_layer)
    remove_last_layer = _swig_new_instance_method(_cmf_core.Cell_remove_last_layer)
    remove_layers = _swig_new_instance_method(_cmf_core.Cell_remove_layers)
    __swig_destroy__ = _cmf_core.delete_Cell

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Cell self, double x, double y, double z, double area, project _project) -> Cell
        Cell(double x,
        double y, double z, double area, cmf::project &_project) 
        """
        _cmf_core.Cell_swiginit(self, _cmf_core.new_Cell(*args, **kwargs))
    to_string = _swig_new_instance_method(_cmf_core.Cell_to_string)
    topology = property(_cmf_core.Cell_topology_get, doc=r"""topology : cmf::upslope::Topology""")

    evaporation = property(_cmf_core.Cell___get_evaporation)


    transpiration = property(_cmf_core.Cell___get_transpiration)

    meteorology = property(_cmf_core.Cell_meteorology_get, _cmf_core.Cell_meteorology_set, doc=r"""meteorology : cmf::atmosphere::Meteorology""")

    rain_source = property(_cmf_core.Cell___get_rain_source,
                    _cmf_core.Cell___set_rain_source)

    layers = property(_cmf_core.Cell_layers_get, doc=r"""layers : cmf::upslope::layer_list""")
    project = property(_cmf_core.Cell_project_get, doc=r"""project : cmf::project""")
    saturated_depth = property(_cmf_core.Cell_saturated_depth_get, _cmf_core.Cell_saturated_depth_set, doc=r"""saturated_depth : real""")
    area = property(_cmf_core.Cell_area_get, doc=r"""area : real""")
    soildepth = property(_cmf_core.Cell_soildepth_get, doc=r"""soildepth : real""")

    @property
    def surface_storages(self):
        "Provides access to all surface storages of the cell, like canopy, snow, surface water etc"
        return [self.get_storage(i) for i in range(self.storage_count())]
    @property
    def storages(self):
        "Provides access to all storages of the cell (surface storages and layers)"
        return self.surface_storages + list(self.layers)

    @property
    def neighbors(self):
        c_iter=neighbor_iterator(self)
        while c_iter.valid():
            yield (c_iter.cell(),c_iter.flowwidth())
            c_iter.next_neighbor()

    surfacewater=property(get_surfacewater, None, doc="Gives access to the surface water, which is either a distributing flux node, or the storage for all surface water")
    canopy=property(get_canopy, None, doc="The canopy water storage of the cell, if it exists")
    snow=property(get_snow, None, doc="The snow pack of the cell, if a storage for the snow exists")

    contributing_area=property(lambda self:self.topology.ContributingArea(), None, doc="Contributing area of this cell m2")
    main_outlet=property(lambda self:self.topology.MainOutlet(), None, doc="The main outlet of the surface water of this cell")

    def connect_soil_with_node(self,node,ctype,flowwidth,distance,upper_boundary=0,lower_boundary=None):
        """Connects all layers between the boundaries with a node using a flux connection
        node: Target node (flux_node)
        type: Type of the connection (e.g. cmf.Richards_lateral)
        flowwidth: Width of the connection
        distance: distance of the connection
        upper_boundary: Connect only layers, whose lower depth is greater then this value
        lower_boundary: Connect only  layers, whose upper depth is smaller then this value
        """
        if lower_boundary is None:
            lower_boundary=self.soildepth
        connections=[ctype(l,node,flowwidth,distance) 
                     for l in self.layers 
                     if     l.boundary[0]<lower_boundary 
                        and l.boundary[1]>upper_boundary 
                    ]

    def install_connection(self,connection_type):
        """Calls the static use_for_cell method of the connection_type, if present.
        The use_for_cell method might do quite a lot of stuff, please consult the docs for the connection.
        Eg. >>>help(Richards.use_for_cell) 
        """
        if hasattr(connection_type,"use_for_cell"):
            connection_type.use_for_cell(self)
        else:
            raise TypeError("Only connection types implementing a static use_for_cell function can be used")
    def __hash__(self):
        return hash((self.x,self.y,self.Id))
    def __eq__(self,cmp):
        return hash(self)==hash(cmp)
    def __repr__(self):
        return "cell #%i(%g,%g,%g)" % (self.Id,self.x,self.y,self.z)


# Register Cell in _cmf_core:
_cmf_core.Cell_swigregister(Cell)

class Topology(object):
    r"""


    represents the connectivity of cells to each other

    C++ includes: Topology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    cell = property(_cmf_core.Topology_cell_get, doc=r"""cell : q(const).p.cmf::upslope::Cell""")
    x = property(_cmf_core.Topology_x_get, _cmf_core.Topology_x_set, doc=r"""x : r.double""")
    y = property(_cmf_core.Topology_y_get, _cmf_core.Topology_y_set, doc=r"""y : r.double""")
    z = property(_cmf_core.Topology_z_get, _cmf_core.Topology_z_set, doc=r"""z : r.double""")
    get_position = _swig_new_instance_method(_cmf_core.Topology_get_position)
    flowwidth = _swig_new_instance_method(_cmf_core.Topology_flowwidth)
    AddNeighbor = _swig_new_instance_method(_cmf_core.Topology_AddNeighbor)
    RemoveNeighbor = _swig_new_instance_method(_cmf_core.Topology_RemoveNeighbor)
    neighbor_count = _swig_new_instance_method(_cmf_core.Topology_neighbor_count)
    MainOutlet = _swig_new_instance_method(_cmf_core.Topology_MainOutlet)
    ContributingArea = _swig_new_instance_method(_cmf_core.Topology_ContributingArea)
    calculate_contributing_area = _swig_new_static_method(_cmf_core.Topology_calculate_contributing_area)
    __eq__ = _swig_new_instance_method(_cmf_core.Topology___eq__)
    __swig_destroy__ = _cmf_core.delete_Topology

# Register Topology in _cmf_core:
_cmf_core.Topology_swigregister(Topology)
Topology_calculate_contributing_area = _cmf_core.Topology_calculate_contributing_area

class neighbor_iterator(object):
    r"""


    A class to iterate through the neighbors of a cell (const). Not needed
    from the Python side, use the generator cell.neighbors instead.

    C++ includes: Topology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(neighbor_iterator self, Cell cell) -> neighbor_iterator
        neighbor_iterator(cmf::upslope::Cell *cell) 
        """
        _cmf_core.neighbor_iterator_swiginit(self, _cmf_core.new_neighbor_iterator(*args, **kwargs))
    cell = _swig_new_instance_method(_cmf_core.neighbor_iterator_cell)
    flowwidth = _swig_new_instance_method(_cmf_core.neighbor_iterator_flowwidth)
    valid = _swig_new_instance_method(_cmf_core.neighbor_iterator_valid)
    next_neighbor = _swig_new_instance_method(_cmf_core.neighbor_iterator_next_neighbor)
    __eq__ = _swig_new_instance_method(_cmf_core.neighbor_iterator___eq__)
    __neq__ = _swig_new_instance_method(_cmf_core.neighbor_iterator___neq__)
    __swig_destroy__ = _cmf_core.delete_neighbor_iterator

# Register neighbor_iterator in _cmf_core:
_cmf_core.neighbor_iterator_swigregister(neighbor_iterator)

class cell_vector(StateVariableOwner):
    r"""


    A cell vector holds a bunch of cells.

    C++ includes: cell_vector.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(cell_vector self) -> cell_vector
        __init__(cell_vector self, cell_vector copy) -> cell_vector
        cell_vector(cell_const_iterator first, cell_const_iterator last) 
        """
        _cmf_core.cell_vector_swiginit(self, _cmf_core.new_cell_vector(*args))
    __getitem__ = _swig_new_instance_method(_cmf_core.cell_vector___getitem__)
    append = _swig_new_instance_method(_cmf_core.cell_vector_append)
    remove = _swig_new_instance_method(_cmf_core.cell_vector_remove)
    pop = _swig_new_instance_method(_cmf_core.cell_vector_pop)
    __len__ = _swig_new_instance_method(_cmf_core.cell_vector___len__)
    __getslice__ = _swig_new_instance_method(_cmf_core.cell_vector___getslice__)
    get_area = _swig_new_instance_method(_cmf_core.cell_vector_get_area)
    __contains__ = _swig_new_instance_method(_cmf_core.cell_vector___contains__)
    __swig_destroy__ = _cmf_core.delete_cell_vector
    lowest = property(_cmf_core.cell_vector_lowest_get, doc=r"""lowest : cmf::upslope::Cell""")
    highest = property(_cmf_core.cell_vector_highest_get, doc=r"""highest : cmf::upslope::Cell""")

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]   
    def __repr__(self):
        if len(self):
            return "[%i cells, %0.0fm2, %0.0f - %0.0f m asl.]" % (len(self),self.get_area(),self.lowest.z,self.highest.z)
        else:
            return "<empty cell vector>"        


# Register cell_vector in _cmf_core:
_cmf_core.cell_vector_swigregister(cell_vector)

find_cell = _cmf_core.find_cell
get_boundary_cells = _cmf_core.get_boundary_cells
get_connections = _cmf_core.get_connections
connect_cells_with_flux = _cmf_core.connect_cells_with_flux
fill_sinks = _cmf_core.fill_sinks
get_area = _cmf_core.get_area
get_center = _cmf_core.get_center
cell_positions = _cmf_core.cell_positions
cell_flux_directions = _cmf_core.cell_flux_directions
cell2cellflux = _cmf_core.cell2cellflux
cell_distance = _cmf_core.cell_distance
class subcatchment(object):
    r"""


    A class to structure cells in a project using their main outlets.

    C++ includes: algorithm.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pourpoint = property(_cmf_core.subcatchment_pourpoint_get, doc=r"""pourpoint : r.q(const).cmf::upslope::Cell""")
    inflowcells = property(_cmf_core.subcatchment_inflowcells_get, _cmf_core.subcatchment_inflowcells_set, doc=r"""inflowcells : cmf::upslope::cell_vector""")
    cells = property(_cmf_core.subcatchment_cells_get, _cmf_core.subcatchment_cells_set, doc=r"""cells : cmf::upslope::cell_vector""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(subcatchment self, Cell pourpoint, double area_threshold=1e308) -> subcatchment
        subcatchment(cmf::upslope::Cell &pourpoint, double
        area_threshold=1e308)

        Creates a subcatchment from a pourpoint cell.

        Parameters:
        -----------

        pourpoint:  The pourpoint (outlet of the subcatchment)

        area_threshold:  Minimum contributing area size to form a
        subcatchment. When area_threshold > area(cells), all upslope cells of
        pourpoint are used. 
        """
        _cmf_core.subcatchment_swiginit(self, _cmf_core.new_subcatchment(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_subcatchment

# Register subcatchment in _cmf_core:
_cmf_core.subcatchment_swigregister(subcatchment)

pressure_to_waterhead = _cmf_core.pressure_to_waterhead
waterhead_to_pressure = _cmf_core.waterhead_to_pressure
pF_to_waterhead = _cmf_core.pF_to_waterhead
waterhead_to_pF = _cmf_core.waterhead_to_pF
class RetentionCurve(object):
    r"""


    Abstract base class for different types of retention curves.

    This class, and its children uses wetness instead of volumetric water
    content. The wetness of a soil is defined as water content per void
    volume

    C++ includes: RetentionCurve.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    K = _swig_new_instance_method(_cmf_core.RetentionCurve_K)
    Wetness_eff = _swig_new_instance_method(_cmf_core.RetentionCurve_Wetness_eff)
    Porosity = _swig_new_instance_method(_cmf_core.RetentionCurve_Porosity)
    VoidVolume = _swig_new_instance_method(_cmf_core.RetentionCurve_VoidVolume)
    FillHeight = _swig_new_instance_method(_cmf_core.RetentionCurve_FillHeight)
    Diffusivity = _swig_new_instance_method(_cmf_core.RetentionCurve_Diffusivity)
    Wetness = _swig_new_instance_method(_cmf_core.RetentionCurve_Wetness)
    theta = _swig_new_instance_method(_cmf_core.RetentionCurve_theta)
    dPsiM_dW = _swig_new_instance_method(_cmf_core.RetentionCurve_dPsiM_dW)
    Wetness_pF = _swig_new_instance_method(_cmf_core.RetentionCurve_Wetness_pF)
    MatricPotential = _swig_new_instance_method(_cmf_core.RetentionCurve_MatricPotential)
    copy = _swig_new_instance_method(_cmf_core.RetentionCurve_copy)
    __swig_destroy__ = _cmf_core.delete_RetentionCurve

# Register RetentionCurve in _cmf_core:
_cmf_core.RetentionCurve_swigregister(RetentionCurve)
rho_wg = cvar.rho_wg

class BrooksCoreyRetentionCurve(RetentionCurve):
    r"""


    Provides the use of the Brooks-Corey retention curve.



    .. math::

         W(\\theta) &=& \\frac{\\theta -
        \\theta_r}{\\theta_s - \\theta_r} \\\\ K(W) &=& K_{sat}
        W^{2b+3} \\\\ \\Psi(W) &=& \\Psi_X
        \\left(\\frac{W}{W_X}\\right)^{-b} \\\\ W(\\Psi) &=&
        {\\left( \\frac{\\Psi_X}{\\Psi}\\right)
        }^{\\frac{1}{b}}\\ W_X 

     where:  :math:`K` is the
    conductivity in :math:`\\frac m{day}`

    :math:`W` is the wetness (Volume of soil water per volume of pores)

    :math:`b` is the shape of the retention curve (usually between 4 (sand) and
    14 (clay))

    :math:`\\Psi(W)` is the matric potential in :math:`m H_2O` at wetness W

    :math:`\\Psi_X` is a matric potential at a known wetness in :math:`m H_2O`

    :math:`W_X` is the wetness with a known matric potential for dynamic changes
    with depth, exponential decays of porosity and saturated conductivity
    are used The decay function is: :math:`v(d)=v(0) (1+a)^{-d}`, where v is
    the value ( :math:`K_{sat},\\Phi`), d is the depth in m and a is the
    fractional decay per m. E.g. 0.1 means the value has in 1 m depth 90%
    of the value at the surface

    C++ includes: RetentionCurve.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Ksat = property(_cmf_core.BrooksCoreyRetentionCurve_Ksat_get, _cmf_core.BrooksCoreyRetentionCurve_Ksat_set, doc=r"""Ksat : real""")
    SetPorosity = _swig_new_instance_method(_cmf_core.BrooksCoreyRetentionCurve_SetPorosity)
    Transmissivity = _swig_new_instance_method(_cmf_core.BrooksCoreyRetentionCurve_Transmissivity)
    wetness_X = property(_cmf_core.BrooksCoreyRetentionCurve_wetness_X_get, _cmf_core.BrooksCoreyRetentionCurve_wetness_X_set, doc=r"""wetness_X : real""")
    Psi_X = property(_cmf_core.BrooksCoreyRetentionCurve_Psi_X_get, _cmf_core.BrooksCoreyRetentionCurve_Psi_X_set, doc=r"""Psi_X : real""")
    residual_theta = property(_cmf_core.BrooksCoreyRetentionCurve_residual_theta_get, _cmf_core.BrooksCoreyRetentionCurve_residual_theta_set, doc=r"""residual_theta : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(BrooksCoreyRetentionCurve self, real ksat=15, real porosity=0.5, real _b=5, real theta_x=0.2, real psi_x=cmf::upslope::pF_to_waterhead(2.5), real porosity_decay=0) -> BrooksCoreyRetentionCurve
        BrooksCoreyRetentionCurve(real ksat=15, real porosity=0.5, real _b=5,
        real theta_x=0.2, real psi_x=pF_to_waterhead(2.5), real
        porosity_decay=0)

        Creates a brooks corey retention curve.

        Parameters:
        -----------

        ksat:  Saturated conductivity :math:`\\frac{m}{day}`

        porosity:   :math:`\\frac{m^3 Pores}{m^3 Soil}`

        _b:  Shape of the retention curve (if you do not know how to
        parameterize this, take a look at the other constructor)

        theta_x:   :math:`\\theta_X` Water content at a specific suction pressure

        psi_x:  Suction pressure for :math:`\\theta_X` in m water column, use the
        conversion functions pF_to_waterhead, pressure_to_waterhead to convert
        pressure in to waterhead height (default pF=2.5)

        porosity_decay:  Relative decay of porosity with depth, e.g. 0.1 means
        conductivity gets 10% smaller per meter 
        """
        _cmf_core.BrooksCoreyRetentionCurve_swiginit(self, _cmf_core.new_BrooksCoreyRetentionCurve(*args, **kwargs))
    CreateFrom2Points = _swig_new_static_method(_cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points)
    copy = _swig_new_instance_method(_cmf_core.BrooksCoreyRetentionCurve_copy)
    __swig_destroy__ = _cmf_core.delete_BrooksCoreyRetentionCurve
    b = property(_cmf_core.BrooksCoreyRetentionCurve_b_get, _cmf_core.BrooksCoreyRetentionCurve_b_set, doc=r"""b : real""")

    def __repr__(self):
        return "cmf.BrooksCoreyRetentionCurve(Ksat=%g,phi=%g,b=%g,wfp0=%0.1f,pF0=%0.2f)" % (self.Ksat,self.Porosity(0.0),self.b,self.wetness_X,waterhead_to_pF(self.Psi_X))
    def __str__(self):
        return "Brooks-Corey retention curve: Ksat=%0.3g m/day,por.=%0.0f%%,b=%g,%0.1f%% water content at pF%0.2f)" % (self.Ksat,self.Porosity(0.0)*100,self.b,self.wetness_X * self.Porosity(0.0) * 100,waterhead_to_pF(self.Psi_X))


# Register BrooksCoreyRetentionCurve in _cmf_core:
_cmf_core.BrooksCoreyRetentionCurve_swigregister(BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve_CreateFrom2Points = _cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points

class VanGenuchtenMualem(RetentionCurve):
    r"""


    Provides the use of the Van Genuchten - Mualem retention curve (Van
    Genuchten 1980)

    Head - moisture relationship: 

    .. math::

         W(\\theta) &=&
        \\frac{\\theta - \\theta_r}{\\theta_s - \\theta_r} \\\\
        K(W) &=& K_{sat} \\sqrt{W}
        \\left(1-\\left(1-W^{1/m}\\right)^m\\right)^2 \\\\ m &=&
        1-\\frac 1 n \\\\ \\Psi(W) &=& 0.01 \\frac{m}{cm}
        \\frac{{\\left(1-{W}^{\\frac{1}{m}}\\right)
        }^{\\frac{1}{n}}}{\\alpha\\,{W}^{\\frac{1}{m\\,n}}} \\\\
        W(\\Psi) &=&
        \\left(1+\\left(\\alpha\\,100\\frac{cm}{m}\\Psi\\right)^n\\right)^{-m}


     where:  :math:`K` is the conductivity in :math:`\\frac m{day}`

    :math:`W` is the wetness (Volume of soil water per volume of pores)

    :math:`n` is a shape parameter of the retention curve

    :math:`\\alpha` is inverse of the air entry potential in :math:`cm^{-1}`

    :math:`\\Psi(W)` is the matric potential in :math:`m H_2O` at wetness W

    C++ includes: RetentionCurve.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = property(_cmf_core.VanGenuchtenMualem_alpha_get, _cmf_core.VanGenuchtenMualem_alpha_set, doc=r"""alpha : real""")
    n = property(_cmf_core.VanGenuchtenMualem_n_get, _cmf_core.VanGenuchtenMualem_n_set, doc=r"""n : real""")
    Ksat = property(_cmf_core.VanGenuchtenMualem_Ksat_get, _cmf_core.VanGenuchtenMualem_Ksat_set, doc=r"""Ksat : real""")
    Phi = property(_cmf_core.VanGenuchtenMualem_Phi_get, _cmf_core.VanGenuchtenMualem_Phi_set, doc=r"""Phi : real""")
    m = property(_cmf_core.VanGenuchtenMualem_m_get, _cmf_core.VanGenuchtenMualem_m_set, doc=r"""m : real""")
    l = property(_cmf_core.VanGenuchtenMualem_l_get, _cmf_core.VanGenuchtenMualem_l_set, doc=r"""l : real""")
    theta_r = property(_cmf_core.VanGenuchtenMualem_theta_r_get, _cmf_core.VanGenuchtenMualem_theta_r_set, doc=r"""theta_r : real""")
    w0 = property(_cmf_core.VanGenuchtenMualem_w0_get, _cmf_core.VanGenuchtenMualem_w0_set, doc=r"""w0 : real""")
    Transmissivity = _swig_new_instance_method(_cmf_core.VanGenuchtenMualem_Transmissivity)
    fit_w0 = _swig_new_instance_method(_cmf_core.VanGenuchtenMualem_fit_w0)
    copy = _swig_new_instance_method(_cmf_core.VanGenuchtenMualem_copy)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(VanGenuchtenMualem self, real Ksat=15, real phi=0.5, real alpha=0.2178, real n=1.211, real m=-1, real theta_r=0.0, real w0=0.99) -> VanGenuchtenMualem
        VanGenuchtenMualem(real Ksat=15, real phi=0.5, real alpha=0.2178, real
        n=1.211, real m=-1, real theta_r=0.0, real w0=0.99)

        Creates a van Genuchten-Mualem retention curve.

        Parameters:
        -----------

        Ksat:  Saturated conductivity in :math:`\\frac m{day}`

        phi:  Porosity in :math:`\\frac{m^3 Pores}{m^3 Soil}`

        alpha:  Van Genuchten :math:`\\alpha` in :math:`\\frac 1{cm}`

        n:  Van Genuchten n

        m:  Van Genuchten m parameter, if negative m is calculated as :math:`1-\\frac 1 n`

        theta_r:  Water content for :math:`\\lim\\limits_{\\Psi_M \\rightarrow -\\infty}{\\theta(\\Psi_M)}`

        w0:  Wetness above the parabolic extrapolation is used instead of the
        Van Genuchten curve (usually calculated with fit_w0) 
        """
        _cmf_core.VanGenuchtenMualem_swiginit(self, _cmf_core.new_VanGenuchtenMualem(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_VanGenuchtenMualem


    def __repr__(self):
        return "cmf.VanGenuchtenMualem(Ksat=%0.3g,Phi=%0.3g,alpha=%0.3g,n=%0.3g,m=%0.3g)" % (self.Ksat,self.Phi,self.alpha,self.n,self.m)

    def __str__(self):
        return "VanGenuchten / Mualem retention curve: Ksat=%0.3g m/day, %0.3g%% Pores, alpha=%0.3g 1/cm, n=%0.3g" % (self.Ksat,self.Phi*100,self.alpha,self.n)


# Register VanGenuchtenMualem in _cmf_core:
_cmf_core.VanGenuchtenMualem_swigregister(VanGenuchtenMualem)

class LinearRetention(RetentionCurve):
    r"""


    The linear retention curve provides a simple linear relationship
    between storage and head.

    Head function (head in m, calculated from upper side control volume)


    .. math::

         h(\\theta) = -\\Delta z \\left( 1 - \\frac{\\theta -
        \\theta_r}{\\theta_s - \\theta_r} \\right) 

    Conductivity
    function 

    .. math::

         K(\\theta) = K_{sat} \\left(\\frac{\\theta -
        \\theta_r}{\\theta_s - \\theta_r}\\right)^\\beta 

    C++ includes: RetentionCurve.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Ksat = property(_cmf_core.LinearRetention_Ksat_get, _cmf_core.LinearRetention_Ksat_set, doc=r"""Ksat : real""")
    porosity = property(_cmf_core.LinearRetention_porosity_get, _cmf_core.LinearRetention_porosity_set, doc=r"""porosity : real""")
    thickness = property(_cmf_core.LinearRetention_thickness_get, _cmf_core.LinearRetention_thickness_set, doc=r"""thickness : real""")
    residual_wetness = property(_cmf_core.LinearRetention_residual_wetness_get, _cmf_core.LinearRetention_residual_wetness_set, doc=r"""residual_wetness : real""")
    porosity_decay = property(_cmf_core.LinearRetention_porosity_decay_get, _cmf_core.LinearRetention_porosity_decay_set, doc=r"""porosity_decay : real""")
    beta = property(_cmf_core.LinearRetention_beta_get, _cmf_core.LinearRetention_beta_set, doc=r"""beta : real""")
    Transmissivity = _swig_new_instance_method(_cmf_core.LinearRetention_Transmissivity)
    copy = _swig_new_instance_method(_cmf_core.LinearRetention_copy)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(LinearRetention self, real ksat, real phi, real thickness, real residual_wetness=0.1) -> LinearRetention
        LinearRetention(real ksat, real phi, real thickness, real
        residual_wetness=0.1) 
        """
        _cmf_core.LinearRetention_swiginit(self, _cmf_core.new_LinearRetention(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_LinearRetention

# Register LinearRetention in _cmf_core:
_cmf_core.LinearRetention_swigregister(LinearRetention)

class SoilLayer(WaterStorage):
    r"""


    A representation of a SoilLayer.

    C++ includes: SoilLayer.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Position = property(_cmf_core.SoilLayer_Position_get, doc=r"""Position : q(const).ptrdiff_t""")
    cell = property(_cmf_core.SoilLayer_cell_get, doc=r"""cell : r.cmf::upslope::Cell""")
    __get_upper = _swig_new_instance_method(_cmf_core.SoilLayer___get_upper)
    __get_lower = _swig_new_instance_method(_cmf_core.SoilLayer___get_lower)
    get_soil = _swig_new_instance_method(_cmf_core.SoilLayer_get_soil)
    set_soil = _swig_new_instance_method(_cmf_core.SoilLayer_set_soil)
    get_K = _swig_new_instance_method(_cmf_core.SoilLayer_get_K)
    anisotropic_kf = property(_cmf_core.SoilLayer_anisotropic_kf_get, _cmf_core.SoilLayer_anisotropic_kf_set, doc=r"""anisotropic_kf : cmf::geometry::point""")
    get_capacity = _swig_new_instance_method(_cmf_core.SoilLayer_get_capacity)
    get_saturated_depth = _swig_new_instance_method(_cmf_core.SoilLayer_get_saturated_depth)
    set_root_uptake_stress_function = _swig_new_instance_method(_cmf_core.SoilLayer_set_root_uptake_stress_function)
    get_Tact = _swig_new_instance_method(_cmf_core.SoilLayer_get_Tact)
    get_flow_crosssection = _swig_new_instance_method(_cmf_core.SoilLayer_get_flow_crosssection)
    cast = _swig_new_static_method(_cmf_core.SoilLayer_cast)
    gravitational_potential = property(_cmf_core.SoilLayer_gravitational_potential_get, doc=r"""gravitational_potential : real""")
    matrix_potential = property(_cmf_core.SoilLayer_matrix_potential_get, doc=r"""matrix_potential : real""")
    wetness = property(_cmf_core.SoilLayer_wetness_get, _cmf_core.SoilLayer_wetness_set, doc=r"""wetness : real""")
    theta = property(_cmf_core.SoilLayer_theta_get, _cmf_core.SoilLayer_theta_set, doc=r"""theta : real""")
    K = property(_cmf_core.SoilLayer_K_get, doc=r"""K : real""")
    Ksat = property(_cmf_core.SoilLayer_Ksat_get, doc=r"""Ksat : real""")
    thickness = property(_cmf_core.SoilLayer_thickness_get, doc=r"""thickness : real""")
    lower_boundary = property(_cmf_core.SoilLayer_lower_boundary_get, doc=r"""lower_boundary : real""")
    upper_boundary = property(_cmf_core.SoilLayer_upper_boundary_get, doc=r"""upper_boundary : real""")
    porosity = property(_cmf_core.SoilLayer_porosity_get, doc=r"""porosity : real""")
    ice_fraction = property(_cmf_core.SoilLayer_ice_fraction_get, _cmf_core.SoilLayer_ice_fraction_set, doc=r"""ice_fraction : real""")
    rootfraction = property(_cmf_core.SoilLayer_rootfraction_get, _cmf_core.SoilLayer_rootfraction_set, doc=r"""rootfraction : real""")

    upper = property(_cmf_core.SoilLayer___get_upper)


    lower = property(_cmf_core.SoilLayer___get_lower)


    boundary=property(lambda self:(self.upper_boundary, self.lower_boundary),None, doc="Returns the upper and lower boundary of the layer")
    pF=property(lambda self : waterhead_to_pF(self.matrix_potential), None, doc="The actual pF value")
    soil=property(get_soil, set_soil, doc="The retention curve of the layer")


    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoilLayer

# Register SoilLayer in _cmf_core:
_cmf_core.SoilLayer_swigregister(SoilLayer)
SoilLayer_cast = _cmf_core.SoilLayer_cast

class layer_list(object):
    r"""


    A vector of layers, with array access to the properties of the layers,
    for fast data exchange.

    C++ includes: layer_list.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(layer_list self, layer_list for_copy) -> layer_list
        __init__(layer_list self) -> layer_list
        __init__(layer_list self, node_list for_copy) -> layer_list
        layer_list(const cmf::water::node_list &for_copy)

        Creates a list of all soil layers from a node_list. 
        """
        _cmf_core.layer_list_swiginit(self, _cmf_core.new_layer_list(*args))
    pop = _swig_new_instance_method(_cmf_core.layer_list_pop)
    append = _swig_new_instance_method(_cmf_core.layer_list_append)
    extend = _swig_new_instance_method(_cmf_core.layer_list_extend)
    get_slice = _swig_new_instance_method(_cmf_core.layer_list_get_slice)
    clear = _swig_new_instance_method(_cmf_core.layer_list_clear)
    size = _swig_new_instance_method(_cmf_core.layer_list_size)
    set_wetness = _swig_new_instance_method(_cmf_core.layer_list_set_wetness)
    set_potential = _swig_new_instance_method(_cmf_core.layer_list_set_potential)
    set_volume = _swig_new_instance_method(_cmf_core.layer_list_set_volume)
    get_percolation = _swig_new_instance_method(_cmf_core.layer_list_get_percolation)
    set_theta = _swig_new_instance_method(_cmf_core.layer_list_set_theta)
    set_ice_fraction = _swig_new_instance_method(_cmf_core.layer_list_set_ice_fraction)
    set_rootfraction = _swig_new_instance_method(_cmf_core.layer_list_set_rootfraction)
    gravitational_potential = property(_cmf_core.layer_list_gravitational_potential_get, doc=r"""gravitational_potential : cmf::math::num_array""")
    matrix_potential = property(_cmf_core.layer_list_matrix_potential_get, doc=r"""matrix_potential : cmf::math::num_array""")
    wetness = property(_cmf_core.layer_list_wetness_get, doc=r"""wetness : cmf::math::num_array""")
    volume = property(_cmf_core.layer_list_volume_get, doc=r"""volume : cmf::math::num_array""")
    potential = property(_cmf_core.layer_list_potential_get, doc=r"""potential : cmf::math::num_array""")
    K = property(_cmf_core.layer_list_K_get, doc=r"""K : cmf::math::num_array""")
    Ksat = property(_cmf_core.layer_list_Ksat_get, doc=r"""Ksat : cmf::math::num_array""")
    thickness = property(_cmf_core.layer_list_thickness_get, doc=r"""thickness : cmf::math::num_array""")
    lower_boundary = property(_cmf_core.layer_list_lower_boundary_get, doc=r"""lower_boundary : cmf::math::num_array""")
    upper_boundary = property(_cmf_core.layer_list_upper_boundary_get, doc=r"""upper_boundary : cmf::math::num_array""")
    porosity = property(_cmf_core.layer_list_porosity_get, doc=r"""porosity : cmf::math::num_array""")
    ice_fraction = property(_cmf_core.layer_list_ice_fraction_get, doc=r"""ice_fraction : cmf::math::num_array""")
    theta = property(_cmf_core.layer_list_theta_get, doc=r"""theta : cmf::math::num_array""")
    root = property(_cmf_core.layer_list_root_get, doc=r"""root : cmf::math::num_array""")
    __get = _swig_new_instance_method(_cmf_core.layer_list___get)

    __repr__=lambda self: repr(list(self))
    __str__ =lambda self: str(list(self))
    __len__=lambda self: self.size()
    def __iadd__(self,other):
        self.append(other)
        return self
    def __add__(self,other):
        res = layer_list(self)
        res.append(other)
        return res
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __getitem__(self,index):
        if (type(index)==slice):
            return self.get_slice(*index.indices(len(self)))
        try:
            gen=iter(index)
            return [self.__get(it) for it in gen]
        except TypeError:
             return self.__get(index)      

    __swig_destroy__ = _cmf_core.delete_layer_list

# Register layer_list in _cmf_core:
_cmf_core.layer_list_swigregister(layer_list)

class MacroPore(WaterStorage):
    r"""


    An additional water storage for a soil layer to model matrix water and
    macro pore water seperately.

    Deprecated The MacroPore model is still very experimental and not
    stable. Only for tryouts!

    If present, the soil layer water storage holds the matrix water and
    the MacroPore holds the water in the macro pore. Use
    cmf::upslope::Macropore::create to create a macropore storage.

    Use cmf::upslope::connections::GradientMacroFlow or
    cmf::upslope::connections::KinematicMacroFlow to model water flow
    between macro pores and a lateral connection ( lateral subsurface
    fluxes) like cmf::upslope::connections::Richards_lateral to connect
    the macro pore with the matrix.

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    porefraction_min = property(_cmf_core.MacroPore_porefraction_min_get, _cmf_core.MacroPore_porefraction_min_set, doc=r"""porefraction_min : real""")
    porefraction_max = property(_cmf_core.MacroPore_porefraction_max_get, _cmf_core.MacroPore_porefraction_max_set, doc=r"""porefraction_max : real""")
    __get_layer = _swig_new_instance_method(_cmf_core.MacroPore___get_layer)
    get_porefraction = _swig_new_instance_method(_cmf_core.MacroPore_get_porefraction)
    density = property(_cmf_core.MacroPore_density_get, _cmf_core.MacroPore_density_set, doc=r"""density : real""")
    Ksat = property(_cmf_core.MacroPore_Ksat_get, _cmf_core.MacroPore_Ksat_set, doc=r"""Ksat : real""")
    crack_wetness = property(_cmf_core.MacroPore_crack_wetness_get, _cmf_core.MacroPore_crack_wetness_set, doc=r"""crack_wetness : real""")
    get_K = _swig_new_instance_method(_cmf_core.MacroPore_get_K)
    get_crackwidth = _swig_new_instance_method(_cmf_core.MacroPore_get_crackwidth)
    get_flowwidth = _swig_new_instance_method(_cmf_core.MacroPore_get_flowwidth)
    K_shape = property(_cmf_core.MacroPore_K_shape_get, _cmf_core.MacroPore_K_shape_set, doc=r"""K_shape : real""")
    create = _swig_new_static_method(_cmf_core.MacroPore_create)
    cast = _swig_new_static_method(_cmf_core.MacroPore_cast)

    def __repr__(self): 
        return self.to_string()


    layer = property(_cmf_core.MacroPore___get_layer)

    filled_fraction = property(_cmf_core.MacroPore_filled_fraction_get, doc=r"""filled_fraction : real""")
    K = property(_cmf_core.MacroPore_K_get, doc=r"""K : real""")
    capacity = property(_cmf_core.MacroPore_capacity_get, doc=r"""capacity : real""")
    cell = property(_cmf_core.MacroPore_cell_get, doc=r"""cell : r.cmf::upslope::Cell""")
    __swig_destroy__ = _cmf_core.delete_MacroPore

# Register MacroPore in _cmf_core:
_cmf_core.MacroPore_swigregister(MacroPore)
MacroPore_create = _cmf_core.MacroPore_create
MacroPore_cast = _cmf_core.MacroPore_cast

class BaseMacroFlow(flux_connection):
    r"""Proxy of C++ cmf::upslope::connections::BaseMacroFlow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_BaseMacroFlow

# Register BaseMacroFlow in _cmf_core:
_cmf_core.BaseMacroFlow_swigregister(BaseMacroFlow)

class GradientMacroFlow(BaseMacroFlow):
    r"""


    Gradient based flux from macro pore to macro pore.

    Deprecated The MacroPore model is still very experimental and not
    stable. Only for tryouts!



    .. math::

         q = K(\\theta) \\frac{\\Delta \\Psi}{\\Delta z} 

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(GradientMacroFlow self, cmf::upslope::MacroPore::ptr left, cmf::water::flux_node::ptr right) -> GradientMacroFlow
        GradientMacroFlow(cmf::upslope::MacroPore::ptr left,
        cmf::water::flux_node::ptr right) 
        """
        _cmf_core.GradientMacroFlow_swiginit(self, _cmf_core.new_GradientMacroFlow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_GradientMacroFlow

# Register GradientMacroFlow in _cmf_core:
_cmf_core.GradientMacroFlow_swigregister(GradientMacroFlow)

class KinematicMacroFlow(BaseMacroFlow):
    r"""


    Linear storage based flux from macro pore to macro pore.

    Deprecated The MacroPore model is still very experimental and not
    stable. Only for tryouts!



    .. math::

         q = A_{cell} K_{macro}
        \\left(\\frac{V_{upper}}{C_{upper}}\\right)^\\beta
        \\left(1-\\frac{V_{lower}}{C_{lower}}\\right) 

    where:
    :math:`A_{cell}` is the area of the owning cell in m2

    :math:`K_{macro}` is the conductivity of the macro pore storage

    :math:`V` is the actual stored water volume in the upper resp. lower macro
    pore storage

    :math:`C` is the capacity of the upper resp. lower macro pore storage

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(KinematicMacroFlow self, cmf::water::WaterStorage::ptr left, cmf::water::flux_node::ptr right, real beta=1.) -> KinematicMacroFlow
        KinematicMacroFlow(cmf::water::WaterStorage::ptr left,
        cmf::water::flux_node::ptr right, real beta=1.)

        Creates the connection.

        Parameters:
        -----------

        left:  right:  the nodes between the connection should be created.

        beta:  a conceptional curve shape parameter for the relation between
        storage and outflow

        Either left or right needs to be a MacroPore, left needs to be a water
        storage 
        """
        _cmf_core.KinematicMacroFlow_swiginit(self, _cmf_core.new_KinematicMacroFlow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_KinematicMacroFlow

# Register KinematicMacroFlow in _cmf_core:
_cmf_core.KinematicMacroFlow_swigregister(KinematicMacroFlow)

class JarvisMacroFlow(BaseMacroFlow):
    r"""


    A physically based macropore to macropore connection according to
    Jarvis & Leeds-Harrison 1987, JSS.



    .. math::

        q_{i->j} [m/s]= \\rho \\frac G {12\\eta} w^2 \\frac{e_v-
        e_r}{1-e_r} S_{c,i}^\\beta\\ (1-S_{c,j})

    where:  :math:`q_{i->j}`
    the flow from macro pore layer i to macropore layer j

    :math:`\\rho=10^{-3} kg/m^3` - the density of water

    :math:`G=9.81 m/s^2` the earth acceleration

    :math:`\\eta=1.0 kg/(m s)` the viscosity of water (at 20 degC)

    :math:`w [m]` the crack width, a function of water content and crack
    distance

    :math:`e_v [-]` the crack porosity

    :math:`e_r [-]` crack por

    :math:`S_c [-]` the crack saturation of layer i resp. j

    :math:`\\beta [-]` a conceptional exponent to shape the flow reaction

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    beta = property(_cmf_core.JarvisMacroFlow_beta_get, _cmf_core.JarvisMacroFlow_beta_set, doc=r"""beta : real""")
    porefraction_r = property(_cmf_core.JarvisMacroFlow_porefraction_r_get, _cmf_core.JarvisMacroFlow_porefraction_r_set, doc=r"""porefraction_r : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(JarvisMacroFlow self, cmf::water::WaterStorage::ptr left, cmf::water::flux_node::ptr right, real beta=1., real porefraction_r=0.0) -> JarvisMacroFlow
        JarvisMacroFlow(cmf::water::WaterStorage::ptr left,
        cmf::water::flux_node::ptr right, real beta=1., real
        porefraction_r=0.0)

        Constructs the connection.

        Parameters:
        -----------

        left:  right:  the connected macropores

        beta:  User defined parameter for the swelling reaction

        porefraction_r:  Porefraction at which flow starts. For swelling soils
        that are closing completely th 
        """
        _cmf_core.JarvisMacroFlow_swiginit(self, _cmf_core.new_JarvisMacroFlow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_JarvisMacroFlow

# Register JarvisMacroFlow in _cmf_core:
_cmf_core.JarvisMacroFlow_swigregister(JarvisMacroFlow)

class GradientMacroMicroExchange(flux_connection):
    r"""


    A gradient based exchange term between macropores and micropores,
    using a fixed (air-) potential for macropores.



    .. math::

        q = K \\frac{\\Delta\\Psi}{d/2} A 

    where:  :math:`K` The
    conductivity of the aggregate boundary

    :math:`\\Delta\\Psi` The potential difference. Using the air potential
    as the constant potential for the macro pores, you get:
    :math:`\\Delta\\Psi = \\Psi_M(\\theta_{micro})`

    :math:`d` the mean aggregate size in m

    :math:`A` the crosssection area, given as the flow width (
    cmf::upslope::MacroPore::get_flowwidth) times layer thickness

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(GradientMacroMicroExchange self, cmf::upslope::SoilLayer::ptr left, cmf::upslope::MacroPore::ptr right) -> GradientMacroMicroExchange
        GradientMacroMicroExchange(cmf::upslope::SoilLayer::ptr left,
        cmf::upslope::MacroPore::ptr right) 
        """
        _cmf_core.GradientMacroMicroExchange_swiginit(self, _cmf_core.new_GradientMacroMicroExchange(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_GradientMacroMicroExchange

# Register GradientMacroMicroExchange in _cmf_core:
_cmf_core.GradientMacroMicroExchange_swigregister(GradientMacroMicroExchange)

class DiffusiveMacroMicroExchange(flux_connection):
    r"""


    A simple first order diffusive water exchange between MacroPore and
    matrix ( SoilLayer)



    .. math::

         q = \\omega (W_{ma} - W_{mi,eff}) V_{soil}

    where:
    :math:`\\omega` is the exchange rate in :math:`day^{-1}`

    :math:`W_{ma}` is the filled fraction of the macropore system [-]

    :math:`W_{mi,eff}` is the water filled pore space of the micropores above
    the residual pF value [-], default 4.2

    :math:`V_{soil} = A_{cell} d_{layer}` is the total volume of the soil layer
    [ :math:`m^3`]

    The residual micropore pF is used to determine a residual water
    content of the micropores. Residual in this case means, that above
    this pF value, water is not draining to the macro pores, even if they
    are empty. Although the default value is at wilting point, lower pF
    values are much more sensible, and should be rather lower than field
    capacity (pF=1.8 - 2.5). However, since this equation is rather
    conceptual than physical, this value can only be estimated or
    calibrated.

    cf. Simunek et al J. of Hydr. 2003

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    omega = property(_cmf_core.DiffusiveMacroMicroExchange_omega_get, _cmf_core.DiffusiveMacroMicroExchange_omega_set, doc=r"""omega : real""")
    pFrmi = property(_cmf_core.DiffusiveMacroMicroExchange_pFrmi_get, _cmf_core.DiffusiveMacroMicroExchange_pFrmi_set, doc=r"""pFrmi : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(DiffusiveMacroMicroExchange self, cmf::upslope::MacroPore::ptr left, cmf::upslope::SoilLayer::ptr right, real omega, real pFrmi=4.2) -> DiffusiveMacroMicroExchange
        DiffusiveMacroMicroExchange(cmf::upslope::MacroPore::ptr left,
        cmf::upslope::SoilLayer::ptr right, real omega, real pFrmi=4.2) 
        """
        _cmf_core.DiffusiveMacroMicroExchange_swiginit(self, _cmf_core.new_DiffusiveMacroMicroExchange(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_DiffusiveMacroMicroExchange

# Register DiffusiveMacroMicroExchange in _cmf_core:
_cmf_core.DiffusiveMacroMicroExchange_swigregister(DiffusiveMacroMicroExchange)

class MACROlikeMacroMicroExchange(flux_connection):
    r"""


    This connection models the water exchange between macropores and
    micropores as in the MACRO Model (Larsbo & Jarvis, 2003), which
    follows Gerke & van Genuchten 1996.

    WARNING:  Deprecated This connection uses the diffusivity of a soil
    given by its retention curve. Since no retention curve provides a
    valid value for Diffusivity in case of saturation this connection will
    blow up the numerical solution for sure.

    The exchange between Macropore and matrix is defined as follows:
    (MACRO 5 Tech report, Larsbo & Jarvis 2003)



    .. math::

        q = \\frac{G_f D_w \\gamma_w}{d^2}(\\theta_b -
        \\theta_{mi}) V_{layer}

    where:  :math:`G_f` is the geometry factor.
    Use 3 for a rectangular slab geometry

    :math:`gamma_w` A scaling factor to fit analytical and numerical solution
    (0.4)

    :math:`d` is an effective diffusive path length related to aggregate size
    and the influence of coatings on the aggregate surfaces in m

    :math:`\\theta_b` the saturated water content of the matrix

    :math:`\\theta_{mi}` the actual water content of the matrix

    :math:`D_w = \\frac12(D(\\theta_b)+D(\\theta_{mi})W_{ma})` is the
    effective water diffusivity in m2/day, as defined below  :math:`W_{ma}` is
    the saturation of the macropores

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Gf = property(_cmf_core.MACROlikeMacroMicroExchange_Gf_get, _cmf_core.MACROlikeMacroMicroExchange_Gf_set, doc=r"""Gf : real""")
    gamma_w = property(_cmf_core.MACROlikeMacroMicroExchange_gamma_w_get, _cmf_core.MACROlikeMacroMicroExchange_gamma_w_set, doc=r"""gamma_w : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(MACROlikeMacroMicroExchange self, cmf::upslope::SoilLayer::ptr left, cmf::upslope::MacroPore::ptr right, real _gamma_w=0.4, real _Gf=3) -> MACROlikeMacroMicroExchange
        MACROlikeMacroMicroExchange(cmf::upslope::SoilLayer::ptr left,
        cmf::upslope::MacroPore::ptr right, real _gamma_w=0.4, real _Gf=3) 
        """
        _cmf_core.MACROlikeMacroMicroExchange_swiginit(self, _cmf_core.new_MACROlikeMacroMicroExchange(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_MACROlikeMacroMicroExchange

# Register MACROlikeMacroMicroExchange in _cmf_core:
_cmf_core.MACROlikeMacroMicroExchange_swigregister(MACROlikeMacroMicroExchange)

class IVolumeHeightFunction(object):
    r"""


    Volume height relations are functional objects, which return a height
    and a crosssectional area of a volume for different geometric bodies.

    This is the abstract base class, where the geometries derive from

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    h = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_h)
    A = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_A)
    V = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_V)
    copy = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_copy)
    q = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_q)
    __swig_destroy__ = _cmf_core.delete_IVolumeHeightFunction

# Register IVolumeHeightFunction in _cmf_core:
_cmf_core.IVolumeHeightFunction_swigregister(IVolumeHeightFunction)

class Prism(IVolumeHeightFunction):
    r"""


    the height of a volume in a Prism with a defined base area

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Area = property(_cmf_core.Prism_Area_get, _cmf_core.Prism_Area_set, doc=r"""Area : double""")
    RoughThickness = property(_cmf_core.Prism_RoughThickness_get, _cmf_core.Prism_RoughThickness_set, doc=r"""RoughThickness : double""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Prism self, double base_area, double thickness_of_rough_ground=0.01) -> Prism
        Prism(double
        base_area, double thickness_of_rough_ground=0.01) 
        """
        _cmf_core.Prism_swiginit(self, _cmf_core.new_Prism(*args, **kwargs))
    copy = _swig_new_instance_method(_cmf_core.Prism_copy)
    __swig_destroy__ = _cmf_core.delete_Prism

# Register Prism in _cmf_core:
_cmf_core.Prism_swigregister(Prism)

class volume_height_function(IVolumeHeightFunction):
    r"""


    A wrapper class for volume / height functional relations.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(volume_height_function self, volume_height_function for_copy) -> volume_height_function
        __init__(volume_height_function self, IVolumeHeightFunction for_copy) -> volume_height_function
        volume_height_function(const IVolumeHeightFunction &for_copy)

        Wrapper for any IVolumeHeightFunction. 
        """
        _cmf_core.volume_height_function_swiginit(self, _cmf_core.new_volume_height_function(*args))
    copy = _swig_new_instance_method(_cmf_core.volume_height_function_copy)
    __swig_destroy__ = _cmf_core.delete_volume_height_function

# Register volume_height_function in _cmf_core:
_cmf_core.volume_height_function_swigregister(volume_height_function)

class IChannel(IVolumeHeightFunction):
    r"""


    Structure for the description of structural parameters of a reach
    Abstract base class for different IChannel geometries.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    get_nManning = _swig_new_instance_method(_cmf_core.IChannel_get_nManning)
    set_nManning = _swig_new_instance_method(_cmf_core.IChannel_set_nManning)
    get_length = _swig_new_instance_method(_cmf_core.IChannel_get_length)
    typecode = _swig_new_instance_method(_cmf_core.IChannel_typecode)
    get_channel_width = _swig_new_instance_method(_cmf_core.IChannel_get_channel_width)
    get_wetted_perimeter = _swig_new_instance_method(_cmf_core.IChannel_get_wetted_perimeter)
    get_depth = _swig_new_instance_method(_cmf_core.IChannel_get_depth)
    get_flux_crossection = _swig_new_instance_method(_cmf_core.IChannel_get_flux_crossection)
    copy = _swig_new_instance_method(_cmf_core.IChannel_copy)
    qManning = _swig_new_instance_method(_cmf_core.IChannel_qManning)
    __swig_destroy__ = _cmf_core.delete_IChannel

# Register IChannel in _cmf_core:
_cmf_core.IChannel_swigregister(IChannel)

class SWATReachType(IChannel):
    r"""


    Structure for the description of structural parameters of a reach.

    Uses the SWAT IChannel geometry (see SWAT Theoretical Documentation,
    Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
    referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
    plain is not plain, but has a small slope=0.5%, but has an infinite
    width

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BottomWidth = property(_cmf_core.SWATReachType_BottomWidth_get, _cmf_core.SWATReachType_BottomWidth_set, doc=r"""BottomWidth : double""")
    ChannelDepth = property(_cmf_core.SWATReachType_ChannelDepth_get, _cmf_core.SWATReachType_ChannelDepth_set, doc=r"""ChannelDepth : double""")
    BankSlope = property(_cmf_core.SWATReachType_BankSlope_get, _cmf_core.SWATReachType_BankSlope_set, doc=r"""BankSlope : double""")
    FloodPlainSlope = property(_cmf_core.SWATReachType_FloodPlainSlope_get, _cmf_core.SWATReachType_FloodPlainSlope_set, doc=r"""FloodPlainSlope : double""")

    def __init__(self, *args):
        r"""
        __init__(SWATReachType self, SWATReachType copy) -> SWATReachType
        __init__(SWATReachType self, double l) -> SWATReachType
        __init__(SWATReachType self, double l, double BankWidth, double Depth) -> SWATReachType
        SWATReachType(double l, double BankWidth, double Depth)

        Creates a new reach structure from a give width and depth.

        Parameters:
        -----------

        l:  length of the channel [m]

        BankWidth:  get_channel_width of the reach from bank to bank [m]

        Depth:  Depth of the reach [m] 
        """
        _cmf_core.SWATReachType_swiginit(self, _cmf_core.new_SWATReachType(*args))
    copy = _swig_new_instance_method(_cmf_core.SWATReachType_copy)
    __swig_destroy__ = _cmf_core.delete_SWATReachType

# Register SWATReachType in _cmf_core:
_cmf_core.SWATReachType_swigregister(SWATReachType)

class TriangularReach(IChannel):
    r"""


    Structure for the description of reaches with a triangular cross
    section.

    Although double triangular cross section reach are rarely met, a
    triangular reach does scale with its water load, and is therefore
    preferable in case where nothing about IChannel geometry is known

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BankSlope = property(_cmf_core.TriangularReach_BankSlope_get, _cmf_core.TriangularReach_BankSlope_set, doc=r"""BankSlope : double""")

    def __init__(self, *args):
        r"""
        __init__(TriangularReach self, double l, double bankSlope=2) -> TriangularReach
        __init__(TriangularReach self, TriangularReach copy) -> TriangularReach
        TriangularReach(const TriangularReach &copy) 
        """
        _cmf_core.TriangularReach_swiginit(self, _cmf_core.new_TriangularReach(*args))
    copy = _swig_new_instance_method(_cmf_core.TriangularReach_copy)
    __swig_destroy__ = _cmf_core.delete_TriangularReach

# Register TriangularReach in _cmf_core:
_cmf_core.TriangularReach_swigregister(TriangularReach)

class RectangularReach(IChannel):
    r"""


    Describes a IChannel with a rectangular crosssection.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RectangularReach self, double l, double width) -> RectangularReach
        __init__(RectangularReach self, RectangularReach copy) -> RectangularReach
        RectangularReach(const RectangularReach &copy) 
        """
        _cmf_core.RectangularReach_swiginit(self, _cmf_core.new_RectangularReach(*args))
    copy = _swig_new_instance_method(_cmf_core.RectangularReach_copy)
    __swig_destroy__ = _cmf_core.delete_RectangularReach

# Register RectangularReach in _cmf_core:
_cmf_core.RectangularReach_swigregister(RectangularReach)

class PipeReach(IChannel):
    r"""


    Describes the geometry of a closed pipe.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    radius = property(_cmf_core.PipeReach_radius_get, _cmf_core.PipeReach_radius_set, doc=r"""radius : double""")

    def __init__(self, *args):
        r"""
        __init__(PipeReach self, double l, double diameter) -> PipeReach
        __init__(PipeReach self, PipeReach copy) -> PipeReach
        PipeReach(const PipeReach &copy) 
        """
        _cmf_core.PipeReach_swiginit(self, _cmf_core.new_PipeReach(*args))
    copy = _swig_new_instance_method(_cmf_core.PipeReach_copy)
    __swig_destroy__ = _cmf_core.delete_PipeReach

# Register PipeReach in _cmf_core:
_cmf_core.PipeReach_swigregister(PipeReach)

class Channel(IChannel):
    r"""


    A wrapper for channel geometries.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Channel self) -> Channel
        __init__(Channel self, double length) -> Channel
        __init__(Channel self, IChannel for_wrapping) -> Channel
        __init__(Channel self, IVolumeHeightFunction for_casting) -> Channel
        __init__(Channel self, Channel for_copy) -> Channel
        __init__(Channel self, char typecode, double length, double width=1., double depth=0.25) -> Channel
        Channel(char
        typecode, double length, double width=1., double depth=0.25)

        Creates a reachtype using a short cut character.

        Acceptes one of the following characters: 'T' TriangularReach, width
        and depth are ignored.

        'R' RectangularReach, depth is ignored

        'P' PipeReach, depth is ignored, width is the diameter of the pipe

        'S' SWATReachType, a trapezoid flow cross section, as used in the SWAT
        model, width (bank width) and depth are used the reach type

        Parameters:
        -----------

        typecode:  Describes the geometry of the reach cross section.

        length:  The length of the channel in m

        width:  width of the reach cross section in m (ignored for typecode
        'T')

        depth:  depth of the reach (ignored for typecode 'T','R','P','S') 
        """
        _cmf_core.Channel_swiginit(self, _cmf_core.new_Channel(*args))
    copy = _swig_new_instance_method(_cmf_core.Channel_copy)
    __swig_destroy__ = _cmf_core.delete_Channel

# Register Channel in _cmf_core:
_cmf_core.Channel_swigregister(Channel)

class MeanChannel(IChannel):
    r"""


    A combination of two channel geometries.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(MeanChannel self, IChannel channel1, IChannel channel2) -> MeanChannel
        __init__(MeanChannel self, MeanChannel meanChannel) -> MeanChannel
        MeanChannel(const MeanChannel &meanChannel) 
        """
        _cmf_core.MeanChannel_swiginit(self, _cmf_core.new_MeanChannel(*args))
    copy = _swig_new_instance_method(_cmf_core.MeanChannel_copy)
    __swig_destroy__ = _cmf_core.delete_MeanChannel

# Register MeanChannel in _cmf_core:
_cmf_core.MeanChannel_swigregister(MeanChannel)

class CrossSectionReach(IChannel):
    r"""


    Structure for the description of reaches with a freely defined cross
    section.

    Although double triangular cross section reach are rarely met, a
    triangular reach does scale with its water load, and is therefore
    preferable in case where nothing about IChannel geometry is known

    C++ includes: cross_section_reach.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    depth = property(_cmf_core.CrossSectionReach_depth_get, _cmf_core.CrossSectionReach_depth_set, doc=r"""depth : cmf::math::num_array""")
    x = property(_cmf_core.CrossSectionReach_x_get, _cmf_core.CrossSectionReach_x_set, doc=r"""x : cmf::math::num_array""")

    def __init__(self, *args):
        r"""
        __init__(CrossSectionReach self, double l, cmf::math::num_array x, cmf::math::num_array depth) -> CrossSectionReach
        __init__(CrossSectionReach self, CrossSectionReach copy) -> CrossSectionReach
        CrossSectionReach(const CrossSectionReach &copy) 
        """
        _cmf_core.CrossSectionReach_swiginit(self, _cmf_core.new_CrossSectionReach(*args))
    copy = _swig_new_instance_method(_cmf_core.CrossSectionReach_copy)
    __swig_destroy__ = _cmf_core.delete_CrossSectionReach
    check_iterator = _swig_new_instance_method(_cmf_core.CrossSectionReach_check_iterator)

# Register CrossSectionReach in _cmf_core:
_cmf_core.CrossSectionReach_swigregister(CrossSectionReach)

class OpenWaterStorage(WaterStorage):
    r"""


    An open water body.

    The potential is calculated from the stored water using a water table
    function

    C++ includes: OpenWaterStorage.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get_height_function = _swig_new_instance_method(_cmf_core.OpenWaterStorage_get_height_function)
    set_height_function = _swig_new_instance_method(_cmf_core.OpenWaterStorage_set_height_function)
    wet_area = _swig_new_instance_method(_cmf_core.OpenWaterStorage_wet_area)
    create = _swig_new_static_method(_cmf_core.OpenWaterStorage_create)
    cast = _swig_new_static_method(_cmf_core.OpenWaterStorage_cast)
    depth = property(_cmf_core.OpenWaterStorage_depth_get, _cmf_core.OpenWaterStorage_depth_set, doc=r"""depth : real""")

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_OpenWaterStorage

# Register OpenWaterStorage in _cmf_core:
_cmf_core.OpenWaterStorage_swigregister(OpenWaterStorage)
OpenWaterStorage_create = _cmf_core.OpenWaterStorage_create
OpenWaterStorage_cast = _cmf_core.OpenWaterStorage_cast

class Reach(OpenWaterStorage):
    r"""


    A reach represents the section of a riover and is a specialization of
    an open water storage.

    The OpenWaterStorage attributes and methods are extended by
    topological features, for the creation of a network of reaches.

    C++ includes: Reach.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get_reachtype = _swig_new_instance_method(_cmf_core.Reach_get_reachtype)
    set_height_function = _swig_new_instance_method(_cmf_core.Reach_set_height_function)
    set_outlet = _swig_new_instance_method(_cmf_core.Reach_set_outlet)
    set_dead_end = _swig_new_instance_method(_cmf_core.Reach_set_dead_end)
    set_downstream = _swig_new_instance_method(_cmf_core.Reach_set_downstream)
    __get_downstream = _swig_new_instance_method(_cmf_core.Reach___get_downstream)
    get_upstream = _swig_new_instance_method(_cmf_core.Reach_get_upstream)
    connect_to_surfacewater = _swig_new_instance_method(_cmf_core.Reach_connect_to_surfacewater)
    distance_to_cell = _swig_new_instance_method(_cmf_core.Reach_distance_to_cell)
    __get_root = _swig_new_instance_method(_cmf_core.Reach___get_root)
    __swig_destroy__ = _cmf_core.delete_Reach
    create = _swig_new_static_method(_cmf_core.Reach_create)
    length = property(_cmf_core.Reach_length_get, doc=r"""length : real""")
    width = property(_cmf_core.Reach_width_get, doc=r"""width : real""")
    channel = property(_cmf_core.Reach_channel_get, doc=r"""channel : cmf::river::IChannel""")

    downstream = property(_cmf_core.Reach___get_downstream)


    root = property(_cmf_core.Reach___get_root)

    upstream_count = property(_cmf_core.Reach_upstream_count_get, doc=r"""
    upstream_count : int
    int
    upstream_count() const

    Returns the number of reaches upstream of this. 
    """)
    diffusive = property(_cmf_core.Reach_diffusive_get, _cmf_core.Reach_diffusive_set, doc=r"""diffusive : bool""")

    @property
    def upstream(self):
        """Returns a list containing all reaches flowing into self"""
        return [self.get_upstream(i) for i in range(self.upstream_count)]
    def __hash__(self):
        return hash(self.water.node_id)
    def connect_to_cell(self,cell,width,subsurface_connection_type=None,subsurface_connection_depth=None,diffusive=None):
        """ Connects a cell with this reach using Manning's equation for surface runoff and
        a given connection for subsurface interflow 
         - width : Boundary width in m
         - subsurface_connection_type  : Any lateral flow connection type
         - subsurface_connection_depth : The depth below ground of the deepest layer to be connected by subsurface_connection_type,
                                         default (None) = cell.z - reach.position.z
         - diffusive: Determines if a kinematic or diffusive wave is to be used for surface runoff
        """
        assert(subsurface_connection_type is None or issubclass(subsurface_connection_type, lateral_sub_surface_flux))
        if diffusive is None:
            diffusive = self.diffusive
        if subsurface_connection_depth is None:
            subsurface_connection_depth = cell.z - self.position.z
        self.connect_to_surfacewater(cell,width,diffusive)
        r_depth = cell.z - self.position.z
        distance = self.distance_to_cell(cell)
        connections=[self.connection_to(cell.surfacewater)]
        if subsurface_connection_type:
            cell.connect_soil_with_node(self,subsurface_connection_type,width,distance,0,subsurface_connection_depth)
            connections.extend(self.connection_to(l) for l in cell.layers)
        return connections


    def __repr__(self): 
        return self.to_string()


# Register Reach in _cmf_core:
_cmf_core.Reach_swigregister(Reach)
Reach_create = _cmf_core.Reach_create

class ReachIterator(object):
    r"""


    An iterator over every upstream reach from a start reach.

    Implements both the Python and the C++ iterator interface Usage C++:
    Usage Python:

    C++ includes: Reach.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    next = _swig_new_instance_method(_cmf_core.ReachIterator_next)
    valid = _swig_new_instance_method(_cmf_core.ReachIterator_valid)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ReachIterator self, cmf::river::Reach::ptr first) -> ReachIterator
        ReachIterator(Reach::ptr first)

        Creates a ReachIterator from a first reach. 
        """
        _cmf_core.ReachIterator_swiginit(self, _cmf_core.new_ReachIterator(*args, **kwargs))
    __reach = _swig_new_instance_method(_cmf_core.ReachIterator___reach)
    position = property(_cmf_core.ReachIterator_position_get, doc=r"""
    position : double
    double
    position() const

    Returns the distance to the root reach. 
    """)

    reach = property(_cmf_core.ReachIterator___reach)


    def __iter__(self):
        while self.valid():
            self.next()
            yield (self.reach,self.position)

    __swig_destroy__ = _cmf_core.delete_ReachIterator

# Register ReachIterator in _cmf_core:
_cmf_core.ReachIterator_swigregister(ReachIterator)

make_river_gap = _cmf_core.make_river_gap
class SurfaceWater(OpenWaterStorage):
    r"""


    A child class of OpenWaterStorage to model surface water on a cell.

    Specially created to connect a SurfaceWater with other nodes, is the
    flux connection cmf::upslope::connections::KinematicSurfaceRunoff

    C++ includes: surfacewater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get_height_function = _swig_new_instance_method(_cmf_core.SurfaceWater_get_height_function)
    get_coverage = _swig_new_instance_method(_cmf_core.SurfaceWater_get_coverage)
    get_cell = _swig_new_instance_method(_cmf_core.SurfaceWater_get_cell)
    cast = _swig_new_static_method(_cmf_core.SurfaceWater_cast)
    puddledepth = property(_cmf_core.SurfaceWater_puddledepth_get, _cmf_core.SurfaceWater_puddledepth_set, doc=r"""puddledepth : real""")
    nManning = property(_cmf_core.SurfaceWater_nManning_get, _cmf_core.SurfaceWater_nManning_set, doc=r"""nManning : real""")

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SurfaceWater

# Register SurfaceWater in _cmf_core:
_cmf_core.SurfaceWater_swigregister(SurfaceWater)
SurfaceWater_cast = _cmf_core.SurfaceWater_cast

class KinematicSurfaceRunoff(flux_connection):
    r"""


    A connection to route water from a SurfaceWater storage to another
    node following a topographic gradient.



    .. math::

        q_{runoff} = A_{cross} d_{eff}^{2/3}
        \\frac{\\sqrt{S}}{n}

    where:  :math:`q_{runoff}` is the surface
    runoff

    :math:`A_{cross}` is the wetted crossectional flux area, given as :math:`d_{eff} \\cdot w`

    :math:`w` is the width of the shared boundary between the surface water
    storage and the target node

    :math:`d_{eff}` is the effective flow depth of the surface water.The
    effective flow depth is defined as 

    .. math::

        d_{eff} = \\begin{cases}
        V/A-d_{puddle}\\ & V/A>d_{puddle} \\\\ 0.0 & V/A<=d_{puddle}
        \\end{cases}

    :math:`V` the volume of stored water in the surface in :math:`m^3`

    :math:`A` the area of the cell in :math:`m^2`

    :math:`d_{puddle}=V_{puddle}/A` the average depth of water in the surface
    water needed to start run off

    :math:`S = \\|\\frac{\\Delta z\\|}{d}` the slope between
    surfacewater center and the target node

    :math:`n` the manning roughness

    The KinematicSurfaceRunoff can be used as a cell connecting flux as
    in: This results in a connection of the surfacewater storage of each
    cell with the surface water storages of its neighborssee

    C++ includes: surfacewater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(KinematicSurfaceRunoff self, cmf::upslope::SurfaceWater::ptr left, cmf::water::flux_node::ptr right, real flowwidth, real distance=-1) -> KinematicSurfaceRunoff
        KinematicSurfaceRunoff(cmf::upslope::SurfaceWater::ptr left,
        cmf::water::flux_node::ptr right, real flowwidth, real distance=-1)

        Creates a KinematicSurfaceRunoff between a SurfaceWater (left) with
        another (right) node.

        Parameters:
        -----------

        left:  A surfacewater storage

        right:  The target node

        flowwidth:  the length of the shared boundary between left and right
        in m

        distance:  the distance between left and right in m. If d<=0m, the
        distance is calculated according to the position of left and right 
        """
        _cmf_core.KinematicSurfaceRunoff_swiginit(self, _cmf_core.new_KinematicSurfaceRunoff(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_KinematicSurfaceRunoff

# Register KinematicSurfaceRunoff in _cmf_core:
_cmf_core.KinematicSurfaceRunoff_swigregister(KinematicSurfaceRunoff)
KinematicSurfaceRunoff.cell_connector = _cmf_core.cvar.KinematicSurfaceRunoff_cell_connector

class DiffusiveSurfaceRunoff(flux_connection):
    r"""


    A connection to route water from a SurfaceWater storage to another
    node following the gradient of the water level.



    .. math::

        q_{runoff} = A_{cross} d_{eff}^{2/3}
        \\frac{\\sqrt{S}}{n}

    where:  :math:`q_{runoff}` is the surface
    runoff

    :math:`A_{cross}` is the wetted crossectional flux area, given as :math:`d_{eff} \\cdot w`

    :math:`w` is the width of the shared boundary between the surface water
    storage and the target node

    :math:`d_{eff}` is the effective flow depth of the surface water.The
    effective flow depth is defined as either the mean of the effective
    depth of the left and the right node (when use_depthmax=false) or the
    maximum of the efficitve depth. The effective depth for a surfacewater
    is always defined as: 

    .. math::

        d_{eff} = \\begin{cases}
        V/A-d_{puddle}\\ & V/A>d_{puddle} \\\\ 0.0 & V/A<=d_{puddle}
        \\end{cases}

    The right node might be not a surfacewater. If the
    right node is an OpenWaterStorage, then the effective depth is the
    depth of the OWS above the cell height of the left surfacewater, given
    by: 

    .. math::

        d_{eff,ows} = \\Psi_{ows} - z_{cell}

    In case of
    another node, the right node depth equals the effective depth of the
    left node.

    :math:`V` the volume of stored water in the surface in :math:`m^3`

    :math:`A` the area of the cell in :math:`m^2`

    :math:`d_{puddle}=V_{puddle}/A` the average depth of water in the surface
    water needed to start run off

    :math:`S = \\|\\frac{\\Delta h\\|}{d}` the slope between
    surfacewater center potential and the target node potential

    :math:`n` the manning roughness

    The DiffusiveSurfaceRunoff can be used as a cell connecting flux as
    in: This results in a connection of the surfacewater storage of each
    cell with the surface water storages of its neighborssee

    C++ includes: surfacewater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    set_linear_slope = _swig_new_static_method(_cmf_core.DiffusiveSurfaceRunoff_set_linear_slope)
    get_linear_slope = _swig_new_static_method(_cmf_core.DiffusiveSurfaceRunoff_get_linear_slope)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(DiffusiveSurfaceRunoff self, cmf::upslope::SurfaceWater::ptr left, cmf::water::flux_node::ptr right, real flowwidth, real distance=-1) -> DiffusiveSurfaceRunoff
        DiffusiveSurfaceRunoff(cmf::upslope::SurfaceWater::ptr left,
        cmf::water::flux_node::ptr right, real flowwidth, real distance=-1) 
        """
        _cmf_core.DiffusiveSurfaceRunoff_swiginit(self, _cmf_core.new_DiffusiveSurfaceRunoff(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_DiffusiveSurfaceRunoff

# Register DiffusiveSurfaceRunoff in _cmf_core:
_cmf_core.DiffusiveSurfaceRunoff_swigregister(DiffusiveSurfaceRunoff)
DiffusiveSurfaceRunoff_set_linear_slope = _cmf_core.DiffusiveSurfaceRunoff_set_linear_slope
DiffusiveSurfaceRunoff_get_linear_slope = _cmf_core.DiffusiveSurfaceRunoff_get_linear_slope
DiffusiveSurfaceRunoff.cell_connector = _cmf_core.cvar.DiffusiveSurfaceRunoff_cell_connector

class aquifer(WaterStorage):
    r"""


    A class to represent large groundwater storages, not bounded to the
    usual horizontal discretization scheme, the Cell.

    Naturally aquifers are connected with aquifer_Darcy or kinematic_wave
    connections. As a boundary condition for a cell based soil water
    system, aquifers are used as a right hand side node of percolation
    connections.

    Basic head ( :math:`\\Psi`) / volume ( :math:`V`) relation: 

    .. math::

         \\Psi =
        z_{base} + \\frac {V}{A \\Phi} 

    :math:`\\Psi` water head in m

    :math:`z_{base}` base height of the aquifer

    :math:`V` volume of stored water in m3

    :math:`A` Base area of the aquifer in m2

    :math:`\\Phi` Porosity, or more general, :math:`\\frac{dV_{bulk}}{dV_{H_2O}}`

    C++ includes: groundwater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    area = property(_cmf_core.aquifer_area_get, _cmf_core.aquifer_area_set, doc=r"""area : real""")
    thickness = property(_cmf_core.aquifer_thickness_get, _cmf_core.aquifer_thickness_set, doc=r"""thickness : real""")
    porosity = property(_cmf_core.aquifer_porosity_get, _cmf_core.aquifer_porosity_set, doc=r"""porosity : real""")
    K = property(_cmf_core.aquifer_K_get, _cmf_core.aquifer_K_set, doc=r"""K : cmf::geometry::point""")
    get_K = _swig_new_instance_method(_cmf_core.aquifer_get_K)
    get_abs_errtol = _swig_new_instance_method(_cmf_core.aquifer_get_abs_errtol)

    def __init__(self, *args):
        r"""
        __init__(aquifer self, project p, point position, real area, real thickness, real porosity, real K=1e-4) -> aquifer
        __init__(aquifer self, cell_vector cells, real thickness, real porosity, real K=1e-4) -> aquifer
        aquifer(cmf::upslope::cell_vector &cells, real thickness, real
        porosity, real K=1e-4)

        Creates an aquifer below a collection of cells.

        Parameters:
        -----------

        cells:  The cells above the aquifer. The area of the aquifer equals
        the area of the cells, and the upper boundary equals the soildepth of
        the lowest cell

        thickness:  The thickness of the aquifer in m

        porosity:  Porosity of the aquifer

        K:  Conductivity of the aquifer in m/day. If the conductivity should
        be anisotropic, change the x,y and z values of the member K 
        """
        _cmf_core.aquifer_swiginit(self, _cmf_core.new_aquifer(*args))
    cast = _swig_new_static_method(_cmf_core.aquifer_cast)
    base_height = property(_cmf_core.aquifer_base_height_get, doc=r"""base_height : double""")
    top_height = property(_cmf_core.aquifer_top_height_get, doc=r"""top_height : double""")

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_aquifer

# Register aquifer in _cmf_core:
_cmf_core.aquifer_swigregister(aquifer)
aquifer_cast = _cmf_core.aquifer_cast

class aquifer_Darcy(flux_connection):
    r"""


    Lateral darcy flow between aquifer objects.



    .. math::

        v_{Darcy}=K_{1,2}\\nabla\\Psi 



    .. math::

        q = v_{Darcy} w
        \\Delta z

    C++ includes: groundwater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flux_width = property(_cmf_core.aquifer_Darcy_flux_width_get, _cmf_core.aquifer_Darcy_flux_width_set, doc=r"""flux_width : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(aquifer_Darcy self, cmf::upslope::aquifer::ptr left, cmf::water::flux_node::ptr right, real width) -> aquifer_Darcy
        aquifer_Darcy(aquifer::ptr left, cmf::water::flux_node::ptr right,
        real width)

        Creates a new Darcy flow connection between two aquifers, or an
        aquifer and another node acting as Dirichlet boundary condition.

        Parameters:
        -----------

        left:  One aquifer

        right:  Another aquifer, or a flux node that can be interpreted as an
        Dirichlet boundary

        width:  Width of the connection 
        """
        _cmf_core.aquifer_Darcy_swiginit(self, _cmf_core.new_aquifer_Darcy(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_aquifer_Darcy

# Register aquifer_Darcy in _cmf_core:
_cmf_core.aquifer_Darcy_swigregister(aquifer_Darcy)

class lateral_sub_surface_flux(flux_connection):
    r"""


    An abstract base class for lateral subsurface fluxes.

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_lateral_sub_surface_flux

# Register lateral_sub_surface_flux in _cmf_core:
_cmf_core.lateral_sub_surface_flux_swigregister(lateral_sub_surface_flux)

class Darcy(lateral_sub_surface_flux):
    r"""


    Calculates the lateral flow using the gravitational potential gradient
    only.



    .. math::

         q_{lat} = \\frac{\\Delta \\Psi_G}{\\|C_1-C_2\\|}
        \\frac 12 (T(C_1)+T(C_2)) w 

    where  :math:`\\Delta \\Psi_G` is
    the gravitational potential difference

    :math:`\\|C_1-C_2\\|` is the distance from Cell 1 to Cell 2

    :math:`T(C)` is the transmissivity of cell C, calculated by
    SoilType::Transmissivity

    :math:`w` is the width of the connection of the cells

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Darcy self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0) -> Darcy
        Darcy(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
        right, real FlowWidth, real Distance=0) 
        """
        _cmf_core.Darcy_swiginit(self, _cmf_core.new_Darcy(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Darcy

# Register Darcy in _cmf_core:
_cmf_core.Darcy_swigregister(Darcy)
Darcy.cell_connector = _cmf_core.cvar.Darcy_cell_connector

class TopographicGradientDarcy(lateral_sub_surface_flux):
    r"""


    Calculates the lateral flow using the topographic gradient.



    .. math::

         q_{lat} = \\frac{z_1 - z_2}{\\|C_1-C_2\\|} \\frac 12
        (T(C_1)+T(C_2)) w 

    where  :math:`z_1 - z_2` is the topographic height
    difference

    :math:`\\|C_1-C_2\\|` is the distance from Cell 1 to Cell 2

    :math:`T(C)` is the transmissivity of cell C, calculated by
    SoilType::Transmissivity

    :math:`w` is the width of the connection of the cells

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(TopographicGradientDarcy self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0) -> TopographicGradientDarcy
        TopographicGradientDarcy(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0)

        Creates the connection.

        Parameters:
        -----------

        left:  Left node of the connection (needs to be soil water storage)

        right:  Right node of the connection (can be any node)

        FlowWidth:  the width of the connection - is multiplied by layer
        thickness to get the interface area

        Distance:  the length of the connection. If 0, the distance is
        calculated from the position of the nodes 
        """
        _cmf_core.TopographicGradientDarcy_swiginit(self, _cmf_core.new_TopographicGradientDarcy(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_TopographicGradientDarcy

# Register TopographicGradientDarcy in _cmf_core:
_cmf_core.TopographicGradientDarcy_swigregister(TopographicGradientDarcy)
TopographicGradientDarcy.cell_connector = _cmf_core.cvar.TopographicGradientDarcy_cell_connector

class DarcyKinematic(lateral_sub_surface_flux):
    r"""


    A simple kinemtic wave model for subsurface flux.



    .. math::

         q = \\frac{\\Delta z_{surface}}{d} K(\\theta)_{source}
        A_{cross} 

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(DarcyKinematic self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0) -> DarcyKinematic
        DarcyKinematic(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0)

        Creates the connection.

        Parameters:
        -----------

        left:  Left node of the connection (needs to be soil water storage)

        right:  Right node of the connection (can be any node)

        FlowWidth:  the width of the connection - is multiplied by layer
        thickness to get the interface area

        Distance:  the length of the connection. If 0, the distance is
        calculated from the position of the nodes 
        """
        _cmf_core.DarcyKinematic_swiginit(self, _cmf_core.new_DarcyKinematic(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_DarcyKinematic

# Register DarcyKinematic in _cmf_core:
_cmf_core.DarcyKinematic_swigregister(DarcyKinematic)
DarcyKinematic.cell_connector = _cmf_core.cvar.DarcyKinematic_cell_connector

class Richards_lateral(lateral_sub_surface_flux):
    r"""


    Calculates the flux using Richard's equation for adjacent layers 

    .. math::


        q_{lat} = \\frac{\\Psi_1 - \\Psi_2}{\\|C_1-C_2\\|}
        K(\\theta) A 

    where:

    :math:`q_{lat}` the lateral flow in :math:`m^3/day`

    :math:`\\Psi_i` the head of node i

    :math:`\\|C_1-C_2\\|` is the distance from Cell 1 to Cell 2

    :math:`K(\\theta_{1,2}) = \\sqrt{K(\\theta_1) K(\\theta_2)}`

    :math:`A` the crosssectional area of the interface between storages 1 and 2

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flow_thickness = property(_cmf_core.Richards_lateral_flow_thickness_get, _cmf_core.Richards_lateral_flow_thickness_set, doc=r"""flow_thickness : real""")
    wet_right_node = property(_cmf_core.Richards_lateral_wet_right_node_get, _cmf_core.Richards_lateral_wet_right_node_set, doc=r"""wet_right_node : bool""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Richards_lateral self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real FlowWidth=0, real Distance=0) -> Richards_lateral
        Richards_lateral(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth=0, real Distance=0)

        Creates the connection.

        Parameters:
        -----------

        left:  Left node of the connection (needs to be soil water storage)

        right:  Right node of the connection (can be any node)

        FlowWidth:  the width of the connection - is multiplied by layer
        thickness to get the interface area

        Distance:  the length of the connection. If 0, the distance is
        calculated from the position of the nodes 
        """
        _cmf_core.Richards_lateral_swiginit(self, _cmf_core.new_Richards_lateral(*args, **kwargs))
    usebaseflow = _swig_new_static_method(_cmf_core.Richards_lateral_usebaseflow)
    __swig_destroy__ = _cmf_core.delete_Richards_lateral

# Register Richards_lateral in _cmf_core:
_cmf_core.Richards_lateral_swigregister(Richards_lateral)
Richards_lateral_usebaseflow = _cmf_core.Richards_lateral_usebaseflow
Richards_lateral.cell_connector = _cmf_core.cvar.Richards_lateral_cell_connector

class TOPModelFlow(flux_connection):
    r"""


    Calculates a flux from a soil layer using TOPMODELs (Beven & Kirkby
    1979) exponential transmissivity concept.



    .. math::

         T = T_0 \\exp(-D_i/m) 

    where:  :math:`T` is the actual
    transmissivity of the profile in :math:`m^2/day`

    :math:`T0` is the transmissivity of the profile at saturation

    :math:`D_i` is the drained depth in m, calculated as :math:`(C-V)/A`, the capacity
    of the layer - volume per area

    :math:`m` a scaling factor in m

    By using the transmissivity in Darcy's law and assuming the GW
    gradient to be parallel to the topographic slope we get for the flow:


    .. math::

         q = T_0 \\exp(-D_i/m) w s

    where:  :math:`q` is the flux in
    :math:`m^3/day`

    :math:`w` is the flow width (unit contour length)

    :math:`s` is the topographic slope between layer and outlet

    TOPMODEL is based on the concept of drained depth, not, as cmf on the
    concept of stored volume. Hence, negative volumes can occur if

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flow_width = property(_cmf_core.TOPModelFlow_flow_width_get, _cmf_core.TOPModelFlow_flow_width_set, doc=r"""flow_width : real""")
    distance = property(_cmf_core.TOPModelFlow_distance_get, _cmf_core.TOPModelFlow_distance_set, doc=r"""distance : real""")
    T0 = property(_cmf_core.TOPModelFlow_T0_get, _cmf_core.TOPModelFlow_T0_set, doc=r"""T0 : real""")
    m = property(_cmf_core.TOPModelFlow_m_get, _cmf_core.TOPModelFlow_m_set, doc=r"""m : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(TOPModelFlow self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real T0, real m, real flowwidth, real distance=0) -> TOPModelFlow
        TOPModelFlow(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real T0, real m, real flowwidth,
        real distance=0) 
        """
        _cmf_core.TOPModelFlow_swiginit(self, _cmf_core.new_TOPModelFlow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_TOPModelFlow

# Register TOPModelFlow in _cmf_core:
_cmf_core.TOPModelFlow_swigregister(TOPModelFlow)

class Manning(flux_connection):
    r"""


    Calculates the flux between two open water bodies, using Manning's
    equation.

    This is the base class for a kinematic wave approach (topography
    driven) and a diffusive wave approach (water table driven). The only
    difference between both approaches is the calculation of the flux
    driving slope. For the model, one of ManningKinematic or
    ManningDiffusive connection is selected 

    .. math::

         v = R^{\\frac 2 3}
        \\frac{\\sqrt{\\Delta_z}}{n} \\\\ q = v \\cdot A 

    Where:  :math:`A = \\frac V l`: Crosssectional area of the wetted
    crossection, Volume per length

    :math:`R = \\frac A{P(d)}`: The hydraulic radius

    :math:`P(d)`: the perimeter of the wetted crosssection, a function of reach
    depth

    :math:`d(V)`: the depth of the reach, a function of the volume

    :math:`\\Delta_z = \\frac{|z_1 - z_2|}{l}`: Slope of the reach

    :math:`n`: Manning friction number

    For the kinematic wave the slope of the river bed is used as slope:


    .. math::

        \\Delta_z = \\frac{|z_1 - z_2|}{l}

    while for the diffusive wave the slope is calculated from the actual
    water head: 

    .. math::

        \\Delta_z = \\frac{|h_1 - h_2|}{l}

    C++ includes: ManningConnection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    is_diffusive_wave = property(_cmf_core.Manning_is_diffusive_wave_get, _cmf_core.Manning_is_diffusive_wave_set, doc=r"""is_diffusive_wave : bool""")
    flux_geometry = property(_cmf_core.Manning_flux_geometry_get, _cmf_core.Manning_flux_geometry_set, doc=r"""flux_geometry : cmf::river::volume_height_function""")
    __swig_destroy__ = _cmf_core.delete_Manning

# Register Manning in _cmf_core:
_cmf_core.Manning_swigregister(Manning)

class Manning_Diffusive(Manning):
    r"""


    Connecting surface water bodies using a diffusive wave.

    This approach might not be numerical stable for deep water with small
    gradient cmf for experimental reasons 

    .. math::


        q_{Manning}&=& A R^{\\frac 2 3} \\sqrt{\\frac {\\Delta_z} n}
        \\\\ A &=& \\frac V l \\mbox{, (Crosssectional area of the
        wetted crossection, Volume per length)} \\\\ R &=& \\frac A
        {P(d)} \\\\ P(d) &=& \\mbox{ the perimeter of the wetted
        crosssection, a function of reach depth} \\\\ d(V) &=& \\mbox{
        the depth of the reach a function of the volume} \\\\ \\Delta_z
        = \\|\\frac{h_1 - h_2}{l} \\mbox{ Slope of the reach
        waterlevels} \\\\ n&=&\\mbox{Manning friction number}




    C++ includes: ManningConnection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    linear_slope_width = property(_cmf_core.Manning_Diffusive_linear_slope_width_get, _cmf_core.Manning_Diffusive_linear_slope_width_set, doc=r"""linear_slope_width : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Manning_Diffusive self, cmf::river::OpenWaterStorage::ptr left, cmf::water::flux_node::ptr right, IChannel reachtype) -> Manning_Diffusive
        Manning_Diffusive(cmf::river::OpenWaterStorage::ptr left,
        cmf::water::flux_node::ptr right, const cmf::river::IChannel
        &reachtype)

        Creates a diffusive wave connection between to open water storages.

        Parameters:
        -----------

        left:  right:  The nodes to be connected by the diffusive wave. Left
        needs to be an open water storage

        reachtype:  The channel geometry 
        """
        _cmf_core.Manning_Diffusive_swiginit(self, _cmf_core.new_Manning_Diffusive(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Manning_Diffusive

# Register Manning_Diffusive in _cmf_core:
_cmf_core.Manning_Diffusive_swigregister(Manning_Diffusive)

class Manning_Kinematic(Manning):
    r"""


    Connecting surface water bodies using a kinematic wave.

    Note the fixed gradient :math:`\\Delta_z` 

    .. math::


        q_{Manning}&=& A R^{\\frac 2 3} \\sqrt{\\frac {\\Delta_z} n}
        \\\\ A &=& \\frac V l \\mbox{, (Crosssectional area of the
        wetted crossection, Volume per length)} \\\\ R &=& \\frac A
        {P(d)} \\\\ P(d) &=& \\mbox{ the perimeter of the wetted
        crosssection, a function of reach depth} \\\\ d(V) &=& \\mbox{
        the depth of the reach a function of the volume} \\\\ \\Delta_z
        &=& \\frac{\\|z_1 - z_2\\|}{l} \\mbox{ Slope of the reach}
        \\\\ n&=&\\mbox{Manning friction number} 



    C++ includes: ManningConnection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Manning_Kinematic self, cmf::river::OpenWaterStorage::ptr left, cmf::water::flux_node::ptr right, IChannel reachtype) -> Manning_Kinematic
        Manning_Kinematic(cmf::river::OpenWaterStorage::ptr left,
        cmf::water::flux_node::ptr right, const cmf::river::IChannel
        &reachtype)

        Creates a kinematic wave connection between to open water storages.

        Parameters:
        -----------

        left:  right:  The nodes to be connected by the kinematic wave. Left
        needs to be an open water storage

        reachtype:  The channel geometry 
        """
        _cmf_core.Manning_Kinematic_swiginit(self, _cmf_core.new_Manning_Kinematic(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Manning_Kinematic

# Register Manning_Kinematic in _cmf_core:
_cmf_core.Manning_Kinematic_swigregister(Manning_Kinematic)

class CanopyOverflow(flux_connection):
    r"""


    Calculates the overflow of a canopy storage using a kinematic wave
    approach.

    This model routes only water that exceeds the canopy capacity to the
    ground with an ad hoc estimated function: 

    .. math::

        q_{CO} =
        \\left(\\frac{V_{act}-V_{max}}{V_{max}}\\right) ^2 \\cdot 2400
        \\frac{A_{cell}}{1000}

    With:  :math:`q_{CO}(t)[\\frac{m^3}{day}]`:
    The flux from canopy to the ground

    :math:`V_{act}[mm]=1000 [mm/m] \\frac{V_{canopy}[m^3]}{A_{cell} [m^2]}`
    The stored water of the canopy in mm

    :math:`V_{max}[mm]=c_{LAI}[mm] LAI` The capacity of the canopy in mm,
    defined by the factor CanopyCapacityPerLAI [mm/LAI], and the leaf area
    index LAI. (see: cmf::upslope::Vegetation)

    C++ includes: surfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(CanopyOverflow self, cmf::water::WaterStorage::ptr Canopy, cmf::water::flux_node::ptr target, Cell cell) -> CanopyOverflow
        CanopyOverflow(cmf::water::WaterStorage::ptr Canopy,
        cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell) 
        """
        _cmf_core.CanopyOverflow_swiginit(self, _cmf_core.new_CanopyOverflow(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.CanopyOverflow_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_CanopyOverflow

# Register CanopyOverflow in _cmf_core:
_cmf_core.CanopyOverflow_swigregister(CanopyOverflow)
CanopyOverflow_use_for_cell = _cmf_core.CanopyOverflow_use_for_cell

class RutterInterception(flux_connection):
    r"""


    Interception storage overflow according to the Rutter and Morton
    (1977) model.

    Calculates the interception overflow as a storage depending fraction
    of incoming rainfall The Rutter model of interception reads as follows
    after Meuser, A., 1990. Effects of afforestation on run-off
    characteristics. Agric. For. Meteorol. 50: 125-138.:


    .. math::

        \\frac{dI_C(t)}{dt}=P(t)(1-p_F-p_S)-P(t)(1-p_F-
        p_S)\\frac{I_C(t)}{I_CMAX}-f_I(E-e)(t)

    With :math:`I_C` the current
    canopy storage and :math:`P(t)` the current rainfall.

    The second term of the equation denotes the flux from the canopy to
    the ground. The implemented formula for canopy storage overflow reads
    then as: 

    .. math::

        q_{CO}(t) =
        P_{net}(t)\\frac{V_{act}[mm]}{V_{max}[mm]}

    With:
    :math:`q_{CO}(t)[\\frac{m^3}{day}]`: The flux from canopy to the ground

    :math:`P_{net}(t)[\\frac{m^3}{day}]`: The flux from the rain to the canopy

    :math:`V_{act}[mm]=1000 [mm/m] \\frac{V_{canopy}[m^3]}{A_{cell} [m^2]}`
    The stored water of the canopy in mm

    :math:`V_{max}[mm]=c_{LAI}[mm]\\cdot LAI` The capacity of the canopy in
    mm, defined by the factor CanopyCapacityPerLAI [mm/LAI], and the leaf
    area index LAI. (see: cmf::upslope::vegetation::Vegetation)

    C++ includes: surfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(RutterInterception self, cmf::water::WaterStorage::ptr Canopy, cmf::water::flux_node::ptr target, Cell cell) -> RutterInterception
        RutterInterception(cmf::water::WaterStorage::ptr Canopy,
        cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell) 
        """
        _cmf_core.RutterInterception_swiginit(self, _cmf_core.new_RutterInterception(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.RutterInterception_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_RutterInterception

# Register RutterInterception in _cmf_core:
_cmf_core.RutterInterception_swigregister(RutterInterception)
RutterInterception_use_for_cell = _cmf_core.RutterInterception_use_for_cell

class SimpleTindexSnowMelt(flux_connection):
    r"""


    Calculates snow melt using a simple degree day method.



    .. math::

         q_{melt} [mm/day] = (T-T_{thres}) * r 

    Usage:

    C++ includes: surfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SnowMeltRate = property(_cmf_core.SimpleTindexSnowMelt_SnowMeltRate_get, _cmf_core.SimpleTindexSnowMelt_SnowMeltRate_set, doc=r"""SnowMeltRate : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SimpleTindexSnowMelt self, cmf::water::WaterStorage::ptr snow, cmf::water::flux_node::ptr surface_water, Cell cell, real rate=7.0) -> SimpleTindexSnowMelt
        SimpleTindexSnowMelt(cmf::water::WaterStorage::ptr snow,
        cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell,
        real rate=7.0)

        Creates a new snow melt connection.

        Parameters:
        -----------

        snow:  Snow storage, usually cel.snow

        surface_water:  target of the melted water (usually cell.surfacewater)

        cell:  The cell, needed to get weather and area

        rate:  The rate of snow melt, given in mm/(degC day), default = 7.0 
        """
        _cmf_core.SimpleTindexSnowMelt_swiginit(self, _cmf_core.new_SimpleTindexSnowMelt(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.SimpleTindexSnowMelt_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_SimpleTindexSnowMelt

# Register SimpleTindexSnowMelt in _cmf_core:
_cmf_core.SimpleTindexSnowMelt_swigregister(SimpleTindexSnowMelt)
SimpleTindexSnowMelt_use_for_cell = _cmf_core.SimpleTindexSnowMelt_use_for_cell

class EnergyBudgetSnowMelt(flux_connection):
    r"""


    Calculates snow melt using the surface energy budget method.

    C++ includes: surfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(EnergyBudgetSnowMelt self, cmf::water::WaterStorage::ptr snow, cmf::water::flux_node::ptr surface_water, Cell cell) -> EnergyBudgetSnowMelt
        EnergyBudgetSnowMelt(cmf::water::WaterStorage::ptr snow,
        cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell) 
        """
        _cmf_core.EnergyBudgetSnowMelt_swiginit(self, _cmf_core.new_EnergyBudgetSnowMelt(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.EnergyBudgetSnowMelt_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_EnergyBudgetSnowMelt

# Register EnergyBudgetSnowMelt in _cmf_core:
_cmf_core.EnergyBudgetSnowMelt_swigregister(EnergyBudgetSnowMelt)
EnergyBudgetSnowMelt_use_for_cell = _cmf_core.EnergyBudgetSnowMelt_use_for_cell

snowfraction = _cmf_core.snowfraction
class Rainfall(flux_connection):
    r"""


    A connection routing rainfall to surface water and to an eventually
    existing canopy storage.

    C++ includes: AtmosphericFluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Throughfall = property(_cmf_core.Rainfall_Throughfall_get, _cmf_core.Rainfall_Throughfall_set, doc=r"""Throughfall : bool""")
    InterceptedRainfall = property(_cmf_core.Rainfall_InterceptedRainfall_get, _cmf_core.Rainfall_InterceptedRainfall_set, doc=r"""InterceptedRainfall : bool""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Rainfall self, cmf::water::flux_node::ptr target, Cell cell, bool getthroughfall=True, bool getintercepted=True) -> Rainfall
        Rainfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell,
        bool getthroughfall=true, bool getintercepted=true)

        Creates a new Rainfall connection. 
        """
        _cmf_core.Rainfall_swiginit(self, _cmf_core.new_Rainfall(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Rainfall

# Register Rainfall in _cmf_core:
_cmf_core.Rainfall_swigregister(Rainfall)

class Snowfall(flux_connection):
    r"""


    A connection routing snowfall (precipitation below freezing Temp) to
    the snow pack.

    C++ includes: AtmosphericFluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Snowfall self, cmf::water::flux_node::ptr target, Cell cell) -> Snowfall
        Snowfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell)

        """
        _cmf_core.Snowfall_swiginit(self, _cmf_core.new_Snowfall(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Snowfall

# Register Snowfall in _cmf_core:
_cmf_core.Snowfall_swigregister(Snowfall)

class MatrixInfiltration(flux_connection):
    r"""


    Connects the surfacewater and the most upper layer using a Richards
    equation like infiltration model.

    The potential infiltration is calculated according to the Richards
    equation. The gradient is from the cell surface to the center of the
    first layer and the conductivity is the geometric mean of the wetted
    surface ( :math:`K_{sat}`) and the conductivity of the layer center (
    :math:`K(\\theta_{layer})` 

    .. math::

         q_{max} &=&
        \\frac{\\Psi_{surface} - \\Psi_{soil}}{\\Delta z} K A_{cell}
        \\\\ K &=& \\sqrt{K\\left(\\theta_{layer}\\right)K_{sat}}
        \\\\ \\Delta z &=& z_{cell} - z_{layer center}




    If the surface water is modeled by a distinct water storage, the
    actual infiltration is given as the product of the potential
    infiltration with the coverage of the surface water
    cmf::upslope::Cell::surface_water_coverage 

    .. math::

        q_{act} = q_{max}
        \\frac{A_{water}}{A_{cell}}

    If the surface water is no storage on its own, but just a water
    distribution node, the actual infiltration is the minimum of the
    potential infiltration and the current inflow (rain, snow melt) to the
    surface 

    .. math::

        q_{act} = \\min\\left(q_{max},
        \\sum{q_{in,surfacewater}}\\right)

    C++ includes: infiltration.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(MatrixInfiltration self, cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr surfacewater) -> MatrixInfiltration
        MatrixInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
        cmf::water::flux_node::ptr surfacewater) 
        """
        _cmf_core.MatrixInfiltration_swiginit(self, _cmf_core.new_MatrixInfiltration(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.MatrixInfiltration_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_MatrixInfiltration

# Register MatrixInfiltration in _cmf_core:
_cmf_core.MatrixInfiltration_swigregister(MatrixInfiltration)
MatrixInfiltration_use_for_cell = _cmf_core.MatrixInfiltration_use_for_cell

class GreenAmptInfiltration(flux_connection):
    r"""


    Connects the surfacewater and the most upper layer using a Green-Ampt
    equation like infiltration.

    The Green-Ampt formula is given as: 

    .. math::

        q(t) = -K_s \\frac{dh}{dz}
        A

    where:  :math:`q(t)` is the infiltration rate in m3/day

    :math:`K_s` is the saturated conductivity in m/day

    :math:`\\frac{dh}{dz}` is the hydraulic gradient in the wetting front

    :math:`A` is the surface area of the cell

    The gradient in the wetting front is calculated as:


    .. math::

        \\frac{dh}{dz} = \\frac{h_f - h_0}{Z_f} =
        \\frac{|\\Psi_f| + Z_f}{Z_f}

    where:  :math:`h_f` is the hydraulic
    head at the bottom of the wetting front in m

    :math:`h_0` is the hydraulic head at the surface in m

    :math:`Z_f` is the length of the wetting front in m

    Since :math:`Z_f` is unknown, the depth of the wetting front can be
    approximated by: 

    .. math::

        Z_f = \\frac{F}{\\theta_s -
        \\theta_i}

    with:  :math:`F` the accumulated volume per area of
    infiltrated water

    :math:`\\theta_s, \\theta_i` the volumetric water content at saturation
    resp. at start of the infiltration

    If the surface water is modeled by a distinct water storage, the
    actual infiltration is given as the product of the potential
    infiltration with the coverage of the surface water
    cmf::upslope::Cell::surface_water_coverage 

    .. math::

        q_{act} = q_{max}
        \\frac{A_{water}}{A_{cell}}

    If the surface water is no storage on its own, but just a water
    distribution node, the actual infiltration is the minimum of the
    potential infiltration and the current inflow (rain, snow melt) to the
    surface 

    .. math::

        q_{act} = \\min\\left(q_{max},
        \\sum{q_{in,surfacewater}}\\right)

    C++ includes: infiltration.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(GreenAmptInfiltration self, cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr surfacewater) -> GreenAmptInfiltration
        GreenAmptInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
        cmf::water::flux_node::ptr surfacewater) 
        """
        _cmf_core.GreenAmptInfiltration_swiginit(self, _cmf_core.new_GreenAmptInfiltration(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.GreenAmptInfiltration_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_GreenAmptInfiltration

# Register GreenAmptInfiltration in _cmf_core:
_cmf_core.GreenAmptInfiltration_swigregister(GreenAmptInfiltration)
GreenAmptInfiltration_use_for_cell = _cmf_core.GreenAmptInfiltration_use_for_cell

class SimpleInfiltration(flux_connection):
    r"""


    Connects the surfacewater and the most upper layer using a simplified
    infiltration model suitable for conceptional models.



    .. math::

         q_{inf} = \\left(1-e_{sat}\\left(W, W_0\\right)\\right)
        q_{inf,pot} 

    where:  :math:`q_{inf}` Effective infiltration from
    surface to first layer (soil)

    :math:`e_{sat}(W, W_0)` Saturation excess, ranging from 0 (nowhere saturated
    soil layer) to 1 (fully saturated). :math:`W` is the average wetness
    calculated from the soil layer, :math:`W_0` is a parameter denoting the
    wetness, where 50% of the layer is saturated using a sigmoidal
    function:  :math:`e_{sat}(W_{soil}, W_0) = \\left(1+e^{-(W-W_0)0.2(1-W_0)}\\right)^{-1}`

    :math:`q_{inf,pot}` is the potential infiltration, given by the incoming
    fluxes limited by the saturated conductivity:  :math:`q_{inf,pot} = \\min(q_{in}, K_{sat} A)`  :math:`q_{in}` Sum of incoming fluxes to the
    surfacewater in :math:`m^3/day`

    :math:`K_{sat}` Saturated conductivity in :math:`m/day`

    :math:`A` Cell area in :math:`m^2`

    C++ includes: infiltration.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    W0 = property(_cmf_core.SimpleInfiltration_W0_get, _cmf_core.SimpleInfiltration_W0_set, doc=r"""W0 : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SimpleInfiltration self, cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr surfacewater, real W0=0.9) -> SimpleInfiltration
        SimpleInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
        cmf::water::flux_node::ptr surfacewater, real W0=0.9)

        Creates the connection between surfacewater and first soil layer.

        Parameters:
        -----------

        soilwater:  the infiltration target

        surfacewater:  the infiltration source

        W0:  the 50% saturation value 
        """
        _cmf_core.SimpleInfiltration_swiginit(self, _cmf_core.new_SimpleInfiltration(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.SimpleInfiltration_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_SimpleInfiltration

# Register SimpleInfiltration in _cmf_core:
_cmf_core.SimpleInfiltration_swigregister(SimpleInfiltration)
SimpleInfiltration_use_for_cell = _cmf_core.SimpleInfiltration_use_for_cell

class SWATPercolation(flux_connection):
    r"""


    A tipping bucket percolation approach similar to the approach in SWAT.



    .. math::

         q_{perc} &=&
        V_{H_2O,drain}\\left(1-e^{-\\frac 1{-TT_{perc}}}\\right)
        \\\\ TT_{perc} &=& \\frac{V_{pores,drain} - V_{field
        cap.}}{K_{sat}} \\\\ V_{x,drain} &=& V_{x,drain} - V_{field cap.}




    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    use_for_cell = _swig_new_static_method(_cmf_core.SWATPercolation_use_for_cell)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SWATPercolation self, cmf::upslope::SoilLayer::ptr upperLayer, cmf::upslope::SoilLayer::ptr lowerLayer) -> SWATPercolation
        SWATPercolation(cmf::upslope::SoilLayer::ptr upperLayer,
        cmf::upslope::SoilLayer::ptr lowerLayer) 
        """
        _cmf_core.SWATPercolation_swiginit(self, _cmf_core.new_SWATPercolation(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SWATPercolation

# Register SWATPercolation in _cmf_core:
_cmf_core.SWATPercolation_swigregister(SWATPercolation)
SWATPercolation_use_for_cell = _cmf_core.SWATPercolation_use_for_cell

class Richards(flux_connection):
    r"""


    Calculates flow according to the Richards equation.



    .. math::

         q_{Richards} &=&
        \\frac{\\Delta\\Psi_{tot}}{d} K(\\theta) A \\\\
        \\Psi_{tot} &= &\\Psi_{M}(\\theta) + h 

     where
    :math:`\\Delta\\Psi_{tot} [m]` is the difference of the total water
    potentials of the two soil layers

    :math:`d [m]` is the distance between the two soil layers

    :math:`K(\\theta)\\left[\\frac m{day}\\right]` is the geometric
    mean conductivity (see SoilType::Kunsat)

    :math:`A [m^2]` is the crosssectional area of the flux

    :math:`\\Psi_M(\\theta) [m]` is the matrix potential (see
    SoilType::MatrixPotential)

    :math:`h [m]` is the height of a soil layer above sea level

    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Richards self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right) -> Richards
        Richards(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
        right)

        Creates a Richards equation connection between two soil layers (left
        and right, rather top and bottom) of the same cell. 
        """
        _cmf_core.Richards_swiginit(self, _cmf_core.new_Richards(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.Richards_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_Richards

# Register Richards in _cmf_core:
_cmf_core.Richards_swigregister(Richards)
Richards_use_for_cell = _cmf_core.Richards_use_for_cell

class SimplRichards(flux_connection):
    r"""


    Calculates flow according to a simplified Richards equation.



    .. math::

         q_{Richards} &=& (K(\\theta) - K(\\theta_r))
        A \\\\ 

     where  :math:`d [m]` is the distance between
    the two soil layers

    :math:`K(\\theta)\\left[\\frac m{day}\\right]` is the geometric
    mean conductivity (see SoilType::Kunsat)

    :math:`A [m^2]` is the crosssectional area of the flux

    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SimplRichards self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right) -> SimplRichards
        SimplRichards(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right) 
        """
        _cmf_core.SimplRichards_swiginit(self, _cmf_core.new_SimplRichards(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.SimplRichards_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_SimplRichards

# Register SimplRichards in _cmf_core:
_cmf_core.SimplRichards_swigregister(SimplRichards)
SimplRichards_use_for_cell = _cmf_core.SimplRichards_use_for_cell

class FreeDrainagePercolation(flux_connection):
    r"""


    Calculates a free drainage (unit gradient) from a layer to somewhere
    else.



    .. math::

         q = K(\\theta) A

    where:  :math:`q` Flux from the layer to the
    other side of the connection in :math:`m^3/day`

    :math:`K(\\theta)` Actual conductivity in :math:`m/day` depending on the water
    content of the layer :math:`\\theta`

    :math:`A` Cell area in :math:`m^2`

    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(FreeDrainagePercolation self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right) -> FreeDrainagePercolation
        FreeDrainagePercolation(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right) 
        """
        _cmf_core.FreeDrainagePercolation_swiginit(self, _cmf_core.new_FreeDrainagePercolation(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_FreeDrainagePercolation

# Register FreeDrainagePercolation in _cmf_core:
_cmf_core.FreeDrainagePercolation_swigregister(FreeDrainagePercolation)

class LayerBypass(flux_connection):
    r"""


    A simplification of macro pore flux for swelling soils.

    Connects the surfacewater of the cell with deeper layers, assuming the
    presence of cracks. At saturation level of the target layer, the
    cracks are closed 

    .. math::

        q_{crack} = K_{max,crack}
        \\left(1-\\left(\\frac{w-w_0}{1-w_0}\\right)^\\beta\\right)
        A

    where:  :math:`q_{crack}` is the flux from the surface water to the
    target layer in m3/day

    :math:`K_{max,crack}` is the maximum conductivity of the cracks in m/day

    :math:`w` is the actual wetness of the target layer

    :math:`w_0` is saturation, where the shrinkage of the cracks starts

    :math:`\\beta` is an empirical shape parameter of the crack size/wetness
    relation

    :math:`A` is the area of the cell

    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Kmax = property(_cmf_core.LayerBypass_Kmax_get, _cmf_core.LayerBypass_Kmax_set, doc=r"""Kmax : real""")
    w0 = property(_cmf_core.LayerBypass_w0_get, _cmf_core.LayerBypass_w0_set, doc=r"""w0 : real""")
    beta = property(_cmf_core.LayerBypass_beta_get, _cmf_core.LayerBypass_beta_set, doc=r"""beta : real""")
    K = _swig_new_instance_method(_cmf_core.LayerBypass_K)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(LayerBypass self, cmf::water::flux_node::ptr left, cmf::upslope::SoilLayer::ptr right, real Kmax=100., real w0=0.0, real beta=1.0) -> LayerBypass
        LayerBypass(cmf::water::flux_node::ptr left,
        cmf::upslope::SoilLayer::ptr right, real Kmax=100., real w0=0.0, real
        beta=1.0)

        Creates a layer bypass connection.

        Parameters:
        -----------

        left:  The source of the flux, usually the surfacewater of the cell

        right:  The target soil layer

        Kmax:  maximum conductivity of the cracks in m/day

        w0:  is the actual wetness of the target layer

        beta:  is an empirical shape parameter of the crack size/wetness
        relation 
        """
        _cmf_core.LayerBypass_swiginit(self, _cmf_core.new_LayerBypass(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_LayerBypass

# Register LayerBypass in _cmf_core:
_cmf_core.LayerBypass_swigregister(LayerBypass)

class RootUptakeStressFunction(object):
    r"""


    An abstract class to calculate the actual transpiration from potential
    transpiration.

    Implementations of WaterStressFunction are used by ET connections
    derived from cmf::upslope::ET::stressedET

    C++ includes: waterstress.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Tact = _swig_new_instance_method(_cmf_core.RootUptakeStressFunction_Tact)
    copy = _swig_new_instance_method(_cmf_core.RootUptakeStressFunction_copy)
    to_string = _swig_new_instance_method(_cmf_core.RootUptakeStressFunction_to_string)
    __swig_destroy__ = _cmf_core.delete_RootUptakeStressFunction

# Register RootUptakeStressFunction in _cmf_core:
_cmf_core.RootUptakeStressFunction_swigregister(RootUptakeStressFunction)

class SuctionStress(RootUptakeStressFunction):
    r"""


    The classical suction depending transpiration Stress curve after
    Feddes.

    The ability of roots to take water from the soil up is limited by the
    suction pressure (matrix potential) of the soil. The stress is defined
    using a trapezoid function, with P0 being the pressure, where water
    uptake is prohibited by saturation. Between P0 and P1 the saturation
    stress gets lower. Between P1 and P2, no stress occurs ( ET=ETpot) and
    with a pressure below P2, water uptake is limited by drought. P3
    indicates the highest suction (lowest pressure) to which plants can
    extract water (wilting point).

    Default values: :math:`P_0 = \\infty, P_1=\\infty, P_2=-5m, P_3=-160m`,
    resulting in no saturation stress and draught stress starting at -5m
    and a wilting point of -160m.

    If one would like to include saturation stress, typical values for P0
    and P1 are 0.0m and 0.1m. By changing P2 and P3, you can account for
    different drought sensibility for different plant types.

    C++ includes: waterstress.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    P0 = property(_cmf_core.SuctionStress_P0_get, _cmf_core.SuctionStress_P0_set, doc=r"""P0 : real""")
    P1 = property(_cmf_core.SuctionStress_P1_get, _cmf_core.SuctionStress_P1_set, doc=r"""P1 : real""")
    P2 = property(_cmf_core.SuctionStress_P2_get, _cmf_core.SuctionStress_P2_set, doc=r"""P2 : real""")
    P3 = property(_cmf_core.SuctionStress_P3_get, _cmf_core.SuctionStress_P3_set, doc=r"""P3 : real""")

    def __init__(self, *args):
        r"""
        __init__(SuctionStress self, real P0=1e308, real P1=1e307, real P2=-5, real P3=-160) -> SuctionStress
        __init__(SuctionStress self, SuctionStress other) -> SuctionStress
        SuctionStress(const SuctionStress &other) 
        """
        _cmf_core.SuctionStress_swiginit(self, _cmf_core.new_SuctionStress(*args))
    copy = _swig_new_instance_method(_cmf_core.SuctionStress_copy)
    __swig_destroy__ = _cmf_core.delete_SuctionStress

# Register SuctionStress in _cmf_core:
_cmf_core.SuctionStress_swigregister(SuctionStress)

class ContentStress(RootUptakeStressFunction):
    r"""


    A simple water content based stress model based on Feddes (1978)

    stress a is piecewise linear function based on water content

    if :math:`\\theta>\\theta_d \\rightarrow ET = ET_{pot}`

    if :math:`\\theta_d>\\theta > \\theta_{wilt} \\rightarrow ET = \\frac{\\theta_d - \\theta}{\\theta_d - \\theta_{wilt}} ET_{pot}`

    if :math:`\\theta_{wilt}>\\theta \\rightarrow ET = 0.0`

    The parameters :math:`\\theta_{d,w}` can be omitted (or set to a negative
    value) to use default values derived from the layer properties. The
    critical water content (where stress starts) is then defined (conf.
    Feddes 1978) as the center between field capacity ( :math:`\\theta_{fc}`)
    and the wilting point ( :math:`\\theta_{wp}`).  :math:`\\theta_w = \\theta(pF=4.2)`: Water content at pF=4.2

    :math:`\\theta_d = 1/2 (\\theta(pF=1.8) + \\theta(pF=4.2))`

    C++ includes: waterstress.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    theta_d = property(_cmf_core.ContentStress_theta_d_get, _cmf_core.ContentStress_theta_d_set, doc=r"""theta_d : real""")
    theta_w = property(_cmf_core.ContentStress_theta_w_get, _cmf_core.ContentStress_theta_w_set, doc=r"""theta_w : real""")
    copy = _swig_new_instance_method(_cmf_core.ContentStress_copy)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ContentStress self, real theta_d=-1, real theta_w=-1) -> ContentStress
        ContentStress(real theta_d=-1, real theta_w=-1)

        Creates a new ContentStress for critical water content theta_d in vol
        Water/vol Soil and wilting point theta_w. 
        """
        _cmf_core.ContentStress_swiginit(self, _cmf_core.new_ContentStress(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ContentStress

# Register ContentStress in _cmf_core:
_cmf_core.ContentStress_swigregister(ContentStress)

class VolumeStress(RootUptakeStressFunction):
    r"""


    A WaterStressFunction based on the stored water volume of a layer.

    If the layer contains more water than V1, ET is not limited (
    ET=ETpot). Below V1 ET goes linear to 0.0 at V0

    C++ includes: waterstress.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    V1 = property(_cmf_core.VolumeStress_V1_get, _cmf_core.VolumeStress_V1_set, doc=r"""V1 : real""")
    V0 = property(_cmf_core.VolumeStress_V0_get, _cmf_core.VolumeStress_V0_set, doc=r"""V0 : real""")

    def __init__(self, *args):
        r"""
        __init__(VolumeStress self, real V1, real V0) -> VolumeStress
        __init__(VolumeStress self, VolumeStress other) -> VolumeStress
        VolumeStress(const VolumeStress &other) 
        """
        _cmf_core.VolumeStress_swiginit(self, _cmf_core.new_VolumeStress(*args))
    copy = _swig_new_instance_method(_cmf_core.VolumeStress_copy)
    __swig_destroy__ = _cmf_core.delete_VolumeStress

# Register VolumeStress in _cmf_core:
_cmf_core.VolumeStress_swigregister(VolumeStress)

class log_wind_profile(aerodynamic_resistance):
    r"""


    , A logarithmic wind profile

    Todo Cite literature for this windprofile and insert equation

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(log_wind_profile self, Cell _cell) -> log_wind_profile
        log_wind_profile(cmf::upslope::Cell &_cell) 
        """
        _cmf_core.log_wind_profile_swiginit(self, _cmf_core.new_log_wind_profile(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_log_wind_profile

# Register log_wind_profile in _cmf_core:
_cmf_core.log_wind_profile_swigregister(log_wind_profile)

PenmanMonteith = _cmf_core.PenmanMonteith
class stressedET(flux_connection):
    r"""


    An abstract base class for ET Methods with a WaterStressFunction.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    get_layer = _swig_new_instance_method(_cmf_core.stressedET_get_layer)
    ETpot = _swig_new_instance_method(_cmf_core.stressedET_ETpot)
    __swig_destroy__ = _cmf_core.delete_stressedET

# Register stressedET in _cmf_core:
_cmf_core.stressedET_swigregister(stressedET)

class constantETpot(stressedET):
    r"""


    A constant evapotranspiration.

    Uses a constant measured or elsewhere modelled ETpot. Actual
    Evapotranspiration is calculated from rootdepth and actual matrix
    potential in the layers using Tact. The value of ETpot can be changed
    during runtime

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ETpot_value = property(_cmf_core.constantETpot_ETpot_value_get, _cmf_core.constantETpot_ETpot_value_set, doc=r"""ETpot_value : real""")
    GetETpot = _swig_new_instance_method(_cmf_core.constantETpot_GetETpot)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(constantETpot self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, double constantETpot_value) -> constantETpot
        constantETpot(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, double constantETpot_value) 
        """
        _cmf_core.constantETpot_swiginit(self, _cmf_core.new_constantETpot(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_constantETpot

# Register constantETpot in _cmf_core:
_cmf_core.constantETpot_swigregister(constantETpot)

class timeseriesETpot(stressedET):
    r"""


    A timeseries driven evapotranspiration.

    Uses a timeseries of measured or elsewhere modelled ETpot. Actual
    Evapotranspiration is calculated from rootdepth and actual matrix
    potential in the layers using Tact. The value of ETpot can be changed
    during runtime

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ETpot_data = property(_cmf_core.timeseriesETpot_ETpot_data_get, _cmf_core.timeseriesETpot_ETpot_data_set, doc=r"""ETpot_data : cmf::math::timeseries""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(timeseriesETpot self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, timeseries ETpot_values) -> timeseriesETpot
        timeseriesETpot(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, cmf::math::timeseries
        ETpot_values) 
        """
        _cmf_core.timeseriesETpot_swiginit(self, _cmf_core.new_timeseriesETpot(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_timeseriesETpot

# Register timeseriesETpot in _cmf_core:
_cmf_core.timeseriesETpot_swigregister(timeseriesETpot)

class PenmanMonteithET(stressedET):
    r"""


    Calculates the potential evapotranspiration according to FAO(1998)

    Governing equations: 

    .. math::

         \\lambda ET &=&
        \\frac{\\Delta\\left(R_n - G\\right)+\\rho_a c_p
        \\frac{e_s - e_a}{r_a}}{\\Delta +
        \\gamma\\left(1+\\frac{r_s}{r_a}\\right)} \\mbox{ FAO 1998,
        Eq. 3} \\\\ \\mbox{With:} \\\\ \\Delta &=& 4098
        \\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\frac{kPa}{^\\circ C}
        \\mbox{ (FAO 1998, Eq. 13)} \\\\ T &=& \\mbox{Actual
        Temperature in } ^\\circ C \\\\ R_n &=& \\mbox{net Radiation
        (see Atmosphere) in } \\frac{MJ}{m^2day} \\\\ G &=& 0 \\
        \\frac{MJ}{m^2day} \\mbox{ if daily average (FAO 1998, Eq. 42)}
        \\\\ && 0.1 R_n \\ \\mbox{ if day time (FAO 1998, Eq. 45)}
        \\\\ && 0.5 R_n \\ \\mbox{ if night time (FAO 1998, Eq. 46)}
        \\\\ \\gamma &=& \\frac{c_p P}{\\epsilon \\lambda}
        \\mbox{ (FAO 1998,Eq. 8): Psychrometric constant }
        \\frac{kPa}{^\\circ C} \\\\ c_p &=& 0.001013
        \\frac{MJ}{kg\\ ^\\circ C}\\mbox{ specific heat at constant
        pressure } \\\\ P &=& 101.3
        \\left(\\frac{293-0.0065z}{293}\\right)^{5.26} \\mbox{ (FAO
        1998,Eq. 7)} \\\\ \\epsilon &=& 0.622 \\frac{mol/g \\mbox{
        vapor}}{mol/g \\mbox{ liquid water}} \\\\ \\lambda &=& 2.45
        \\frac{MJ}{kg} \\mbox{ (FAO 1998,Eq. 8)} \\\\ R &=& 0.287
        \\frac{kJ}{kg\\ k}\\mbox{ Spec. gas const.} \\\\ \\rho_a
        &=& \\frac{P}{1.01(T+273)R} \\mbox{ (FAO 1998,Box. 6)} \\\\
        e_s &=& \\mbox{ Sat. vapor press. } [kPa] \\\\ e_a &=& \\mbox{
        Act. vapor press. } [kPa] \\\\ r_a &=&
        \\frac{\\ln\\left(\\frac{2-d}{z_{om}}\\right)\\ln\\left(\\frac{2-d}{z_{oh}}\\right)}{k^2
        u_2} \\mbox{ (FAO 1998, Eq. 4/Box 4} \\frac s m \\\\ &&
        d=\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1 z_{om}, k=0.41 \\\\ h
        &=& \\mbox{ Vegetation height in }m \\\\ u_2 &=& \\mbox{
        Windspeed in 2m above canopy } \\frac m s \\\\ r_s &=&
        \\frac{r_l}{LAI_{Active}} \\mbox{ (FAO 1998, Eq. 5/Box 5)}
        \\frac s m \\\\ && r_l=100 \\frac s m, LAI_{Active}=0.5 LAI


    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    daily = property(_cmf_core.PenmanMonteithET_daily_get, _cmf_core.PenmanMonteithET_daily_set, doc=r"""daily : bool""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PenmanMonteithET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target) -> PenmanMonteithET
        PenmanMonteithET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target) 
        """
        _cmf_core.PenmanMonteithET_swiginit(self, _cmf_core.new_PenmanMonteithET(*args, **kwargs))
    r_s = _swig_new_static_method(_cmf_core.PenmanMonteithET_r_s)
    r_a = _swig_new_static_method(_cmf_core.PenmanMonteithET_r_a)
    use_for_cell = _swig_new_static_method(_cmf_core.PenmanMonteithET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_PenmanMonteithET

# Register PenmanMonteithET in _cmf_core:
_cmf_core.PenmanMonteithET_swigregister(PenmanMonteithET)
PenmanMonteithET_r_s = _cmf_core.PenmanMonteithET_r_s
PenmanMonteithET_r_a = _cmf_core.PenmanMonteithET_r_a
PenmanMonteithET_use_for_cell = _cmf_core.PenmanMonteithET_use_for_cell

class PriestleyTaylorET(stressedET):
    r"""


    Calculates the Evapotranspiration using Priestley-Taylor equation.



    .. math::

        lambda ET = \\alpha \\frac{\\Delta}{\\Delta + \\gamma}
        \\left(R_n - G\\right)

    where:  :math:`\\Delta = 4098 \\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\frac{kPa}{^\\circ C}`,
    the slope of the vapor pressure/ temperature curve

    :math:`\\gamma = \\frac{c_p P}{\\epsilon \\lambda} \\frac{kPa}{^\\circ C}` Psychrometric constant

    :math:`\\lambda = 2.45 \\frac{MJ}{kg}` the latent heat of vaporization

    :math:`R_n \\frac{MJ}{m^2day}` net Radiation (see Atmosphere)

    :math:`G` Ground heat flux

    :math:`\\alpha` the Priestley-Taylor constant (default 1.26 for humid
    climates)

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    daily = property(_cmf_core.PriestleyTaylorET_daily_get, _cmf_core.PriestleyTaylorET_daily_set, doc=r"""daily : bool""")
    alpha = property(_cmf_core.PriestleyTaylorET_alpha_get, _cmf_core.PriestleyTaylorET_alpha_set, doc=r"""alpha : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PriestleyTaylorET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, real alpha=1.26) -> PriestleyTaylorET
        PriestleyTaylorET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, real alpha=1.26) 
        """
        _cmf_core.PriestleyTaylorET_swiginit(self, _cmf_core.new_PriestleyTaylorET(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.PriestleyTaylorET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_PriestleyTaylorET

# Register PriestleyTaylorET in _cmf_core:
_cmf_core.PriestleyTaylorET_swigregister(PriestleyTaylorET)
PriestleyTaylorET_use_for_cell = _cmf_core.PriestleyTaylorET_use_for_cell

class HargreaveET(stressedET):
    r"""


    Calculates the Evapotranspiration using Hargreave's equation.



    .. math::

        ET_{rc} = 0.0135 K_T\\ s_0 \\sqrt{\\Delta T} (T +
        17.8)

    where:  :math:`ET_{rc}` the reference crop evapotranspiration
    in mm/day

    :math:`K_T = 0.00185{\\Delta T}^2 - 0.0433 \\Delta T + 0.4023`
    Continentality factor as given in the reference

    :math:`\\Delta T = |T_{max} - T_{min}|[K]` Daily temperature range

    :math:`T [^\\circ C]` daily mean temperature

    :math:`s_0 = 15.392 d_r \\left(\\omega_s\\sin(\\Phi) \\sin{\\gamma} + \\cos{\\Phi}\\cos{\\gamma} * \\sin(\\omega_s)\\right)` the extraterrestrial solar radiation
    in mm/day

    :math:`d_r = 1 + 0.0033 \\cos(DOY\\frac{2 \\pi}{365})` relative
    distance between earth and sun

    :math:`\\omega_s = \\arccos(-\\tan{\\Phi} \\tan{\\gamma})`
    sunset hour angle (radians)

    :math:`\\gamma = 0.4039 \\sin(DOY\\frac{2 \\pi}{365} - 1.405)`
    solar declination (radians)

    :math:`\\Phi` geographic latitude (radians)

    See:  SAMANI, Zohrab.Estimating solar radiation and evapotranspiration
    using minimum climatological data. Journal of Irrigation and Drainage
    Engineering, 2000, 126. Jg., Nr. 4, S. 265-267.  Crop specific
    potential evapotranspiration is scaled by LAI: :math:`ET_{pot} = ET_{rc} \\frac{LAI}{2.88}`.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(HargreaveET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target) -> HargreaveET
        HargreaveET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target) 
        """
        _cmf_core.HargreaveET_swiginit(self, _cmf_core.new_HargreaveET(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.HargreaveET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_HargreaveET

# Register HargreaveET in _cmf_core:
_cmf_core.HargreaveET_swigregister(HargreaveET)
HargreaveET_use_for_cell = _cmf_core.HargreaveET_use_for_cell

class OudinET(stressedET):
    r"""


    Calculates ETpot after Oudin et al 2005.

    https://doi.org/10.1016/j.jhydrol.2004.08.026 This ETpot formula is a
    generalization of two older approaches by introducing parameters to
    shape the dependency of ETpot from temperature and extraterrestrial
    radiation

    :math:`\\lambda ET_{pot} = R_{a} \\cdot \\frac{T_{a} + K_2}{K_1}`

    Oudin et al (2005) found an optimum for :math:`K_1=100, K_2=5`. The origin
    of this formula lays in Jensen & Haise (1963) with :math:`K_1=40, K_2=0` and
    McGuiness-Bordne (1972) with :math:`K_1=68, K_2=5`.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(OudinET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, double K1=100, double K2=5) -> OudinET
        OudinET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, double K1=100, double K2=5) 
        """
        _cmf_core.OudinET_swiginit(self, _cmf_core.new_OudinET(*args, **kwargs))
    JensenHaise1963 = _swig_new_static_method(_cmf_core.OudinET_JensenHaise1963)
    McGuinessBordne1972 = _swig_new_static_method(_cmf_core.OudinET_McGuinessBordne1972)
    K1 = property(_cmf_core.OudinET_K1_get, _cmf_core.OudinET_K1_set, doc=r"""K1 : double""")
    K2 = property(_cmf_core.OudinET_K2_get, _cmf_core.OudinET_K2_set, doc=r"""K2 : double""")
    use_for_cell = _swig_new_static_method(_cmf_core.OudinET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_OudinET

# Register OudinET in _cmf_core:
_cmf_core.OudinET_swigregister(OudinET)
OudinET_JensenHaise1963 = _cmf_core.OudinET_JensenHaise1963
OudinET_McGuinessBordne1972 = _cmf_core.OudinET_McGuinessBordne1972
OudinET_use_for_cell = _cmf_core.OudinET_use_for_cell

class TurcET(stressedET):
    r"""


    Calculates ETpot after Turc (DVWK).

    :math:`ET_{act}` is calculated using a WaterStressFunction



    .. math::

         ET_{pot,Turc} = 0.0031 C(rH) (R_G + 209) \\frac{T}{T + 15}


    where:  :math:`T` is the mean daily temperature

    :math:`C(rH) = \\begin{cases} 1 + \\frac{50\\% - rH}{70\\%}, & rH < 50\\% \\\\ 1 & rH > 50\\% \\end{cases}`, a modification
    parameter for low humidity

    :math:`rH` relative Humidity in %

    :math:`R_G` global radiation in :math:`J/cm^2`

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(TurcET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target) -> TurcET
        TurcET(cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
        ET_target) 
        """
        _cmf_core.TurcET_swiginit(self, _cmf_core.new_TurcET(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.TurcET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_TurcET

# Register TurcET in _cmf_core:
_cmf_core.TurcET_swigregister(TurcET)
TurcET_use_for_cell = _cmf_core.TurcET_use_for_cell

class CanopyStorageEvaporation(flux_connection):
    r"""


    Calculates the evaporation from a canopy storage.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(CanopyStorageEvaporation self, cmf::water::WaterStorage::ptr CanopyStorage, cmf::water::flux_node::ptr ET_target, Cell cell) -> CanopyStorageEvaporation
        CanopyStorageEvaporation(cmf::water::WaterStorage::ptr CanopyStorage,
        cmf::water::flux_node::ptr ET_target, cmf::upslope::Cell &cell) 
        """
        _cmf_core.CanopyStorageEvaporation_swiginit(self, _cmf_core.new_CanopyStorageEvaporation(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_CanopyStorageEvaporation

# Register CanopyStorageEvaporation in _cmf_core:
_cmf_core.CanopyStorageEvaporation_swigregister(CanopyStorageEvaporation)

class PenmanEvaporation(flux_connection):
    r"""


    Calculates evaporation from an open water body.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PenmanEvaporation self, cmf::river::OpenWaterStorage::ptr source, cmf::water::flux_node::ptr Evap_target, Meteorology meteo) -> PenmanEvaporation
        PenmanEvaporation(cmf::river::OpenWaterStorage::ptr source,
        cmf::water::flux_node::ptr Evap_target, const
        cmf::atmosphere::Meteorology &meteo) 
        """
        _cmf_core.PenmanEvaporation_swiginit(self, _cmf_core.new_PenmanEvaporation(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_PenmanEvaporation

# Register PenmanEvaporation in _cmf_core:
_cmf_core.PenmanEvaporation_swigregister(PenmanEvaporation)

class ShuttleworthWallace(aerodynamic_resistance):
    r"""


    Calculates the sum of soil evaporation and transpiration according to
    Shuttleworth & Wallace 1985, as implemented in BROOK 90 (Federer 1990)

    The difference to BROOK90 is, that the actual transpiration is not
    calculated by plant resitance and potential gradient between plant and
    soil, but by an piecewise linear function of the pF value :math:`pF = \\log_{10}\\left(-\\Psi [hPa]\\right)`: 

    .. math::


        \\frac{T_{act}}{T_{pot}} = \\begin{cases}1 & pF \\le 3.35
        \\\\ \\frac{pF - 4.2}{3.35 - 4.2} & pF \\in [3.35 .. 4.2]
        \\\\ 0 & pF \\ge 4.2\\end{cases} 

    Calculation procedure, as in BROOK 90:

    Evapotranspiration from the canopy: :math:`\\lambda ET_{canopy} = \\frac{r_{ac} \\Delta\\ R_{n,canopy} + c_p\\rho D_0}{\\Delta \\gamma r_{ac} + \\gamma r_{sc}}`

    Evaporation from the ground: :math:`\\lambda E_{ground} = \\frac{r_{as} \\Delta\\ R_{n,ground} + c_p\\rho D_0}{\\Delta \\gamma r_{as} + \\gamma r_{ss}}`

    In case of a complete surface water covered ground, the surface
    resistance :math:`r_{ss}` becomes 0. (GIR)

    with  :math:`\\Delta = \\frac{de_s}{dT} = 4098\\ 0.6108 \\exp\\left(\\frac{17.27 T}{T+237.3}\\right)(T+237.3)^{-2}`,
    the slope of the sat. vap. press. T function

    :math:`R_{n,ground} = R_n \\exp(-C_R LAI)`, the net radiation flux to
    the ground

    :math:`R_{n,canopy} = R_n - R_{n,ground}`, the net radiation flux to the
    canopy

    :math:`\\lambda,c_p\\rho,\\gamma` latent heat of vaporization, heat
    capacity of air, psychrometer constant

    :math:`D_0` vapor pressure deficit at effective source height, see
    function D0

    :math:`r_{ac}, r_{sc}, r_{as}, r_{ss}` Resistances for the vapor pressure
    (see below)

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    RAA = property(_cmf_core.ShuttleworthWallace_RAA_get, _cmf_core.ShuttleworthWallace_RAA_set, doc=r"""RAA : double""")
    RAC = property(_cmf_core.ShuttleworthWallace_RAC_get, _cmf_core.ShuttleworthWallace_RAC_set, doc=r"""RAC : double""")
    RSC = property(_cmf_core.ShuttleworthWallace_RSC_get, _cmf_core.ShuttleworthWallace_RSC_set, doc=r"""RSC : double""")
    RAS = property(_cmf_core.ShuttleworthWallace_RAS_get, _cmf_core.ShuttleworthWallace_RAS_set, doc=r"""RAS : double""")
    RSS = property(_cmf_core.ShuttleworthWallace_RSS_get, _cmf_core.ShuttleworthWallace_RSS_set, doc=r"""RSS : double""")
    refresh_counter = property(_cmf_core.ShuttleworthWallace_refresh_counter_get, _cmf_core.ShuttleworthWallace_refresh_counter_set, doc=r"""refresh_counter : int""")
    refresh = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_refresh)
    PTR = property(_cmf_core.ShuttleworthWallace_PTR_get, _cmf_core.ShuttleworthWallace_PTR_set, doc=r"""PTR : double""")
    PSNVP = property(_cmf_core.ShuttleworthWallace_PSNVP_get, _cmf_core.ShuttleworthWallace_PSNVP_set, doc=r"""PSNVP : double""")
    ASNVP = property(_cmf_core.ShuttleworthWallace_ASNVP_get, _cmf_core.ShuttleworthWallace_ASNVP_set, doc=r"""ASNVP : double""")
    GER = property(_cmf_core.ShuttleworthWallace_GER_get, _cmf_core.ShuttleworthWallace_GER_set, doc=r"""GER : double""")
    PIR = property(_cmf_core.ShuttleworthWallace_PIR_get, _cmf_core.ShuttleworthWallace_PIR_set, doc=r"""PIR : double""")
    AIR = property(_cmf_core.ShuttleworthWallace_AIR_get, _cmf_core.ShuttleworthWallace_AIR_set, doc=r"""AIR : double""")
    ATR_sum = property(_cmf_core.ShuttleworthWallace_ATR_sum_get, _cmf_core.ShuttleworthWallace_ATR_sum_set, doc=r"""ATR_sum : double""")
    ATR = property(_cmf_core.ShuttleworthWallace_ATR_get, _cmf_core.ShuttleworthWallace_ATR_set, doc=r"""ATR : cmf::math::num_array""")
    KSNVP = property(_cmf_core.ShuttleworthWallace_KSNVP_get, _cmf_core.ShuttleworthWallace_KSNVP_set, doc=r"""KSNVP : double""")
    allow_dew = property(_cmf_core.ShuttleworthWallace_allow_dew_get, _cmf_core.ShuttleworthWallace_allow_dew_set, doc=r"""allow_dew : bool""")
    transp_from_layer = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_transp_from_layer)
    evap_from_layer = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_evap_from_layer)
    evap_from_surfacewater = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_evap_from_surfacewater)
    evap_from_canopy = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_evap_from_canopy)
    evap_from_snow = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_evap_from_snow)
    set_RSS_parameters = _swig_new_static_method(_cmf_core.ShuttleworthWallace_set_RSS_parameters)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ShuttleworthWallace self, Cell cell, bool allow_dew=True) -> ShuttleworthWallace
        ShuttleworthWallace(cmf::upslope::Cell &cell, bool allow_dew=true)

        Calculates the transpiration and the soil evaporation from dry
        surfaces. 
        """
        _cmf_core.ShuttleworthWallace_swiginit(self, _cmf_core.new_ShuttleworthWallace(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.ShuttleworthWallace_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_ShuttleworthWallace

# Register ShuttleworthWallace in _cmf_core:
_cmf_core.ShuttleworthWallace_swigregister(ShuttleworthWallace)
ShuttleworthWallace_set_RSS_parameters = _cmf_core.ShuttleworthWallace_set_RSS_parameters
ShuttleworthWallace_use_for_cell = _cmf_core.ShuttleworthWallace_use_for_cell

class SW_transpiration(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace transpiration.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_transpiration self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_transpiration
        SW_transpiration(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)

        """
        _cmf_core.SW_transpiration_swiginit(self, _cmf_core.new_SW_transpiration(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_transpiration

# Register SW_transpiration in _cmf_core:
_cmf_core.SW_transpiration_swigregister(SW_transpiration)

class SW_evap_from_layer(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace ground evaporation.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_evap_from_layer self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_evap_from_layer
        SW_evap_from_layer(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)

        """
        _cmf_core.SW_evap_from_layer_swiginit(self, _cmf_core.new_SW_evap_from_layer(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_evap_from_layer

# Register SW_evap_from_layer in _cmf_core:
_cmf_core.SW_evap_from_layer_swigregister(SW_evap_from_layer)

class SW_evap_from_canopy(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace canopy interception evaporation.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_evap_from_canopy self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_evap_from_canopy
        SW_evap_from_canopy(cmf::water::WaterStorage::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)

        """
        _cmf_core.SW_evap_from_canopy_swiginit(self, _cmf_core.new_SW_evap_from_canopy(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_evap_from_canopy

# Register SW_evap_from_canopy in _cmf_core:
_cmf_core.SW_evap_from_canopy_swigregister(SW_evap_from_canopy)

class SW_evap_from_snow(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace canopy interception evaporation.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_evap_from_snow self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_evap_from_snow
        SW_evap_from_snow(cmf::water::WaterStorage::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)

        """
        _cmf_core.SW_evap_from_snow_swiginit(self, _cmf_core.new_SW_evap_from_snow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_evap_from_snow

# Register SW_evap_from_snow in _cmf_core:
_cmf_core.SW_evap_from_snow_swigregister(SW_evap_from_snow)

class SW_evap_from_surfacewater(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace canopy interception evaporation.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_evap_from_surfacewater self, cmf::river::OpenWaterStorage::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_evap_from_surfacewater
        SW_evap_from_surfacewater(cmf::river::OpenWaterStorage::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)

        """
        _cmf_core.SW_evap_from_surfacewater_swiginit(self, _cmf_core.new_SW_evap_from_surfacewater(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_evap_from_surfacewater

# Register SW_evap_from_surfacewater in _cmf_core:
_cmf_core.SW_evap_from_surfacewater_swigregister(SW_evap_from_surfacewater)


class project_list_wrapper:
    def __init__(self,getitem,getlen,name):
        self.__get = getitem
        self.__len = getlen
        self.name = name
    def __len__(self):
        return int(self.__len())
    def __getitem__(self,index):
        if (type(index)==slice):
             return [self.__get(i) for i in range(*index.indices(len(self)))]
        try:
             gen=iter(index)
             return [self.__get(it) for it in gen]
        except TypeError:
             return self.__get(index)
    def __iter__(self):
        for i in range(len(self)):
            yield self.__get(i)
    def __repr__(self):
        return '[%i %s of project]' % (len(self),self.name)


class project(StateVariableOwner):
    r"""


    The study area, holding all cells, outlets and streams.

    Todo Describe tracers

    C++ includes: project.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    remove_node = _swig_new_instance_method(_cmf_core.project_remove_node)
    solutes = property(_cmf_core.project_solutes_get, doc=r"""solutes : q(const).cmf::water::solute_vector""")
    meteo_stations = property(_cmf_core.project_meteo_stations_get, _cmf_core.project_meteo_stations_set, doc=r"""meteo_stations : cmf::atmosphere::MeteoStationList""")
    rainfall_stations = property(_cmf_core.project_rainfall_stations_get, _cmf_core.project_rainfall_stations_set, doc=r"""rainfall_stations : cmf::atmosphere::RainfallStationList""")
    use_IDW_meteo = _swig_new_instance_method(_cmf_core.project_use_IDW_meteo)
    use_nearest_meteo = _swig_new_instance_method(_cmf_core.project_use_nearest_meteo)
    use_IDW_rainfall = _swig_new_instance_method(_cmf_core.project_use_IDW_rainfall)
    use_nearest_rainfall = _swig_new_instance_method(_cmf_core.project_use_nearest_rainfall)
    get_cell = _swig_new_instance_method(_cmf_core.project_get_cell)
    size = _swig_new_instance_method(_cmf_core.project_size)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(project self, std::string solute_names="") -> project
        project(std::string
        solute_names="")

        Creates a new project.

        Parameters:
        -----------

        solute_names:  A string representing the names of the solutes to be
        used in the project. Sepereate solute names with space. 
        """
        _cmf_core.project_swiginit(self, _cmf_core.new_project(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_project
    NewCell = _swig_new_instance_method(_cmf_core.project_NewCell)
    NewOutlet = _swig_new_instance_method(_cmf_core.project_NewOutlet)
    NewStorage = _swig_new_instance_method(_cmf_core.project_NewStorage)
    NewOpenStorage = _swig_new_instance_method(_cmf_core.project_NewOpenStorage)
    NewNeumannBoundary = _swig_new_instance_method(_cmf_core.project_NewNeumannBoundary)
    NewReach = _swig_new_instance_method(_cmf_core.project_NewReach)
    get_reach = _swig_new_instance_method(_cmf_core.project_get_reach)
    reach_count = _swig_new_instance_method(_cmf_core.project_reach_count)
    get_node = _swig_new_instance_method(_cmf_core.project_get_node)
    node_count = _swig_new_instance_method(_cmf_core.project_node_count)
    get_storages = _swig_new_instance_method(_cmf_core.project_get_storages)
    cells = property(_cmf_core.project_cells_get, doc=r"""cells : cmf::upslope::cell_vector""")

    def __repr__(self):
        return "cmf.project(%i cells, %i meteo stations, %i project nodes)" % (len(self.cells),len(self.meteo_stations),len(self.nodes))
    def __len__(self):
        return self.size()
    def __getitem__(self,index):
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(self)))]
        else:
            return self.get_cell(index)        
    def __iter__(self):
        for i in range(self.size()):
            yield self.get_cell(i)
    @property
    def reaches(self):
        "Returns the reaches of the project"
        return project_list_wrapper(self.get_reach,self.reach_count,'reaches')
    @property
    def nodes(self):
        "Returns the nodes of the project"
        return project_list_wrapper(self.get_node,self.node_count,'nodes')


# Register project in _cmf_core:
_cmf_core.project_swigregister(project)

class Integrator(object):
    r"""


    Base class for any kind of integrator.

    Pure virtual functions: Integrate

    copy Please provide a custom copy constructor

    C++ includes: integrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __getitem__ = _swig_new_instance_method(_cmf_core.Integrator___getitem__)
    get_dxdt = _swig_new_instance_method(_cmf_core.Integrator_get_dxdt)
    add_states = _swig_new_instance_method(_cmf_core.Integrator_add_states)
    add_single_state = _swig_new_instance_method(_cmf_core.Integrator_add_single_state)
    integratables = property(_cmf_core.Integrator_integratables_get, _cmf_core.Integrator_integratables_set, doc=r"""integratables : cmf::math::integratable_list""")
    reset_integratables = property(_cmf_core.Integrator_reset_integratables_get, _cmf_core.Integrator_reset_integratables_set, doc=r"""reset_integratables : bool""")
    use_OpenMP = property(_cmf_core.Integrator_use_OpenMP_get, _cmf_core.Integrator_use_OpenMP_set, doc=r"""use_OpenMP : bool""")
    size = _swig_new_instance_method(_cmf_core.Integrator_size)
    get_state = _swig_new_instance_method(_cmf_core.Integrator_get_state)
    set_state = _swig_new_instance_method(_cmf_core.Integrator_set_state)
    get_states = _swig_new_instance_method(_cmf_core.Integrator_get_states)
    __swig_destroy__ = _cmf_core.delete_Integrator
    get_t = _swig_new_instance_method(_cmf_core.Integrator_get_t)
    set_t = _swig_new_instance_method(_cmf_core.Integrator_set_t)
    get_dt = _swig_new_instance_method(_cmf_core.Integrator_get_dt)
    reset = _swig_new_instance_method(_cmf_core.Integrator_reset)
    copy = _swig_new_instance_method(_cmf_core.Integrator_copy)
    integrate = _swig_new_instance_method(_cmf_core.Integrator_integrate)
    integrate_until = _swig_new_instance_method(_cmf_core.Integrator_integrate_until)

    def __repr__(self): 
        return self.to_string()

    __len__ = _swig_new_instance_method(_cmf_core.Integrator___len__)

    t = property(get_t,set_t,doc="Sets the actual time of the solution")
    dt = property(get_dt,doc="Get the current time step of the solver")
    def __call__(self, t, dt=None, reset=False):
        """
        Advances the integration until `t`

        A shortcut to .integrate_until

        Parameters
        ----------
        t : cmf.Time
            The time step to advance to. If t < current time, the solver will
            advance to self.t + t
        dt : cmf.Time, optional
            The timestep for the integration. If not given try to integrate in one step
        reset : bool, optional
            If True, the solver will perform a reset before starting

        Returns
        -------
        cmf.Time
            The new time stamp
        """
        if dt is None:
            dt = Time()
        if t < self.t:
            self.integrate_until(self.t+t, dt, reset=reset)
        else:
            self.integrate_until(t, dt, reset=reset)
        return self.t

    def run(self, start=None, end=None, step=day*1, max_errors=0, reset=False):
        """
        Returns an iterator over the timesteps start..end

        **Examples:**

        >>> solver=cmf.CVodeIntegrator(...)
        >>> for t in solver.run(solver.t, solver.t + cmf.week, cmf.h):
        >>>    print(t, solver[0].state)
        or with list comprehension
        >>> states = [solver[0].state for t in solver.run(solver.t, solver.t + cmf.week, cmf.h)]

        Parameters
        ----------
        start : cmf.Time, optional
                Start time for the solver iteration
        end : cmf.Time, optional
                End time of the iteration
        step : cmf.Time, optional
                Step size for the integration
        max_errors: int
                Number of tolerated errors. If >0, up to these number of runtime errors
                will be saved with their time and the integration proceeds after a reset
                of the solver. Some systems operate with values close to their physical
                limits and inifinite values in the integration can easily occur. For
                these kind of systems set max_errors to eg. 10. A larger number of errors
                should be eliminated usually.
        reset: bool
                If True, the solver performs a `reset` at every time step

        Yields
        ------
        cmf.Time
             the actual timestep
        """
        import logging
        if not start is None:
            self.t = start
        if end is None:
            end = self.t + 100*step
        errors = []
        t = self.t
        while self.t < end:
            try:
                t = self(self.t+step, reset=reset)
            except Exception as e:
                if len(errors) < max_errors:
                    errors.append((t, e))
                    self.reset()
                    logging.warning(str(t) + ': ' + str(e))
            yield t


# Register Integrator in _cmf_core:
_cmf_core.Integrator_swigregister(Integrator)

class BDF2(Integrator):
    r"""


    An order 2 BDF-Method with fixed-point iteration and variable step
    size.

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8 and

    Eckert S., Baaser H., Gross D. and Scherf O. (2004) "A BDF2
    integration method with step size control for elasto-plasticity",
    Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1

    Most important function: Integrate

    C++ includes: bdf2.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    get_error_position = _swig_new_instance_method(_cmf_core.BDF2_get_error_position)
    max_order = property(_cmf_core.BDF2_max_order_get, _cmf_core.BDF2_max_order_set, doc=r"""max_order : int""")

    def __init__(self, *args):
        r"""
        __init__(BDF2 self, real epsilon=1e-9, Time tStepMin=cmf::math::timespan(10)) -> BDF2
        __init__(BDF2 self, StateVariableOwner states, real epsilon=1e-9, Time tStepMin=cmf::math::timespan(10)) -> BDF2
        __init__(BDF2 self, Integrator templ) -> BDF2
        BDF2(const Integrator
        &templ)

        Constructs a new BDF2 integrator.

        Parameters:
        -----------

        templ:  Template to be used to construct a BDF2 method 
        """
        _cmf_core.BDF2_swiginit(self, _cmf_core.new_BDF2(*args))
    __swig_destroy__ = _cmf_core.delete_BDF2

# Register BDF2 in _cmf_core:
_cmf_core.BDF2_swigregister(BDF2)

class ExplicitEuler_fixed(Integrator):
    r"""


    An explicit Euler integrator, with a fixed time step.

    C++ includes: explicit_euler.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ExplicitEuler_fixed self, StateVariableOwner states) -> ExplicitEuler_fixed
        __init__(ExplicitEuler_fixed self) -> ExplicitEuler_fixed
        __init__(ExplicitEuler_fixed self, Integrator copy) -> ExplicitEuler_fixed
        ExplicitEuler_fixed(const Integrator &copy)

        copy constructor 
        """
        _cmf_core.ExplicitEuler_fixed_swiginit(self, _cmf_core.new_ExplicitEuler_fixed(*args))
    __swig_destroy__ = _cmf_core.delete_ExplicitEuler_fixed

# Register ExplicitEuler_fixed in _cmf_core:
_cmf_core.ExplicitEuler_fixed_swigregister(ExplicitEuler_fixed)

class HeunIntegrator(Integrator):
    r"""


    A simple predictor - corrector solver.

    Not tested and very experimentally :math:`y^{n+1} = y^n + \\alpha f(y^n + f(y^n)dt)dt + (1-\\alpha)f(y^n)dt`

    C++ includes: explicit_euler.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = property(_cmf_core.HeunIntegrator_alpha_get, _cmf_core.HeunIntegrator_alpha_set, doc=r"""alpha : real""")

    def __init__(self, *args):
        r"""
        __init__(HeunIntegrator self, StateVariableOwner states, real Alpha=0.5) -> HeunIntegrator
        __init__(HeunIntegrator self, real Alpha=0.5) -> HeunIntegrator
        __init__(HeunIntegrator self, Integrator copy) -> HeunIntegrator
        HeunIntegrator(const Integrator &copy)

        copy constructor 
        """
        _cmf_core.HeunIntegrator_swiginit(self, _cmf_core.new_HeunIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_HeunIntegrator

# Register HeunIntegrator in _cmf_core:
_cmf_core.HeunIntegrator_swigregister(HeunIntegrator)

class ImplicitEuler(Integrator):
    r"""


    An implicit (backward) Euler integrator using fixpoint iteration.

    C++ includes: implicit_euler.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    dt_min = property(_cmf_core.ImplicitEuler_dt_min_get, _cmf_core.ImplicitEuler_dt_min_set, doc=r"""dt_min : cmf::math::Time""")

    def __init__(self, *args):
        r"""
        __init__(ImplicitEuler self, StateVariableOwner states, real epsilon=1e-9, Time tStepMin=cmf::math::timespan(10)) -> ImplicitEuler
        __init__(ImplicitEuler self, real epsilon=1e-9, Time tStepMin=cmf::math::timespan(10)) -> ImplicitEuler
        __init__(ImplicitEuler self, Integrator arg2) -> ImplicitEuler
        ImplicitEuler(const Integrator &)

        copy constructor 
        """
        _cmf_core.ImplicitEuler_swiginit(self, _cmf_core.new_ImplicitEuler(*args))
    __swig_destroy__ = _cmf_core.delete_ImplicitEuler

# Register ImplicitEuler in _cmf_core:
_cmf_core.ImplicitEuler_swigregister(ImplicitEuler)

class RKFIntegrator(Integrator):
    r"""


    Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
    Fehlberg (RKF54) method.

    C++ includes: RKFintegrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RKFIntegrator self, StateVariableOwner states, real epsilon=1e-9, Time dt_min=cmf::math::timespan(1000)) -> RKFIntegrator
        __init__(RKFIntegrator self, real epsilon=1e-9, Time dt_min=cmf::math::timespan(1000)) -> RKFIntegrator
        RKFIntegrator(real epsilon=1e-9, cmf::math::Time
        dt_min=cmf::math::timespan(1000))

        Constructs a new RKFIntegrator.

        Parameters:
        -----------

        epsilon:  relative error tolerance per time step (default=1e-9)

        dt_min:  minimum time step (default=1s) 
        """
        _cmf_core.RKFIntegrator_swiginit(self, _cmf_core.new_RKFIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_RKFIntegrator

# Register RKFIntegrator in _cmf_core:
_cmf_core.RKFIntegrator_swigregister(RKFIntegrator)

class CVodeIntegrator(Integrator):
    r"""


    A wrapper class for the CVODE integrator from the SUNDIALS library.

    https://computation.llnl.gov/casc/sundials/main.html

    C++ includes: cvodeintegrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    preconditioner = property(_cmf_core.CVodeIntegrator_preconditioner_get, _cmf_core.CVodeIntegrator_preconditioner_set, doc=r"""preconditioner : char""")
    MaxNonLinearIterations = property(_cmf_core.CVodeIntegrator_MaxNonLinearIterations_get, _cmf_core.CVodeIntegrator_MaxNonLinearIterations_set, doc=r"""MaxNonLinearIterations : int""")
    MaxConvergenceFailures = property(_cmf_core.CVodeIntegrator_MaxConvergenceFailures_get, _cmf_core.CVodeIntegrator_MaxConvergenceFailures_set, doc=r"""MaxConvergenceFailures : int""")
    MaxErrorTestFailures = property(_cmf_core.CVodeIntegrator_MaxErrorTestFailures_get, _cmf_core.CVodeIntegrator_MaxErrorTestFailures_set, doc=r"""MaxErrorTestFailures : int""")
    maxl = property(_cmf_core.CVodeIntegrator_maxl_get, _cmf_core.CVodeIntegrator_maxl_set, doc=r"""maxl : int""")
    LinearSolver = property(_cmf_core.CVodeIntegrator_LinearSolver_get, _cmf_core.CVodeIntegrator_LinearSolver_set, doc=r"""LinearSolver : int""")
    MaxOrder = property(_cmf_core.CVodeIntegrator_MaxOrder_get, _cmf_core.CVodeIntegrator_MaxOrder_set, doc=r"""MaxOrder : int""")
    max_step = property(_cmf_core.CVodeIntegrator_max_step_get, _cmf_core.CVodeIntegrator_max_step_set, doc=r"""max_step : cmf::math::Time""")
    get_order = _swig_new_instance_method(_cmf_core.CVodeIntegrator_get_order)
    initialize = _swig_new_instance_method(_cmf_core.CVodeIntegrator_initialize)
    release = _swig_new_instance_method(_cmf_core.CVodeIntegrator_release)

    def __init__(self, *args):
        r"""
        __init__(CVodeIntegrator self, real epsilon=1e-9, char _preconditioner='R') -> CVodeIntegrator
        __init__(CVodeIntegrator self, StateVariableOwner states, real epsilon=1e-9, char _preconditioner='R') -> CVodeIntegrator
        __init__(CVodeIntegrator self, CVodeIntegrator templ) -> CVodeIntegrator
        CVodeIntegrator(const CVodeIntegrator &templ)

        copy constructor, creates a new CVODE integrator similiar to the
        given, but without statevariables 
        """
        _cmf_core.CVodeIntegrator_swiginit(self, _cmf_core.new_CVodeIntegrator(*args))
    get_error = _swig_new_instance_method(_cmf_core.CVodeIntegrator_get_error)
    get_nonlinear_iterations = _swig_new_instance_method(_cmf_core.CVodeIntegrator_get_nonlinear_iterations)
    get_rhsevals = _swig_new_instance_method(_cmf_core.CVodeIntegrator_get_rhsevals)
    copy = _swig_new_instance_method(_cmf_core.CVodeIntegrator_copy)
    __swig_destroy__ = _cmf_core.delete_CVodeIntegrator

# Register CVodeIntegrator in _cmf_core:
_cmf_core.CVodeIntegrator_swigregister(CVodeIntegrator)

class MultiIntegrator(Integrator):
    r"""


    The MultiIntegrator is a wrapper for a bunch integrators. The states
    of the integrators should not have direct connections over integrator
    boundaries.

    C++ includes: multiintegrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    copy = _swig_new_instance_method(_cmf_core.MultiIntegrator_copy)
    add_states_to_integrator = _swig_new_instance_method(_cmf_core.MultiIntegrator_add_states_to_integrator)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(MultiIntegrator self, Integrator template_integrator, int count) -> MultiIntegrator
        MultiIntegrator(const cmf::math::Integrator &template_integrator, int
        count)

        Creates a new MultiIntegrator.

        Parameters:
        -----------

        template_integrator:  Template for the integrators

        count:  Number of integrators 
        """
        _cmf_core.MultiIntegrator_swiginit(self, _cmf_core.new_MultiIntegrator(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_MultiIntegrator

# Register MultiIntegrator in _cmf_core:
_cmf_core.MultiIntegrator_swigregister(MultiIntegrator)

class SoluteWaterIntegrator(Integrator):
    r"""


    A SoluteWaterIntegrator implements the cmf::math::Integrator
    interface, but consists of two independent ODE-solvers.

    Added statevariables are sorted by waterstorages and solute storages
    and assigned to the correct solver.

    C++ includes: WaterSoluteIntegrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    copy = _swig_new_instance_method(_cmf_core.SoluteWaterIntegrator_copy)

    def __init__(self, *args):
        r"""
        __init__(SoluteWaterIntegrator self, solute_vector solutes, Integrator water_integrator, Integrator solute_integrator) -> SoluteWaterIntegrator
        __init__(SoluteWaterIntegrator self, solute_vector solutes, Integrator water_integrator, Integrator solute_integrator, StateVariableOwner states) -> SoluteWaterIntegrator
        SoluteWaterIntegrator(cmf::water::solute_vector solutes, const
        cmf::math::Integrator &water_integrator, const cmf::math::Integrator
        &solute_integrator, cmf::math::StateVariableOwner &states)

        Creates a new SoluteWaterIntegrator.

        Parameters:
        -----------

        solutes:  Solutes of the project

        water_integrator:  Template for the integrator of WaterStorage state
        variables

        solute_integrator:  Template for the integrator of soluteStorage state
        variables

        states:  States to be added to the integrators 
        """
        _cmf_core.SoluteWaterIntegrator_swiginit(self, _cmf_core.new_SoluteWaterIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_SoluteWaterIntegrator
    to_string = _swig_new_instance_method(_cmf_core.SoluteWaterIntegrator_to_string)

# Register SoluteWaterIntegrator in _cmf_core:
_cmf_core.SoluteWaterIntegrator_swigregister(SoluteWaterIntegrator)


ConstantFlux = TechnicalFlux
ConstantStateFlux = statecontrol_connection
WaterBalanceFlux = waterbalance_connection
ConceptualInfiltration = SimpleInfiltration



