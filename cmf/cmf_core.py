# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _cmf_core
else:
    import _cmf_core

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _cmf_core.SWIG_PyInstanceMethod_New
_swig_new_static_method = _cmf_core.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_SwigPyIterator
    value = _swig_new_instance_method(_cmf_core.SwigPyIterator_value)
    incr = _swig_new_instance_method(_cmf_core.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_cmf_core.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_cmf_core.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_cmf_core.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_cmf_core.SwigPyIterator_copy)
    next = _swig_new_instance_method(_cmf_core.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_cmf_core.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_cmf_core.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_cmf_core.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _cmf_core:
_cmf_core.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _cmf_core.SHARED_PTR_DISOWN

get_parallel_threads = _cmf_core.get_parallel_threads
set_parallel_threads = _cmf_core.set_parallel_threads
class cubicspline(object):
    r"""


    Interpolates points with a cubic spline interpolation.

    Code is modified
    after:http://ganeshtiwaridotcomdotnp.blogspot.de/2009/12/c-c-code-
    cubic- spline-interpolation.html

    C++ includes: spline.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(cubicspline self, cmf::math::num_array const & x, cmf::math::num_array const & y) -> cubicspline
        cubicspline(const cmf::math::num_array &x, const cmf::math::num_array
        &y) cmf::math::cubicspline::cubicspline
        """
        _cmf_core.cubicspline_swiginit(self, _cmf_core.new_cubicspline(*args, **kwargs))
    generate = _swig_new_instance_method(_cmf_core.cubicspline_generate)
    size = _swig_new_instance_method(_cmf_core.cubicspline_size)
    __call__ = _swig_new_instance_method(_cmf_core.cubicspline___call__)
    __swig_destroy__ = _cmf_core.delete_cubicspline

# Register cubicspline in _cmf_core:
_cmf_core.cubicspline_swigregister(cubicspline)
class point(object):
    r"""


    2D-Point Class.

    Used as location property anywhere in the text Calculation of
    distances

    +,-,-=,*= Operators overloaded

    C++ includes: geometry.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_cmf_core.point_x_get, _cmf_core.point_x_set, doc=r"""x : double""")
    y = property(_cmf_core.point_y_get, _cmf_core.point_y_set, doc=r"""y : double""")
    z = property(_cmf_core.point_z_get, _cmf_core.point_z_set, doc=r"""z : double""")

    def __init__(self, *args):
        r"""
        __init__(point self) -> point
        __init__(point self, point p) -> point
        __init__(point self, double x_, double y_, double z_=0.0) -> point
        point(double x_,
        double y_, double z_=0.0) cmf::geometry::point::point Creates a point
        from two doubles. 
        """
        _cmf_core.point_swiginit(self, _cmf_core.new_point(*args))
    distanceTo = _swig_new_instance_method(_cmf_core.point_distanceTo)
    z_weight_distance = _swig_new_instance_method(_cmf_core.point_z_weight_distance)
    distance3DTo = _swig_new_instance_method(_cmf_core.point_distance3DTo)
    distance = _swig_new_static_method(_cmf_core.point_distance)
    distance_max = _swig_new_instance_method(_cmf_core.point_distance_max)
    azimuth = _swig_new_instance_method(_cmf_core.point_azimuth)
    angleToXAxis = _swig_new_instance_method(_cmf_core.point_angleToXAxis)
    sum = _swig_new_instance_method(_cmf_core.point_sum)
    length = _swig_new_instance_method(_cmf_core.point_length)
    __add__ = _swig_new_instance_method(_cmf_core.point___add__)
    __iadd__ = _swig_new_instance_method(_cmf_core.point___iadd__)
    __sub__ = _swig_new_instance_method(_cmf_core.point___sub__)
    __isub__ = _swig_new_instance_method(_cmf_core.point___isub__)
    __mul__ = _swig_new_instance_method(_cmf_core.point___mul__)
    __imul__ = _swig_new_instance_method(_cmf_core.point___imul__)

    def __truediv__(self, *args):
        return _cmf_core.point___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv__(self, *args):
        return _cmf_core.point___itruediv__(self, *args)
    __idiv__ = __itruediv__


    __eq__ = _swig_new_instance_method(_cmf_core.point___eq__)
    __ne__ = _swig_new_instance_method(_cmf_core.point___ne__)
    __len__ = _swig_new_instance_method(_cmf_core.point___len__)
    __rmul__ = _swig_new_instance_method(_cmf_core.point___rmul__)
    __rdiv__ = _swig_new_instance_method(_cmf_core.point___rdiv__)

    def __getitem__(self,index) :
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(self)))]
        if index==0 :
            return self.x
        elif index==1 :
            return self.y
        elif index==2 :
            return self.z
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __setitem__(self,index,value) :
        if index==0 :
            self.x=value
        elif index==1 :
            self.y=value
        elif index==2 :
            self.z=value
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z
    def __repr__(self):
        return 'cmf.point(%g,%g,%g)' % (self.x,self.y,self.z)

    __swig_destroy__ = _cmf_core.delete_point

# Register point in _cmf_core:
_cmf_core.point_swigregister(point)
cvar = _cmf_core.cvar
PI = cvar.PI

dot = _cmf_core.dot
distance = _cmf_core.distance
class point_vector(object):
    r"""


    Holds three arrays x,y and z for fast access of point coordinates.

    C++ includes: geometry.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    X = property(_cmf_core.point_vector_X_get, _cmf_core.point_vector_X_set, doc=r"""X : cmf::math::num_array""")
    Y = property(_cmf_core.point_vector_Y_get, _cmf_core.point_vector_Y_set, doc=r"""Y : cmf::math::num_array""")
    Z = property(_cmf_core.point_vector_Z_get, _cmf_core.point_vector_Z_set, doc=r"""Z : cmf::math::num_array""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(point_vector self, ptrdiff_t size) -> point_vector
        point_vector(ptrdiff_t size) cmf::geometry::point_vector::point_vector
        Create a point vector of a specific size. 
        """
        _cmf_core.point_vector_swiginit(self, _cmf_core.new_point_vector(*args, **kwargs))
    get = _swig_new_instance_method(_cmf_core.point_vector_get)
    set = _swig_new_instance_method(_cmf_core.point_vector_set)
    size = _swig_new_instance_method(_cmf_core.point_vector_size)
    __swig_destroy__ = _cmf_core.delete_point_vector

# Register point_vector in _cmf_core:
_cmf_core.point_vector_swigregister(point_vector)

import datetime


minimum = _cmf_core.minimum
maximum = _cmf_core.maximum
minmax = _cmf_core.minmax
mean = _cmf_core.mean
geo_mean = _cmf_core.geo_mean
harmonic_mean = _cmf_core.harmonic_mean
piecewise_linear = _cmf_core.piecewise_linear
boltzmann = _cmf_core.boltzmann
sign = _cmf_core.sign
square = _cmf_core.square
JULIANDAY_0_1_1900 = _cmf_core.JULIANDAY_0_1_1900

class Time(object):
    r"""


    A time class, used to pass around current modelling times.

    Timespans and dates in cmf are used with a special object, called
    Time. An extra class has the advantage, that the user does not have to
    remember, which unit of time he or she uses or what time unit is
    accepted by a specific function of the model. Arithmetic and boolean
    operators are supported by Time. Internally the time classes stores
    the time as integer milliseconds, therefore rounding issues will only
    appear at very small time ranges. Absolute time (like dates) are
    represented as milliseconds gone by from Dec, 31st 1899. Microsoft
    Excel dates are represented as days from that time, using floating
    point numbers, therefore it is very simple to convert Excel time
    representations to cmf time.

    Another object is Date, which is doesn't provide the operators, but
    has a nice printed version and some special date functions, like day
    of year (DOY) and provides access to the current hour of day and so
    on, which only applyto dates and not to time spans. You can convert
    Time to Date an vice versa. The printing is not culture aware and uses
    the European representation. If you use the Python standard library
    datetime, conversion between Python time and cmf time is possible

    Creating absolute time values (dates) Creating time spans

    In principle, there are three ways to create time spans. One is to use
    one of the static functions, another is to multiply an existing time
    span (like one of the build in constants) or to substrate two absolute
    times.

    Available constants  : 4.1 seconds

    : 2.3 hours (138 min)

    : 2.3 hours (138 min)

    : 60 hours (2.5 days)

    : 7 days

    : 365/12 days (30.4167 days)

    : 365 days

    Available operators:

    time + time = time, time - time = time

    time * float = time ,time / float = time

    time/time=float

    >, <, ==, !=

    Conversions

    Converting to python datetime

    Converting to numbers

    t.AsMilliseconds()

    t.AsSeconds()

    t.AsMinutes()

    t.AsHours()

    t.AsDays()

    t.AsYears()

    Creating time ranges

    C++ includes: time.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ms_per_day = _cmf_core.Time_ms_per_day
    

    def __init__(self, *args):
        r"""
        __init__(Time self, int day, int month, int year, int hour=0, int minute=0, int second=0, int ms=0) -> Time
        __init__(Time self, Date date) -> Time
        __init__(Time self, Time t) -> Time
        __init__(Time self) -> Time
        __init__(Time self, long long milliseconds) -> Time
        Time(long long
        milliseconds) cmf::math::Time::Time
        """
        _cmf_core.Time_swiginit(self, _cmf_core.new_Time(*args))
    AsDays = _swig_new_instance_method(_cmf_core.Time_AsDays)
    AsHours = _swig_new_instance_method(_cmf_core.Time_AsHours)
    AsMinutes = _swig_new_instance_method(_cmf_core.Time_AsMinutes)
    AsSeconds = _swig_new_instance_method(_cmf_core.Time_AsSeconds)
    AsMilliseconds = _swig_new_instance_method(_cmf_core.Time_AsMilliseconds)
    AsDate = _swig_new_instance_method(_cmf_core.Time_AsDate)
    to_string = _swig_new_instance_method(_cmf_core.Time_to_string)
    is_not_0 = _swig_new_instance_method(_cmf_core.Time_is_not_0)
    DOY = _swig_new_instance_method(_cmf_core.Time_DOY)
    __add__ = _swig_new_instance_method(_cmf_core.Time___add__)
    __sub__ = _swig_new_instance_method(_cmf_core.Time___sub__)
    __iadd__ = _swig_new_instance_method(_cmf_core.Time___iadd__)
    __isub__ = _swig_new_instance_method(_cmf_core.Time___isub__)
    __mod__ = _swig_new_instance_method(_cmf_core.Time___mod__)
    __mul__ = _swig_new_instance_method(_cmf_core.Time___mul__)
    __imul__ = _swig_new_instance_method(_cmf_core.Time___imul__)

    def __itruediv__(self, *args):
        return _cmf_core.Time___itruediv__(self, *args)
    __idiv__ = __itruediv__


    __imod__ = _swig_new_instance_method(_cmf_core.Time___imod__)

    def __truediv__(self, *args):
        return _cmf_core.Time___truediv__(self, *args)
    __div__ = __truediv__


    times_in = _swig_new_instance_method(_cmf_core.Time_times_in)
    __lt__ = _swig_new_instance_method(_cmf_core.Time___lt__)
    __gt__ = _swig_new_instance_method(_cmf_core.Time___gt__)
    __le__ = _swig_new_instance_method(_cmf_core.Time___le__)
    __ge__ = _swig_new_instance_method(_cmf_core.Time___ge__)
    __eq__ = _swig_new_instance_method(_cmf_core.Time___eq__)
    __ne__ = _swig_new_instance_method(_cmf_core.Time___ne__)

    def __repr__(self):
        if self>year*40:
            return self.AsDate().to_string()
        else:
            return self.to_string()

    def __nonzero__(self):
        return self.is_not_0()

    def __rmul__(self,other):
        return self*other

    def __radd__(self,other):
        return self + other

    def __getstate__(self):
        return self.AsMilliseconds()

    def __setstate__(self, data):
        self.__init__(data)

    def as_datetime(self):
        d=self.AsDate()
        return datetime.datetime(d.year,d.month,d.day,d.hour,d.minute,d.second,d.ms*1000)

    def as_timedelta(self):
        return datetime.timedelta(milliseconds=self.AsMilliseconds())

    year   = property(lambda self: self.AsDate().year)
    month  = property(lambda self: self.AsDate().month)
    day    = property(lambda self: self.AsDate().day)
    hour   = property(lambda self: self.AsDate().hour)
    minute = property(lambda self: self.AsDate().minute)
    second = property(lambda self: self.AsDate().second)
    ms     = property(lambda self: self.AsDate().ms)

    def __format__(self, fmt):
        return self.as_datetime().__format__(fmt)

    __swig_destroy__ = _cmf_core.delete_Time

# Register Time in _cmf_core:
_cmf_core.Time_swigregister(Time)
Pi = cvar.Pi

class Date(object):
    r"""


    An absolute time, not for calculation. Date and Time are
    interchangable.

    C++ includes: time.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    year = property(_cmf_core.Date_year_get, _cmf_core.Date_year_set, doc=r"""year : int""")
    month = property(_cmf_core.Date_month_get, _cmf_core.Date_month_set, doc=r"""month : int""")
    day = property(_cmf_core.Date_day_get, _cmf_core.Date_day_set, doc=r"""day : int""")
    hour = property(_cmf_core.Date_hour_get, _cmf_core.Date_hour_set, doc=r"""hour : int""")
    minute = property(_cmf_core.Date_minute_get, _cmf_core.Date_minute_set, doc=r"""minute : int""")
    second = property(_cmf_core.Date_second_get, _cmf_core.Date_second_set, doc=r"""second : int""")
    ms = property(_cmf_core.Date_ms_get, _cmf_core.Date_ms_set, doc=r"""ms : int""")

    def __init__(self, *args):
        r"""
        __init__(Date self, int _day, int _month, int _year, int _hour=0, int _minute=0, int _second=0, int _ms=0) -> Date
        __init__(Date self, Time time) -> Date
        Date(int _day, int
        _month, int _year, int _hour=0, int _minute=0, int _second=0, int
        _ms=0) cmf::math::Date::Date Creates a new date. 
        """
        _cmf_core.Date_swiginit(self, _cmf_core.new_Date(*args))
    ToTime = _swig_new_instance_method(_cmf_core.Date_ToTime)
    DOY = _swig_new_instance_method(_cmf_core.Date_DOY)
    to_string = _swig_new_instance_method(_cmf_core.Date_to_string)

    def __repr__(self):
        return self.to_string()

    def __getstate__(self):
        return Date.ToTime().__getstate__()

    def __setstate__(self, data):
        t = Time(data)
        self.__init__(t)

    def as_datetime(self):
        return datetime.datetime(self.year,self.month,self.day,self.hour,self.minute,self.second,self.ms*1000)

    def __format__(self, fmt):
        return self.as_datetime().__format__(fmt)

    __swig_destroy__ = _cmf_core.delete_Date

# Register Date in _cmf_core:
_cmf_core.Date_swigregister(Date)
class timeseries(object):
    r"""


    A timeseries is a list of values, equally distributed over time.

    To create one, one have to provide as start date and a step size. The
    end time is calculated from the number of values. Values queried for
    times before the start time are returned as the first item, values
    after the end time equal the last item. A timeseries with only one
    item reacts like a scalar value.

    Creating a time series

    With this technique it is simple to read files or databases to fill
    timeseries.<b> Using a timeseries</b>

    C++ includes: timeseries.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    set_begin = _swig_new_instance_method(_cmf_core.timeseries_set_begin)
    set_step = _swig_new_instance_method(_cmf_core.timeseries_set_step)
    interpolationpower = _swig_new_instance_method(_cmf_core.timeseries_interpolationpower)
    set_interpolationpower = _swig_new_instance_method(_cmf_core.timeseries_set_interpolationpower)
    add = _swig_new_instance_method(_cmf_core.timeseries_add)
    is_empty = _swig_new_instance_method(_cmf_core.timeseries_is_empty)
    clear = _swig_new_instance_method(_cmf_core.timeseries_clear)
    adress = _swig_new_instance_method(_cmf_core.timeseries_adress)
    as_array = _swig_new_instance_method(_cmf_core.timeseries_as_array)
    copy = _swig_new_instance_method(_cmf_core.timeseries_copy)
    size = _swig_new_instance_method(_cmf_core.timeseries_size)
    count_values = _swig_new_instance_method(_cmf_core.timeseries_count_values)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(timeseries self, Time begin=cmf::math::Time(), Time step=day, int interpolationmethod=1, size_t count=0) -> timeseries
        timeseries(const cmf::math::timeseries &ts)
        cmf::math::timeseries::timeseries
        """
        _cmf_core.timeseries_swiginit(self, _cmf_core.new_timeseries(*args, **kwargs))
    from_array = _swig_new_static_method(_cmf_core.timeseries_from_array)
    from_scalar = _swig_new_static_method(_cmf_core.timeseries_from_scalar)
    from_file = _swig_new_static_method(_cmf_core.timeseries_from_file)
    get_t = _swig_new_instance_method(_cmf_core.timeseries_get_t)
    get_i = _swig_new_instance_method(_cmf_core.timeseries_get_i)
    set_t = _swig_new_instance_method(_cmf_core.timeseries_set_t)
    set_i = _swig_new_instance_method(_cmf_core.timeseries_set_i)
    get_slice = _swig_new_instance_method(_cmf_core.timeseries_get_slice)
    set_slice = _swig_new_instance_method(_cmf_core.timeseries_set_slice)
    remove_nodata = _swig_new_instance_method(_cmf_core.timeseries_remove_nodata)
    __iadd__ = _swig_new_instance_method(_cmf_core.timeseries___iadd__)
    __isub__ = _swig_new_instance_method(_cmf_core.timeseries___isub__)
    __imul__ = _swig_new_instance_method(_cmf_core.timeseries___imul__)

    def __itruediv__(self, *args):
        return _cmf_core.timeseries___itruediv__(self, *args)
    __idiv__ = __itruediv__


    __add__ = _swig_new_instance_method(_cmf_core.timeseries___add__)
    __sub__ = _swig_new_instance_method(_cmf_core.timeseries___sub__)
    __mul__ = _swig_new_instance_method(_cmf_core.timeseries___mul__)

    def __truediv__(self, *args):
        return _cmf_core.timeseries___truediv__(self, *args)
    __div__ = __truediv__


    __neg__ = _swig_new_instance_method(_cmf_core.timeseries___neg__)
    inv = _swig_new_instance_method(_cmf_core.timeseries_inv)
    reduce_min = _swig_new_instance_method(_cmf_core.timeseries_reduce_min)
    reduce_max = _swig_new_instance_method(_cmf_core.timeseries_reduce_max)
    reduce_sum = _swig_new_instance_method(_cmf_core.timeseries_reduce_sum)
    reduce_avg = _swig_new_instance_method(_cmf_core.timeseries_reduce_avg)
    floating_avg = _swig_new_instance_method(_cmf_core.timeseries_floating_avg)
    floating_max = _swig_new_instance_method(_cmf_core.timeseries_floating_max)
    floating_min = _swig_new_instance_method(_cmf_core.timeseries_floating_min)
    mean = _swig_new_instance_method(_cmf_core.timeseries_mean)
    min = _swig_new_instance_method(_cmf_core.timeseries_min)
    max = _swig_new_instance_method(_cmf_core.timeseries_max)
    log = _swig_new_instance_method(_cmf_core.timeseries_log)
    log10 = _swig_new_instance_method(_cmf_core.timeseries_log10)
    power = _swig_new_instance_method(_cmf_core.timeseries_power)
    exp = _swig_new_instance_method(_cmf_core.timeseries_exp)
    begin = property(_cmf_core.timeseries_begin_get, doc=r"""
    begin : cmf::math::Time
    cmf::math::Time
    begin() const cmf::math::timeseries::begin First date of measurement.

    """)
    step = property(_cmf_core.timeseries_step_get, doc=r"""
    step : cmf::math::Time
    cmf::math::Time
    step() const cmf::math::timeseries::step  Time between the
    measurements. 
    """)
    end = property(_cmf_core.timeseries_end_get, doc=r"""
    end : cmf::math::Time
    cmf::math::Time
    end() const cmf::math::timeseries::end Last date of measurements. 
    """)
    __len__ = _swig_new_instance_method(_cmf_core.timeseries___len__)

    def __repr__(self):
       return "cmf.timeseries(%s:%s:%s,count=%i)" % (self.begin,self.end,self.step,self.size())

    def extend(self,list) :
        """ Adds the values of a sequence to the timeseries"""
        for item in list :
            self.add(float(item))

    def __getitem__(self,index):
        if isinstance(index,int):
            return self.get_i(index)
        elif isinstance(index,slice):
            if index.step:
                return self.get_slice(index.start,index.stop,index.step)
            else:
                return self.get_slice(index.start,index.stop)
        else:
            return self.get_t(index)

    def __setitem__(self,index,value):
        if isinstance(index,int):
            self.set_i(index,value)
        elif isinstance(index,slice):
            if index.step:
                raise ValueError("Slices must be continous, when used for setting")
            else:
                if not isinstance(value,timeseries):
                    value=timeseries(value)
                self.set_slice(index.start,index.stop,value)
        else:
            self.set_t(index,value)

    def __iter__(self):
        for i in range(self.size()):
            yield self.get_i(i)

    def __radd__(self,other):
        return self + other

    def __rmul__(self,other):
        return self + other

    def __rsub__(self,other):
        res=-self
        res+=other
        return res

    def __rdiv__(self,other):
        res=self.inv() 
        res*=other
        return res


    __swig_destroy__ = _cmf_core.delete_timeseries

# Register timeseries in _cmf_core:
_cmf_core.timeseries_swigregister(timeseries)
ms = cvar.ms
sec = cvar.sec
min = cvar.min
h = cvar.h
day = cvar.day
week = cvar.week
year = cvar.year
month = cvar.month
never = cvar.never

nash_sutcliffe = _cmf_core.nash_sutcliffe
class StateVariable(object):
    r"""


    Abstract class state variable.

    Simple exponential system class header implementing a state variable:
    @code    class RateGrowth    {    public:        real rate;
    virtual real Derivate(const cmf::math::Time& time) {return
    rate*get_state();}    };    @endcode

    C++ includes: statevariable.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    dxdt = _swig_new_instance_method(_cmf_core.StateVariable_dxdt)
    get_abs_errtol = _swig_new_instance_method(_cmf_core.StateVariable_get_abs_errtol)
    to_string = _swig_new_instance_method(_cmf_core.StateVariable_to_string)
    __swig_destroy__ = _cmf_core.delete_StateVariable
    is_connected = _swig_new_instance_method(_cmf_core.StateVariable_is_connected)
    state = property(_cmf_core.StateVariable_state_get, _cmf_core.StateVariable_state_set, doc=r"""state : real""")

    def __repr__(self):
        return self.to_string()


# Register StateVariable in _cmf_core:
_cmf_core.StateVariable_swigregister(StateVariable)
class state_list(object):
    r"""Proxy of C++ cmf::math::state_list class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(state_list self) -> state_list
        __init__(state_list self, state_list other) -> state_list
        state_list(const state_list &other)
        cmf::math::state_list::state_list
        """
        _cmf_core.state_list_swiginit(self, _cmf_core.new_state_list(*args))
    append = _swig_new_instance_method(_cmf_core.state_list_append)
    extend = _swig_new_instance_method(_cmf_core.state_list_extend)
    size = _swig_new_instance_method(_cmf_core.state_list_size)

    def __nonzero__(self):
        return _cmf_core.state_list___nonzero__(self)
    __bool__ = __nonzero__


    __iadd__ = _swig_new_instance_method(_cmf_core.state_list___iadd__)
    __getitem = _swig_new_instance_method(_cmf_core.state_list___getitem)
    __len__ = _swig_new_instance_method(_cmf_core.state_list___len__)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

    def __getitem__(self, index):

        if isinstance(index,slice):
            res = type(self)()
            for i in range(*index.indices(len(self))):
                res.append(self.__getitem(i))
            return res
        else:
            try:
                it=iter(index)
                res = type(self)()
                for o in it:
                    res.append(self.__getitem(o))
                return res
            except:
                return self.__getitem(index)


    __swig_destroy__ = _cmf_core.delete_state_list

# Register state_list in _cmf_core:
_cmf_core.state_list_swigregister(state_list)
__add__ = _cmf_core.__add__
class Adsorption(object):
    r"""


    Abstract class to use adsorption process for tracers on surfaces.

    Use the derived classes to use a certain isotherm

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    freesolute = _swig_new_instance_method(_cmf_core.Adsorption_freesolute)
    totalsolute = _swig_new_instance_method(_cmf_core.Adsorption_totalsolute)
    copy = _swig_new_instance_method(_cmf_core.Adsorption_copy)
    __swig_destroy__ = _cmf_core.delete_Adsorption

# Register Adsorption in _cmf_core:
_cmf_core.Adsorption_swigregister(Adsorption)
class NullAdsorption(Adsorption):
    r"""


    A class for tracers without interaction with the storage container.
    freesolute returns xt.

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    copy = _swig_new_instance_method(_cmf_core.NullAdsorption_copy)
    __swig_destroy__ = _cmf_core.delete_NullAdsorption

    def __init__(self, *args, **kwargs):
        r"""__init__(NullAdsorption self) -> NullAdsorption"""
        _cmf_core.NullAdsorption_swiginit(self, _cmf_core.new_NullAdsorption(*args, **kwargs))

# Register NullAdsorption in _cmf_core:
_cmf_core.NullAdsorption_swigregister(NullAdsorption)
class LinearAdsorption(Adsorption):
    r"""


    This class calculates the adsorption equilibrium between sorbat and
    sorbent using the linear (Henry) isotherme.

    Linear (Henry) isotherme:



    .. math::

        \\frac{x_{ad}}{m} = K c

    where  :math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}` is the total tracer
    mass

    :math:`x_{free}` is the dissolved tracer mass

    :math:`m` is the mass of the sorbent in the same unit as the tracer mass

    :math:`K` is the Henry sorption coefficient

    :math:`c = \\frac{x_{free}}{V}` is the concentration of the tracer in
    tracer mass per m3

    CMF stores in a solute storage the total mass of a tracer and needs to
    calculate the free tracer mass. Calculating :math:`x_{free}` from :math:`x_{tot}`
    gives from the eq. above: 

    .. math::

        x_{free} = x_{tot} \\frac{V}{K m +
        V}

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    K = property(_cmf_core.LinearAdsorption_K_get, _cmf_core.LinearAdsorption_K_set, doc=r"""K : real""")
    m = property(_cmf_core.LinearAdsorption_m_get, _cmf_core.LinearAdsorption_m_set, doc=r"""m : real""")

    def __init__(self, *args):
        r"""
        __init__(LinearAdsorption self, real K, real m) -> LinearAdsorption
        __init__(LinearAdsorption self, LinearAdsorption other) -> LinearAdsorption
        LinearAdsorption(real K, real m)
        cmf::water::LinearAdsorption::LinearAdsorption
        """
        _cmf_core.LinearAdsorption_swiginit(self, _cmf_core.new_LinearAdsorption(*args))
    copy = _swig_new_instance_method(_cmf_core.LinearAdsorption_copy)
    __swig_destroy__ = _cmf_core.delete_LinearAdsorption

# Register LinearAdsorption in _cmf_core:
_cmf_core.LinearAdsorption_swigregister(LinearAdsorption)
class LangmuirAdsorption(Adsorption):
    r"""


    This class calculates the adsorption equilibrium between sorbat and
    sorbent using the Langmuir isotherme.

    Langmuir Adsorption:



    .. math::

        \\frac{x_{ad}}{m} = q = \\frac{K c}{1 + K c}

    where
    :math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}`
    is the total tracer mass

    :math:`x_{free}` is the dissolved tracer mass

    :math:`m` is the mass of the sorbent in the same unit as the tracer mass

    :math:`K` is the Langmuir sorption coefficient

    :math:`c = \\frac{x_{free}}{V}` is the concentration of the tracer in
    tracer mass per m3

    CMF stores in a solute storage the total mass of a tracer and needs to
    calculate the free tracer mass. The analytical solution for :math:`x_{free}`
    from :math:`x_{tot}` is implemented in freesolute and derived usingsympy. If
    you really want to see it, look in the code.

    http://en.wikipedia.org/wiki/Langmuir_equation

    C++ includes: adsorption.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    K = property(_cmf_core.LangmuirAdsorption_K_get, _cmf_core.LangmuirAdsorption_K_set, doc=r"""K : real""")
    m = property(_cmf_core.LangmuirAdsorption_m_get, _cmf_core.LangmuirAdsorption_m_set, doc=r"""m : real""")

    def __init__(self, *args):
        r"""
        __init__(LangmuirAdsorption self, real K, real m) -> LangmuirAdsorption
        __init__(LangmuirAdsorption self, LangmuirAdsorption other) -> LangmuirAdsorption
        LangmuirAdsorption(real K, real m)
        cmf::water::LangmuirAdsorption::LangmuirAdsorption
        """
        _cmf_core.LangmuirAdsorption_swiginit(self, _cmf_core.new_LangmuirAdsorption(*args))
    copy = _swig_new_instance_method(_cmf_core.LangmuirAdsorption_copy)
    __swig_destroy__ = _cmf_core.delete_LangmuirAdsorption

# Register LangmuirAdsorption in _cmf_core:
_cmf_core.LangmuirAdsorption_swigregister(LangmuirAdsorption)
class solute(object):
    r"""


    A structure to identify a solute.

    C++ includes: Solute.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(solute self, solute copy) -> solute
        solute(const
        solute &copy) cmf::water::solute::solute
        """
        _cmf_core.solute_swiginit(self, _cmf_core.new_solute(*args, **kwargs))
    __eq__ = _swig_new_instance_method(_cmf_core.solute___eq__)
    __lt__ = _swig_new_instance_method(_cmf_core.solute___lt__)
    __gt__ = _swig_new_instance_method(_cmf_core.solute___gt__)
    __le__ = _swig_new_instance_method(_cmf_core.solute___le__)
    __ge__ = _swig_new_instance_method(_cmf_core.solute___ge__)
    __ne__ = _swig_new_instance_method(_cmf_core.solute___ne__)
    Name = property(_cmf_core.solute_Name_get, _cmf_core.solute_Name_set, doc=r"""Name : std::string""")
    Unit = property(_cmf_core.solute_Unit_get, _cmf_core.solute_Unit_set, doc=r"""Unit : std::string""")
    Uptake = property(_cmf_core.solute_Uptake_get, _cmf_core.solute_Uptake_set, doc=r"""Uptake : double""")
    Id = property(_cmf_core.solute_Id_get, doc=r"""Id : q(const).size_t""")
    __repr__ = _swig_new_instance_method(_cmf_core.solute___repr__)

    def __hash__(self):
        return hash((type(self), self.Id))

    __swig_destroy__ = _cmf_core.delete_solute

# Register solute in _cmf_core:
_cmf_core.solute_swigregister(solute)
class solute_vector(object):
    r"""


    Manages the solutes of the model.

    C++ includes: Solute.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size = _swig_new_instance_method(_cmf_core.solute_vector_size)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(solute_vector self, std::string str) -> solute_vector
        solute_vector(std::string str)
        cmf::water::solute_vector::solute_vector Creates a solute vector from
        solute names, separated by whitespace. E.g. solutes=
        solute_vector("dO18 dH2") 
        """
        _cmf_core.solute_vector_swiginit(self, _cmf_core.new_solute_vector(*args, **kwargs))
    get_solute = _swig_new_instance_method(_cmf_core.solute_vector_get_solute)
    find_by_name = _swig_new_instance_method(_cmf_core.solute_vector_find_by_name)
    __len__ = _swig_new_instance_method(_cmf_core.solute_vector___len__)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __repr__(self):
        return repr([s.Name for s in self])
    def __getitem__(self, index):

        if isinstance(index,slice):
            res = " ".join(
                    self.get_solute(i).Name
                    for i in range(*index.indices(len(self)))
            )
            return type(self)(res)
        else:
            try:
                it=iter(index)
                res = type(self)()
                for o in it:
                    res.append(self.get_solute(o))
                return res
            except:
                return self.get_solute(index)

    __swig_destroy__ = _cmf_core.delete_solute_vector

# Register solute_vector in _cmf_core:
_cmf_core.solute_vector_swigregister(solute_vector)
class SoluteTimeseries(object):
    r"""


    A map of concentration time series for solutes.

    C++ includes: Solute.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    conc = _swig_new_instance_method(_cmf_core.SoluteTimeseries_conc)
    size = _swig_new_instance_method(_cmf_core.SoluteTimeseries_size)

    def __init__(self, *args):
        r"""
        __init__(SoluteTimeseries self) -> SoluteTimeseries
        __init__(SoluteTimeseries self, solute_vector solutes, Time begin, Time step) -> SoluteTimeseries
        __init__(SoluteTimeseries self, SoluteTimeseries sts) -> SoluteTimeseries
        SoluteTimeseries(const solute_vector &solutes, cmf::math::Time
        begin, cmf::math::Time step)
        cmf::water::SoluteTimeseries::SoluteTimeseries
        """
        _cmf_core.SoluteTimeseries_swiginit(self, _cmf_core.new_SoluteTimeseries(*args))
    __getitem__ = _swig_new_instance_method(_cmf_core.SoluteTimeseries___getitem__)
    __setitem__ = _swig_new_instance_method(_cmf_core.SoluteTimeseries___setitem__)
    __len__ = _swig_new_instance_method(_cmf_core.SoluteTimeseries___len__)
    __swig_destroy__ = _cmf_core.delete_SoluteTimeseries

# Register SoluteTimeseries in _cmf_core:
_cmf_core.SoluteTimeseries_swigregister(SoluteTimeseries)
class SoluteReaction(object):
    r"""


    Abstract class for a solute reaction.

    Can be derived with python.

    C++ includes: reaction.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    get_flux = _swig_new_instance_method(_cmf_core.SoluteReaction_get_flux)
    __call__ = _swig_new_instance_method(_cmf_core.SoluteReaction___call__)
    to_string = _swig_new_instance_method(_cmf_core.SoluteReaction_to_string)
    is_compatible = _swig_new_instance_method(_cmf_core.SoluteReaction_is_compatible)
    __swig_destroy__ = _cmf_core.delete_SoluteReaction

    def __repr__(self):
        return self.to_string()


    def __init__(self, *args, **kwargs):
        r"""__init__(SoluteReaction self) -> SoluteReaction"""
        if self.__class__ == SoluteReaction:
            _self = None
        else:
            _self = self
        _cmf_core.SoluteReaction_swiginit(self, _cmf_core.new_SoluteReaction(_self, *args, **kwargs))
    def __disown__(self):
        self.this.disown()
        _cmf_core.disown_SoluteReaction(self)
        return weakref.proxy(self)

# Register SoluteReaction in _cmf_core:
_cmf_core.SoluteReaction_swigregister(SoluteReaction)
class SoluteConstantFluxReaction(SoluteReaction):
    r"""


    Adds a constant flux to the solute storage.

    Normally used for operator split model coupling. Use this to replace
    the old source parameter of a solute storage

    Usage:

    C++ includes: reaction.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flux = property(_cmf_core.SoluteConstantFluxReaction_flux_get, _cmf_core.SoluteConstantFluxReaction_flux_set, doc=r"""flux : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SoluteConstantFluxReaction self, real f) -> SoluteConstantFluxReaction
        SoluteConstantFluxReaction(real f)
        cmf::water::SoluteConstantFluxReaction::SoluteConstantFluxReaction
        """
        _cmf_core.SoluteConstantFluxReaction_swiginit(self, _cmf_core.new_SoluteConstantFluxReaction(*args, **kwargs))

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoluteConstantFluxReaction

# Register SoluteConstantFluxReaction in _cmf_core:
_cmf_core.SoluteConstantFluxReaction_swigregister(SoluteConstantFluxReaction)
class SoluteDecayReaction(SoluteReaction):
    r"""


    Adds a linear decay to solute storages.

    Normally used for operator split model coupling. Use this to replace
    the old source parameter of a solute storage

    Usage:

    C++ includes: reaction.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    decay = property(_cmf_core.SoluteDecayReaction_decay_get, _cmf_core.SoluteDecayReaction_decay_set, doc=r"""decay : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SoluteDecayReaction self, real d) -> SoluteDecayReaction
        SoluteDecayReaction(real d)
        cmf::water::SoluteDecayReaction::SoluteDecayReaction
        """
        _cmf_core.SoluteDecayReaction_swiginit(self, _cmf_core.new_SoluteDecayReaction(*args, **kwargs))

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoluteDecayReaction

# Register SoluteDecayReaction in _cmf_core:
_cmf_core.SoluteDecayReaction_swigregister(SoluteDecayReaction)
class SoluteEquilibriumReaction(SoluteReaction):
    r"""


    An equilibrium reaction between two solutes A<->B.



    .. math::

         A \\rightleftharpoons B 



    .. math::

        \\frac{d[B]}{dt} = -\\frac{d[A]}{dt} = k_{AB} [A] - k_{BA}
        [B] 

    C++ includes: reaction.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    A = property(_cmf_core.SoluteEquilibriumReaction_A_get, doc=r"""A : cmf::water::solute""")
    B = property(_cmf_core.SoluteEquilibriumReaction_B_get, doc=r"""B : cmf::water::solute""")
    k_ab = property(_cmf_core.SoluteEquilibriumReaction_k_ab_get, _cmf_core.SoluteEquilibriumReaction_k_ab_set, doc=r"""k_ab : real""")
    k_ba = property(_cmf_core.SoluteEquilibriumReaction_k_ba_get, _cmf_core.SoluteEquilibriumReaction_k_ba_set, doc=r"""k_ba : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SoluteEquilibriumReaction self, solute A, solute B, real k_ab, real k_ba) -> SoluteEquilibriumReaction
        SoluteEquilibriumReaction(const solute &A, const solute &B, real k_ab,
        real k_ba)
        cmf::water::SoluteEquilibriumReaction::SoluteEquilibriumReaction
        Creates a solute equilibrium reaction A<->B. 
        """
        _cmf_core.SoluteEquilibriumReaction_swiginit(self, _cmf_core.new_SoluteEquilibriumReaction(*args, **kwargs))

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoluteEquilibriumReaction

# Register SoluteEquilibriumReaction in _cmf_core:
_cmf_core.SoluteEquilibriumReaction_swigregister(SoluteEquilibriumReaction)
class SoluteRateReaction(SoluteReaction):
    r"""


    A general solute reaction system to describe multi-species kinetics
    with a power law.

    WARNING:  Experimental feature!

    cf. tohttps://en.wikipedia.org/wiki/Rate_equation



    .. math::

         A + 2B \\rightarrow 3C \\Rightarrow 0 = -1A - 2B + 3C 

    Where :math:`-1, -2, 3` are the stoichiometric coefficients :math:`v_i`
    corresponding to the substance :math:`X_i`.

    The reaction rate :math:`r^+` is given by a power law:



    .. math::

         r = k \\prod [X_i]^{m_i} \\forall v_i < 0 

    With :math:`m_i`
    as the partial order, which is sometimes equal to the stoichiometric
    coefficient.

    Which gives the following differential equation system



    .. math::

        \\frac{dX_i}{dt} = v_i r^+([X]) V 

    If the opposite reaction is taking place at the same time (equilibrium
    reaction), with the reaction rate :math:`r^-` for the backwards reaction we
    get: 

    .. math::

        \\frac{dX_i}{dt} = V \\left(v_i r^+([X]) - v_i
        r^-([X])\\right)

    C++ includes: reaction.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    k_forward = property(_cmf_core.SoluteRateReaction_k_forward_get, _cmf_core.SoluteRateReaction_k_forward_set, doc=r"""k_forward : real""")
    k_back = property(_cmf_core.SoluteRateReaction_k_back_get, _cmf_core.SoluteRateReaction_k_back_set, doc=r"""k_back : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SoluteRateReaction self, real kForward, real kBack=0.0) -> SoluteRateReaction
        SoluteRateReaction(real kForward, real kBack=0.0)
        cmf::water::SoluteRateReaction::SoluteRateReaction
        """
        _cmf_core.SoluteRateReaction_swiginit(self, _cmf_core.new_SoluteRateReaction(*args, **kwargs))
    __add_reactance = _swig_new_instance_method(_cmf_core.SoluteRateReaction___add_reactance)

    def __repr__(self):
        return self.to_string()


    def update(self, reactances):
        if any(not isinstance(s, solute) for s in reactances):
            raise TypeError('All dict keys need to be cmf.solute objects')
        for s, value in reactances.items():
            try:
                self.__add_reactance(s, *value)
            except TypeError:
                self.__add_reactance(s, value)
        return self

    def append(self, solute, stoichiometric_coefficient, partial_order=None):
        if partial_order is None:
            self.__add_reactance(solute, stoichiometric_coefficient)
        else:
            self.__add_reactance(solute, stoichiometric_coefficient, partial_order)
        return self

    @classmethod
    def decay(cls, solute, rate):
        return cls(rate).append(solute, -1)

    @classmethod
    def constant_source(cls, solute, rate):
        """
        Creates a constant concentration source

        @param solute: A cmf.solute
        @param rate: The change rate of the concentration in mol/(m³ day)
        """
        return cls(rate).append(solute, 1, 0)

    @classmethod
    def multi(cls, reactances, k_forward, k_back=0.0):
        return cls(k_forward, k_back).update(reactances)

    __swig_destroy__ = _cmf_core.delete_SoluteRateReaction

# Register SoluteRateReaction in _cmf_core:
_cmf_core.SoluteRateReaction_swigregister(SoluteRateReaction)
class Solute1stOrderReaction(SoluteReaction):
    r"""


    A solute reaction of 1st order kinetics (linear decline to product)
    A->B.



    .. math::

         A \\rightarrow B 



    .. math::

        \\frac{d[B]}{dt} = -\\frac{d[A]}{dt} = k [A]

    Where A is the educt and B is the product.

    C++ includes: reaction.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    A = property(_cmf_core.Solute1stOrderReaction_A_get, doc=r"""A : cmf::water::solute""")
    B = property(_cmf_core.Solute1stOrderReaction_B_get, doc=r"""B : cmf::water::solute""")
    k = property(_cmf_core.Solute1stOrderReaction_k_get, _cmf_core.Solute1stOrderReaction_k_set, doc=r"""k : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Solute1stOrderReaction self, solute A, solute B, real k) -> Solute1stOrderReaction
        Solute1stOrderReaction(const solute &A, const solute &B, real k)
        cmf::water::Solute1stOrderReaction::Solute1stOrderReaction
        """
        _cmf_core.Solute1stOrderReaction_swiginit(self, _cmf_core.new_Solute1stOrderReaction(*args, **kwargs))

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_Solute1stOrderReaction

# Register Solute1stOrderReaction in _cmf_core:
_cmf_core.Solute1stOrderReaction_swigregister(Solute1stOrderReaction)
class Solute2ndOrderReaction(SoluteReaction):
    r"""


    A solute reaction of 2nd order kinetics A + B -> C.



    .. math::

         A + B \\rightarrow C 



    .. math::

        \\frac{d[C]}{dt} = -\\frac{d[A]}{dt} = -\\frac{d[B]}{dt} =
        k [A] [B]

    Where A and B are the educts and C is the product. For a 2nd order
    reaction of a single educt A just write:

    C++ includes: reaction.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    A = property(_cmf_core.Solute2ndOrderReaction_A_get, doc=r"""A : cmf::water::solute""")
    B = property(_cmf_core.Solute2ndOrderReaction_B_get, doc=r"""B : cmf::water::solute""")
    C = property(_cmf_core.Solute2ndOrderReaction_C_get, doc=r"""C : cmf::water::solute""")
    k = property(_cmf_core.Solute2ndOrderReaction_k_get, _cmf_core.Solute2ndOrderReaction_k_set, doc=r"""k : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Solute2ndOrderReaction self, solute A, solute B, solute C, real k) -> Solute2ndOrderReaction
        Solute2ndOrderReaction(const solute &A, const solute &B, const solute
        &C, real k) cmf::water::Solute2ndOrderReaction::Solute2ndOrderReaction
        Creates a 2nd order kinetic reaction. 
        """
        _cmf_core.Solute2ndOrderReaction_swiginit(self, _cmf_core.new_Solute2ndOrderReaction(*args, **kwargs))

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_Solute2ndOrderReaction

# Register Solute2ndOrderReaction in _cmf_core:
_cmf_core.Solute2ndOrderReaction_swigregister(Solute2ndOrderReaction)
class SoluteDiffusiveTransport(SoluteReaction):
    r"""


    Calculates a diffusive flux between solute storages.

    WARNING:  Experimental feature! The math might not be a correct
    diffusion equation



    .. math::

         q = \\alpha \\cdot \\left([A]_1 - [A]_2\\right) V_2


    :math:`[A]_n` Concentration of solute A in storage n in mol/m³ or a
    similar unit

    :math:`\\alpha` Diffusion velocity in 1/day. Depends on the distance
    between the storages. To calculate it from a distance independent
    diffusion velocity :math:`D [m/day]` over a distance d use :math:`\\alpha = D / d`

    :math:`V_2` the water volume of the source water storage

    C++ includes: reaction.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    alpha = property(_cmf_core.SoluteDiffusiveTransport_alpha_get, _cmf_core.SoluteDiffusiveTransport_alpha_set, doc=r"""alpha : real""")
    left = property(_cmf_core.SoluteDiffusiveTransport_left_get, doc=r"""left : r.q(const).cmf::water::SoluteStorage""")
    right = property(_cmf_core.SoluteDiffusiveTransport_right_get, doc=r"""right : r.q(const).cmf::water::SoluteStorage""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SoluteDiffusiveTransport self, real alpha, SoluteStorage left, SoluteStorage right) -> SoluteDiffusiveTransport
        SoluteDiffusiveTransport(real alpha, const SoluteStorage &left, const
        SoluteStorage &right)
        cmf::water::SoluteDiffusiveTransport::SoluteDiffusiveTransport
        """
        _cmf_core.SoluteDiffusiveTransport_swiginit(self, _cmf_core.new_SoluteDiffusiveTransport(*args, **kwargs))

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoluteDiffusiveTransport

# Register SoluteDiffusiveTransport in _cmf_core:
_cmf_core.SoluteDiffusiveTransport_swigregister(SoluteDiffusiveTransport)
clear_reactions_of_waterstorage = _cmf_core.clear_reactions_of_waterstorage
class SoluteReactionList(object):
    r"""Proxy of C++ cmf::List< cmf::water::SoluteReaction::ptr > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    append = _swig_new_instance_method(_cmf_core.SoluteReactionList_append)
    extend = _swig_new_instance_method(_cmf_core.SoluteReactionList_extend)
    remove = _swig_new_instance_method(_cmf_core.SoluteReactionList_remove)
    remove_at = _swig_new_instance_method(_cmf_core.SoluteReactionList_remove_at)
    clear = _swig_new_instance_method(_cmf_core.SoluteReactionList_clear)
    size = _swig_new_instance_method(_cmf_core.SoluteReactionList_size)
    index = _swig_new_instance_method(_cmf_core.SoluteReactionList_index)

    def __init__(self, *args):
        r"""
        __init__(SoluteReactionList self) -> SoluteReactionList
        __init__(SoluteReactionList self, SoluteReactionList other) -> SoluteReactionList
        List(std::initializer_list< T
        > l) cmf::List::List
        """
        _cmf_core.SoluteReactionList_swiginit(self, _cmf_core.new_SoluteReactionList(*args))
    __getitem__ = _swig_new_instance_method(_cmf_core.SoluteReactionList___getitem__)
    __setitem__ = _swig_new_instance_method(_cmf_core.SoluteReactionList___setitem__)
    __delitem__ = _swig_new_instance_method(_cmf_core.SoluteReactionList___delitem__)
    __len__ = _swig_new_instance_method(_cmf_core.SoluteReactionList___len__)
    __contains__ = _swig_new_instance_method(_cmf_core.SoluteReactionList___contains__)

    def __repr__(self):
        return type(self).__name__ + '([' + ', '.join(repr(obj) for obj in self) + '])'

    __swig_destroy__ = _cmf_core.delete_SoluteReactionList

# Register SoluteReactionList in _cmf_core:
_cmf_core.SoluteReactionList_swigregister(SoluteReactionList)
attach_reactions_to_waterstorage = _cmf_core.attach_reactions_to_waterstorage
class SoluteStorage(StateVariable):
    r"""


    A class for the storage of any tracer.

    The state is the amount (mol, kg etc. see cmf::water) of the tracer in
    the storage.

    The derivative function is given by: 

    .. math::

        \\frac{dX}{dt} =
        \\sum_{f=1}^{F}{q_f \\cdot [X]_f} + \\sum_{r=1}^{R}{q_r([X], t)}
        \\left[\\frac{mol}{day}\\right] 

    :math:`F` = Number of fluxes in
    water storage

    :math:`q_f` = Water flux in :math:`\\frac{m^3}{day}`

    :math:`\\left[X\\right]_f` = Concentration of solute X in flux :math:`q_f` in
    :math:`\\frac{mol}{m^3}`

    :math:`q_r([X], t)` = Production or loss rate from R
    cmf::water::SoluteReaction objects :math:`\\frac{mol}{day}`

    C++ includes: SoluteStorage.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    set_adsorption = _swig_new_instance_method(_cmf_core.SoluteStorage_set_adsorption)
    reactions = property(_cmf_core.SoluteStorage_reactions_get, _cmf_core.SoluteStorage_reactions_set, doc=r"""reactions : cmf::List<(cmf::water::SoluteReaction::ptr)>""")
    Solute = property(_cmf_core.SoluteStorage_Solute_get, doc=r"""Solute : r.q(const).cmf::water::solute""")
    get_water = _swig_new_instance_method(_cmf_core.SoluteStorage_get_water)
    add_connected_states = _swig_new_instance_method(_cmf_core.SoluteStorage_add_connected_states)
    reactive_flux = _swig_new_instance_method(_cmf_core.SoluteStorage_reactive_flux)
    set_abs_errtol = _swig_new_instance_method(_cmf_core.SoluteStorage_set_abs_errtol)
    conc = property(_cmf_core.SoluteStorage_conc_get, _cmf_core.SoluteStorage_conc_set, doc=r"""conc : real""")

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoluteStorage

# Register SoluteStorage in _cmf_core:
_cmf_core.SoluteStorage_swigregister(SoluteStorage)
class flux_node(object):
    r"""


    Base class for everything that can be connected by fluxes.

    Flux nodes can be WaterStorages, flux end points, sinks, sources and
    bridges to other model domains (e.g. Ponded water to river system).
    The base class can be used where a simple routing, potentially with
    mixing, is needed.

    C++ includes: flux_node.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    node_id = property(_cmf_core.flux_node_node_id_get, doc=r"""node_id : q(const).int""")
    is_storage = _swig_new_instance_method(_cmf_core.flux_node_is_storage)
    Name = property(_cmf_core.flux_node_Name_get, _cmf_core.flux_node_Name_set, doc=r"""Name : std::string""")
    to_string = _swig_new_instance_method(_cmf_core.flux_node_to_string)
    __swig_destroy__ = _cmf_core.delete_flux_node
    __eq__ = _swig_new_instance_method(_cmf_core.flux_node___eq__)
    RecalcFluxes = _swig_new_instance_method(_cmf_core.flux_node_RecalcFluxes)
    connection_to = _swig_new_instance_method(_cmf_core.flux_node_connection_to)
    remove_connection = _swig_new_instance_method(_cmf_core.flux_node_remove_connection)
    flux_to = _swig_new_instance_method(_cmf_core.flux_node_flux_to)
    flux3d_to = _swig_new_instance_method(_cmf_core.flux_node_flux3d_to)
    get_3d_flux = _swig_new_instance_method(_cmf_core.flux_node_get_3d_flux)
    waterbalance = _swig_new_instance_method(_cmf_core.flux_node_waterbalance)
    __call__ = _swig_new_instance_method(_cmf_core.flux_node___call__)
    conc = _swig_new_instance_method(_cmf_core.flux_node_conc)
    position = property(_cmf_core.flux_node_position_get, _cmf_core.flux_node_position_set, doc=r"""position : cmf::geometry::point""")
    get_potential = _swig_new_instance_method(_cmf_core.flux_node_get_potential)
    is_empty = _swig_new_instance_method(_cmf_core.flux_node_is_empty)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(flux_node self, project _project, point location=cmf::geometry::point()) -> flux_node
        flux_node(cmf::project &_project, cmf::geometry::point
        location=cmf::geometry::point()) cmf::water::flux_node::flux_node
        """
        _cmf_core.flux_node_swiginit(self, _cmf_core.new_flux_node(*args, **kwargs))
    project = property(_cmf_core.flux_node_project_get, doc=r"""project : cmf::project""")
    potential = property(_cmf_core.flux_node_potential_get, _cmf_core.flux_node_potential_set, doc=r"""potential : real""")
    connections = property(_cmf_core.flux_node_connections_get, doc=r"""connections : cmf::water::connection_list""")

    def __repr__(self): return self.to_string()
    def fluxes(self,t):
        return [(con.q(self,t),con[self]) for con in self.connections]
    @property
    def connected_nodes(self):
        return [con[self] for con in self.connections]


# Register flux_node in _cmf_core:
_cmf_core.flux_node_swigregister(flux_node)
count_node_references = _cmf_core.count_node_references
get_higher_node = _cmf_core.get_higher_node
get_lower_node = _cmf_core.get_lower_node
class flux_connection(object):
    r"""


    The connections in cmf hold the processes for the calculation of
    fluxes between water storages and model boundaries.

    Represents a connection between flux_nodes, where water fluxes occur.

    C++ includes: flux_connection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    left_node = _swig_new_instance_method(_cmf_core.flux_connection_left_node)
    right_node = _swig_new_instance_method(_cmf_core.flux_connection_right_node)
    kill_me = _swig_new_instance_method(_cmf_core.flux_connection_kill_me)
    refresh = _swig_new_instance_method(_cmf_core.flux_connection_refresh)
    connection_id = property(_cmf_core.flux_connection_connection_id_get, doc=r"""connection_id : q(const).int""")
    __eq__ = _swig_new_instance_method(_cmf_core.flux_connection___eq__)
    get_target = _swig_new_instance_method(_cmf_core.flux_connection_get_target)
    exchange_target = _swig_new_instance_method(_cmf_core.flux_connection_exchange_target)
    q = _swig_new_instance_method(_cmf_core.flux_connection_q)
    conc = _swig_new_instance_method(_cmf_core.flux_connection_conc)
    type = property(_cmf_core.flux_connection_type_get, doc=r"""type : q(const).std::string""")
    get_tracer_filter = _swig_new_instance_method(_cmf_core.flux_connection_get_tracer_filter)
    set_tracer_filter = _swig_new_instance_method(_cmf_core.flux_connection_set_tracer_filter)
    to_string = _swig_new_instance_method(_cmf_core.flux_connection_to_string)
    short_string = _swig_new_instance_method(_cmf_core.flux_connection_short_string)
    __swig_destroy__ = _cmf_core.delete_flux_connection


    def __repr__(self):
        return self.to_string()

    def __getitem__(self,index):
        return self.get_target(index)

    def __iter__(self):
        yield self.get_target(0)
        yield self.get_target(1)

    def __contains__(self,cmp):
        return cmp==self[0] or cmp==self[1]


# Register flux_connection in _cmf_core:
_cmf_core.flux_connection_swigregister(flux_connection)
replace_node = _cmf_core.replace_node
class connection_list(object):
    r"""


    A self sorting list of connections.

    C++ includes: flux_connection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    append = _swig_new_instance_method(_cmf_core.connection_list_append)
    extend = _swig_new_instance_method(_cmf_core.connection_list_extend)
    contains = _swig_new_instance_method(_cmf_core.connection_list_contains)
    remove = _swig_new_instance_method(_cmf_core.connection_list_remove)
    do_action = _swig_new_instance_method(_cmf_core.connection_list_do_action)
    size = _swig_new_instance_method(_cmf_core.connection_list_size)
    at = _swig_new_instance_method(_cmf_core.connection_list_at)
    begin = _swig_new_instance_method(_cmf_core.connection_list_begin)
    end = _swig_new_instance_method(_cmf_core.connection_list_end)
    __swig_destroy__ = _cmf_core.delete_connection_list
    __len__ = _swig_new_instance_method(_cmf_core.connection_list___len__)
    __contains__ = _swig_new_instance_method(_cmf_core.connection_list___contains__)


    def __repr__(self):
        return repr(list(self)) + "<cmf.connection_list>"

    def __getitem__(self,index):
        return self.at(index)

    def __iter__(self):
        for i in range(len(self)):
            yield self.at(i)


    def __init__(self, *args, **kwargs):
        r"""__init__(connection_list self) -> connection_list"""
        _cmf_core.connection_list_swiginit(self, _cmf_core.new_connection_list(*args, **kwargs))

# Register connection_list in _cmf_core:
_cmf_core.connection_list_swigregister(connection_list)
class BaseConnection(flux_connection):
    r"""Proxy of C++ cmf::water::BaseConnection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(BaseConnection self, cmf::water::WaterStorage::ptr left, cmf::water::flux_node::ptr right, std::string type) -> BaseConnection"""
        if self.__class__ == BaseConnection:
            _self = None
        else:
            _self = self
        _cmf_core.BaseConnection_swiginit(self, _cmf_core.new_BaseConnection(_self, *args, **kwargs))
    calc_q = _swig_new_instance_method(_cmf_core.BaseConnection_calc_q)
    __swig_destroy__ = _cmf_core.delete_BaseConnection
    def __disown__(self):
        self.this.disown()
        _cmf_core.disown_BaseConnection(self)
        return weakref.proxy(self)
    NewNodes = _swig_new_instance_method(_cmf_core.BaseConnection_NewNodes)

# Register BaseConnection in _cmf_core:
_cmf_core.BaseConnection_swigregister(BaseConnection)
class linear_scale(object):
    r"""


    A linear scaling functor, with slope and displacement.

    C++ includes: boundary_condition.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    displacement = property(_cmf_core.linear_scale_displacement_get, _cmf_core.linear_scale_displacement_set, doc=r"""displacement : real""")
    slope = property(_cmf_core.linear_scale_slope_get, _cmf_core.linear_scale_slope_set, doc=r"""slope : real""")
    __call__ = _swig_new_instance_method(_cmf_core.linear_scale___call__)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(linear_scale self, real _slope=1, real _displacement=0) -> linear_scale
        linear_scale(real _slope=1, real _displacement=0)
        cmf::water::linear_scale::linear_scale Creates a linear scale (by
        default it is a unity scale, :math:`a=1; b=0`) 
        """
        _cmf_core.linear_scale_swiginit(self, _cmf_core.new_linear_scale(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_linear_scale

# Register linear_scale in _cmf_core:
_cmf_core.linear_scale_swigregister(linear_scale)
class DirichletBoundary(flux_node):
    r"""


    Dirichlet (constant head) boundary condition.

    This boundary condition can be used either as a pure sink boundary
    condition or as a conditional source / sink boundary condition. The
    constant head of the boundary condition is interpreted and handled by
    the connections of the boundary condition. Not head aware connections,
    should not be used, since they are ignoring the constant head.

    C++ includes: boundary_condition.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    set_dynamic_potential = _swig_new_instance_method(_cmf_core.DirichletBoundary_set_dynamic_potential)
    set_conc = _swig_new_instance_method(_cmf_core.DirichletBoundary_set_conc)
    is_source = property(_cmf_core.DirichletBoundary_is_source_get, _cmf_core.DirichletBoundary_is_source_set, doc=r"""is_source : bool""")
    RecalcFluxes = _swig_new_instance_method(_cmf_core.DirichletBoundary_RecalcFluxes)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(DirichletBoundary self, project _p, real potential, point Location=cmf::geometry::point()) -> DirichletBoundary
        DirichletBoundary(cmf::project &_p, real potential,
        cmf::geometry::point Location=cmf::geometry::point())
        cmf::water::DirichletBoundary::DirichletBoundary
        """
        _cmf_core.DirichletBoundary_swiginit(self, _cmf_core.new_DirichletBoundary(*args, **kwargs))

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_DirichletBoundary

# Register DirichletBoundary in _cmf_core:
_cmf_core.DirichletBoundary_swigregister(DirichletBoundary)
class NeumannBoundary(flux_node):
    r"""


    A Neumann boundary condition (constant flux boundary condition)

    The flux is a timeseries, but can be used as a scalar. To scale the
    timeseries to the specific conditions of this boundary condition the
    linear_scale flux_scale can be used.

    C++ includes: boundary_condition.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    get_flux = _swig_new_instance_method(_cmf_core.NeumannBoundary_get_flux)
    set_flux = _swig_new_instance_method(_cmf_core.NeumannBoundary_set_flux)
    flux_scale = property(_cmf_core.NeumannBoundary_flux_scale_get, _cmf_core.NeumannBoundary_flux_scale_set, doc=r"""flux_scale : cmf::water::linear_scale""")
    concentration = property(_cmf_core.NeumannBoundary_concentration_get, _cmf_core.NeumannBoundary_concentration_set, doc=r"""concentration : cmf::water::SoluteTimeseries""")
    __call__ = _swig_new_instance_method(_cmf_core.NeumannBoundary___call__)
    connect_to = _swig_new_instance_method(_cmf_core.NeumannBoundary_connect_to)

    def __init__(self, *args):
        r"""
        __init__(NeumannBoundary self, project _project, timeseries _flux, SoluteTimeseries _concentration=cmf::water::SoluteTimeseries(), point loc=cmf::geometry::point()) -> NeumannBoundary
        __init__(NeumannBoundary self, project _project, point loc=cmf::geometry::point()) -> NeumannBoundary
        NeumannBoundary(cmf::project &_project, cmf::math::timeseries _flux,
        cmf::water::SoluteTimeseries
        _concentration=cmf::water::SoluteTimeseries(), cmf::geometry::point
        loc=cmf::geometry::point())
        cmf::water::NeumannBoundary::NeumannBoundary Ctor of the Neumann
        boundary.

        Parameters:
        -----------

        _project:  The project this boundary condition belongs to

        _flux:  The flux timeseries (a scalar is converted to a timeseries
        automatically)

        _concentration:  The concentration timeseries

        loc:  The location of the boundary condition 
        """
        _cmf_core.NeumannBoundary_swiginit(self, _cmf_core.new_NeumannBoundary(*args))
    create = _swig_new_static_method(_cmf_core.NeumannBoundary_create)

    def __repr__(self):
        return self.to_string()


    flux = property(get_flux,set_flux, doc="The flux over the boundary condition")

    __swig_destroy__ = _cmf_core.delete_NeumannBoundary

# Register NeumannBoundary in _cmf_core:
_cmf_core.NeumannBoundary_swigregister(NeumannBoundary)
class NeumannFlux(flux_connection):
    r"""


    Connection between Neumann-boundary and a flux node.

    This flux_connection is created, when connecting a Neumann boundary
    condition with a state variable using Neumann::connect_to

    C++ includes: boundary_condition.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(NeumannFlux self, std::shared_ptr< cmf::water::NeumannBoundary > left, cmf::water::flux_node::ptr right) -> NeumannFlux
        NeumannFlux(std::shared_ptr< NeumannBoundary > left,
        cmf::water::flux_node::ptr right)
        cmf::water::NeumannFlux::NeumannFlux
        """
        _cmf_core.NeumannFlux_swiginit(self, _cmf_core.new_NeumannFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_NeumannFlux

# Register NeumannFlux in _cmf_core:
_cmf_core.NeumannFlux_swigregister(NeumannFlux)
class WaterStorage(StateVariable, flux_node):
    r"""


    A state variable for the storage of water.

    A class for the storage of water. The state is the volume of water
    stored in :math:`m^3` The derivative function is given by:


    .. math::

         \\frac{dV}{dt}&=&\\sum_{f=1}^{F} q_f \\\\
        F&=& \\mbox{Number of fluxes in water storage} \\\\ q_f&=&
        \\mbox{Water flux in } \\frac{m^3}{day} \\\\




    Todo Check the head based state mode

    C++ includes: WaterStorage.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(WaterStorage self, project project, std::string const & Name="", double InitialState=0, double scale=1) -> WaterStorage
        WaterStorage(cmf::project &project, const std::string &Name="",
        double InitialState=0, double scale=1)
        cmf::water::WaterStorage::WaterStorage creates a water storage
        (abstract class)

        Parameters:
        -----------

        project:  The project the waterstorage belongs to

        Name:  Name of the water storage

        InitialState:  Initial water content in m3

        scale:  A kind of "standard size" in m3 of the water storage to
        scale tolerances, default 1m3 
        """
        _cmf_core.WaterStorage_swiginit(self, _cmf_core.new_WaterStorage(*args, **kwargs))
    from_node = _swig_new_static_method(_cmf_core.WaterStorage_from_node)
    Solute = _swig_new_instance_method(_cmf_core.WaterStorage_Solute)
    conc = _swig_new_instance_method(_cmf_core.WaterStorage_conc)
    cast = _swig_new_static_method(_cmf_core.WaterStorage_cast)
    create = _swig_new_static_method(_cmf_core.WaterStorage_create)
    volume = property(_cmf_core.WaterStorage_volume_get, _cmf_core.WaterStorage_volume_set, doc=r"""volume : real""")
    statevariable = property(_cmf_core.WaterStorage_statevariable_get, _cmf_core.WaterStorage_statevariable_set, doc=r"""statevariable : char""")

    def __repr__(self):
        return self.to_string()

    __getitem__ = _swig_new_instance_method(_cmf_core.WaterStorage___getitem__)
    __swig_destroy__ = _cmf_core.delete_WaterStorage

# Register WaterStorage in _cmf_core:
_cmf_core.WaterStorage_swigregister(WaterStorage)
class WaterbalanceFlux(flux_connection):
    r"""


    Routes the sum of all other fluxes to a target.



    .. math::

         q_{1,0} = \\sum_{i=2}^N{q_{1,i}(V_1,V_i,t)}

    where:
    :math:`q_{i,j}` is the flux between the two node i and j. Subscript 0 is the
    right node, subscript 1 is the left node and 2..N are the nodes
    connected to the left node, except for the right node

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(WaterbalanceFlux self, cmf::water::flux_node::ptr source, cmf::water::flux_node::ptr target) -> WaterbalanceFlux
        WaterbalanceFlux(flux_node::ptr source, flux_node::ptr target)
        cmf::water::WaterbalanceFlux::WaterbalanceFlux
        """
        _cmf_core.WaterbalanceFlux_swiginit(self, _cmf_core.new_WaterbalanceFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_WaterbalanceFlux

# Register WaterbalanceFlux in _cmf_core:
_cmf_core.WaterbalanceFlux_swigregister(WaterbalanceFlux)
class PartitionFluxRoute(flux_connection):
    r"""


    Routes a fraction of the flux calculated from a master flux_connection
    between source to target1 directly further to target2 without any
    timelag.

    The connection connects target 1 and target 2.



    .. math::

         q_{t1,t2} = f \\cdot q_{s, t1}(t) 

    Where :math:`q_{t1,t2}` is the flux from t1 to t2, f is the fraction and :math:`q_{s,t1}(t)` is the original flux

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PartitionFluxRoute self, cmf::water::flux_node::ptr source, cmf::water::flux_node::ptr target1, cmf::water::flux_node::ptr target2, real fraction, bool no_back_flow=True) -> PartitionFluxRoute
        PartitionFluxRoute(flux_node::ptr source, flux_node::ptr target1,
        flux_node::ptr target2, real fraction, bool no_back_flow=true)
        cmf::water::PartitionFluxRoute::PartitionFluxRoute

        Parameters:
        -----------

        source:  Water storage from which the water flows out. The flux is
        defined by some other flux connection between

        target1:  Target node (boundary condition or storage). The target of
        the master flux connection

        target2:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        fraction:  Fraction of the source->target1 flow to be routed further
        to target2

        no_back_flow:  If true (default), no flow between target 1 and target
        2 occurs, if water is flowing from target 1 to source. If set to
        false, in the case of water flowing from target 1 to source, the
        fraction is also flowing from target 2 to target 1. No test if target
        2 has water is made. 
        """
        _cmf_core.PartitionFluxRoute_swiginit(self, _cmf_core.new_PartitionFluxRoute(*args, **kwargs))
    source = _swig_new_instance_method(_cmf_core.PartitionFluxRoute_source)
    fraction = property(_cmf_core.PartitionFluxRoute_fraction_get, _cmf_core.PartitionFluxRoute_fraction_set, doc=r"""fraction : real""")
    no_back_flow = property(_cmf_core.PartitionFluxRoute_no_back_flow_get, _cmf_core.PartitionFluxRoute_no_back_flow_set, doc=r"""no_back_flow : bool""")
    __swig_destroy__ = _cmf_core.delete_PartitionFluxRoute

# Register PartitionFluxRoute in _cmf_core:
_cmf_core.PartitionFluxRoute_swigregister(PartitionFluxRoute)
class ExternallyControlledFlux(flux_connection):
    r"""


    Flux from one node to another, controlled by the user or an external
    program, by changing the flux constant.

    It is easy to create negative volumes in water storages with this
    connection, which can be hazard to the solver, since most connections
    rely on a positive volume in a storage. Handle with care!

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flux = property(_cmf_core.ExternallyControlledFlux_flux_get, _cmf_core.ExternallyControlledFlux_flux_set, doc=r"""flux : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ExternallyControlledFlux self, cmf::water::flux_node::ptr source, cmf::water::flux_node::ptr target, real flux_value=0) -> ExternallyControlledFlux
        ExternallyControlledFlux(flux_node::ptr source, flux_node::ptr target,
        real flux_value=0)
        cmf::water::ExternallyControlledFlux::ExternallyControlledFlux
        """
        _cmf_core.ExternallyControlledFlux_swiginit(self, _cmf_core.new_ExternallyControlledFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ExternallyControlledFlux

# Register ExternallyControlledFlux in _cmf_core:
_cmf_core.ExternallyControlledFlux_swigregister(ExternallyControlledFlux)
set_flux = _cmf_core.set_flux
can_set_flux = _cmf_core.can_set_flux
class LinearStorageConnection(flux_connection):
    r"""


    Calculates flux out of a storage as a linear function of its volume.

    This connection serves the same purpose as the old kinematic_wave
    connection, but the parameters are easier to explain



    .. math::

         q = \\frac{V - V_{residual}}{t_r} 

    where:  :math:`V` The actual
    volume of water stored in source

    :math:`V_{residual} [m^3]` The volume of water not flowing out (default = 0)
    :math:`t_r` is the residence time in the source.

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    residencetime = property(_cmf_core.LinearStorageConnection_residencetime_get, _cmf_core.LinearStorageConnection_residencetime_set, doc=r"""residencetime : real""")
    residual = property(_cmf_core.LinearStorageConnection_residual_get, _cmf_core.LinearStorageConnection_residual_set, doc=r"""residual : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(LinearStorageConnection self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real residencetime, real residual=0.0) -> LinearStorageConnection
        LinearStorageConnection(WaterStorage::ptr source, flux_node::ptr
        target, real residencetime, real residual=0.0)
        cmf::water::LinearStorageConnection::LinearStorageConnection Creates a
        linear storage connection or Nash-box.



        .. math::

             q = \\frac{V - V_{residual}}{t_r}} 

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        residencetime:   :math:`t_r [days]` The residence time of the water in this
        storage

        residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
        (default = 0) 
        """
        _cmf_core.LinearStorageConnection_swiginit(self, _cmf_core.new_LinearStorageConnection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_LinearStorageConnection

# Register LinearStorageConnection in _cmf_core:
_cmf_core.LinearStorageConnection_swigregister(LinearStorageConnection)
class PowerLawConnection(flux_connection):
    r"""


    Calculates flux out of a storage as a linear function of its volume to
    a power.

    This connection serves the same purpose as the old kinematic_wave
    connection, but the parameters are easier to explain.



    .. math::

         q = Q_0 {\\left(\\frac{V - V_{residual}}{V_0}
        \\right)^\\beta} 

    where:  :math:`V` The actual volume of water
    stored in source

    :math:`V_{residual} [m^3]` The volume of water not flowing out (default = 0)

    :math:`V_0` A reference volume to scale the outflux. One can see :math:`V_0` as
    the inflection point of the outflow curve

    :math:`\\beta` A parameter to shape the response curve. :math:`Q_0` is the
    outflow from the source in :math:`\\frac{m^3}{day}`, when :math:`V = V_0`.

    WARNING:   :math:`\\beta < 0.5` may lead to numerical troubles and have a
    dubious hydrological meaning. Please avoid.

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Q0 = property(_cmf_core.PowerLawConnection_Q0_get, _cmf_core.PowerLawConnection_Q0_set, doc=r"""Q0 : real""")
    beta = property(_cmf_core.PowerLawConnection_beta_get, _cmf_core.PowerLawConnection_beta_set, doc=r"""beta : real""")
    residual = property(_cmf_core.PowerLawConnection_residual_get, _cmf_core.PowerLawConnection_residual_set, doc=r"""residual : real""")
    V0 = property(_cmf_core.PowerLawConnection_V0_get, _cmf_core.PowerLawConnection_V0_set, doc=r"""V0 : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PowerLawConnection self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real Q0, real V0, real beta=1.0, real residual=0.0) -> PowerLawConnection
        PowerLawConnection(WaterStorage::ptr source, flux_node::ptr target,
        real Q0, real V0, real beta=1.0, real residual=0.0)
        cmf::water::PowerLawConnection::PowerLawConnection Creates a power law
        connection.

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        Q0:  Reference flow :math:`Q_0 = q(V_0)` Outflow when the source storage
        equals the reference volume

        V0:  Reference volume :math:`V_0` The reference volume to scale the exponent

        beta:   :math:`\\beta [-]` An empirical exponent to shape the flux
        function (default = 1 (linear function))

        residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
        (default = 0) 
        """
        _cmf_core.PowerLawConnection_swiginit(self, _cmf_core.new_PowerLawConnection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_PowerLawConnection

# Register PowerLawConnection in _cmf_core:
_cmf_core.PowerLawConnection_swigregister(PowerLawConnection)
class ExponentialDeclineConnection(flux_connection):
    r"""


    A conceptual TOPmodel inspired connection.



    .. math::

         q = Q_0 \\cdot e^{(V-V_0)/m} 

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Q0 = property(_cmf_core.ExponentialDeclineConnection_Q0_get, _cmf_core.ExponentialDeclineConnection_Q0_set, doc=r"""Q0 : real""")
    m = property(_cmf_core.ExponentialDeclineConnection_m_get, _cmf_core.ExponentialDeclineConnection_m_set, doc=r"""m : real""")
    V0 = property(_cmf_core.ExponentialDeclineConnection_V0_get, _cmf_core.ExponentialDeclineConnection_V0_set, doc=r"""V0 : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ExponentialDeclineConnection self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real Q0, real V0, real m) -> ExponentialDeclineConnection
        ExponentialDeclineConnection(WaterStorage::ptr source,
        flux_node::ptr target, real Q0, real V0, real m)
        cmf::water::ExponentialDeclineConnection::ExponentialDeclineConnection
        creates the exponential decline connection 
        """
        _cmf_core.ExponentialDeclineConnection_swiginit(self, _cmf_core.new_ExponentialDeclineConnection(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ExponentialDeclineConnection

# Register ExponentialDeclineConnection in _cmf_core:
_cmf_core.ExponentialDeclineConnection_swigregister(ExponentialDeclineConnection)
class ConstraintLinearStorageFlux(flux_connection):
    r"""


    Calculates flux out of a storage as a linear function of its volume,
    constraint by the volume stored in the target storage.



    .. math::

         q = \\frac {1}{t_r} \\left({V_{l} - V_{l,min}}\\right)
        \\cdot \\left(\\frac{V_{r,max}-V_{r}}{V_{r,max}}\\right)

    where:  :math:`V_l` The actual volume stored by the left water storage

    :math:`V_{l,min} [m^3]` The volume of water not flowing out (default = 0)

    :math:`\\beta` A parameter to shape the response curve. In case of
    :math:`\\beta \\neq 1`, :math:`t_r` is not a residence time, but just a
    parameter.

    :math:`t_r [days]` The residence time of the water in this storage in days

    :math:`V_{r,max}` The capacity of the right water storage in m3

    :math:`V_{r}` The actual volume of the right water storage

    :math:`\\gamma` A shape parameter for the target capacity constriction

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    residencetime = property(_cmf_core.ConstraintLinearStorageFlux_residencetime_get, _cmf_core.ConstraintLinearStorageFlux_residencetime_set, doc=r"""residencetime : real""")
    Vlmin = property(_cmf_core.ConstraintLinearStorageFlux_Vlmin_get, _cmf_core.ConstraintLinearStorageFlux_Vlmin_set, doc=r"""Vlmin : real""")
    Vrmax = property(_cmf_core.ConstraintLinearStorageFlux_Vrmax_get, _cmf_core.ConstraintLinearStorageFlux_Vrmax_set, doc=r"""Vrmax : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ConstraintLinearStorageFlux self, cmf::water::WaterStorage::ptr source, cmf::water::WaterStorage::ptr target, real residencetime=1.0, real Vlmin=0.0, real Vrmax=1.0) -> ConstraintLinearStorageFlux
        ConstraintLinearStorageFlux(WaterStorage::ptr source,
        WaterStorage::ptr target, real residencetime=1.0, real Vlmin=0.0, real
        Vrmax=1.0)
        cmf::water::ConstraintLinearStorageFlux::ConstraintLinearStorageFlux
        Creates a linear storage connection, constrained by the fill level of
        the source.



        .. math::

             q = \\frac 1 {t_r} {\\left(\\frac{V - V_{residual}}{V_0}
            \\right)^\\beta} 

        Parameters:
        -----------

        source:  Water storage from which the water flows out. Flux is a
        function of source.volume

        target:  Target node (boundary condition or storage). Does not
        influence the strength of the flow

        residencetime:   :math:`t_r [days]` The residence time of the water in this
        storage

        Vlmin:   :math:`V_{l,min} [m^3]` The volume of water not flowing out
        (default = 0)

        Vrmax:   :math:`V_{r,max}` Capacity of the target water storage in m3 
        """
        _cmf_core.ConstraintLinearStorageFlux_swiginit(self, _cmf_core.new_ConstraintLinearStorageFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ConstraintLinearStorageFlux

# Register ConstraintLinearStorageFlux in _cmf_core:
_cmf_core.ConstraintLinearStorageFlux_swigregister(ConstraintLinearStorageFlux)
class ConstantFlux(flux_connection):
    r"""


    Produces a constant but changeable flux from a source to a target, if
    enough water is present in the source.



    .. math::

         q=\\begin{cases}0 & V_{source}\\le V_{min}\\\\ q_0
        \\frac{V_{source} - V_{min}}{t_{decr} q_{0} - V_{min}} & V_{source}
        \\le t_{decr} q_{0}\\\\ q_{0} &  \\end{cases}

    This is similar to a neumann boundary, however this is not a boundary
    condition, but water is taken from the source (left) water storage and
    limited by that water storage.

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MaxFlux = property(_cmf_core.ConstantFlux_MaxFlux_get, _cmf_core.ConstantFlux_MaxFlux_set, doc=r"""MaxFlux : real""")
    MinState = property(_cmf_core.ConstantFlux_MinState_get, _cmf_core.ConstantFlux_MinState_set, doc=r"""MinState : real""")
    FluxDecreaseTime = property(_cmf_core.ConstantFlux_FluxDecreaseTime_get, _cmf_core.ConstantFlux_FluxDecreaseTime_set, doc=r"""FluxDecreaseTime : cmf::math::Time""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ConstantFlux self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr target, real maximum_flux, real minimal_state=0, Time flux_decrease_time=h) -> ConstantFlux
        ConstantFlux(cmf::water::WaterStorage::ptr source,
        cmf::water::flux_node::ptr target, real maximum_flux, real
        minimal_state=0, cmf::math::Time flux_decrease_time=cmf::math::h)
        cmf::water::ConstantFlux::ConstantFlux Produces a constant but
        changeable flux from a source to a target, if enough water is present
        in the source.

        Parameters:
        -----------

        source:  The source of the water

        target:  The target of the water

        maximum_flux:  The requested flux :math:`q_{0} [\\frac{m^3}{day}]`

        minimal_state:  Minimal volume of stored water in source in :math:`[m^3]`

        flux_decrease_time:  ( cmf::math::Time) 
        """
        _cmf_core.ConstantFlux_swiginit(self, _cmf_core.new_ConstantFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ConstantFlux

# Register ConstantFlux in _cmf_core:
_cmf_core.ConstantFlux_swigregister(ConstantFlux)
class LinearGradientFlux(flux_connection):
    r"""


    A generic node-to-node gradient based connection.

    This connection is similar to the Darcy-connection, but there are no
    restrictions concerning the type of nodes. However, the left side
    needs to be a water storage 

    .. math::

         q = Q_1 \\nabla \\Psi 

    where:  :math:`q`: the resulting flux in :math:`m^3/day`

    :math:`Q_1`: Flux over the connection for a unity gradient ( :math:`\\nabla \\Psi = 1`) in :math:`\\frac{m^3}{day}`

    :math:`\\nabla \\Psi = \\frac{\\Psi_{l}-\\Psi_{r}}{d}`: The
    hydraulic gradient of the (l)eft, resp. (r)ight node of the connection

    :math:`d`: The topographic length of the connection in m

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Q1 = property(_cmf_core.LinearGradientFlux_Q1_get, _cmf_core.LinearGradientFlux_Q1_set, doc=r"""Q1 : real""")
    d = property(_cmf_core.LinearGradientFlux_d_get, _cmf_core.LinearGradientFlux_d_set, doc=r"""d : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(LinearGradientFlux self, cmf::water::flux_node::ptr left, cmf::water::flux_node::ptr right, real Q1, real d=-1.0) -> LinearGradientFlux
        LinearGradientFlux(cmf::water::flux_node::ptr left,
        cmf::water::flux_node::ptr right, real Q1, real d=-1.0)
        cmf::water::LinearGradientFlux::LinearGradientFlux Creates a generic
        gradient based flux, if enough water is present in the source.

        Parameters:
        -----------

        left:  The left node of the connection

        right:  The right node of the connection

        Q1:  Flux over the connection for a unity gradient ( :math:`\\nabla \\Psi = 1`) in :math:`\\frac{m^3}{day}`

        d:  the topographic lenght of the connection in m 
        """
        _cmf_core.LinearGradientFlux_swiginit(self, _cmf_core.new_LinearGradientFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_LinearGradientFlux

# Register LinearGradientFlux in _cmf_core:
_cmf_core.LinearGradientFlux_swigregister(LinearGradientFlux)
class ConstantStateFlux(flux_connection):
    r"""


    Calculates a flux to or from a water storage to hold it's state at a
    more or less constant level.



    .. math::

         q=\\frac{h_1 - h_{target}}{t_c [days]} 

    where:  :math:`q` the
    resulting flux in m3/day

    :math:`h_1` the reference state

    :math:`h_{target}` the state of the target (right) node

    :math:`t_c` the time to reach the target state

    C++ includes: simple_connections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    reaction_time = property(_cmf_core.ConstantStateFlux_reaction_time_get, _cmf_core.ConstantStateFlux_reaction_time_set, doc=r"""reaction_time : cmf::math::Time""")
    target_state = property(_cmf_core.ConstantStateFlux_target_state_get, _cmf_core.ConstantStateFlux_target_state_set, doc=r"""target_state : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ConstantStateFlux self, cmf::water::WaterStorage::ptr controlled_storage, cmf::water::flux_node::ptr other_end, real target_state, Time reaction_time) -> ConstantStateFlux
        ConstantStateFlux(cmf::water::WaterStorage::ptr controlled_storage,
        cmf::water::flux_node::ptr other_end, real target_state,
        cmf::math::Time reaction_time)
        cmf::water::ConstantStateFlux::ConstantStateFlux Creates a flux
        connection to control the state of a storage.

        Parameters:
        -----------

        controlled_storage:  Water storage, to be controlled

        other_end:  source of missing water or target of excessive water

        target_state:  State the controlled storage should hold (
        :math:`h_{target}`)

        reaction_time:  Time to reach state ( :math:`t_c`) 
        """
        _cmf_core.ConstantStateFlux_swiginit(self, _cmf_core.new_ConstantStateFlux(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ConstantStateFlux

# Register ConstantStateFlux in _cmf_core:
_cmf_core.ConstantStateFlux_swigregister(ConstantStateFlux)
class node_list(object):
    r"""


    A collection of nodes for fast access of the waterbalance.

    In setups with many storages and rather fast computations, the speed
    of data access for output generation can take a high portion of the
    total run time. To accelerate data access, one can use the node_list
    object

    Todo Add a get_volume / set_volume function pair, to complement
    get_potential / set_potential

    C++ includes: collections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size = _swig_new_instance_method(_cmf_core.node_list_size)

    def __init__(self, *args):
        r"""
        __init__(node_list self) -> node_list
        __init__(node_list self, node_list forcopy) -> node_list
        node_list(const cmf::water::node_list &forcopy)
        cmf::water::node_list::node_list Copy the node_list. 
        """
        _cmf_core.node_list_swiginit(self, _cmf_core.new_node_list(*args))
    __iadd__ = _swig_new_instance_method(_cmf_core.node_list___iadd__)
    __add__ = _swig_new_instance_method(_cmf_core.node_list___add__)
    __get = _swig_new_instance_method(_cmf_core.node_list___get)
    __getslice = _swig_new_instance_method(_cmf_core.node_list___getslice)
    __cmf_state_list_interface__ = _swig_new_instance_method(_cmf_core.node_list___cmf_state_list_interface__)
    append = _swig_new_instance_method(_cmf_core.node_list_append)
    remove = _swig_new_instance_method(_cmf_core.node_list_remove)
    get_potentials = _swig_new_instance_method(_cmf_core.node_list_get_potentials)
    global_water_balance = _swig_new_instance_method(_cmf_core.node_list_global_water_balance)
    water_balance = _swig_new_instance_method(_cmf_core.node_list_water_balance)
    conc = _swig_new_instance_method(_cmf_core.node_list_conc)
    get_fluxes_to = _swig_new_instance_method(_cmf_core.node_list_get_fluxes_to)
    get_fluxes3d_to = _swig_new_instance_method(_cmf_core.node_list_get_fluxes3d_to)
    get_fluxes3d = _swig_new_instance_method(_cmf_core.node_list_get_fluxes3d)
    get_positions = _swig_new_instance_method(_cmf_core.node_list_get_positions)
    __swig_destroy__ = _cmf_core.delete_node_list
    potentials = property(_cmf_core.node_list_potentials_get, _cmf_core.node_list_potentials_set, doc=r"""potentials : cmf::math::num_array""")

    def __getitem__(self,index):
        if isinstance(index,slice):
            return self.__getslice(*index.indices(self.size())) 
        else:
            try:
                it = iter(index)
                return node_list(self.__get(i) for i in it)
            except:
                return self.__get(index)

    def __len__(self):
        return self.size()       
    def __iter__(self):
        for i in range(self.size()):
            yield self[i]
    def __repr__(self):
        if len(self): return "[%i nodes: %s ... %s]" % (len(self),self[0], self[-1])
        else: return "[empty node list]"
    def extend(self,sequence):
        """Extends the node list with the sequence (any iterable will do) """
        for o in sequence:
            self.append(o)
    @staticmethod
    def from_sequence(sequence):
        """Returns a new node list populated from the sequence (any iterable will do) """
        nl=node_list()
        nl.extend(sequence)
        return nl


# Register node_list in _cmf_core:
_cmf_core.node_list_swigregister(node_list)
class NeumannBoundary_list(object):
    r"""


    Provides fast access to Neumann boundaries for flux update.

    If many Neumann boundary conditions are present in a project, a fast
    data exchange to update the fluxes might be needed.

    With this specialized list a num_array can be passed to the boundary
    conditions for a fast flux update If a multiple system layout for the
    cmf setup is chosen, we might have a node_list Dirichlet boundary
    conditions (dbc), a corresponding NeumannBoundary_list (nbc) of
    Neumann boundaries and a node_list containing the storages connected
    with the NeumannBoundary_list (storages). The fast data exchange is
    written in Python as:

    C++ includes: collections.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    get = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_get)
    get_fluxes = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_get_fluxes)
    append = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_append)
    size = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_size)

    def __init__(self, *args):
        r"""
        __init__(NeumannBoundary_list self) -> NeumannBoundary_list
        __init__(NeumannBoundary_list self, node_list copy) -> NeumannBoundary_list
        __init__(NeumannBoundary_list self, NeumannBoundary_list copy) -> NeumannBoundary_list
        NeumannBoundary_list(const NeumannBoundary_list &copy)
        cmf::water::NeumannBoundary_list::NeumannBoundary_list
        """
        _cmf_core.NeumannBoundary_list_swiginit(self, _cmf_core.new_NeumannBoundary_list(*args))
    to_node_list = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_to_node_list)
    global_water_balance = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_global_water_balance)
    water_balance = _swig_new_instance_method(_cmf_core.NeumannBoundary_list_water_balance)
    fluxes = property(_cmf_core.NeumannBoundary_list_fluxes_get, _cmf_core.NeumannBoundary_list_fluxes_set, doc=r"""fluxes : cmf::math::num_array""")

    def __getitem__(self,index):
        return self.get(index)
    def __len__(self):
        return self.size()       
    def __iter__(self):
        for i in range(self.size()):
            yield self[i]
    def extend(self,sequence):
        """Extends the list of Neumann boundaries with the sequence (any iterable will do) """
        for o in sequence:
            self.append(o)
    @staticmethod
    def from_sequence(sequence):
        """Returns a new list of Neumann boundaries populated from the sequence (any iterable will do) """
        nl=NeumannBoundary_list()
        nl.extend(sequence)
        return nl

    __swig_destroy__ = _cmf_core.delete_NeumannBoundary_list

# Register NeumannBoundary_list in _cmf_core:
_cmf_core.NeumannBoundary_list_swigregister(NeumannBoundary_list)
vapour_pressure = _cmf_core.vapour_pressure
vpd_from_rH = _cmf_core.vpd_from_rH
rH_from_vpd = _cmf_core.rH_from_vpd
watts_to_MJ = _cmf_core.watts_to_MJ
MJ_to_watts = _cmf_core.MJ_to_watts
extraterrestrial_radiation = _cmf_core.extraterrestrial_radiation
global_radiation = _cmf_core.global_radiation
Pressure = _cmf_core.Pressure
class Weather(object):
    r"""


    A structure holding meteorological information, excluding
    precipitation

    C++ includes: Weather.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    T = property(_cmf_core.Weather_T_get, _cmf_core.Weather_T_set, doc=r"""T : double""")
    Tmax = property(_cmf_core.Weather_Tmax_get, _cmf_core.Weather_Tmax_set, doc=r"""Tmax : double""")
    Tmin = property(_cmf_core.Weather_Tmin_get, _cmf_core.Weather_Tmin_set, doc=r"""Tmin : double""")
    Tground = property(_cmf_core.Weather_Tground_get, _cmf_core.Weather_Tground_set, doc=r"""Tground : double""")
    Windspeed = property(_cmf_core.Weather_Windspeed_get, _cmf_core.Weather_Windspeed_set, doc=r"""Windspeed : double""")
    e_a = property(_cmf_core.Weather_e_a_get, _cmf_core.Weather_e_a_set, doc=r"""e_a : double""")
    e_s = property(_cmf_core.Weather_e_s_get, _cmf_core.Weather_e_s_set, doc=r"""e_s : double""")
    sunshine = property(_cmf_core.Weather_sunshine_get, _cmf_core.Weather_sunshine_set, doc=r"""sunshine : double""")
    Rs = property(_cmf_core.Weather_Rs_get, _cmf_core.Weather_Rs_set, doc=r"""Rs : double""")
    Ra = property(_cmf_core.Weather_Ra_get, _cmf_core.Weather_Ra_set, doc=r"""Ra : double""")
    daylength = property(_cmf_core.Weather_daylength_get, _cmf_core.Weather_daylength_set, doc=r"""daylength : double""")
    instrument_height = property(_cmf_core.Weather_instrument_height_get, _cmf_core.Weather_instrument_height_set, doc=r"""instrument_height : double""")
    Rn = _swig_new_instance_method(_cmf_core.Weather_Rn)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Weather self, double T=15.0, double Tmax=17.0, double Tmin=13.0, double rH=70.0, double wind=2.0, double sunshine=0.5, double Rs=15, double Ra=30, double daylength=12) -> Weather
        Weather(double T=15.0, double Tmax=17.0, double Tmin=13.0, double
        rH=70.0, double wind=2.0, double sunshine=0.5, double Rs=15, double
        Ra=30, double daylength=12) cmf::atmosphere::Weather::Weather Creates
        a "weather" from given data.

        Parameters:
        -----------

        T:  actual Temperature in deg C

        Tmax:  daily maximum Temperature in deg C

        Tmin:  daily minimum Temperature in deg C

        rH:  actual relative humidity in % [0..100]

        wind:  actual wind speed in m/s

        sunshine:  actual fraction of sunshine duration per potential sunshine
        duration in h/h

        Rs:  actual incoming shortwave global radiation in MJ/(m2 day)

        Ra:  actual extraterrestrial shortwave global radiation in MJ/(m2 day)

        daylength:  length of the day in h 
        """
        _cmf_core.Weather_swiginit(self, _cmf_core.new_Weather(*args, **kwargs))
    to_string = _swig_new_instance_method(_cmf_core.Weather_to_string)
    set_snow_threshold = _swig_new_static_method(_cmf_core.Weather_set_snow_threshold)
    get_snow_threshold = _swig_new_static_method(_cmf_core.Weather_get_snow_threshold)
    __iadd__ = _swig_new_instance_method(_cmf_core.Weather___iadd__)
    __imul__ = _swig_new_instance_method(_cmf_core.Weather___imul__)
    __add__ = _swig_new_instance_method(_cmf_core.Weather___add__)
    __mul__ = _swig_new_instance_method(_cmf_core.Weather___mul__)

    def __repr__(self):
        return "cmf.Weather(Tmin=%0.2f,Tmax=%0.2f)" % (self.Tmin,self.Tmax)
    def __str__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_Weather

# Register Weather in _cmf_core:
_cmf_core.Weather_swigregister(Weather)
class Meteorology(object):
    r"""


    An abstract class, for objects generating Weather records at a
    specific time.

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_cmf_core.Meteorology___call__)
    get_weather = _swig_new_instance_method(_cmf_core.Meteorology_get_weather)
    copy = _swig_new_instance_method(_cmf_core.Meteorology_copy)
    get_instrument_height = _swig_new_instance_method(_cmf_core.Meteorology_get_instrument_height)
    __swig_destroy__ = _cmf_core.delete_Meteorology

# Register Meteorology in _cmf_core:
_cmf_core.Meteorology_swigregister(Meteorology)
class ConstantMeteorology(Meteorology):
    r"""


    A primitive implementation of the Meteorology interface.

    Holds a Weather record and returns it for any date

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    weather = property(_cmf_core.ConstantMeteorology_weather_get, _cmf_core.ConstantMeteorology_weather_set, doc=r"""weather : cmf::atmosphere::Weather""")

    def __init__(self, *args):
        r"""
        __init__(ConstantMeteorology self) -> ConstantMeteorology
        __init__(ConstantMeteorology self, Weather w) -> ConstantMeteorology
        __init__(ConstantMeteorology self, ConstantMeteorology other) -> ConstantMeteorology
        ConstantMeteorology(const cmf::atmosphere::Weather &w)
        cmf::atmosphere::ConstantMeteorology::ConstantMeteorology Creates a
        ConstantMeteorology with weather w. 
        """
        _cmf_core.ConstantMeteorology_swiginit(self, _cmf_core.new_ConstantMeteorology(*args))
    copy = _swig_new_instance_method(_cmf_core.ConstantMeteorology_copy)
    __swig_destroy__ = _cmf_core.delete_ConstantMeteorology

# Register ConstantMeteorology in _cmf_core:
_cmf_core.ConstantMeteorology_swigregister(ConstantMeteorology)
class MeteoStation(object):
    r"""


    A meteorological station holding timeseries to create Weather records.

    In order to calculate ETpot with cmf a big amount of meteorological
    data is needed, more data than usually available. The MeteoStation
    class can estimate missing data from a minimal set. As more data, as
    one provides, the better the calculation of ETpot becomes. The minimal
    data needed is Tmin and Tmax (daily) and precipitation. To calculate
    the global radiation (although measured global radiation could be
    inserted), the position of meteorological station in geographic
    coordinates has to be set.

    A meteorological station is created by
    cmf::atmosphere::MeteoStationList::add_station . Usage from python:

    There are two modes for the meteorology: daily=true and daily=false.
    If daily=true, Radiation is given as a daily mean value. If
    daily=false, Radiation is given as an hourly mean value, which shows
    the dial ETpot variation but results in erronous results if the
    timestep is daily.

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Latitude = property(_cmf_core.MeteoStation_Latitude_get, _cmf_core.MeteoStation_Latitude_set, doc=r"""Latitude : double""")
    Longitude = property(_cmf_core.MeteoStation_Longitude_get, _cmf_core.MeteoStation_Longitude_set, doc=r"""Longitude : double""")
    Timezone = property(_cmf_core.MeteoStation_Timezone_get, _cmf_core.MeteoStation_Timezone_set, doc=r"""Timezone : double""")
    x = property(_cmf_core.MeteoStation_x_get, _cmf_core.MeteoStation_x_set, doc=r"""x : double""")
    y = property(_cmf_core.MeteoStation_y_get, _cmf_core.MeteoStation_y_set, doc=r"""y : double""")
    z = property(_cmf_core.MeteoStation_z_get, _cmf_core.MeteoStation_z_set, doc=r"""z : double""")
    Name = property(_cmf_core.MeteoStation_Name_get, _cmf_core.MeteoStation_Name_set, doc=r"""Name : std::string""")
    get_position = _swig_new_instance_method(_cmf_core.MeteoStation_get_position)
    daily = property(_cmf_core.MeteoStation_daily_get, _cmf_core.MeteoStation_daily_set, doc=r"""daily : bool""")
    InstrumentHeight = property(_cmf_core.MeteoStation_InstrumentHeight_get, _cmf_core.MeteoStation_InstrumentHeight_set, doc=r"""InstrumentHeight : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(MeteoStation self, MeteoStation other) -> MeteoStation
        MeteoStation(const cmf::atmosphere::MeteoStation &other)
        cmf::atmosphere::MeteoStation::MeteoStation Copy c'tor. 
        """
        _cmf_core.MeteoStation_swiginit(self, _cmf_core.new_MeteoStation(*args, **kwargs))
    get_data = _swig_new_instance_method(_cmf_core.MeteoStation_get_data)
    use_for_cell = _swig_new_instance_method(_cmf_core.MeteoStation_use_for_cell)
    SetSunshineFraction = _swig_new_instance_method(_cmf_core.MeteoStation_SetSunshineFraction)
    T = property(_cmf_core.MeteoStation_T_get, _cmf_core.MeteoStation_T_set, doc=r"""T : cmf::math::timeseries""")
    Tmax = property(_cmf_core.MeteoStation_Tmax_get, _cmf_core.MeteoStation_Tmax_set, doc=r"""Tmax : cmf::math::timeseries""")
    Tmin = property(_cmf_core.MeteoStation_Tmin_get, _cmf_core.MeteoStation_Tmin_set, doc=r"""Tmin : cmf::math::timeseries""")
    Tground = property(_cmf_core.MeteoStation_Tground_get, _cmf_core.MeteoStation_Tground_set, doc=r"""Tground : cmf::math::timeseries""")
    Windspeed = property(_cmf_core.MeteoStation_Windspeed_get, _cmf_core.MeteoStation_Windspeed_set, doc=r"""Windspeed : cmf::math::timeseries""")
    rHmean = property(_cmf_core.MeteoStation_rHmean_get, _cmf_core.MeteoStation_rHmean_set, doc=r"""rHmean : cmf::math::timeseries""")
    rHmin = property(_cmf_core.MeteoStation_rHmin_get, _cmf_core.MeteoStation_rHmin_set, doc=r"""rHmin : cmf::math::timeseries""")
    rHmax = property(_cmf_core.MeteoStation_rHmax_get, _cmf_core.MeteoStation_rHmax_set, doc=r"""rHmax : cmf::math::timeseries""")
    Tdew = property(_cmf_core.MeteoStation_Tdew_get, _cmf_core.MeteoStation_Tdew_set, doc=r"""Tdew : cmf::math::timeseries""")
    Sunshine = property(_cmf_core.MeteoStation_Sunshine_get, _cmf_core.MeteoStation_Sunshine_set, doc=r"""Sunshine : cmf::math::timeseries""")
    Rs = property(_cmf_core.MeteoStation_Rs_get, _cmf_core.MeteoStation_Rs_set, doc=r"""Rs : cmf::math::timeseries""")
    T_lapse = property(_cmf_core.MeteoStation_T_lapse_get, _cmf_core.MeteoStation_T_lapse_set, doc=r"""T_lapse : cmf::math::timeseries""")

    def TimeseriesDictionary(self):
        return {"Tmin":self.Tmin,
                "Tmax":self.Tmax,
                "Tdew":self.Tdew,
                "T":self.T,
                "rHmean":self.rHmean,
                "rHmax":self.rHmax,
                "rHmin":self.rHmin,
                "Sunshine":self.Sunshine,
                "Windspeed":self.Windspeed,
                "Rs" : self.Rs}
    def __repr__(self):
        return "cmf.MeteoStation(%s,lat=%0.5g,lon=%0.5g,z=%6.1f)" % (self.Name,self.Latitude,self.Longitude,self.z)

    __swig_destroy__ = _cmf_core.delete_MeteoStation

# Register MeteoStation in _cmf_core:
_cmf_core.MeteoStation_swigregister(MeteoStation)
class MeteoStationReference(Meteorology):
    r"""


    A reference to a meteorological station.

    Returns the weather at a given time for its place using
    MeteoStation::T_lapse

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    get_station = _swig_new_instance_method(_cmf_core.MeteoStationReference_get_station)
    get_position = _swig_new_instance_method(_cmf_core.MeteoStationReference_get_position)

    def __init__(self, *args):
        r"""
        __init__(MeteoStationReference self, cmf::atmosphere::MeteoStation::ptr station, point location) -> MeteoStationReference
        __init__(MeteoStationReference self, MeteoStationReference copy) -> MeteoStationReference
        MeteoStationReference(MeteoStation::ptr station, cmf::geometry::point
        location)
        cmf::atmosphere::MeteoStationReference::MeteoStationReference Create a
        located reference to a meteo station.

        Parameters:
        -----------

        station:   MeteoStation

        location:  Location of the reference 
        """
        _cmf_core.MeteoStationReference_swiginit(self, _cmf_core.new_MeteoStationReference(*args))
    copy = _swig_new_instance_method(_cmf_core.MeteoStationReference_copy)
    __swig_destroy__ = _cmf_core.delete_MeteoStationReference

# Register MeteoStationReference in _cmf_core:
_cmf_core.MeteoStationReference_swigregister(MeteoStationReference)
class MeteoStationList(object):
    r"""


    A list of meteorological stations.

    Can find the nearest station for a position and calculate the
    temperature lapse

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __len__ = _swig_new_instance_method(_cmf_core.MeteoStationList___len__)
    __getitem__ = _swig_new_instance_method(_cmf_core.MeteoStationList___getitem__)
    calculate_Temp_lapse = _swig_new_instance_method(_cmf_core.MeteoStationList_calculate_Temp_lapse)
    add_station = _swig_new_instance_method(_cmf_core.MeteoStationList_add_station)
    remove_station = _swig_new_instance_method(_cmf_core.MeteoStationList_remove_station)

    def __init__(self, *args):
        r"""
        __init__(MeteoStationList self) -> MeteoStationList
        __init__(MeteoStationList self, MeteoStationList copy) -> MeteoStationList
        MeteoStationList(const MeteoStationList &copy)
        cmf::atmosphere::MeteoStationList::MeteoStationList Copy c'tor. 
        """
        _cmf_core.MeteoStationList_swiginit(self, _cmf_core.new_MeteoStationList(*args))
    reference_to_nearest = _swig_new_instance_method(_cmf_core.MeteoStationList_reference_to_nearest)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __repr__(self):
        return "list of %i cmf meteorological stations" % len(self)

    __swig_destroy__ = _cmf_core.delete_MeteoStationList

# Register MeteoStationList in _cmf_core:
_cmf_core.MeteoStationList_swigregister(MeteoStationList)
class IDW_Meteorology(Meteorology):
    r"""


    Regionalizes meteorological measurements using a simple inverse
    distance weighted (IDW) method.

    See:  IDW

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(IDW_Meteorology self, point position, MeteoStationList stations, double z_weight, double power) -> IDW_Meteorology
        __init__(IDW_Meteorology self, IDW_Meteorology copy) -> IDW_Meteorology
        IDW_Meteorology(const IDW_Meteorology &copy)
        cmf::atmosphere::IDW_Meteorology::IDW_Meteorology Copy c'tor. 
        """
        _cmf_core.IDW_Meteorology_swiginit(self, _cmf_core.new_IDW_Meteorology(*args))
    copy = _swig_new_instance_method(_cmf_core.IDW_Meteorology_copy)
    __swig_destroy__ = _cmf_core.delete_IDW_Meteorology

# Register IDW_Meteorology in _cmf_core:
_cmf_core.IDW_Meteorology_swigregister(IDW_Meteorology)
class aerodynamic_resistance(object):
    r"""


    Abstract class. Child classes can be used to calculate aerodynamic
    resistances against turbulent heat fluxes.

    C++ includes: meteorology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    get_aerodynamic_resistance = _swig_new_instance_method(_cmf_core.aerodynamic_resistance_get_aerodynamic_resistance)
    __swig_destroy__ = _cmf_core.delete_aerodynamic_resistance

# Register aerodynamic_resistance in _cmf_core:
_cmf_core.aerodynamic_resistance_swigregister(aerodynamic_resistance)
class RainSource(flux_node):
    r"""


    An abstract class for different types of rainfall sources.

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_cmf_core.RainSource___call__)
    get_intensity = _swig_new_instance_method(_cmf_core.RainSource_get_intensity)

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_RainSource

# Register RainSource in _cmf_core:
_cmf_core.RainSource_swigregister(RainSource)
class ConstantRainSource(RainSource):
    r"""


    A simple implementation of RainSource.

    Returns intensity for any time step.

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    intensity = property(_cmf_core.ConstantRainSource_intensity_get, _cmf_core.ConstantRainSource_intensity_set, doc=r"""intensity : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ConstantRainSource self, project _project, point location, real _intensity) -> ConstantRainSource
        ConstantRainSource(cmf::project &_project, cmf::geometry::point
        location, real _intensity)
        cmf::atmosphere::ConstantRainSource::ConstantRainSource Creates a new
        ConstantRainSource.

        Consider using Cell::set_rainfall for internal creation of a constant
        rain source, instead of direct use

        Parameters:
        -----------

        _project:  The project the rain source is belonging to.

        location:  The location of the rain source

        _intensity:  The constant rainfall intensity in mm/day 
        """
        _cmf_core.ConstantRainSource_swiginit(self, _cmf_core.new_ConstantRainSource(*args, **kwargs))
    set_conc = _swig_new_instance_method(_cmf_core.ConstantRainSource_set_conc)

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_ConstantRainSource

# Register ConstantRainSource in _cmf_core:
_cmf_core.ConstantRainSource_swigregister(ConstantRainSource)
class TimeseriesRainSource(RainSource):
    r"""


    A rainsource with a timeseries.

    Simpler to use than a rainfall station if there are only few cells in
    the project

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    data = property(_cmf_core.TimeseriesRainSource_data_get, _cmf_core.TimeseriesRainSource_data_set, doc=r"""data : cmf::math::timeseries""")
    concentrations = property(_cmf_core.TimeseriesRainSource_concentrations_get, _cmf_core.TimeseriesRainSource_concentrations_set, doc=r"""concentrations : cmf::water::SoluteTimeseries""")
    __swig_destroy__ = _cmf_core.delete_TimeseriesRainSource

# Register TimeseriesRainSource in _cmf_core:
_cmf_core.TimeseriesRainSource_swigregister(TimeseriesRainSource)
class RainfallStation(object):
    r"""


    RainfallStation describes a rainfall timeseries in mm/day at a certain
    place.

    Use RainfallStationReference or IDWRainfall to distribute the data
    into space

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    Location = property(_cmf_core.RainfallStation_Location_get, _cmf_core.RainfallStation_Location_set, doc=r"""Location : cmf::geometry::point""")
    create = _swig_new_static_method(_cmf_core.RainfallStation_create)
    id = property(_cmf_core.RainfallStation_id_get, doc=r"""id : q(const).size_t""")
    name = property(_cmf_core.RainfallStation_name_get, doc=r"""name : q(const).std::string""")
    data = property(_cmf_core.RainfallStation_data_get, _cmf_core.RainfallStation_data_set, doc=r"""data : cmf::math::timeseries""")
    __repr__ = _swig_new_instance_method(_cmf_core.RainfallStation___repr__)
    concentration = property(_cmf_core.RainfallStation_concentration_get, _cmf_core.RainfallStation_concentration_set, doc=r"""concentration : cmf::water::SoluteTimeseries""")
    use_for_cell = _swig_new_instance_method(_cmf_core.RainfallStation_use_for_cell)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(RainfallStation self, RainfallStation copy) -> RainfallStation
        RainfallStation(const RainfallStation &copy)
        cmf::atmosphere::RainfallStation::RainfallStation copy c'tor 
        """
        _cmf_core.RainfallStation_swiginit(self, _cmf_core.new_RainfallStation(*args, **kwargs))
    __call__ = _swig_new_instance_method(_cmf_core.RainfallStation___call__)
    __swig_destroy__ = _cmf_core.delete_RainfallStation

# Register RainfallStation in _cmf_core:
_cmf_core.RainfallStation_swigregister(RainfallStation)
class RainfallStationList(object):
    r"""


    A list of rainfall stations.

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __len__ = _swig_new_instance_method(_cmf_core.RainfallStationList___len__)
    __getitem__ = _swig_new_instance_method(_cmf_core.RainfallStationList___getitem__)
    add = _swig_new_instance_method(_cmf_core.RainfallStationList_add)
    remove = _swig_new_instance_method(_cmf_core.RainfallStationList_remove)

    def __repr__(self):
        return repr(list(self))
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]


    def __init__(self, *args, **kwargs):
        r"""__init__(RainfallStationList self) -> RainfallStationList"""
        _cmf_core.RainfallStationList_swiginit(self, _cmf_core.new_RainfallStationList(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_RainfallStationList

# Register RainfallStationList in _cmf_core:
_cmf_core.RainfallStationList_swigregister(RainfallStationList)
class RainfallStationReference(RainSource):
    r"""


    References a single RainfallStation to provide rainfall intensity
    data.

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    from_nearest_station = _swig_new_static_method(_cmf_core.RainfallStationReference_from_nearest_station)
    from_station_id = _swig_new_static_method(_cmf_core.RainfallStationReference_from_station_id)

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_RainfallStationReference

# Register RainfallStationReference in _cmf_core:
_cmf_core.RainfallStationReference_swigregister(RainfallStationReference)
class IDWRainfall(RainSource):
    r"""


    A RainSource using a spatially interpolated rainfall intensity from
    all stations.

    Interpolation method is inverse distance weighted (IDW)

    C++ includes: precipitation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    create = _swig_new_static_method(_cmf_core.IDWRainfall_create)

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_IDWRainfall

# Register IDWRainfall in _cmf_core:
_cmf_core.IDWRainfall_swigregister(IDWRainfall)
class Vegetation(object):
    r"""


    Holds the vegetation parameters for the calculation of ET and
    fractionating rainfall. Not every ET method uses all parameters.

    C++ includes: StructVegetation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    LAI = property(_cmf_core.Vegetation_LAI_get, _cmf_core.Vegetation_LAI_set, doc=r"""LAI : double""")
    Height = property(_cmf_core.Vegetation_Height_get, _cmf_core.Vegetation_Height_set, doc=r"""Height : double""")
    albedo = property(_cmf_core.Vegetation_albedo_get, _cmf_core.Vegetation_albedo_set, doc=r"""albedo : double""")
    snow_albedo = property(_cmf_core.Vegetation_snow_albedo_get, _cmf_core.Vegetation_snow_albedo_set, doc=r"""snow_albedo : double""")
    CanopyCapacityPerLAI = property(_cmf_core.Vegetation_CanopyCapacityPerLAI_get, _cmf_core.Vegetation_CanopyCapacityPerLAI_set, doc=r"""CanopyCapacityPerLAI : double""")
    RootDepth = property(_cmf_core.Vegetation_RootDepth_get, _cmf_core.Vegetation_RootDepth_set, doc=r"""RootDepth : double""")
    RootContent = property(_cmf_core.Vegetation_RootContent_get, _cmf_core.Vegetation_RootContent_set, doc=r"""RootContent : double""")
    fraction_at_rootdepth = property(_cmf_core.Vegetation_fraction_at_rootdepth_get, _cmf_core.Vegetation_fraction_at_rootdepth_set, doc=r"""fraction_at_rootdepth : double""")
    StomatalResistance = property(_cmf_core.Vegetation_StomatalResistance_get, _cmf_core.Vegetation_StomatalResistance_set, doc=r"""StomatalResistance : double""")
    CanopyClosure = property(_cmf_core.Vegetation_CanopyClosure_get, _cmf_core.Vegetation_CanopyClosure_set, doc=r"""CanopyClosure : double""")
    CanopyPARExtinction = property(_cmf_core.Vegetation_CanopyPARExtinction_get, _cmf_core.Vegetation_CanopyPARExtinction_set, doc=r"""CanopyPARExtinction : double""")
    LeafWidth = property(_cmf_core.Vegetation_LeafWidth_get, _cmf_core.Vegetation_LeafWidth_set, doc=r"""LeafWidth : double""")
    RootLength = _swig_new_instance_method(_cmf_core.Vegetation_RootLength)
    RootFraction = _swig_new_instance_method(_cmf_core.Vegetation_RootFraction)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Vegetation self, double _LAI=2.88, double _Height=0.12, double _RootDepth=0.25, double _StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1, double _CanopyCapacityPerLAI=0.1, double _fraction_at_rootdepth=1.0) -> Vegetation
        Vegetation(double
        _LAI=2.88, double _Height=0.12, double _RootDepth=0.25, double
        _StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
        double _CanopyCapacityPerLAI=0.1, double _fraction_at_rootdepth=1.0)
        cmf::upslope::vegetation::Vegetation::Vegetation
        """
        _cmf_core.Vegetation_swiginit(self, _cmf_core.new_Vegetation(*args, **kwargs))
    __repr__ = _swig_new_instance_method(_cmf_core.Vegetation___repr__)
    __swig_destroy__ = _cmf_core.delete_Vegetation

# Register Vegetation in _cmf_core:
_cmf_core.Vegetation_swigregister(Vegetation)
class CellConnector(object):
    r"""


    A helper class to connect cells with flux_connection objects. This is
    generated by flux_connection classes, intended to connect cells.

    C++ includes: cell.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(CellConnector self, cmf::upslope::connectorfunction connector) -> CellConnector
        CellConnector(connectorfunction connector)
        cmf::upslope::CellConnector::CellConnector
        """
        _cmf_core.CellConnector_swiginit(self, _cmf_core.new_CellConnector(*args, **kwargs))
    __call__ = _swig_new_instance_method(_cmf_core.CellConnector___call__)
    connect = _swig_new_instance_method(_cmf_core.CellConnector_connect)
    __swig_destroy__ = _cmf_core.delete_CellConnector

# Register CellConnector in _cmf_core:
_cmf_core.CellConnector_swigregister(CellConnector)
class Cell(object):
    r"""


    This class is the basic landscape object.

    It is the owner of water storages, and the upper and lower boundary
    conditions of the system (rainfall, atmospheric vapor, deep
    groundwater)

    C++ includes: cell.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_cmf_core.Cell_x_get, _cmf_core.Cell_x_set, doc=r"""x : double""")
    y = property(_cmf_core.Cell_y_get, _cmf_core.Cell_y_set, doc=r"""y : double""")
    z = property(_cmf_core.Cell_z_get, _cmf_core.Cell_z_set, doc=r"""z : double""")
    get_position = _swig_new_instance_method(_cmf_core.Cell_get_position)
    m3_to_mm = _swig_new_instance_method(_cmf_core.Cell_m3_to_mm)
    mm_to_m3 = _swig_new_instance_method(_cmf_core.Cell_mm_to_m3)
    InvalidateSatDepth = _swig_new_instance_method(_cmf_core.Cell_InvalidateSatDepth)
    vegetation = property(_cmf_core.Cell_vegetation_get, _cmf_core.Cell_vegetation_set, doc=r"""vegetation : cmf::upslope::vegetation::Vegetation""")
    set_aerodynamic_resistance = _swig_new_instance_method(_cmf_core.Cell_set_aerodynamic_resistance)
    set_weather = _swig_new_instance_method(_cmf_core.Cell_set_weather)
    set_rainfall = _swig_new_instance_method(_cmf_core.Cell_set_rainfall)
    get_rainfall = _swig_new_instance_method(_cmf_core.Cell_get_rainfall)
    __set_rain_source = _swig_new_instance_method(_cmf_core.Cell___set_rain_source)
    __get_rain_source = _swig_new_instance_method(_cmf_core.Cell___get_rain_source)
    set_uptakestress = _swig_new_instance_method(_cmf_core.Cell_set_uptakestress)
    __get_evaporation = _swig_new_instance_method(_cmf_core.Cell___get_evaporation)
    __get_transpiration = _swig_new_instance_method(_cmf_core.Cell___get_transpiration)
    get_surfacewater = _swig_new_instance_method(_cmf_core.Cell_get_surfacewater)
    surfacewater_as_storage = _swig_new_instance_method(_cmf_core.Cell_surfacewater_as_storage)
    add_storage = _swig_new_instance_method(_cmf_core.Cell_add_storage)
    remove_storage = _swig_new_instance_method(_cmf_core.Cell_remove_storage)
    storage_count = _swig_new_instance_method(_cmf_core.Cell_storage_count)
    get_storage = _swig_new_instance_method(_cmf_core.Cell_get_storage)
    get_canopy = _swig_new_instance_method(_cmf_core.Cell_get_canopy)
    get_snow = _swig_new_instance_method(_cmf_core.Cell_get_snow)
    snow_coverage = _swig_new_instance_method(_cmf_core.Cell_snow_coverage)
    albedo = _swig_new_instance_method(_cmf_core.Cell_albedo)
    surface_water_coverage = _swig_new_instance_method(_cmf_core.Cell_surface_water_coverage)
    heat_flux = _swig_new_instance_method(_cmf_core.Cell_heat_flux)
    Tground = property(_cmf_core.Cell_Tground_get, _cmf_core.Cell_Tground_set, doc=r"""Tground : real""")
    leave_wetness = _swig_new_instance_method(_cmf_core.Cell_leave_wetness)
    Id = property(_cmf_core.Cell_Id_get, _cmf_core.Cell_Id_set, doc=r"""Id : ptrdiff_t""")
    get_WKB = _swig_new_instance_method(_cmf_core.Cell_get_WKB)
    set_WKB = _swig_new_instance_method(_cmf_core.Cell_set_WKB)
    get_weather = _swig_new_instance_method(_cmf_core.Cell_get_weather)
    layer_count = _swig_new_instance_method(_cmf_core.Cell_layer_count)
    get_layer = _swig_new_instance_method(_cmf_core.Cell_get_layer)
    add_layer = _swig_new_instance_method(_cmf_core.Cell_add_layer)
    remove_last_layer = _swig_new_instance_method(_cmf_core.Cell_remove_last_layer)
    remove_layers = _swig_new_instance_method(_cmf_core.Cell_remove_layers)
    __swig_destroy__ = _cmf_core.delete_Cell

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Cell self, double x, double y, double z, double area, project _project) -> Cell
        Cell(double x,
        double y, double z, double area, cmf::project &_project)
        cmf::upslope::Cell::Cell
        """
        _cmf_core.Cell_swiginit(self, _cmf_core.new_Cell(*args, **kwargs))
    to_string = _swig_new_instance_method(_cmf_core.Cell_to_string)
    __cmf_state_list_interface__ = _swig_new_instance_method(_cmf_core.Cell___cmf_state_list_interface__)
    topology = property(_cmf_core.Cell_topology_get, doc=r"""topology : cmf::upslope::Topology""")

    evaporation = property(fget=_cmf_core.Cell___get_evaporation)


    transpiration = property(fget=_cmf_core.Cell___get_transpiration)

    meteorology = property(_cmf_core.Cell_meteorology_get, _cmf_core.Cell_meteorology_set, doc=r"""meteorology : cmf::atmosphere::Meteorology""")

    rain_source = property(fget=_cmf_core.Cell___get_rain_source,
                    fset=_cmf_core.Cell___set_rain_source)

    layers = property(_cmf_core.Cell_layers_get, doc=r"""layers : cmf::upslope::layer_list""")
    project = property(_cmf_core.Cell_project_get, doc=r"""project : cmf::project""")
    saturated_depth = property(_cmf_core.Cell_saturated_depth_get, _cmf_core.Cell_saturated_depth_set, doc=r"""saturated_depth : real""")
    area = property(_cmf_core.Cell_area_get, doc=r"""area : real""")
    soildepth = property(_cmf_core.Cell_soildepth_get, doc=r"""soildepth : real""")

    @property
    def surface_storages(self):
        "Provides access to all surface storages of the cell, like canopy, snow, surface water etc"
        return [self.get_storage(i) for i in range(self.storage_count())]
    @property
    def storages(self):
        "Provides access to all storages of the cell (surface storages and layers)"
        return self.surface_storages + list(self.layers)

    @property
    def neighbors(self):
        c_iter=neighbor_iterator(self)
        while c_iter.valid():
            yield (c_iter.cell(),c_iter.flowwidth())
            c_iter.next_neighbor()

    surfacewater=property(get_surfacewater, None, doc="Gives access to the surface water, which is either a distributing flux node, or the storage for all surface water")
    canopy=property(get_canopy, None, doc="The canopy water storage of the cell, if it exists")
    snow=property(get_snow, None, doc="The snow pack of the cell, if a storage for the snow exists")

    contributing_area=property(lambda self:self.topology.ContributingArea(), None, doc="Contributing area of this cell m2")
    main_outlet=property(lambda self:self.topology.MainOutlet(), None, doc="The main outlet of the surface water of this cell")

    def connect_soil_with_node(self,node,ctype,flowwidth,distance,upper_boundary=0,lower_boundary=None):
        """Connects all layers between the boundaries with a node using a flux connection
        node: Target node (flux_node)
        type: Type of the connection (e.g. cmf.Richards_lateral)
        flowwidth: Width of the connection
        distance: distance of the connection
        upper_boundary: Connect only layers, whose lower depth is greater then this value
        lower_boundary: Connect only  layers, whose upper depth is smaller then this value
        """
        if lower_boundary is None:
            lower_boundary=self.soildepth
        connections=[ctype(l,node,flowwidth,distance) 
                     for l in self.layers 
                     if     l.boundary[0]<lower_boundary 
                        and l.boundary[1]>upper_boundary 
                    ]

    def install_connection(self,connection_type):
        """Calls the static use_for_cell method of the connection_type, if present.
        The use_for_cell method might do quite a lot of stuff, please consult the docs for the connection.
        Eg. >>>help(Richards.use_for_cell) 
        """
        if hasattr(connection_type,"use_for_cell"):
            connection_type.use_for_cell(self)
        else:
            raise TypeError("Only connection types implementing a static use_for_cell function can be used")
    def __hash__(self):
        return hash((self.x,self.y,self.Id))
    def __eq__(self,cmp):
        return hash(self)==hash(cmp)
    def __repr__(self):
        return "cell #%i(%g,%g,%g)" % (self.Id,self.x,self.y,self.z)


# Register Cell in _cmf_core:
_cmf_core.Cell_swigregister(Cell)
class Topology(object):
    r"""


    represents the connectivity of cells to each other

    C++ includes: Topology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    cell = property(_cmf_core.Topology_cell_get, doc=r"""cell : q(const).p.cmf::upslope::Cell""")
    x = property(_cmf_core.Topology_x_get, _cmf_core.Topology_x_set, doc=r"""x : r.double""")
    y = property(_cmf_core.Topology_y_get, _cmf_core.Topology_y_set, doc=r"""y : r.double""")
    z = property(_cmf_core.Topology_z_get, _cmf_core.Topology_z_set, doc=r"""z : r.double""")
    get_position = _swig_new_instance_method(_cmf_core.Topology_get_position)
    flowwidth = _swig_new_instance_method(_cmf_core.Topology_flowwidth)
    AddNeighbor = _swig_new_instance_method(_cmf_core.Topology_AddNeighbor)
    RemoveNeighbor = _swig_new_instance_method(_cmf_core.Topology_RemoveNeighbor)
    neighbor_count = _swig_new_instance_method(_cmf_core.Topology_neighbor_count)
    MainOutlet = _swig_new_instance_method(_cmf_core.Topology_MainOutlet)
    ContributingArea = _swig_new_instance_method(_cmf_core.Topology_ContributingArea)
    calculate_contributing_area = _swig_new_static_method(_cmf_core.Topology_calculate_contributing_area)
    __eq__ = _swig_new_instance_method(_cmf_core.Topology___eq__)
    __swig_destroy__ = _cmf_core.delete_Topology

# Register Topology in _cmf_core:
_cmf_core.Topology_swigregister(Topology)
class neighbor_iterator(object):
    r"""


    A class to iterate through the neighbors of a cell (const). Not needed
    from the Python side, use the generator cell.neighbors instead.

    C++ includes: Topology.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(neighbor_iterator self, Cell cell) -> neighbor_iterator
        neighbor_iterator(cmf::upslope::Topology &topo)
        cmf::upslope::neighbor_iterator::neighbor_iterator
        """
        _cmf_core.neighbor_iterator_swiginit(self, _cmf_core.new_neighbor_iterator(*args, **kwargs))
    cell = _swig_new_instance_method(_cmf_core.neighbor_iterator_cell)
    flowwidth = _swig_new_instance_method(_cmf_core.neighbor_iterator_flowwidth)
    valid = _swig_new_instance_method(_cmf_core.neighbor_iterator_valid)
    next_neighbor = _swig_new_instance_method(_cmf_core.neighbor_iterator_next_neighbor)
    __eq__ = _swig_new_instance_method(_cmf_core.neighbor_iterator___eq__)
    __neq__ = _swig_new_instance_method(_cmf_core.neighbor_iterator___neq__)
    __swig_destroy__ = _cmf_core.delete_neighbor_iterator

# Register neighbor_iterator in _cmf_core:
_cmf_core.neighbor_iterator_swigregister(neighbor_iterator)
class cell_vector(object):
    r"""


    A cell vector holds a bunch of cells.

    C++ includes: cell_vector.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(cell_vector self) -> cell_vector
        __init__(cell_vector self, cell_vector copy) -> cell_vector
        cell_vector(const cell_vector &copy)
        cmf::upslope::cell_vector::cell_vector
        """
        _cmf_core.cell_vector_swiginit(self, _cmf_core.new_cell_vector(*args))
    __getitem__ = _swig_new_instance_method(_cmf_core.cell_vector___getitem__)
    append = _swig_new_instance_method(_cmf_core.cell_vector_append)
    remove = _swig_new_instance_method(_cmf_core.cell_vector_remove)
    pop = _swig_new_instance_method(_cmf_core.cell_vector_pop)
    __len__ = _swig_new_instance_method(_cmf_core.cell_vector___len__)
    __getslice__ = _swig_new_instance_method(_cmf_core.cell_vector___getslice__)
    get_area = _swig_new_instance_method(_cmf_core.cell_vector_get_area)
    __contains__ = _swig_new_instance_method(_cmf_core.cell_vector___contains__)
    __swig_destroy__ = _cmf_core.delete_cell_vector
    lowest = property(_cmf_core.cell_vector_lowest_get, doc=r"""lowest : cmf::upslope::Cell""")
    highest = property(_cmf_core.cell_vector_highest_get, doc=r"""highest : cmf::upslope::Cell""")

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]   
    def __repr__(self):
        if len(self):
            return "[%i cells, %0.0fm2, %0.0f - %0.0f m asl.]" % (len(self),self.get_area(),self.lowest.z,self.highest.z)
        else:
            return "<empty cell vector>"        


# Register cell_vector in _cmf_core:
_cmf_core.cell_vector_swigregister(cell_vector)
find_cell = _cmf_core.find_cell
get_boundary_cells = _cmf_core.get_boundary_cells
get_connections = _cmf_core.get_connections
connect_cells_with_flux = _cmf_core.connect_cells_with_flux
fill_sinks = _cmf_core.fill_sinks
get_area = _cmf_core.get_area
get_center = _cmf_core.get_center
cell_positions = _cmf_core.cell_positions
cell_flux_directions = _cmf_core.cell_flux_directions
cell2cellflux = _cmf_core.cell2cellflux
cell_distance = _cmf_core.cell_distance
class subcatchment(object):
    r"""


    A class to structure cells in a project using their main outlets.

    C++ includes: algorithm.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pourpoint = property(_cmf_core.subcatchment_pourpoint_get, doc=r"""pourpoint : r.q(const).cmf::upslope::Cell""")
    inflowcells = property(_cmf_core.subcatchment_inflowcells_get, doc=r"""inflowcells : cmf::upslope::cell_vector""")
    cells = property(_cmf_core.subcatchment_cells_get, doc=r"""cells : cmf::upslope::cell_vector""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(subcatchment self, Cell pourpoint, double area_threshold=1e308) -> subcatchment
        subcatchment(cmf::upslope::Cell &pourpoint, double
        area_threshold=1e308) cmf::upslope::subcatchment::subcatchment Creates
        a subcatchment from a pourpoint cell.

        Parameters:
        -----------

        pourpoint:  The pourpoint (outlet of the subcatchment)

        area_threshold:  Minimum contributing area size to form a
        subcatchment. When area_threshold > area(cells), all upslope cells of
        pourpoint are used. 
        """
        _cmf_core.subcatchment_swiginit(self, _cmf_core.new_subcatchment(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_subcatchment

# Register subcatchment in _cmf_core:
_cmf_core.subcatchment_swigregister(subcatchment)
pressure_to_waterhead = _cmf_core.pressure_to_waterhead
waterhead_to_pressure = _cmf_core.waterhead_to_pressure
pF_to_waterhead = _cmf_core.pF_to_waterhead
waterhead_to_pF = _cmf_core.waterhead_to_pF
class RetentionCurve(object):
    r"""


    Abstract base class for different types of retention curves.

    This class, and its children uses wetness instead of volumetric water
    content. The wetness of a soil is defined as water content per void
    volume

    C++ includes: RetentionCurve.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    K = _swig_new_instance_method(_cmf_core.RetentionCurve_K)
    Wetness_eff = _swig_new_instance_method(_cmf_core.RetentionCurve_Wetness_eff)
    Porosity = _swig_new_instance_method(_cmf_core.RetentionCurve_Porosity)
    VoidVolume = _swig_new_instance_method(_cmf_core.RetentionCurve_VoidVolume)
    FillHeight = _swig_new_instance_method(_cmf_core.RetentionCurve_FillHeight)
    Diffusivity = _swig_new_instance_method(_cmf_core.RetentionCurve_Diffusivity)
    Wetness = _swig_new_instance_method(_cmf_core.RetentionCurve_Wetness)
    theta = _swig_new_instance_method(_cmf_core.RetentionCurve_theta)
    dPsiM_dW = _swig_new_instance_method(_cmf_core.RetentionCurve_dPsiM_dW)
    Wetness_pF = _swig_new_instance_method(_cmf_core.RetentionCurve_Wetness_pF)
    MatricPotential = _swig_new_instance_method(_cmf_core.RetentionCurve_MatricPotential)
    copy = _swig_new_instance_method(_cmf_core.RetentionCurve_copy)
    __swig_destroy__ = _cmf_core.delete_RetentionCurve

# Register RetentionCurve in _cmf_core:
_cmf_core.RetentionCurve_swigregister(RetentionCurve)
rho_wg = cvar.rho_wg

class BrooksCoreyRetentionCurve(RetentionCurve):
    r"""


    Provides the use of the Brooks-Corey retention curve.



    .. math::

         W(\\theta) &=& \\frac{\\theta -
        \\theta_r}{\\theta_s - \\theta_r} \\\\ K(W) &=& K_{sat}
        W^{2b+3} \\\\ \\Psi(W) &=& \\Psi_X
        \\left(\\frac{W}{W_X}\\right)^{-b} \\\\ W(\\Psi) &=&
        {\\left( \\frac{\\Psi_X}{\\Psi}\\right)
        }^{\\frac{1}{b}}\\ W_X 

     where:  :math:`K` is the
    conductivity in :math:`\\frac m{day}`

    :math:`W` is the wetness (Volume of soil water per volume of pores)

    :math:`b` is the shape of the retention curve (usually between 4 (sand) and
    14 (clay))

    :math:`\\Psi(W)` is the matric potential in :math:`m H_2O` at wetness W

    :math:`\\Psi_X` is a matric potential at a known wetness in :math:`m H_2O`

    :math:`W_X` is the wetness with a known matric potential for dynamic changes
    with depth, exponential decays of porosity and saturated conductivity
    are used The decay function is: :math:`v(d)=v(0) (1+a)^{-d}`, where v is
    the value ( :math:`K_{sat},\\Phi`), d is the depth in m and a is the
    fractional decay per m. E.g. 0.1 means the value has in 1 m depth 90%
    of the value at the surface

    C++ includes: RetentionCurve.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Ksat = property(_cmf_core.BrooksCoreyRetentionCurve_Ksat_get, _cmf_core.BrooksCoreyRetentionCurve_Ksat_set, doc=r"""Ksat : real""")
    SetPorosity = _swig_new_instance_method(_cmf_core.BrooksCoreyRetentionCurve_SetPorosity)
    Transmissivity = _swig_new_instance_method(_cmf_core.BrooksCoreyRetentionCurve_Transmissivity)
    wetness_X = property(_cmf_core.BrooksCoreyRetentionCurve_wetness_X_get, _cmf_core.BrooksCoreyRetentionCurve_wetness_X_set, doc=r"""wetness_X : real""")
    Psi_X = property(_cmf_core.BrooksCoreyRetentionCurve_Psi_X_get, _cmf_core.BrooksCoreyRetentionCurve_Psi_X_set, doc=r"""Psi_X : real""")
    residual_theta = property(_cmf_core.BrooksCoreyRetentionCurve_residual_theta_get, _cmf_core.BrooksCoreyRetentionCurve_residual_theta_set, doc=r"""residual_theta : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(BrooksCoreyRetentionCurve self, real ksat=15, real porosity=0.5, real _b=5, real theta_x=0.2, real psi_x=cmf::upslope::pF_to_waterhead(2.5), real porosity_decay=0) -> BrooksCoreyRetentionCurve
        BrooksCoreyRetentionCurve(real ksat=15, real porosity=0.5, real _b=5,
        real theta_x=0.2, real psi_x=pF_to_waterhead(2.5), real
        porosity_decay=0)
        cmf::upslope::BrooksCoreyRetentionCurve::BrooksCoreyRetentionCurve
        Creates a brooks corey retention curve.

        Parameters:
        -----------

        ksat:  Saturated conductivity :math:`\\frac{m}{day}`

        porosity:   :math:`\\frac{m^3 Pores}{m^3 Soil}`

        _b:  Shape of the retention curve (if you do not know how to
        parameterize this, take a look at the other constructor)

        theta_x:   :math:`\\theta_X` Water content at a specific suction pressure

        psi_x:  Suction pressure for :math:`\\theta_X` in m water column, use the
        conversion functions pF_to_waterhead, pressure_to_waterhead to convert
        pressure in to waterhead height (default pF=2.5)

        porosity_decay:  Relative decay of porosity with depth, e.g. 0.1 means
        conductivity gets 10% smaller per meter 
        """
        _cmf_core.BrooksCoreyRetentionCurve_swiginit(self, _cmf_core.new_BrooksCoreyRetentionCurve(*args, **kwargs))
    CreateFrom2Points = _swig_new_static_method(_cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points)
    copy = _swig_new_instance_method(_cmf_core.BrooksCoreyRetentionCurve_copy)
    __swig_destroy__ = _cmf_core.delete_BrooksCoreyRetentionCurve
    b = property(_cmf_core.BrooksCoreyRetentionCurve_b_get, _cmf_core.BrooksCoreyRetentionCurve_b_set, doc=r"""b : real""")

    def __repr__(self):
        return "cmf.BrooksCoreyRetentionCurve(Ksat=%g,phi=%g,b=%g,wfp0=%0.1f,pF0=%0.2f)" % (self.Ksat,self.Porosity(0.0),self.b,self.wetness_X,waterhead_to_pF(self.Psi_X))
    def __str__(self):
        return "Brooks-Corey retention curve: Ksat=%0.3g m/day,por.=%0.0f%%,b=%g,%0.1f%% water content at pF%0.2f)" % (self.Ksat,self.Porosity(0.0)*100,self.b,self.wetness_X * self.Porosity(0.0) * 100,waterhead_to_pF(self.Psi_X))


# Register BrooksCoreyRetentionCurve in _cmf_core:
_cmf_core.BrooksCoreyRetentionCurve_swigregister(BrooksCoreyRetentionCurve)
class VanGenuchtenMualem(RetentionCurve):
    r"""


    Provides the use of the Van Genuchten - Mualem retention curve (Van
    Genuchten 1980)

    Head - moisture relationship: 

    .. math::

         W(\\theta) &=&
        \\frac{\\theta - \\theta_r}{\\theta_s - \\theta_r} \\\\
        K(W) &=& K_{sat} \\sqrt{W}
        \\left(1-\\left(1-W^{1/m}\\right)^m\\right)^2 \\\\ m &=&
        1-\\frac 1 n \\\\ \\Psi(W) &=& 0.01 \\frac{m}{cm}
        \\frac{{\\left(1-{W}^{\\frac{1}{m}}\\right)
        }^{\\frac{1}{n}}}{\\alpha\\,{W}^{\\frac{1}{m\\,n}}} \\\\
        W(\\Psi) &=&
        \\left(1+\\left(\\alpha\\,100\\frac{cm}{m}\\Psi\\right)^n\\right)^{-m}


     where:  :math:`K` is the conductivity in :math:`\\frac m{day}`

    :math:`W` is the wetness (Volume of soil water per volume of pores)

    :math:`n` is a shape parameter of the retention curve

    :math:`\\alpha` is inverse of the air entry potential in :math:`cm^{-1}`

    :math:`\\Psi(W)` is the matric potential in :math:`m H_2O` at wetness W

    C++ includes: RetentionCurve.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    alpha = property(_cmf_core.VanGenuchtenMualem_alpha_get, _cmf_core.VanGenuchtenMualem_alpha_set, doc=r"""alpha : real""")
    n = property(_cmf_core.VanGenuchtenMualem_n_get, _cmf_core.VanGenuchtenMualem_n_set, doc=r"""n : real""")
    Ksat = property(_cmf_core.VanGenuchtenMualem_Ksat_get, _cmf_core.VanGenuchtenMualem_Ksat_set, doc=r"""Ksat : real""")
    Phi = property(_cmf_core.VanGenuchtenMualem_Phi_get, _cmf_core.VanGenuchtenMualem_Phi_set, doc=r"""Phi : real""")
    m = property(_cmf_core.VanGenuchtenMualem_m_get, _cmf_core.VanGenuchtenMualem_m_set, doc=r"""m : real""")
    l = property(_cmf_core.VanGenuchtenMualem_l_get, _cmf_core.VanGenuchtenMualem_l_set, doc=r"""l : real""")
    theta_r = property(_cmf_core.VanGenuchtenMualem_theta_r_get, _cmf_core.VanGenuchtenMualem_theta_r_set, doc=r"""theta_r : real""")
    w0 = property(_cmf_core.VanGenuchtenMualem_w0_get, _cmf_core.VanGenuchtenMualem_w0_set, doc=r"""w0 : real""")
    Transmissivity = _swig_new_instance_method(_cmf_core.VanGenuchtenMualem_Transmissivity)
    fit_w0 = _swig_new_instance_method(_cmf_core.VanGenuchtenMualem_fit_w0)
    copy = _swig_new_instance_method(_cmf_core.VanGenuchtenMualem_copy)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(VanGenuchtenMualem self, real Ksat=15, real phi=0.5, real alpha=0.2178, real n=1.211, real m=-1, real theta_r=0.0, real w0=0.99) -> VanGenuchtenMualem
        VanGenuchtenMualem(real Ksat=15, real phi=0.5, real alpha=0.2178, real
        n=1.211, real m=-1, real theta_r=0.0, real w0=0.99)
        cmf::upslope::VanGenuchtenMualem::VanGenuchtenMualem Creates a van
        Genuchten-Mualem retention curve.

        Parameters:
        -----------

        Ksat:  Saturated conductivity in :math:`\\frac m{day}`

        phi:  Porosity in :math:`\\frac{m^3 Pores}{m^3 Soil}`

        alpha:  Van Genuchten :math:`\\alpha` in :math:`\\frac 1{cm}`

        n:  Van Genuchten n

        m:  Van Genuchten m parameter, if negative m is calculated as :math:`1-\\frac 1 n`

        theta_r:  Water content for :math:`\\lim\\limits_{\\Psi_M \\rightarrow -\\infty}{\\theta(\\Psi_M)}`

        w0:  Wetness above the parabolic extrapolation is used instead of the
        Van Genuchten curve (usually calculated with fit_w0) 
        """
        _cmf_core.VanGenuchtenMualem_swiginit(self, _cmf_core.new_VanGenuchtenMualem(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_VanGenuchtenMualem


    def __repr__(self):
        return "cmf.VanGenuchtenMualem(Ksat=%0.3g,Phi=%0.3g,alpha=%0.3g,n=%0.3g,m=%0.3g)" % (self.Ksat,self.Phi,self.alpha,self.n,self.m)

    def __str__(self):
        return "VanGenuchten / Mualem retention curve: Ksat=%0.3g m/day, %0.3g%% Pores, alpha=%0.3g 1/cm, n=%0.3g" % (self.Ksat,self.Phi*100,self.alpha,self.n)


# Register VanGenuchtenMualem in _cmf_core:
_cmf_core.VanGenuchtenMualem_swigregister(VanGenuchtenMualem)
class LinearRetention(RetentionCurve):
    r"""


    The linear retention curve provides a simple linear relationship
    between storage and head.

    Head function (head in m, calculated from upper side control volume)


    .. math::

         h(\\theta) = -\\Delta z \\left( 1 - \\frac{\\theta -
        \\theta_r}{\\theta_s - \\theta_r} \\right) 

    Conductivity
    function 

    .. math::

         K(\\theta) = K_{sat}  \\left(\\frac{\\theta -
        \\theta_r}{\\theta_s - \\theta_r}\\right)^\\beta 

    C++ includes: RetentionCurve.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Ksat = property(_cmf_core.LinearRetention_Ksat_get, _cmf_core.LinearRetention_Ksat_set, doc=r"""Ksat : real""")
    porosity = property(_cmf_core.LinearRetention_porosity_get, _cmf_core.LinearRetention_porosity_set, doc=r"""porosity : real""")
    thickness = property(_cmf_core.LinearRetention_thickness_get, _cmf_core.LinearRetention_thickness_set, doc=r"""thickness : real""")
    residual_wetness = property(_cmf_core.LinearRetention_residual_wetness_get, _cmf_core.LinearRetention_residual_wetness_set, doc=r"""residual_wetness : real""")
    porosity_decay = property(_cmf_core.LinearRetention_porosity_decay_get, _cmf_core.LinearRetention_porosity_decay_set, doc=r"""porosity_decay : real""")
    beta = property(_cmf_core.LinearRetention_beta_get, _cmf_core.LinearRetention_beta_set, doc=r"""beta : real""")
    Transmissivity = _swig_new_instance_method(_cmf_core.LinearRetention_Transmissivity)
    copy = _swig_new_instance_method(_cmf_core.LinearRetention_copy)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(LinearRetention self, real ksat, real phi, real thickness, real residual_wetness=0.1) -> LinearRetention
        LinearRetention(real ksat, real phi, real thickness, real
        residual_wetness=0.1) cmf::upslope::LinearRetention::LinearRetention
        """
        _cmf_core.LinearRetention_swiginit(self, _cmf_core.new_LinearRetention(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_LinearRetention

# Register LinearRetention in _cmf_core:
_cmf_core.LinearRetention_swigregister(LinearRetention)
class conductable(object):
    r"""


    An abstract interface for all classes providing a conductivity (e.g.

    soil layer or aquifer) Each water storage where the concept of
    conductivity is applicable should implement (by deriving) the
    interface

    This class is not part of the Python interface, since a dynamic typed
    language can use duck typing instead of this interface

    C++ includes: conductable.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    get_K = _swig_new_instance_method(_cmf_core.conductable_get_K)
    cast = _swig_new_static_method(_cmf_core.conductable_cast)
    __swig_destroy__ = _cmf_core.delete_conductable

# Register conductable in _cmf_core:
_cmf_core.conductable_swigregister(conductable)
class SoilLayer(WaterStorage, conductable):
    r"""


    A representation of a SoilLayer.

    C++ includes: SoilLayer.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Position = property(_cmf_core.SoilLayer_Position_get, doc=r"""Position : q(const).ptrdiff_t""")
    cell = property(_cmf_core.SoilLayer_cell_get, doc=r"""cell : r.cmf::upslope::Cell""")
    __get_upper = _swig_new_instance_method(_cmf_core.SoilLayer___get_upper)
    __get_lower = _swig_new_instance_method(_cmf_core.SoilLayer___get_lower)
    get_soil = _swig_new_instance_method(_cmf_core.SoilLayer_get_soil)
    set_soil = _swig_new_instance_method(_cmf_core.SoilLayer_set_soil)
    anisotropic_kf = property(_cmf_core.SoilLayer_anisotropic_kf_get, _cmf_core.SoilLayer_anisotropic_kf_set, doc=r"""anisotropic_kf : cmf::geometry::point""")
    get_capacity = _swig_new_instance_method(_cmf_core.SoilLayer_get_capacity)
    get_saturated_depth = _swig_new_instance_method(_cmf_core.SoilLayer_get_saturated_depth)
    set_root_uptake_stress_function = _swig_new_instance_method(_cmf_core.SoilLayer_set_root_uptake_stress_function)
    get_Tact = _swig_new_instance_method(_cmf_core.SoilLayer_get_Tact)
    get_flow_crosssection = _swig_new_instance_method(_cmf_core.SoilLayer_get_flow_crosssection)
    cast = _swig_new_static_method(_cmf_core.SoilLayer_cast)
    gravitational_potential = property(_cmf_core.SoilLayer_gravitational_potential_get, doc=r"""gravitational_potential : real""")
    matrix_potential = property(_cmf_core.SoilLayer_matrix_potential_get, doc=r"""matrix_potential : real""")
    wetness = property(_cmf_core.SoilLayer_wetness_get, _cmf_core.SoilLayer_wetness_set, doc=r"""wetness : real""")
    theta = property(_cmf_core.SoilLayer_theta_get, _cmf_core.SoilLayer_theta_set, doc=r"""theta : real""")
    K = property(_cmf_core.SoilLayer_K_get, doc=r"""K : real""")
    Ksat = property(_cmf_core.SoilLayer_Ksat_get, doc=r"""Ksat : real""")
    thickness = property(_cmf_core.SoilLayer_thickness_get, doc=r"""thickness : real""")
    lower_boundary = property(_cmf_core.SoilLayer_lower_boundary_get, doc=r"""lower_boundary : real""")
    upper_boundary = property(_cmf_core.SoilLayer_upper_boundary_get, doc=r"""upper_boundary : real""")
    porosity = property(_cmf_core.SoilLayer_porosity_get, doc=r"""porosity : real""")
    ice_fraction = property(_cmf_core.SoilLayer_ice_fraction_get, _cmf_core.SoilLayer_ice_fraction_set, doc=r"""ice_fraction : real""")
    rootfraction = property(_cmf_core.SoilLayer_rootfraction_get, _cmf_core.SoilLayer_rootfraction_set, doc=r"""rootfraction : real""")

    upper = property(fget=_cmf_core.SoilLayer___get_upper)


    lower = property(fget=_cmf_core.SoilLayer___get_lower)


    boundary=property(lambda self:(self.upper_boundary, self.lower_boundary),None, doc="Returns the upper and lower boundary of the layer")
    pF=property(lambda self : waterhead_to_pF(self.matrix_potential), None, doc="The actual pF value")
    soil=property(get_soil, set_soil, doc="The retention curve of the layer")


    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoilLayer

# Register SoilLayer in _cmf_core:
_cmf_core.SoilLayer_swigregister(SoilLayer)
class layer_list(object):
    r"""


    A vector of layers, with array access to the properties of the layers,
    for fast data exchange.

    C++ includes: layer_list.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(layer_list self, layer_list for_copy) -> layer_list
        __init__(layer_list self) -> layer_list
        __init__(layer_list self, node_list for_copy) -> layer_list
        layer_list(const layer_list &for_copy)
        cmf::upslope::layer_list::layer_list Copy constructor. 
        """
        _cmf_core.layer_list_swiginit(self, _cmf_core.new_layer_list(*args))
    pop = _swig_new_instance_method(_cmf_core.layer_list_pop)
    append = _swig_new_instance_method(_cmf_core.layer_list_append)
    extend = _swig_new_instance_method(_cmf_core.layer_list_extend)
    get_slice = _swig_new_instance_method(_cmf_core.layer_list_get_slice)
    clear = _swig_new_instance_method(_cmf_core.layer_list_clear)
    size = _swig_new_instance_method(_cmf_core.layer_list_size)
    set_wetness = _swig_new_instance_method(_cmf_core.layer_list_set_wetness)
    set_potential = _swig_new_instance_method(_cmf_core.layer_list_set_potential)
    set_volume = _swig_new_instance_method(_cmf_core.layer_list_set_volume)
    get_percolation = _swig_new_instance_method(_cmf_core.layer_list_get_percolation)
    set_theta = _swig_new_instance_method(_cmf_core.layer_list_set_theta)
    set_ice_fraction = _swig_new_instance_method(_cmf_core.layer_list_set_ice_fraction)
    set_rootfraction = _swig_new_instance_method(_cmf_core.layer_list_set_rootfraction)
    gravitational_potential = property(_cmf_core.layer_list_gravitational_potential_get, doc=r"""gravitational_potential : cmf::math::num_array""")
    matrix_potential = property(_cmf_core.layer_list_matrix_potential_get, doc=r"""matrix_potential : cmf::math::num_array""")
    wetness = property(_cmf_core.layer_list_wetness_get, doc=r"""wetness : cmf::math::num_array""")
    volume = property(_cmf_core.layer_list_volume_get, doc=r"""volume : cmf::math::num_array""")
    potential = property(_cmf_core.layer_list_potential_get, doc=r"""potential : cmf::math::num_array""")
    K = property(_cmf_core.layer_list_K_get, doc=r"""K : cmf::math::num_array""")
    Ksat = property(_cmf_core.layer_list_Ksat_get, doc=r"""Ksat : cmf::math::num_array""")
    thickness = property(_cmf_core.layer_list_thickness_get, doc=r"""thickness : cmf::math::num_array""")
    lower_boundary = property(_cmf_core.layer_list_lower_boundary_get, doc=r"""lower_boundary : cmf::math::num_array""")
    upper_boundary = property(_cmf_core.layer_list_upper_boundary_get, doc=r"""upper_boundary : cmf::math::num_array""")
    porosity = property(_cmf_core.layer_list_porosity_get, doc=r"""porosity : cmf::math::num_array""")
    ice_fraction = property(_cmf_core.layer_list_ice_fraction_get, doc=r"""ice_fraction : cmf::math::num_array""")
    theta = property(_cmf_core.layer_list_theta_get, doc=r"""theta : cmf::math::num_array""")
    root = property(_cmf_core.layer_list_root_get, doc=r"""root : cmf::math::num_array""")
    __get = _swig_new_instance_method(_cmf_core.layer_list___get)

    __repr__=lambda self: repr(list(self))
    __str__ =lambda self: str(list(self))
    __len__=lambda self: self.size()
    def __iadd__(self,other):
        self.append(other)
        return self
    def __add__(self,other):
        res = layer_list(self)
        res.append(other)
        return res
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __getitem__(self,index):
        if (type(index)==slice):
            return self.get_slice(*index.indices(len(self)))
        try:
            gen=iter(index)
            return [self.__get(it) for it in gen]
        except TypeError:
             return self.__get(index)      

    __swig_destroy__ = _cmf_core.delete_layer_list

# Register layer_list in _cmf_core:
_cmf_core.layer_list_swigregister(layer_list)
class MacroPore(WaterStorage):
    r"""


    An additional water storage for a soil layer to model matrix water and
    macro pore water seperately.

    Deprecated The MacroPore model is still very experimental and not
    stable. Only for tryouts!

    If present, the soil layer water storage holds the matrix water and
    the MacroPore holds the water in the macro pore. Use
    cmf::upslope::Macropore::create to create a macropore storage.

    Use cmf::upslope::connections::GradientMacroFlow or
    cmf::upslope::connections::KinematicMacroFlow to model water flow
    between macro pores and a lateral connection ( lateral subsurface
    fluxes) like cmf::upslope::connections::Richards_lateral to connect
    the macro pore with the matrix.

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    porefraction_min = property(_cmf_core.MacroPore_porefraction_min_get, _cmf_core.MacroPore_porefraction_min_set, doc=r"""porefraction_min : real""")
    porefraction_max = property(_cmf_core.MacroPore_porefraction_max_get, _cmf_core.MacroPore_porefraction_max_set, doc=r"""porefraction_max : real""")
    __get_layer = _swig_new_instance_method(_cmf_core.MacroPore___get_layer)
    get_porefraction = _swig_new_instance_method(_cmf_core.MacroPore_get_porefraction)
    density = property(_cmf_core.MacroPore_density_get, _cmf_core.MacroPore_density_set, doc=r"""density : real""")
    Ksat = property(_cmf_core.MacroPore_Ksat_get, _cmf_core.MacroPore_Ksat_set, doc=r"""Ksat : real""")
    crack_wetness = property(_cmf_core.MacroPore_crack_wetness_get, _cmf_core.MacroPore_crack_wetness_set, doc=r"""crack_wetness : real""")
    get_K = _swig_new_instance_method(_cmf_core.MacroPore_get_K)
    get_crackwidth = _swig_new_instance_method(_cmf_core.MacroPore_get_crackwidth)
    get_flowwidth = _swig_new_instance_method(_cmf_core.MacroPore_get_flowwidth)
    K_shape = property(_cmf_core.MacroPore_K_shape_get, _cmf_core.MacroPore_K_shape_set, doc=r"""K_shape : real""")
    create = _swig_new_static_method(_cmf_core.MacroPore_create)
    cast = _swig_new_static_method(_cmf_core.MacroPore_cast)

    def __repr__(self):
        return self.to_string()


    layer = property(fget=_cmf_core.MacroPore___get_layer)

    filled_fraction = property(_cmf_core.MacroPore_filled_fraction_get, doc=r"""filled_fraction : real""")
    K = property(_cmf_core.MacroPore_K_get, doc=r"""K : real""")
    capacity = property(_cmf_core.MacroPore_capacity_get, doc=r"""capacity : real""")
    cell = property(_cmf_core.MacroPore_cell_get, doc=r"""cell : r.cmf::upslope::Cell""")
    __swig_destroy__ = _cmf_core.delete_MacroPore

# Register MacroPore in _cmf_core:
_cmf_core.MacroPore_swigregister(MacroPore)
class BaseMacroFlow(flux_connection):
    r"""Proxy of C++ cmf::upslope::connections::BaseMacroFlow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_BaseMacroFlow

# Register BaseMacroFlow in _cmf_core:
_cmf_core.BaseMacroFlow_swigregister(BaseMacroFlow)
class GradientMacroFlow(BaseMacroFlow):
    r"""


    Gradient based flux from macro pore to macro pore.

    Deprecated The MacroPore model is still very experimental and not
    stable. Only for tryouts!



    .. math::

          q = K(\\theta) \\frac{\\Delta \\Psi}{\\Delta z} 

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(GradientMacroFlow self, cmf::upslope::MacroPore::ptr left, cmf::water::flux_node::ptr right) -> GradientMacroFlow
        GradientMacroFlow(cmf::upslope::MacroPore::ptr left,
        cmf::water::flux_node::ptr right)
        cmf::upslope::connections::GradientMacroFlow::GradientMacroFlow
        """
        _cmf_core.GradientMacroFlow_swiginit(self, _cmf_core.new_GradientMacroFlow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_GradientMacroFlow

# Register GradientMacroFlow in _cmf_core:
_cmf_core.GradientMacroFlow_swigregister(GradientMacroFlow)
class KinematicMacroFlow(BaseMacroFlow):
    r"""


    Linear storage based flux from macro pore to macro pore.

    Deprecated The MacroPore model is still very experimental and not
    stable. Only for tryouts!



    .. math::

         q = A_{cell} K_{macro}
        \\left(\\frac{V_{upper}}{C_{upper}}\\right)^\\beta
        \\left(1-\\frac{V_{lower}}{C_{lower}}\\right) 

    where:
    :math:`A_{cell}` is the area of the owning cell in m2

    :math:`K_{macro}` is the conductivity of the macro pore storage

    :math:`V` is the actual stored water volume in the upper resp. lower macro
    pore storage

    :math:`C` is the capacity of the upper resp. lower macro pore storage

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(KinematicMacroFlow self, cmf::water::WaterStorage::ptr left, cmf::water::flux_node::ptr right, real beta=1.) -> KinematicMacroFlow
        KinematicMacroFlow(cmf::water::WaterStorage::ptr left,
        cmf::water::flux_node::ptr right, real beta=1.)
        cmf::upslope::connections::KinematicMacroFlow::KinematicMacroFlow
        Creates the connection.

        Parameters:
        -----------

        left:  right:  the nodes between the connection should be created.

        beta:  a conceptional curve shape parameter for the relation between
        storage and outflow

        Either left or right needs to be a MacroPore, left needs to be a water
        storage 
        """
        _cmf_core.KinematicMacroFlow_swiginit(self, _cmf_core.new_KinematicMacroFlow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_KinematicMacroFlow

# Register KinematicMacroFlow in _cmf_core:
_cmf_core.KinematicMacroFlow_swigregister(KinematicMacroFlow)
class JarvisMacroFlow(BaseMacroFlow):
    r"""


    A physically based macropore to macropore connection according to
    Jarvis & Leeds-Harrison 1987, JSS.



    .. math::

        q_{i->j} [m/s]= \\rho \\frac G {12\\eta} w^2 \\frac{e_v-
        e_r}{1-e_r} S_{c,i}^\\beta\\ (1-S_{c,j})

    where:  :math:`q_{i->j}`
    the flow from macro pore layer i to macropore layer j

    :math:`\\rho=10^{-3} kg/m^3` - the density of water

    :math:`G=9.81 m/s^2` the earth acceleration

    :math:`\\eta=1.0 kg/(m s)` the viscosity of water (at 20 degC)

    :math:`w [m]` the crack width, a function of water content and crack
    distance

    :math:`e_v [-]` the crack porosity

    :math:`e_r [-]` crack por

    :math:`S_c [-]` the crack saturation of layer i resp. j

    :math:`\\beta [-]` a conceptional exponent to shape the flow reaction

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    beta = property(_cmf_core.JarvisMacroFlow_beta_get, _cmf_core.JarvisMacroFlow_beta_set, doc=r"""beta : real""")
    porefraction_r = property(_cmf_core.JarvisMacroFlow_porefraction_r_get, _cmf_core.JarvisMacroFlow_porefraction_r_set, doc=r"""porefraction_r : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(JarvisMacroFlow self, cmf::water::WaterStorage::ptr left, cmf::water::flux_node::ptr right, real beta=1., real porefraction_r=0.0) -> JarvisMacroFlow
        JarvisMacroFlow(cmf::water::WaterStorage::ptr left,
        cmf::water::flux_node::ptr right, real beta=1., real
        porefraction_r=0.0)
        cmf::upslope::connections::JarvisMacroFlow::JarvisMacroFlow Constructs
        the connection.

        Parameters:
        -----------

        left:  right:  the connected macropores

        beta:  User defined parameter for the swelling reaction

        porefraction_r:  Porefraction at which flow starts. For swelling soils
        that are closing completely th 
        """
        _cmf_core.JarvisMacroFlow_swiginit(self, _cmf_core.new_JarvisMacroFlow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_JarvisMacroFlow

# Register JarvisMacroFlow in _cmf_core:
_cmf_core.JarvisMacroFlow_swigregister(JarvisMacroFlow)
class GradientMacroMicroExchange(flux_connection):
    r"""


    A gradient based exchange term between macropores and micropores,
    using a fixed (air-) potential for macropores.



    .. math::

        q = K \\frac{\\Delta\\Psi}{d/2}  A 

    where:  :math:`K` The
    conductivity of the aggregate boundary

    :math:`\\Delta\\Psi` The potential difference. Using the air potential
    as the constant potential for the macro pores, you get:
    :math:`\\Delta\\Psi = \\Psi_M(\\theta_{micro})`

    :math:`d` the mean aggregate size in m

    :math:`A` the crosssection area, given as the flow width (
    cmf::upslope::MacroPore::get_flowwidth) times layer thickness

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(GradientMacroMicroExchange self, cmf::upslope::SoilLayer::ptr left, cmf::upslope::MacroPore::ptr right) -> GradientMacroMicroExchange
        GradientMacroMicroExchange(cmf::upslope::SoilLayer::ptr left,
        cmf::upslope::MacroPore::ptr right)
        cmf::upslope::connections::GradientMacroMicroExchange::GradientMacroMicroExchange
        """
        _cmf_core.GradientMacroMicroExchange_swiginit(self, _cmf_core.new_GradientMacroMicroExchange(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_GradientMacroMicroExchange

# Register GradientMacroMicroExchange in _cmf_core:
_cmf_core.GradientMacroMicroExchange_swigregister(GradientMacroMicroExchange)
class DiffusiveMacroMicroExchange(flux_connection):
    r"""


    A simple first order diffusive water exchange between MacroPore and
    matrix ( SoilLayer)



    .. math::

         q = \\omega (W_{ma} - W_{mi,eff}) V_{soil}

    where:
    :math:`\\omega` is the exchange rate in :math:`day^{-1}`

    :math:`W_{ma}` is the filled fraction of the macropore system [-]

    :math:`W_{mi,eff}` is the water filled pore space of the micropores above
    the residual pF value [-], default 4.2

    :math:`V_{soil} = A_{cell} d_{layer}` is the total volume of the soil layer
    [ :math:`m^3`]

    The residual micropore pF is used to determine a residual water
    content of the micropores. Residual in this case means, that above
    this pF value, water is not draining to the macro pores, even if they
    are empty. Although the default value is at wilting point, lower pF
    values are much more sensible, and should be rather lower than field
    capacity (pF=1.8 - 2.5). However, since this equation is rather
    conceptual than physical, this value can only be estimated or
    calibrated.

    cf. Simunek et al J. of Hydr. 2003

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    omega = property(_cmf_core.DiffusiveMacroMicroExchange_omega_get, _cmf_core.DiffusiveMacroMicroExchange_omega_set, doc=r"""omega : real""")
    pFrmi = property(_cmf_core.DiffusiveMacroMicroExchange_pFrmi_get, _cmf_core.DiffusiveMacroMicroExchange_pFrmi_set, doc=r"""pFrmi : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(DiffusiveMacroMicroExchange self, cmf::upslope::MacroPore::ptr left, cmf::upslope::SoilLayer::ptr right, real omega, real pFrmi=4.2) -> DiffusiveMacroMicroExchange
        DiffusiveMacroMicroExchange(cmf::upslope::MacroPore::ptr left,
        cmf::upslope::SoilLayer::ptr right, real omega, real pFrmi=4.2)
        cmf::upslope::connections::DiffusiveMacroMicroExchange::DiffusiveMacroMicroExchange
        """
        _cmf_core.DiffusiveMacroMicroExchange_swiginit(self, _cmf_core.new_DiffusiveMacroMicroExchange(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_DiffusiveMacroMicroExchange

# Register DiffusiveMacroMicroExchange in _cmf_core:
_cmf_core.DiffusiveMacroMicroExchange_swigregister(DiffusiveMacroMicroExchange)
class MACROlikeMacroMicroExchange(flux_connection):
    r"""


    This connection models the water exchange between macropores and
    micropores as in the MACRO Model (Larsbo & Jarvis, 2003), which
    follows Gerke & van Genuchten 1996.

    WARNING:  Deprecated This connection uses the diffusivity of a soil
    given by its retention curve. Since no retention curve provides a
    valid value for Diffusivity in case of saturation this connection will
    blow up the numerical solution for sure.

    The exchange between Macropore and matrix is defined as follows:
    (MACRO 5 Tech report, Larsbo & Jarvis 2003)



    .. math::

        q = \\frac{G_f D_w \\gamma_w}{d^2}(\\theta_b -
        \\theta_{mi}) V_{layer}

    where:  :math:`G_f` is the geometry factor.
    Use 3 for a rectangular slab geometry

    :math:`gamma_w` A scaling factor to fit analytical and numerical solution
    (0.4)

    :math:`d` is an effective diffusive path length related to aggregate size
    and the influence of coatings on the aggregate surfaces in m

    :math:`\\theta_b` the saturated water content of the matrix

    :math:`\\theta_{mi}` the actual water content of the matrix

    :math:`D_w = \\frac12(D(\\theta_b)+D(\\theta_{mi})W_{ma})` is the
    effective water diffusivity in m2/day, as defined below  :math:`W_{ma}` is
    the saturation of the macropores

    C++ includes: macropore.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Gf = property(_cmf_core.MACROlikeMacroMicroExchange_Gf_get, _cmf_core.MACROlikeMacroMicroExchange_Gf_set, doc=r"""Gf : real""")
    gamma_w = property(_cmf_core.MACROlikeMacroMicroExchange_gamma_w_get, _cmf_core.MACROlikeMacroMicroExchange_gamma_w_set, doc=r"""gamma_w : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(MACROlikeMacroMicroExchange self, cmf::upslope::SoilLayer::ptr left, cmf::upslope::MacroPore::ptr right, real _gamma_w=0.4, real _Gf=3) -> MACROlikeMacroMicroExchange
        MACROlikeMacroMicroExchange(cmf::upslope::SoilLayer::ptr left,
        cmf::upslope::MacroPore::ptr right, real _gamma_w=0.4, real _Gf=3)
        cmf::upslope::connections::MACROlikeMacroMicroExchange::MACROlikeMacroMicroExchange
        """
        _cmf_core.MACROlikeMacroMicroExchange_swiginit(self, _cmf_core.new_MACROlikeMacroMicroExchange(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_MACROlikeMacroMicroExchange

# Register MACROlikeMacroMicroExchange in _cmf_core:
_cmf_core.MACROlikeMacroMicroExchange_swigregister(MACROlikeMacroMicroExchange)
class IVolumeHeightFunction(object):
    r"""


    Volume height relations are functional objects, which return a height
    and a crosssectional area of a volume for different geometric bodies.

    This is the abstract base class, where the geometries derive from

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    h = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_h)
    A = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_A)
    V = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_V)
    copy = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_copy)
    q = _swig_new_instance_method(_cmf_core.IVolumeHeightFunction_q)
    __swig_destroy__ = _cmf_core.delete_IVolumeHeightFunction

# Register IVolumeHeightFunction in _cmf_core:
_cmf_core.IVolumeHeightFunction_swigregister(IVolumeHeightFunction)
class Prism(IVolumeHeightFunction):
    r"""


    the height of a volume in a Prism with a defined base area

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = property(_cmf_core.Prism_Area_get, _cmf_core.Prism_Area_set, doc=r"""Area : double""")
    RoughThickness = property(_cmf_core.Prism_RoughThickness_get, _cmf_core.Prism_RoughThickness_set, doc=r"""RoughThickness : double""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Prism self, double base_area, double thickness_of_rough_ground=0.01) -> Prism
        Prism(double
        base_area, double thickness_of_rough_ground=0.01)
        cmf::river::Prism::Prism
        """
        _cmf_core.Prism_swiginit(self, _cmf_core.new_Prism(*args, **kwargs))
    copy = _swig_new_instance_method(_cmf_core.Prism_copy)
    __swig_destroy__ = _cmf_core.delete_Prism

# Register Prism in _cmf_core:
_cmf_core.Prism_swigregister(Prism)
class volume_height_function(IVolumeHeightFunction):
    r"""


    A wrapper class for volume / height functional relations.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(volume_height_function self, volume_height_function for_copy) -> volume_height_function
        __init__(volume_height_function self, IVolumeHeightFunction for_copy) -> volume_height_function
        volume_height_function(const volume_height_function &for_copy)
        cmf::river::volume_height_function::volume_height_function Copy
        constructable. 
        """
        _cmf_core.volume_height_function_swiginit(self, _cmf_core.new_volume_height_function(*args))
    copy = _swig_new_instance_method(_cmf_core.volume_height_function_copy)
    __swig_destroy__ = _cmf_core.delete_volume_height_function

# Register volume_height_function in _cmf_core:
_cmf_core.volume_height_function_swigregister(volume_height_function)
class IChannel(IVolumeHeightFunction):
    r"""


    Structure for the description of structural parameters of a reach
    Abstract base class for different IChannel geometries.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    get_nManning = _swig_new_instance_method(_cmf_core.IChannel_get_nManning)
    set_nManning = _swig_new_instance_method(_cmf_core.IChannel_set_nManning)
    get_length = _swig_new_instance_method(_cmf_core.IChannel_get_length)
    typecode = _swig_new_instance_method(_cmf_core.IChannel_typecode)
    get_channel_width = _swig_new_instance_method(_cmf_core.IChannel_get_channel_width)
    get_wetted_perimeter = _swig_new_instance_method(_cmf_core.IChannel_get_wetted_perimeter)
    get_depth = _swig_new_instance_method(_cmf_core.IChannel_get_depth)
    get_flux_crossection = _swig_new_instance_method(_cmf_core.IChannel_get_flux_crossection)
    copy = _swig_new_instance_method(_cmf_core.IChannel_copy)
    qManning = _swig_new_instance_method(_cmf_core.IChannel_qManning)
    __swig_destroy__ = _cmf_core.delete_IChannel

# Register IChannel in _cmf_core:
_cmf_core.IChannel_swigregister(IChannel)
class SWATReachType(IChannel):
    r"""


    Structure for the description of structural parameters of a reach.

    Uses the SWAT IChannel geometry (see SWAT Theoretical Documentation,
    Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
    referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
    plain is not plain, but has a small slope=0.5%, but has an infinite
    width

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BottomWidth = property(_cmf_core.SWATReachType_BottomWidth_get, _cmf_core.SWATReachType_BottomWidth_set, doc=r"""BottomWidth : double""")
    ChannelDepth = property(_cmf_core.SWATReachType_ChannelDepth_get, _cmf_core.SWATReachType_ChannelDepth_set, doc=r"""ChannelDepth : double""")
    BankSlope = property(_cmf_core.SWATReachType_BankSlope_get, _cmf_core.SWATReachType_BankSlope_set, doc=r"""BankSlope : double""")
    FloodPlainSlope = property(_cmf_core.SWATReachType_FloodPlainSlope_get, _cmf_core.SWATReachType_FloodPlainSlope_set, doc=r"""FloodPlainSlope : double""")

    def __init__(self, *args):
        r"""
        __init__(SWATReachType self, SWATReachType copy) -> SWATReachType
        __init__(SWATReachType self, double l) -> SWATReachType
        __init__(SWATReachType self, double l, double BankWidth, double Depth) -> SWATReachType
        SWATReachType(double l, double BankWidth, double Depth)
        cmf::river::SWATReachType::SWATReachType Creates a new reach structure
        from a give width and depth.

        Parameters:
        -----------

        l:  length of the channel [m]

        BankWidth:  get_channel_width of the reach from bank to bank [m]

        Depth:  Depth of the reach [m] 
        """
        _cmf_core.SWATReachType_swiginit(self, _cmf_core.new_SWATReachType(*args))
    copy = _swig_new_instance_method(_cmf_core.SWATReachType_copy)
    __swig_destroy__ = _cmf_core.delete_SWATReachType

# Register SWATReachType in _cmf_core:
_cmf_core.SWATReachType_swigregister(SWATReachType)
class TriangularReach(IChannel):
    r"""


    Structure for the description of reaches with a triangular cross
    section.

    Although double triangular cross section reach are rarely met, a
    triangular reach does scale with its water load, and is therefore
    preferable in case where nothing about IChannel geometry is known

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BankSlope = property(_cmf_core.TriangularReach_BankSlope_get, _cmf_core.TriangularReach_BankSlope_set, doc=r"""BankSlope : double""")

    def __init__(self, *args):
        r"""
        __init__(TriangularReach self, double l, double bankSlope=2) -> TriangularReach
        __init__(TriangularReach self, TriangularReach copy) -> TriangularReach
        TriangularReach(double l, double bankSlope=2)
        cmf::river::TriangularReach::TriangularReach Creates a new triangular
        reach type. 
        """
        _cmf_core.TriangularReach_swiginit(self, _cmf_core.new_TriangularReach(*args))
    copy = _swig_new_instance_method(_cmf_core.TriangularReach_copy)
    __swig_destroy__ = _cmf_core.delete_TriangularReach

# Register TriangularReach in _cmf_core:
_cmf_core.TriangularReach_swigregister(TriangularReach)
class RectangularReach(IChannel):
    r"""


    Describes a IChannel with a rectangular crosssection.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RectangularReach self, double l, double width) -> RectangularReach
        __init__(RectangularReach self, RectangularReach copy) -> RectangularReach
        RectangularReach(double l, double width)
        cmf::river::RectangularReach::RectangularReach Creates a new
        rectangular reach type with width [m]. 
        """
        _cmf_core.RectangularReach_swiginit(self, _cmf_core.new_RectangularReach(*args))
    copy = _swig_new_instance_method(_cmf_core.RectangularReach_copy)
    __swig_destroy__ = _cmf_core.delete_RectangularReach

# Register RectangularReach in _cmf_core:
_cmf_core.RectangularReach_swigregister(RectangularReach)
class PipeReach(IChannel):
    r"""


    Describes the geometry of a closed pipe.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    radius = property(_cmf_core.PipeReach_radius_get, _cmf_core.PipeReach_radius_set, doc=r"""radius : double""")

    def __init__(self, *args):
        r"""
        __init__(PipeReach self, double l, double diameter) -> PipeReach
        __init__(PipeReach self, PipeReach copy) -> PipeReach
        PipeReach(double l, double diameter) cmf::river::PipeReach::PipeReach
        Creates a tube IChannel with diameter [m]. 
        """
        _cmf_core.PipeReach_swiginit(self, _cmf_core.new_PipeReach(*args))
    copy = _swig_new_instance_method(_cmf_core.PipeReach_copy)
    __swig_destroy__ = _cmf_core.delete_PipeReach

# Register PipeReach in _cmf_core:
_cmf_core.PipeReach_swigregister(PipeReach)
class Channel(IChannel):
    r"""


    A wrapper for channel geometries.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Channel self) -> Channel
        __init__(Channel self, double length) -> Channel
        __init__(Channel self, IChannel for_wrapping) -> Channel
        __init__(Channel self, IVolumeHeightFunction for_casting) -> Channel
        __init__(Channel self, Channel for_copy) -> Channel
        __init__(Channel self, char typecode, double length, double width=1., double depth=0.25) -> Channel
        Channel(double
        length) cmf::river::Channel::Channel Creates a triangular reach of a
        length. 
        """
        _cmf_core.Channel_swiginit(self, _cmf_core.new_Channel(*args))
    copy = _swig_new_instance_method(_cmf_core.Channel_copy)
    __swig_destroy__ = _cmf_core.delete_Channel

# Register Channel in _cmf_core:
_cmf_core.Channel_swigregister(Channel)
class MeanChannel(IChannel):
    r"""


    A combination of two channel geometries.

    C++ includes: ReachType.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(MeanChannel self, IChannel channel1, IChannel channel2) -> MeanChannel
        __init__(MeanChannel self, MeanChannel meanChannel) -> MeanChannel
        MeanChannel(const MeanChannel &meanChannel)
        cmf::river::MeanChannel::MeanChannel
        """
        _cmf_core.MeanChannel_swiginit(self, _cmf_core.new_MeanChannel(*args))
    copy = _swig_new_instance_method(_cmf_core.MeanChannel_copy)
    __swig_destroy__ = _cmf_core.delete_MeanChannel

# Register MeanChannel in _cmf_core:
_cmf_core.MeanChannel_swigregister(MeanChannel)
class CrossSectionReach(IChannel):
    r"""


    Structure for the description of reaches with a freely defined cross
    section.

    Although double triangular cross section reach are rarely met, a
    triangular reach does scale with its water load, and is therefore
    preferable in case where nothing about IChannel geometry is known

    C++ includes: cross_section_reach.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    depth = property(_cmf_core.CrossSectionReach_depth_get, _cmf_core.CrossSectionReach_depth_set, doc=r"""depth : cmf::math::num_array""")
    x = property(_cmf_core.CrossSectionReach_x_get, _cmf_core.CrossSectionReach_x_set, doc=r"""x : cmf::math::num_array""")

    def __init__(self, *args):
        r"""
        __init__(CrossSectionReach self, double l, cmf::math::num_array x, cmf::math::num_array depth) -> CrossSectionReach
        __init__(CrossSectionReach self, CrossSectionReach copy) -> CrossSectionReach
        CrossSectionReach(double l, cmf::math::num_array x,
        cmf::math::num_array depth)
        cmf::river::CrossSectionReach::CrossSectionReach Creates a new
        triangular reach type. 
        """
        _cmf_core.CrossSectionReach_swiginit(self, _cmf_core.new_CrossSectionReach(*args))
    copy = _swig_new_instance_method(_cmf_core.CrossSectionReach_copy)
    __swig_destroy__ = _cmf_core.delete_CrossSectionReach
    check_iterator = _swig_new_instance_method(_cmf_core.CrossSectionReach_check_iterator)

# Register CrossSectionReach in _cmf_core:
_cmf_core.CrossSectionReach_swigregister(CrossSectionReach)
class OpenWaterStorage(WaterStorage):
    r"""


    An open water body.

    The potential is calculated from the stored water using a water table
    function

    C++ includes: OpenWaterStorage.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get_height_function = _swig_new_instance_method(_cmf_core.OpenWaterStorage_get_height_function)
    set_height_function = _swig_new_instance_method(_cmf_core.OpenWaterStorage_set_height_function)
    wet_area = _swig_new_instance_method(_cmf_core.OpenWaterStorage_wet_area)
    create = _swig_new_static_method(_cmf_core.OpenWaterStorage_create)
    cast = _swig_new_static_method(_cmf_core.OpenWaterStorage_cast)
    depth = property(_cmf_core.OpenWaterStorage_depth_get, _cmf_core.OpenWaterStorage_depth_set, doc=r"""depth : real""")

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_OpenWaterStorage

# Register OpenWaterStorage in _cmf_core:
_cmf_core.OpenWaterStorage_swigregister(OpenWaterStorage)
class Reach(OpenWaterStorage):
    r"""


    A reach represents the section of a riover and is a specialization of
    an open water storage.

    The OpenWaterStorage attributes and methods are extended by
    topological features, for the creation of a network of reaches.

    C++ includes: Reach.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get_reachtype = _swig_new_instance_method(_cmf_core.Reach_get_reachtype)
    set_height_function = _swig_new_instance_method(_cmf_core.Reach_set_height_function)
    set_outlet = _swig_new_instance_method(_cmf_core.Reach_set_outlet)
    set_dead_end = _swig_new_instance_method(_cmf_core.Reach_set_dead_end)
    set_downstream = _swig_new_instance_method(_cmf_core.Reach_set_downstream)
    __get_downstream = _swig_new_instance_method(_cmf_core.Reach___get_downstream)
    get_upstream = _swig_new_instance_method(_cmf_core.Reach_get_upstream)
    connect_to_surfacewater = _swig_new_instance_method(_cmf_core.Reach_connect_to_surfacewater)
    distance_to_cell = _swig_new_instance_method(_cmf_core.Reach_distance_to_cell)
    __get_root = _swig_new_instance_method(_cmf_core.Reach___get_root)
    __swig_destroy__ = _cmf_core.delete_Reach
    create = _swig_new_static_method(_cmf_core.Reach_create)
    length = property(_cmf_core.Reach_length_get, doc=r"""length : real""")
    width = property(_cmf_core.Reach_width_get, doc=r"""width : real""")
    channel = property(_cmf_core.Reach_channel_get, doc=r"""channel : cmf::river::IChannel""")

    downstream = property(fget=_cmf_core.Reach___get_downstream)


    root = property(fget=_cmf_core.Reach___get_root)

    upstream_count = property(_cmf_core.Reach_upstream_count_get, doc=r"""
    upstream_count : int
    int
    upstream_count() const cmf::river::Reach::upstream_count Returns the
    number of reaches upstream of this. 
    """)
    diffusive = property(_cmf_core.Reach_diffusive_get, _cmf_core.Reach_diffusive_set, doc=r"""diffusive : bool""")

    @property
    def upstream(self):
        """Returns a list containing all reaches flowing into self"""
        return [self.get_upstream(i) for i in range(self.upstream_count)]
    def __hash__(self):
        return hash(self.water.node_id)
    def connect_to_cell(self,cell,width,subsurface_connection_type=None,subsurface_connection_depth=None,diffusive=None):
        """ Connects a cell with this reach using Manning's equation for surface runoff and
        a given connection for subsurface interflow 
         - width : Boundary width in m
         - subsurface_connection_type  : Any lateral flow connection type
         - subsurface_connection_depth : The depth below ground of the deepest layer to be connected by subsurface_connection_type,
                                         default (None) = cell.z - reach.position.z
         - diffusive: Determines if a kinematic or diffusive wave is to be used for surface runoff
        """
        assert(subsurface_connection_type is None or issubclass(subsurface_connection_type, lateral_sub_surface_flux))
        if diffusive is None:
            diffusive = self.diffusive
        if subsurface_connection_depth is None:
            subsurface_connection_depth = cell.z - self.position.z
        self.connect_to_surfacewater(cell,width,diffusive)
        r_depth = cell.z - self.position.z
        distance = self.distance_to_cell(cell)
        connections=[self.connection_to(cell.surfacewater)]
        if subsurface_connection_type:
            cell.connect_soil_with_node(self,subsurface_connection_type,width,distance,0,subsurface_connection_depth)
            connections.extend(self.connection_to(l) for l in cell.layers)
        return connections


    def __repr__(self):
        return self.to_string()


# Register Reach in _cmf_core:
_cmf_core.Reach_swigregister(Reach)
class ReachIterator(object):
    r"""


    An iterator over every upstream reach from a start reach.

    Implements both the Python and the C++ iterator interface Usage C++:
    Usage Python:

    C++ includes: Reach.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    next = _swig_new_instance_method(_cmf_core.ReachIterator_next)
    valid = _swig_new_instance_method(_cmf_core.ReachIterator_valid)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ReachIterator self, cmf::river::Reach::ptr first) -> ReachIterator
        ReachIterator(Reach::ptr first)
        cmf::river::ReachIterator::ReachIterator Creates a ReachIterator from
        a first reach. 
        """
        _cmf_core.ReachIterator_swiginit(self, _cmf_core.new_ReachIterator(*args, **kwargs))
    __reach = _swig_new_instance_method(_cmf_core.ReachIterator___reach)
    position = property(_cmf_core.ReachIterator_position_get, doc=r"""
    position : double
    double
    position() const cmf::river::ReachIterator::position Returns the
    distance to the root reach. 
    """)

    reach = property(fget=_cmf_core.ReachIterator___reach)


    def __iter__(self):
        while self.valid():
            self.next()
            yield (self.reach,self.position)

    __swig_destroy__ = _cmf_core.delete_ReachIterator

# Register ReachIterator in _cmf_core:
_cmf_core.ReachIterator_swigregister(ReachIterator)
make_river_gap = _cmf_core.make_river_gap
class SurfaceWater(OpenWaterStorage):
    r"""


    A child class of OpenWaterStorage to model surface water on a cell.

    Specially created to connect a SurfaceWater with other nodes, is the
    flux connection cmf::upslope::connections::KinematicSurfaceRunoff

    C++ includes: surfacewater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get_height_function = _swig_new_instance_method(_cmf_core.SurfaceWater_get_height_function)
    get_coverage = _swig_new_instance_method(_cmf_core.SurfaceWater_get_coverage)
    get_cell = _swig_new_instance_method(_cmf_core.SurfaceWater_get_cell)
    cast = _swig_new_static_method(_cmf_core.SurfaceWater_cast)
    puddledepth = property(_cmf_core.SurfaceWater_puddledepth_get, _cmf_core.SurfaceWater_puddledepth_set, doc=r"""puddledepth : real""")
    nManning = property(_cmf_core.SurfaceWater_nManning_get, _cmf_core.SurfaceWater_nManning_set, doc=r"""nManning : real""")

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SurfaceWater

# Register SurfaceWater in _cmf_core:
_cmf_core.SurfaceWater_swigregister(SurfaceWater)
class KinematicSurfaceRunoff(flux_connection):
    r"""


    A connection to route water from a SurfaceWater storage to another
    node following a topographic gradient.



    .. math::

        q_{runoff} = A_{cross} d_{eff}^{2/3}
        \\frac{\\sqrt{S}}{n}

    where:  :math:`q_{runoff}` is the surface
    runoff

    :math:`A_{cross}` is the wetted crossectional flux area, given as :math:`d_{eff} \\cdot w`

    :math:`w` is the width of the shared boundary between the surface water
    storage and the target node

    :math:`d_{eff}` is the effective flow depth of the surface water.The
    effective flow depth is defined as 

    .. math::

        d_{eff} = \\begin{cases}
        V/A-d_{puddle}\\ & V/A>d_{puddle} \\\\ 0.0 & V/A<=d_{puddle}
        \\end{cases}

    :math:`V` the volume of stored water in the surface in :math:`m^3`

    :math:`A` the area of the cell in :math:`m^2`

    :math:`d_{puddle}=V_{puddle}/A` the average depth of water in the surface
    water needed to start run off

    :math:`S = \\|\\frac{\\Delta z\\|}{d}` the slope between
    surfacewater center and the target node

    :math:`n` the manning roughness

    The KinematicSurfaceRunoff can be used as a cell connecting flux as
    in: This results in a connection of the surfacewater storage of each
    cell with the surface water storages of its neighborssee

    C++ includes: surfacewater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(KinematicSurfaceRunoff self, cmf::upslope::SurfaceWater::ptr left, cmf::water::flux_node::ptr right, real flowwidth, real distance=-1) -> KinematicSurfaceRunoff
        KinematicSurfaceRunoff(cmf::upslope::SurfaceWater::ptr left,
        cmf::water::flux_node::ptr right, real flowwidth, real distance=-1)
        cmf::upslope::connections::KinematicSurfaceRunoff::KinematicSurfaceRunoff
        Creates a KinematicSurfaceRunoff between a SurfaceWater (left) with
        another (right) node.

        Parameters:
        -----------

        left:  A surfacewater storage

        right:  The target node

        flowwidth:  the length of the shared boundary between left and right
        in m

        distance:  the distance between left and right in m. If d<=0m, the
        distance is calculated according to the position of left and right 
        """
        _cmf_core.KinematicSurfaceRunoff_swiginit(self, _cmf_core.new_KinematicSurfaceRunoff(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_KinematicSurfaceRunoff

# Register KinematicSurfaceRunoff in _cmf_core:
_cmf_core.KinematicSurfaceRunoff_swigregister(KinematicSurfaceRunoff)
KinematicSurfaceRunoff.cell_connector = _cmf_core.cvar.KinematicSurfaceRunoff_cell_connector

class DiffusiveSurfaceRunoff(flux_connection):
    r"""


    A connection to route water from a SurfaceWater storage to another
    node following the gradient of the water level.



    .. math::

        q_{runoff} = A_{cross} d_{eff}^{2/3}
        \\frac{\\sqrt{S}}{n}

    where:  :math:`q_{runoff}` is the surface
    runoff

    :math:`A_{cross}` is the wetted crossectional flux area, given as :math:`d_{eff} \\cdot w`

    :math:`w` is the width of the shared boundary between the surface water
    storage and the target node

    :math:`d_{eff}` is the effective flow depth of the surface water.The
    effective flow depth is defined as either the mean of the effective
    depth of the left and the right node (when use_depthmax=false) or the
    maximum of the efficitve depth. The effective depth for a surfacewater
    is always defined as: 

    .. math::

        d_{eff} = \\begin{cases}
        V/A-d_{puddle}\\ & V/A>d_{puddle} \\\\ 0.0 & V/A<=d_{puddle}
        \\end{cases}

    The right node might be not a surfacewater. If the
    right node is an OpenWaterStorage, then the effective depth is the
    depth of the OWS above the cell height of the left surfacewater, given
    by: 

    .. math::

        d_{eff,ows} = \\Psi_{ows} - z_{cell}

    In case of
    another node, the right node depth equals the effective depth of the
    left node.

    :math:`V` the volume of stored water in the surface in :math:`m^3`

    :math:`A` the area of the cell in :math:`m^2`

    :math:`d_{puddle}=V_{puddle}/A` the average depth of water in the surface
    water needed to start run off

    :math:`S = \\|\\frac{\\Delta h\\|}{d}` the slope between
    surfacewater center potential and the target node potential

    :math:`n` the manning roughness

    The DiffusiveSurfaceRunoff can be used as a cell connecting flux as
    in: This results in a connection of the surfacewater storage of each
    cell with the surface water storages of its neighborssee

    C++ includes: surfacewater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(DiffusiveSurfaceRunoff self, cmf::upslope::SurfaceWater::ptr left, cmf::water::flux_node::ptr right, real flowwidth, real distance=-1) -> DiffusiveSurfaceRunoff
        DiffusiveSurfaceRunoff(cmf::upslope::SurfaceWater::ptr left,
        cmf::water::flux_node::ptr right, real flowwidth, real distance=-1)
        cmf::upslope::connections::DiffusiveSurfaceRunoff::DiffusiveSurfaceRunoff
        """
        _cmf_core.DiffusiveSurfaceRunoff_swiginit(self, _cmf_core.new_DiffusiveSurfaceRunoff(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_DiffusiveSurfaceRunoff

# Register DiffusiveSurfaceRunoff in _cmf_core:
_cmf_core.DiffusiveSurfaceRunoff_swigregister(DiffusiveSurfaceRunoff)
DiffusiveSurfaceRunoff.cell_connector = _cmf_core.cvar.DiffusiveSurfaceRunoff_cell_connector

class aquifer(WaterStorage, conductable):
    r"""


    A class to represent large groundwater storages, not bounded to the
    usual horizontal discretization scheme, the Cell.

    Naturally aquifers are connected with aquifer_Darcy or kinematic_wave
    connections. As a boundary condition for a cell based soil water
    system, aquifers are used as a right hand side node of percolation
    connections.

    Basic head ( :math:`\\Psi`) / volume ( :math:`V`) relation: 

    .. math::

         \\Psi =
        z_{base} + \\frac {V}{A \\Phi} 

    :math:`\\Psi` water head in m

    :math:`z_{base}` base height of the aquifer

    :math:`V` volume of stored water in m3

    :math:`A` Base area of the aquifer in m2

    :math:`\\Phi` Porosity, or more general, :math:`\\frac{dV_{bulk}}{dV_{H_2O}}`

    C++ includes: groundwater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    area = property(_cmf_core.aquifer_area_get, _cmf_core.aquifer_area_set, doc=r"""area : real""")
    thickness = property(_cmf_core.aquifer_thickness_get, _cmf_core.aquifer_thickness_set, doc=r"""thickness : real""")
    porosity = property(_cmf_core.aquifer_porosity_get, _cmf_core.aquifer_porosity_set, doc=r"""porosity : real""")
    K = property(_cmf_core.aquifer_K_get, _cmf_core.aquifer_K_set, doc=r"""K : cmf::geometry::point""")
    get_abs_errtol = _swig_new_instance_method(_cmf_core.aquifer_get_abs_errtol)

    def __init__(self, *args):
        r"""
        __init__(aquifer self, project p, point position, real area, real thickness, real porosity, real K=1e-4) -> aquifer
        __init__(aquifer self, cell_vector cells, real thickness, real porosity, real K=1e-4) -> aquifer
        aquifer(cmf::upslope::cell_vector &cells, real thickness, real
        porosity, real K=1e-4) cmf::upslope::aquifer::aquifer Creates an
        aquifer below a collection of cells.

        Parameters:
        -----------

        cells:  The cells above the aquifer. The area of the aquifer equals
        the area of the cells, and the upper boundary equals the soildepth of
        the lowest cell

        thickness:  The thickness of the aquifer in m

        porosity:  Porosity of the aquifer

        K:  Conductivity of the aquifer in m/day. If the conductivity should
        be anisotropic, change the x,y and z values of the member K 
        """
        _cmf_core.aquifer_swiginit(self, _cmf_core.new_aquifer(*args))
    cast = _swig_new_static_method(_cmf_core.aquifer_cast)
    base_height = property(_cmf_core.aquifer_base_height_get, doc=r"""base_height : double""")
    top_height = property(_cmf_core.aquifer_top_height_get, doc=r"""top_height : double""")

    def __repr__(self):
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_aquifer

# Register aquifer in _cmf_core:
_cmf_core.aquifer_swigregister(aquifer)
class aquifer_Darcy(flux_connection):
    r"""


    Lateral darcy flow between aquifer objects.



    .. math::

        v_{Darcy}=K_{1,2}\\nabla\\Psi 



    .. math::

        q = v_{Darcy} w
        \\Delta z

    C++ includes: groundwater.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flux_width = property(_cmf_core.aquifer_Darcy_flux_width_get, _cmf_core.aquifer_Darcy_flux_width_set, doc=r"""flux_width : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(aquifer_Darcy self, cmf::upslope::aquifer::ptr left, cmf::water::flux_node::ptr right, real width) -> aquifer_Darcy
        aquifer_Darcy(aquifer::ptr left, cmf::water::flux_node::ptr right,
        real width) cmf::upslope::aquifer_Darcy::aquifer_Darcy Creates a new
        Darcy flow connection between two aquifers, or an aquifer and another
        node acting as Dirichlet boundary condition.

        Parameters:
        -----------

        left:  One aquifer

        right:  Another aquifer, or a flux node that can be interpreted as an
        Dirichlet boundary

        width:  Width of the connection 
        """
        _cmf_core.aquifer_Darcy_swiginit(self, _cmf_core.new_aquifer_Darcy(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_aquifer_Darcy

# Register aquifer_Darcy in _cmf_core:
_cmf_core.aquifer_Darcy_swigregister(aquifer_Darcy)
class lateral_sub_surface_flux(flux_connection):
    r"""


    An abstract base class for lateral subsurface fluxes.

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_lateral_sub_surface_flux

# Register lateral_sub_surface_flux in _cmf_core:
_cmf_core.lateral_sub_surface_flux_swigregister(lateral_sub_surface_flux)
class Darcy(lateral_sub_surface_flux):
    r"""


    Calculates the lateral flow using the gravitational potential gradient
    only.



    .. math::

         q_{lat} = \\frac{\\Delta \\Psi_G}{\\|C_1-C_2\\|}
        \\frac 12 (T(C_1)+T(C_2)) w 

    where  :math:`\\Delta \\Psi_G` is
    the gravitational potential difference

    :math:`\\|C_1-C_2\\|` is the distance from Cell 1 to Cell 2

    :math:`T(C)` is the transmissivity of cell C, calculated by
    SoilType::Transmissivity

    :math:`w` is the width of the connection of the cells

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Darcy self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0) -> Darcy
        Darcy(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
        right, real FlowWidth, real Distance=0)
        cmf::upslope::connections::Darcy::Darcy
        """
        _cmf_core.Darcy_swiginit(self, _cmf_core.new_Darcy(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Darcy

# Register Darcy in _cmf_core:
_cmf_core.Darcy_swigregister(Darcy)
Darcy.cell_connector = _cmf_core.cvar.Darcy_cell_connector

class TopographicGradientDarcy(lateral_sub_surface_flux):
    r"""


    Calculates the lateral flow using the topographic gradient.



    .. math::

         q_{lat} = \\frac{z_1 - z_2}{\\|C_1-C_2\\|} \\frac 12
        (T(C_1)+T(C_2)) w 

    where  :math:`z_1 - z_2` is the topographic height
    difference

    :math:`\\|C_1-C_2\\|` is the distance from Cell 1 to Cell 2

    :math:`T(C)` is the transmissivity of cell C, calculated by
    SoilType::Transmissivity

    :math:`w` is the width of the connection of the cells

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(TopographicGradientDarcy self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0) -> TopographicGradientDarcy
        TopographicGradientDarcy(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0)
        cmf::upslope::connections::TopographicGradientDarcy::TopographicGradientDarcy
        Creates the connection.

        Parameters:
        -----------

        left:  Left node of the connection (needs to be soil water storage)

        right:  Right node of the connection (can be any node)

        FlowWidth:  the width of the connection - is multiplied by layer
        thickness to get the interface area

        Distance:  the length of the connection. If 0, the distance is
        calculated from the position of the nodes 
        """
        _cmf_core.TopographicGradientDarcy_swiginit(self, _cmf_core.new_TopographicGradientDarcy(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_TopographicGradientDarcy

# Register TopographicGradientDarcy in _cmf_core:
_cmf_core.TopographicGradientDarcy_swigregister(TopographicGradientDarcy)
TopographicGradientDarcy.cell_connector = _cmf_core.cvar.TopographicGradientDarcy_cell_connector

class DarcyKinematic(lateral_sub_surface_flux):
    r"""


    A simple kinemtic wave model for subsurface flux.



    .. math::

         q = \\frac{\\Delta z_{surface}}{d} K(\\theta)_{source}
        A_{cross} 

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(DarcyKinematic self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0) -> DarcyKinematic
        DarcyKinematic(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0)
        cmf::upslope::connections::DarcyKinematic::DarcyKinematic Creates the
        connection.

        Parameters:
        -----------

        left:  Left node of the connection (needs to be soil water storage)

        right:  Right node of the connection (can be any node)

        FlowWidth:  the width of the connection - is multiplied by layer
        thickness to get the interface area

        Distance:  the length of the connection. If 0, the distance is
        calculated from the position of the nodes 
        """
        _cmf_core.DarcyKinematic_swiginit(self, _cmf_core.new_DarcyKinematic(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_DarcyKinematic

# Register DarcyKinematic in _cmf_core:
_cmf_core.DarcyKinematic_swigregister(DarcyKinematic)
DarcyKinematic.cell_connector = _cmf_core.cvar.DarcyKinematic_cell_connector

class Richards_lateral(lateral_sub_surface_flux):
    r"""


    Calculates the flux using Richard's equation for adjacent layers.



    .. math::

              q_{lat} = \\frac{\\Psi_1 -
        \\Psi_2}{\\|C_1-C_2\\|}      K(\\theta) A 

    where:
    :math:`q_{lat}` the lateral flow in :math:`m^3/day`

    :math:`\\Psi_i` the head of node i

    :math:`\\|C_1-C_2\\|` is the distance from Cell 1 to Cell 2

    :math:`K(\\theta_{1,2}) = \\sqrt{K(\\theta_1) K(\\theta_2)}`

    :math:`A` the crosssectional area of the interface between storages 1 and 2

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flow_thickness = property(_cmf_core.Richards_lateral_flow_thickness_get, _cmf_core.Richards_lateral_flow_thickness_set, doc=r"""flow_thickness : real""")
    wet_right_node = property(_cmf_core.Richards_lateral_wet_right_node_get, _cmf_core.Richards_lateral_wet_right_node_set, doc=r"""wet_right_node : bool""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Richards_lateral self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real FlowWidth=0, real Distance=0) -> Richards_lateral
        Richards_lateral(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth=0, real Distance=0)
        cmf::upslope::connections::Richards_lateral::Richards_lateral Creates
        the connection.

        Parameters:
        -----------

        left:  Left node of the connection (needs to be soil water storage)

        right:  Right node of the connection (can be any node)

        FlowWidth:  the width of the connection - is multiplied by layer
        thickness to get the interface area

        Distance:  the length of the connection. If 0, the distance is
        calculated from the position of the nodes 
        """
        _cmf_core.Richards_lateral_swiginit(self, _cmf_core.new_Richards_lateral(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Richards_lateral

# Register Richards_lateral in _cmf_core:
_cmf_core.Richards_lateral_swigregister(Richards_lateral)
Richards_lateral.cell_connector = _cmf_core.cvar.Richards_lateral_cell_connector

class TOPModelFlow(flux_connection):
    r"""


    Calculates a flux from a soil layer using TOPMODELs (Beven & Kirkby
    1979) exponential transmissivity concept.



    .. math::

         T = T_0 \\exp(-D_i/m) 

    where:  :math:`T` is the actual
    transmissivity of the profile in :math:`m^2/day`

    :math:`T0` is the transmissivity of the profile at saturation

    :math:`D_i` is the drained depth in m, calculated as :math:`(C-V)/A`, the capacity
    of the layer - volume per area

    :math:`m` a scaling factor in m

    By using the transmissivity in Darcy's law and assuming the GW
    gradient to be parallel to the topographic slope we get for the flow:


    .. math::

         q = T_0 \\exp(-D_i/m) w s

    where:  :math:`q` is the flux in
    :math:`m^3/day`

    :math:`w` is the flow width (unit contour length)

    :math:`s` is the topographic slope between layer and outlet

    TOPMODEL is based on the concept of drained depth, not, as cmf on the
    concept of stored volume. Hence, negative volumes can occur if

    C++ includes: subsurfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flow_width = property(_cmf_core.TOPModelFlow_flow_width_get, _cmf_core.TOPModelFlow_flow_width_set, doc=r"""flow_width : real""")
    distance = property(_cmf_core.TOPModelFlow_distance_get, _cmf_core.TOPModelFlow_distance_set, doc=r"""distance : real""")
    T0 = property(_cmf_core.TOPModelFlow_T0_get, _cmf_core.TOPModelFlow_T0_set, doc=r"""T0 : real""")
    m = property(_cmf_core.TOPModelFlow_m_get, _cmf_core.TOPModelFlow_m_set, doc=r"""m : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(TOPModelFlow self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right, real T0, real m, real flowwidth, real distance=0) -> TOPModelFlow
        TOPModelFlow(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real T0, real m, real flowwidth,
        real distance=0)
        cmf::upslope::connections::TOPModelFlow::TOPModelFlow
        """
        _cmf_core.TOPModelFlow_swiginit(self, _cmf_core.new_TOPModelFlow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_TOPModelFlow

# Register TOPModelFlow in _cmf_core:
_cmf_core.TOPModelFlow_swigregister(TOPModelFlow)
class Manning(flux_connection):
    r"""


    Calculates the flux between two open water bodies, using Manning's
    equation.

    This is the base class for a kinematic wave approach (topography
    driven) and a diffusive wave approach (water table driven). The only
    difference between both approaches is the calculation of the flux
    driving slope. For the model, one of ManningKinematic or
    ManningDiffusive connection is selected 

    .. math::

           v =  R^{\\frac 2 3}
        \\frac{\\sqrt{\\Delta_z}}{n} \\\\   q =  v \\cdot A


    Where:  :math:`A = \\frac V l`: Crosssectional area of the wetted
    crossection, Volume per length

    :math:`R = \\frac A{P(d)}`: The hydraulic radius

    :math:`P(d)`: the perimeter of the wetted crosssection, a function of reach
    depth

    :math:`d(V)`: the depth of the reach, a function of the volume

    :math:`\\Delta_z = \\frac{|z_1 - z_2|}{l}`: Slope of the reach

    :math:`n`: Manning friction number

    For the kinematic wave the slope of the river bed is used as slope:


    .. math::

        \\Delta_z = \\frac{|z_1 - z_2|}{l}

    while for the diffusive wave the slope is calculated from the actual
    water head: 

    .. math::

        \\Delta_z = \\frac{|h_1 - h_2|}{l}

    C++ includes: ManningConnection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    is_diffusive_wave = property(_cmf_core.Manning_is_diffusive_wave_get, _cmf_core.Manning_is_diffusive_wave_set, doc=r"""is_diffusive_wave : bool""")
    flux_geometry = property(_cmf_core.Manning_flux_geometry_get, _cmf_core.Manning_flux_geometry_set, doc=r"""flux_geometry : cmf::river::volume_height_function""")
    __swig_destroy__ = _cmf_core.delete_Manning

# Register Manning in _cmf_core:
_cmf_core.Manning_swigregister(Manning)
class Manning_Diffusive(Manning):
    r"""


    Connecting surface water bodies using a diffusive wave.

    This approach might not be numerical stable for deep water with small
    gradient cmf for experimental reasons 

    .. math::


        q_{Manning}&=& A R^{\\frac 2 3} \\sqrt{\\frac {\\Delta_z} n}
        \\\\   A &=& \\frac V l \\mbox{, (Crosssectional area of the
        wetted crossection, Volume per length)} \\\\   R &=& \\frac A
        {P(d)} \\\\   P(d) &=& \\mbox{ the perimeter of the wetted
        crosssection, a function of reach depth} \\\\   d(V) &=& \\mbox{
        the depth of the reach a function of the volume} \\\\
        \\Delta_z = \\|\\frac{h_1 - h_2}{l} \\mbox{ Slope of the reach
        waterlevels} \\\\ n&=&\\mbox{Manning friction number}




    C++ includes: ManningConnection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Manning_Diffusive self, cmf::river::OpenWaterStorage::ptr left, cmf::water::flux_node::ptr right, IChannel reachtype) -> Manning_Diffusive
        Manning_Diffusive(cmf::river::OpenWaterStorage::ptr left,
        cmf::water::flux_node::ptr right, const cmf::river::IChannel
        &reachtype) cmf::river::Manning_Diffusive::Manning_Diffusive Creates a
        diffusive wave connection between to open water storages.

        Parameters:
        -----------

        left:  right:  The nodes to be connected by the diffusive wave. Left
        needs to be an open water storage

        reachtype:  The channel geometry 
        """
        _cmf_core.Manning_Diffusive_swiginit(self, _cmf_core.new_Manning_Diffusive(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Manning_Diffusive

# Register Manning_Diffusive in _cmf_core:
_cmf_core.Manning_Diffusive_swigregister(Manning_Diffusive)
class Manning_Kinematic(Manning):
    r"""


    Connecting surface water bodies using a kinematic wave.

    Note the fixed gradient :math:`\\Delta_z` 

    .. math::


        q_{Manning}&=& A R^{\\frac 2 3} \\sqrt{\\frac {\\Delta_z} n}
        \\\\   A &=& \\frac V l \\mbox{, (Crosssectional area of the
        wetted crossection, Volume per length)} \\\\   R &=& \\frac A
        {P(d)} \\\\   P(d) &=& \\mbox{ the perimeter of the wetted
        crosssection, a function of reach depth} \\\\   d(V) &=& \\mbox{
        the depth of the reach a function of the volume} \\\\
        \\Delta_z &=& \\frac{\\|z_1 - z_2\\|}{l} \\mbox{ Slope of
        the reach} \\\\ n&=&\\mbox{Manning friction number}




    C++ includes: ManningConnection.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Manning_Kinematic self, cmf::river::OpenWaterStorage::ptr left, cmf::water::flux_node::ptr right, IChannel reachtype) -> Manning_Kinematic
        Manning_Kinematic(cmf::river::OpenWaterStorage::ptr left,
        cmf::water::flux_node::ptr right, const cmf::river::IChannel
        &reachtype) cmf::river::Manning_Kinematic::Manning_Kinematic Creates a
        kinematic wave connection between to open water storages.

        Parameters:
        -----------

        left:  right:  The nodes to be connected by the kinematic wave. Left
        needs to be an open water storage

        reachtype:  The channel geometry 
        """
        _cmf_core.Manning_Kinematic_swiginit(self, _cmf_core.new_Manning_Kinematic(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Manning_Kinematic

# Register Manning_Kinematic in _cmf_core:
_cmf_core.Manning_Kinematic_swigregister(Manning_Kinematic)
class CanopyOverflow(flux_connection):
    r"""


    Calculates the overflow of a canopy storage using a kinematic wave
    approach.

    This model routes only water that exceeds the canopy capacity to the
    ground with an ad hoc estimated function: 

    .. math::

        q_{CO} =
        \\left(\\frac{V_{act}-V_{max}}{V_{max}}\\right) ^2 \\cdot 2400
        \\frac{A_{cell}}{1000}

    With:  :math:`q_{CO}(t)[\\frac{m^3}{day}]`:
    The flux from canopy to the ground

    :math:`V_{act}[mm]=1000 [mm/m] \\frac{V_{canopy}[m^3]}{A_{cell} [m^2]}`
    The stored water of the canopy in mm

    :math:`V_{max}[mm]=c_{LAI}[mm] LAI` The capacity of the canopy in mm,
    defined by the factor CanopyCapacityPerLAI [mm/LAI], and the leaf area
    index LAI. (see: cmf::upslope::Vegetation)

    C++ includes: surfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(CanopyOverflow self, cmf::water::WaterStorage::ptr Canopy, cmf::water::flux_node::ptr target, Cell cell) -> CanopyOverflow
        CanopyOverflow(cmf::water::WaterStorage::ptr Canopy,
        cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell)
        cmf::upslope::connections::CanopyOverflow::CanopyOverflow
        """
        _cmf_core.CanopyOverflow_swiginit(self, _cmf_core.new_CanopyOverflow(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.CanopyOverflow_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_CanopyOverflow

# Register CanopyOverflow in _cmf_core:
_cmf_core.CanopyOverflow_swigregister(CanopyOverflow)
class RutterInterception(flux_connection):
    r"""


    Interception storage overflow according to the Rutter and Morton
    (1977) model.

    Calculates the interception overflow as a storage depending fraction
    of incoming rainfall The Rutter model of interception reads as follows
    after Meuser, A., 1990. Effects of afforestation on run-off
    characteristics. Agric. For. Meteorol. 50: 125-138.:


    .. math::

        \\frac{dI_C(t)}{dt}=P(t)(1-p_F-p_S)-P(t)(1-p_F-
        p_S)\\frac{I_C(t)}{I_CMAX}-f_I(E-e)(t)

    With :math:`I_C` the current
    canopy storage and :math:`P(t)` the current rainfall.

    The second term of the equation denotes the flux from the canopy to
    the ground. The implemented formula for canopy storage overflow reads
    then as: 

    .. math::

        q_{CO}(t) =
        P_{net}(t)\\frac{V_{act}[mm]}{V_{max}[mm]}

    With:
    :math:`q_{CO}(t)[\\frac{m^3}{day}]`: The flux from canopy to the ground

    :math:`P_{net}(t)[\\frac{m^3}{day}]`: The flux from the rain to the canopy

    :math:`V_{act}[mm]=1000 [mm/m] \\frac{V_{canopy}[m^3]}{A_{cell} [m^2]}`
    The stored water of the canopy in mm

    :math:`V_{max}[mm]=c_{LAI}[mm]\\cdot LAI` The capacity of the canopy in
    mm, defined by the factor CanopyCapacityPerLAI [mm/LAI], and the leaf
    area index LAI. (see: cmf::upslope::vegetation::Vegetation)

    C++ includes: surfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(RutterInterception self, cmf::water::WaterStorage::ptr Canopy, cmf::water::flux_node::ptr target, Cell cell) -> RutterInterception
        RutterInterception(cmf::water::WaterStorage::ptr Canopy,
        cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell)
        cmf::upslope::connections::RutterInterception::RutterInterception
        """
        _cmf_core.RutterInterception_swiginit(self, _cmf_core.new_RutterInterception(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.RutterInterception_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_RutterInterception

# Register RutterInterception in _cmf_core:
_cmf_core.RutterInterception_swigregister(RutterInterception)
class TempIndexSnowMelt(flux_connection):
    r"""


    Calculates snow melt using a simple degree day method.



    .. math::

         q_{melt} [mm/day] = (T-T_{thres}) * r 

    Usage:

    C++ includes: surfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SnowMeltRate = property(_cmf_core.TempIndexSnowMelt_SnowMeltRate_get, _cmf_core.TempIndexSnowMelt_SnowMeltRate_set, doc=r"""SnowMeltRate : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(TempIndexSnowMelt self, cmf::water::WaterStorage::ptr snow, cmf::water::flux_node::ptr surface_water, Cell cell, real rate=7.0) -> TempIndexSnowMelt
        TempIndexSnowMelt(cmf::water::WaterStorage::ptr snow,
        cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell,
        real rate=7.0)
        cmf::upslope::connections::TempIndexSnowMelt::TempIndexSnowMelt
        Creates a new snow melt connection.

        Parameters:
        -----------

        snow:  Snow storage, usually cel.snow

        surface_water:  target of the melted water (usually cell.surfacewater)

        cell:  The cell, needed to get weather and area

        rate:  The rate of snow melt, given in mm/(degC day), default = 7.0 
        """
        _cmf_core.TempIndexSnowMelt_swiginit(self, _cmf_core.new_TempIndexSnowMelt(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.TempIndexSnowMelt_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_TempIndexSnowMelt

# Register TempIndexSnowMelt in _cmf_core:
_cmf_core.TempIndexSnowMelt_swigregister(TempIndexSnowMelt)
class EnergyBudgetSnowMelt(flux_connection):
    r"""


    Calculates snow melt using the surface energy budget method.

    C++ includes: surfacefluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(EnergyBudgetSnowMelt self, cmf::water::WaterStorage::ptr snow, cmf::water::flux_node::ptr surface_water, Cell cell) -> EnergyBudgetSnowMelt
        EnergyBudgetSnowMelt(cmf::water::WaterStorage::ptr snow,
        cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell)
        cmf::upslope::connections::EnergyBudgetSnowMelt::EnergyBudgetSnowMelt
        """
        _cmf_core.EnergyBudgetSnowMelt_swiginit(self, _cmf_core.new_EnergyBudgetSnowMelt(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.EnergyBudgetSnowMelt_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_EnergyBudgetSnowMelt

# Register EnergyBudgetSnowMelt in _cmf_core:
_cmf_core.EnergyBudgetSnowMelt_swigregister(EnergyBudgetSnowMelt)
snowfraction = _cmf_core.snowfraction
class Rainfall(flux_connection):
    r"""


    A connection routing rainfall to surface water and to an eventually
    existing canopy storage.

    C++ includes: AtmosphericFluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Throughfall = property(_cmf_core.Rainfall_Throughfall_get, _cmf_core.Rainfall_Throughfall_set, doc=r"""Throughfall : bool""")
    InterceptedRainfall = property(_cmf_core.Rainfall_InterceptedRainfall_get, _cmf_core.Rainfall_InterceptedRainfall_set, doc=r"""InterceptedRainfall : bool""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Rainfall self, cmf::water::flux_node::ptr target, Cell cell, bool getthroughfall=True, bool getintercepted=True) -> Rainfall
        Rainfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell,
        bool getthroughfall=true, bool getintercepted=true)
        cmf::upslope::connections::Rainfall::Rainfall Creates a new Rainfall
        connection. 
        """
        _cmf_core.Rainfall_swiginit(self, _cmf_core.new_Rainfall(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Rainfall

# Register Rainfall in _cmf_core:
_cmf_core.Rainfall_swigregister(Rainfall)
class Snowfall(flux_connection):
    r"""


    A connection routing snowfall (precipitation below freezing Temp) to
    the snow pack.

    C++ includes: AtmosphericFluxes.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Snowfall self, cmf::water::flux_node::ptr target, Cell cell) -> Snowfall
        Snowfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell)
        cmf::upslope::connections::Snowfall::Snowfall
        """
        _cmf_core.Snowfall_swiginit(self, _cmf_core.new_Snowfall(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_Snowfall

# Register Snowfall in _cmf_core:
_cmf_core.Snowfall_swigregister(Snowfall)
class MatrixInfiltration(flux_connection):
    r"""


    Connects the surfacewater and the most upper layer using a Richards
    equation like infiltration model.

    The potential infiltration is calculated according to the Richards
    equation. The gradient is from the cell surface to the center of the
    first layer and the conductivity is the geometric mean of the wetted
    surface ( :math:`K_{sat}`) and the conductivity of the layer center (
    :math:`K(\\theta_{layer})` 

    .. math::

         q_{max} &=&
        \\frac{\\Psi_{surface} - \\Psi_{soil}}{\\Delta z} K A_{cell}
        \\\\ K &=& \\sqrt{K\\left(\\theta_{layer}\\right)K_{sat}}
        \\\\ \\Delta z &=& z_{cell} - z_{layer center}




    If the surface water is modeled by a distinct water storage, the
    actual infiltration is given as the product of the potential
    infiltration with the coverage of the surface water
    cmf::upslope::Cell::surface_water_coverage 

    .. math::

        q_{act} = q_{max}
        \\frac{A_{water}}{A_{cell}}

    If the surface water is no storage on its own, but just a water
    distribution node, the actual infiltration is the minimum of the
    potential infiltration and the current inflow (rain, snow melt) to the
    surface 

    .. math::

        q_{act} = \\min\\left(q_{max},
        \\sum{q_{in,surfacewater}}\\right)

    C++ includes: infiltration.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(MatrixInfiltration self, cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr surfacewater) -> MatrixInfiltration
        MatrixInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
        cmf::water::flux_node::ptr surfacewater)
        cmf::upslope::connections::MatrixInfiltration::MatrixInfiltration
        """
        _cmf_core.MatrixInfiltration_swiginit(self, _cmf_core.new_MatrixInfiltration(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.MatrixInfiltration_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_MatrixInfiltration

# Register MatrixInfiltration in _cmf_core:
_cmf_core.MatrixInfiltration_swigregister(MatrixInfiltration)
class GreenAmptInfiltration(flux_connection):
    r"""


    Connects the surfacewater and the most upper layer using a Green-Ampt
    equation like infiltration.

    The Green-Ampt formula is given as: 

    .. math::

        q(t) = -K_s \\frac{dh}{dz}
        A

    where:  :math:`q(t)` is the infiltration rate in m3/day

    :math:`K_s` is the saturated conductivity in m/day

    :math:`\\frac{dh}{dz}` is the hydraulic gradient in the wetting front

    :math:`A` is the surface area of the cell

    The gradient in the wetting front is calculated as:


    .. math::

        \\frac{dh}{dz} = \\frac{h_f - h_0}{Z_f} =
        \\frac{|\\Psi_f| + Z_f}{Z_f}

    where:  :math:`h_f` is the hydraulic
    head at the bottom of the wetting front in m

    :math:`h_0` is the hydraulic head at the surface in m

    :math:`Z_f` is the length of the wetting front in m

    Since :math:`Z_f` is unknown, the depth of the wetting front can be
    approximated by: 

    .. math::

        Z_f = \\frac{F}{\\theta_s -
        \\theta_i}

    with:  :math:`F` the accumulated volume per area of
    infiltrated water

    :math:`\\theta_s, \\theta_i` the volumetric water content at saturation
    resp. at start of the infiltration

    If the surface water is modeled by a distinct water storage, the
    actual infiltration is given as the product of the potential
    infiltration with the coverage of the surface water
    cmf::upslope::Cell::surface_water_coverage 

    .. math::

        q_{act} = q_{max}
        \\frac{A_{water}}{A_{cell}}

    If the surface water is no storage on its own, but just a water
    distribution node, the actual infiltration is the minimum of the
    potential infiltration and the current inflow (rain, snow melt) to the
    surface 

    .. math::

        q_{act} = \\min\\left(q_{max},
        \\sum{q_{in,surfacewater}}\\right)

    C++ includes: infiltration.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(GreenAmptInfiltration self, cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr surfacewater) -> GreenAmptInfiltration
        GreenAmptInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
        cmf::water::flux_node::ptr surfacewater)
        cmf::upslope::connections::GreenAmptInfiltration::GreenAmptInfiltration
        """
        _cmf_core.GreenAmptInfiltration_swiginit(self, _cmf_core.new_GreenAmptInfiltration(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.GreenAmptInfiltration_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_GreenAmptInfiltration

# Register GreenAmptInfiltration in _cmf_core:
_cmf_core.GreenAmptInfiltration_swigregister(GreenAmptInfiltration)
class ConceptualInfiltration(flux_connection):
    r"""


    Connects the surfacewater and the most upper layer using a simplified
    infiltration model suitable for conceptional models.



    .. math::

         q_{inf} = \\left(1-e_{sat}\\left(W, W_0\\right)\\right)
        q_{inf,pot} 

    where:  :math:`q_{inf}` Effective infiltration from
    surface to first layer (soil)

    :math:`e_{sat}(W, W_0)` Saturation excess, ranging from 0 (nowhere saturated
    soil layer) to 1 (fully saturated). :math:`W` is the average wetness
    calculated from the soil layer, :math:`W_0` is a parameter denoting the
    wetness, where 50% of the layer is saturated using a sigmoidal
    function:  :math:`e_{sat}(W_{soil}, W_0) = \\left(1+e^{-(W-W_0)0.2(1-W_0)}\\right)^{-1}`

    :math:`q_{inf,pot}` is the potential infiltration, given by the incoming
    fluxes limited by the saturated conductivity:  :math:`q_{inf,pot} = \\min(q_{in}, K_{sat} A)`  :math:`q_{in}` Sum of incoming fluxes to the
    surfacewater in :math:`m^3/day`

    :math:`K_{sat}` Saturated conductivity in :math:`m/day`

    :math:`A` Cell area in :math:`m^2`

    C++ includes: infiltration.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    W0 = property(_cmf_core.ConceptualInfiltration_W0_get, _cmf_core.ConceptualInfiltration_W0_set, doc=r"""W0 : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ConceptualInfiltration self, cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr surfacewater, real W0=0.9) -> ConceptualInfiltration
        ConceptualInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
        cmf::water::flux_node::ptr surfacewater, real W0=0.9)
        cmf::upslope::connections::ConceptualInfiltration::ConceptualInfiltration
        Creates the connection between surfacewater and first soil layer.

        Parameters:
        -----------

        soilwater:  the infiltration target

        surfacewater:  the infiltration source

        W0:  the 50% saturation value 
        """
        _cmf_core.ConceptualInfiltration_swiginit(self, _cmf_core.new_ConceptualInfiltration(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.ConceptualInfiltration_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_ConceptualInfiltration

# Register ConceptualInfiltration in _cmf_core:
_cmf_core.ConceptualInfiltration_swigregister(ConceptualInfiltration)
class SWATPercolation(flux_connection):
    r"""


    A tipping bucket percolation approach similar to the approach in SWAT.



    .. math::

         q_{perc} &=&
        V_{H_2O,drain}\\left(1-e^{-\\frac 1{-TT_{perc}}}\\right)
        \\\\ TT_{perc} &=& \\frac{V_{pores,drain} - V_{field
        cap.}}{K_{sat}} \\\\ V_{x,drain} &=& V_{x,drain} - V_{field cap.}




    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    use_for_cell = _swig_new_static_method(_cmf_core.SWATPercolation_use_for_cell)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SWATPercolation self, cmf::upslope::SoilLayer::ptr upperLayer, cmf::upslope::SoilLayer::ptr lowerLayer) -> SWATPercolation
        SWATPercolation(cmf::upslope::SoilLayer::ptr upperLayer,
        cmf::upslope::SoilLayer::ptr lowerLayer)
        cmf::upslope::connections::SWATPercolation::SWATPercolation
        """
        _cmf_core.SWATPercolation_swiginit(self, _cmf_core.new_SWATPercolation(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SWATPercolation

# Register SWATPercolation in _cmf_core:
_cmf_core.SWATPercolation_swigregister(SWATPercolation)
class Richards(flux_connection):
    r"""


    Calculates flow according to the Richards equation.



    .. math::

         q_{Richards} &=&
        \\frac{\\Delta\\Psi_{tot}}{d} K(\\theta) A \\\\
        \\Psi_{tot} &= &\\Psi_{M}(\\theta) + h 

     where
    :math:`\\Delta\\Psi_{tot} [m]` is the difference of the total water
    potentials of the two soil layers

    :math:`d [m]` is the distance between the two soil layers

    :math:`K(\\theta)\\left[\\frac m{day}\\right]` is the geometric
    mean conductivity (see SoilType::Kunsat)

    :math:`A [m^2]` is the crosssectional area of the flux

    :math:`\\Psi_M(\\theta) [m]` is the matrix potential (see
    SoilType::MatrixPotential)

    :math:`h [m]` is the height of a soil layer above sea level

    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Richards self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right) -> Richards
        Richards(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
        right) cmf::upslope::connections::Richards::Richards Creates a
        Richards equation connection between two soil layers (left and right,
        rather top and bottom) of the same cell. 
        """
        _cmf_core.Richards_swiginit(self, _cmf_core.new_Richards(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.Richards_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_Richards

# Register Richards in _cmf_core:
_cmf_core.Richards_swigregister(Richards)
class FreeDrainagePercolation(flux_connection):
    r"""


    Calculates a free drainage (unit gradient) from a layer to somewhere
    else.



    .. math::

         q = K(\\theta) A

    where:  :math:`q` Flux from the layer to the
    other side of the connection in :math:`m^3/day`

    :math:`K(\\theta)` Actual conductivity in :math:`m/day` depending on the water
    content of the layer :math:`\\theta`

    :math:`A` Cell area in :math:`m^2`

    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(FreeDrainagePercolation self, cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right) -> FreeDrainagePercolation
        FreeDrainagePercolation(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right)
        cmf::upslope::connections::FreeDrainagePercolation::FreeDrainagePercolation
        """
        _cmf_core.FreeDrainagePercolation_swiginit(self, _cmf_core.new_FreeDrainagePercolation(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_FreeDrainagePercolation

# Register FreeDrainagePercolation in _cmf_core:
_cmf_core.FreeDrainagePercolation_swigregister(FreeDrainagePercolation)
class LayerBypass(flux_connection):
    r"""


    A simplification of macro pore flux for swelling soils.

    Connects the surfacewater of the cell with deeper layers, assuming the
    presence of cracks. At saturation level of the target layer, the
    cracks are closed 

    .. math::

        q_{crack} = K_{max,crack}
        \\left(1-\\left(\\frac{w-w_0}{1-w_0}\\right)^\\beta\\right)
        A

    where:  :math:`q_{crack}` is the flux from the surface water to the
    target layer in m3/day

    :math:`K_{max,crack}` is the maximum conductivity of the cracks in m/day

    :math:`w` is the actual wetness of the target layer

    :math:`w_0` is saturation, where the shrinkage of the cracks starts

    :math:`\\beta` is an empirical shape parameter of the crack size/wetness
    relation

    :math:`A` is the area of the cell

    C++ includes: Percolation.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Kmax = property(_cmf_core.LayerBypass_Kmax_get, _cmf_core.LayerBypass_Kmax_set, doc=r"""Kmax : real""")
    w0 = property(_cmf_core.LayerBypass_w0_get, _cmf_core.LayerBypass_w0_set, doc=r"""w0 : real""")
    beta = property(_cmf_core.LayerBypass_beta_get, _cmf_core.LayerBypass_beta_set, doc=r"""beta : real""")
    K = _swig_new_instance_method(_cmf_core.LayerBypass_K)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(LayerBypass self, cmf::water::flux_node::ptr left, cmf::upslope::SoilLayer::ptr right, real Kmax=100., real w0=0.0, real beta=1.0) -> LayerBypass
        LayerBypass(cmf::water::flux_node::ptr left,
        cmf::upslope::SoilLayer::ptr right, real Kmax=100., real w0=0.0, real
        beta=1.0) cmf::upslope::connections::LayerBypass::LayerBypass Creates
        a layer bypass connection.

        Parameters:
        -----------

        left:  The source of the flux, usually the surfacewater of the cell

        right:  The target soil layer

        Kmax:  maximum conductivity of the cracks in m/day

        w0:  is the actual wetness of the target layer

        beta:  is an empirical shape parameter of the crack size/wetness
        relation 
        """
        _cmf_core.LayerBypass_swiginit(self, _cmf_core.new_LayerBypass(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_LayerBypass

# Register LayerBypass in _cmf_core:
_cmf_core.LayerBypass_swigregister(LayerBypass)
class RootUptakeStressFunction(object):
    r"""


    An abstract class to calculate the actual transpiration from potential
    transpiration.

    Implementations of WaterStressFunction are used by ET connections
    derived from cmf::upslope::ET::stressedET

    C++ includes: waterstress.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Tact = _swig_new_instance_method(_cmf_core.RootUptakeStressFunction_Tact)
    copy = _swig_new_instance_method(_cmf_core.RootUptakeStressFunction_copy)
    to_string = _swig_new_instance_method(_cmf_core.RootUptakeStressFunction_to_string)
    __swig_destroy__ = _cmf_core.delete_RootUptakeStressFunction

# Register RootUptakeStressFunction in _cmf_core:
_cmf_core.RootUptakeStressFunction_swigregister(RootUptakeStressFunction)
class SuctionStress(RootUptakeStressFunction):
    r"""


    The classical suction depending transpiration Stress curve after
    Feddes.

    The ability of roots to take water from the soil up is limited by the
    suction pressure (matrix potential) of the soil. The stress is defined
    using a trapezoid function, with P0 being the pressure, where water
    uptake is prohibited by saturation. Between P0 and P1 the saturation
    stress gets lower. Between P1 and P2, no stress occurs ( ET=ETpot) and
    with a pressure below P2, water uptake is limited by drought. P3
    indicates the highest suction (lowest pressure) to which plants can
    extract water (wilting point).

    Default values: :math:`P_0 = \\infty, P_1=\\infty, P_2=-5m, P_3=-160m`,
    resulting in no saturation stress and draught stress starting at -5m
    and a wilting point of -160m.

    If one would like to include saturation stress, typical values for P0
    and P1 are 0.0m and 0.1m. By changing P2 and P3, you can account for
    different drought sensibility for different plant types.

    C++ includes: waterstress.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    P0 = property(_cmf_core.SuctionStress_P0_get, _cmf_core.SuctionStress_P0_set, doc=r"""P0 : real""")
    P1 = property(_cmf_core.SuctionStress_P1_get, _cmf_core.SuctionStress_P1_set, doc=r"""P1 : real""")
    P2 = property(_cmf_core.SuctionStress_P2_get, _cmf_core.SuctionStress_P2_set, doc=r"""P2 : real""")
    P3 = property(_cmf_core.SuctionStress_P3_get, _cmf_core.SuctionStress_P3_set, doc=r"""P3 : real""")

    def __init__(self, *args):
        r"""
        __init__(SuctionStress self, real P0=1e308, real P1=1e307, real P2=-5, real P3=-160) -> SuctionStress
        __init__(SuctionStress self, SuctionStress other) -> SuctionStress
        SuctionStress(real P0=1e308, real P1=1e307, real P2=-5, real
        P3=-160) cmf::upslope::ET::SuctionStress::SuctionStress Creates a new
        suction stress function. 
        """
        _cmf_core.SuctionStress_swiginit(self, _cmf_core.new_SuctionStress(*args))
    copy = _swig_new_instance_method(_cmf_core.SuctionStress_copy)
    __swig_destroy__ = _cmf_core.delete_SuctionStress

# Register SuctionStress in _cmf_core:
_cmf_core.SuctionStress_swigregister(SuctionStress)
class ContentStress(RootUptakeStressFunction):
    r"""


    A simple water content based stress model based on Feddes (1978)

    stress a is piecewise linear function based on water content

    if :math:`\\theta>\\theta_d \\rightarrow ET = ET_{pot}`

    if :math:`\\theta_d>\\theta > \\theta_{wilt} \\rightarrow ET = \\frac{\\theta_d - \\theta}{\\theta_d - \\theta_{wilt}} ET_{pot}`

    if :math:`\\theta_{wilt}>\\theta \\rightarrow ET = 0.0`

    The parameters :math:`\\theta_{d,w}` can be omitted (or set to a negative
    value) to use default values derived from the layer properties. The
    critical water content (where stress starts) is then defined (conf.
    Feddes 1978) as the center between field capacity ( :math:`\\theta_{fc}`)
    and the wilting point ( :math:`\\theta_{wp}`).  :math:`\\theta_w = \\theta(pF=4.2)`: Water content at pF=4.2

    :math:`\\theta_d = 1/2 (\\theta(pF=1.8) + \\theta(pF=4.2))`

    C++ includes: waterstress.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    theta_d = property(_cmf_core.ContentStress_theta_d_get, _cmf_core.ContentStress_theta_d_set, doc=r"""theta_d : real""")
    theta_w = property(_cmf_core.ContentStress_theta_w_get, _cmf_core.ContentStress_theta_w_set, doc=r"""theta_w : real""")
    copy = _swig_new_instance_method(_cmf_core.ContentStress_copy)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ContentStress self, real theta_d=-1, real theta_w=-1) -> ContentStress
        ContentStress(real theta_d=-1, real theta_w=-1)
        cmf::upslope::ET::ContentStress::ContentStress Creates a new
        ContentStress for critical water content theta_d in vol Water/vol Soil
        and wilting point theta_w. 
        """
        _cmf_core.ContentStress_swiginit(self, _cmf_core.new_ContentStress(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_ContentStress

# Register ContentStress in _cmf_core:
_cmf_core.ContentStress_swigregister(ContentStress)
class VolumeStress(RootUptakeStressFunction):
    r"""


    A WaterStressFunction based on the stored water volume of a layer.

    If the layer contains more water than V1, ET is not limited (
    ET=ETpot). Below V1 ET goes linear to 0.0 at V0

    C++ includes: waterstress.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    V1 = property(_cmf_core.VolumeStress_V1_get, _cmf_core.VolumeStress_V1_set, doc=r"""V1 : real""")
    V0 = property(_cmf_core.VolumeStress_V0_get, _cmf_core.VolumeStress_V0_set, doc=r"""V0 : real""")

    def __init__(self, *args):
        r"""
        __init__(VolumeStress self, real V1, real V0) -> VolumeStress
        __init__(VolumeStress self, VolumeStress other) -> VolumeStress
        VolumeStress(real V1, real V0)
        cmf::upslope::ET::VolumeStress::VolumeStress Creates a new water
        stress function for water volume.

        Parameters:
        -----------

        V1:  Water content in :math:`m^3` without stress ( ET=ETpot)

        V0:  Water content in :math:`m^3` with full stress ( ET=0.0) 
        """
        _cmf_core.VolumeStress_swiginit(self, _cmf_core.new_VolumeStress(*args))
    copy = _swig_new_instance_method(_cmf_core.VolumeStress_copy)
    __swig_destroy__ = _cmf_core.delete_VolumeStress

# Register VolumeStress in _cmf_core:
_cmf_core.VolumeStress_swigregister(VolumeStress)
class log_wind_profile(aerodynamic_resistance):
    r"""


    , A logarithmic wind profile

    Todo Cite literature for this windprofile and insert equation

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(log_wind_profile self, Cell _cell) -> log_wind_profile
        log_wind_profile(cmf::upslope::Cell &_cell)
        cmf::atmosphere::log_wind_profile::log_wind_profile
        """
        _cmf_core.log_wind_profile_swiginit(self, _cmf_core.new_log_wind_profile(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_log_wind_profile

# Register log_wind_profile in _cmf_core:
_cmf_core.log_wind_profile_swigregister(log_wind_profile)
PenmanMonteith = _cmf_core.PenmanMonteith
class stressedET(flux_connection):
    r"""


    An abstract base class for ET Methods with a WaterStressFunction.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    get_layer = _swig_new_instance_method(_cmf_core.stressedET_get_layer)
    ETpot = _swig_new_instance_method(_cmf_core.stressedET_ETpot)
    __swig_destroy__ = _cmf_core.delete_stressedET

# Register stressedET in _cmf_core:
_cmf_core.stressedET_swigregister(stressedET)
class constantETpot(stressedET):
    r"""


    A constant evapotranspiration.

    Uses a constant measured or elsewhere modelled ETpot. Actual
    Evapotranspiration is calculated from rootdepth and actual matrix
    potential in the layers using Tact. The value of ETpot can be changed
    during runtime

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ETpot_value = property(_cmf_core.constantETpot_ETpot_value_get, _cmf_core.constantETpot_ETpot_value_set, doc=r"""ETpot_value : real""")
    GetETpot = _swig_new_instance_method(_cmf_core.constantETpot_GetETpot)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(constantETpot self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, double constantETpot_value) -> constantETpot
        constantETpot(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, double constantETpot_value)
        cmf::upslope::ET::constantETpot::constantETpot
        """
        _cmf_core.constantETpot_swiginit(self, _cmf_core.new_constantETpot(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_constantETpot

# Register constantETpot in _cmf_core:
_cmf_core.constantETpot_swigregister(constantETpot)
class timeseriesETpot(stressedET):
    r"""


    A timeseries driven evapotranspiration.

    Uses a timeseries of measured or elsewhere modelled ETpot. Actual
    Evapotranspiration is calculated from rootdepth and actual matrix
    potential in the layers using Tact. The value of ETpot can be changed
    during runtime

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ETpot_data = property(_cmf_core.timeseriesETpot_ETpot_data_get, _cmf_core.timeseriesETpot_ETpot_data_set, doc=r"""ETpot_data : cmf::math::timeseries""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(timeseriesETpot self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, timeseries ETpot_values) -> timeseriesETpot
        timeseriesETpot(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, cmf::math::timeseries
        ETpot_values) cmf::upslope::ET::timeseriesETpot::timeseriesETpot
        """
        _cmf_core.timeseriesETpot_swiginit(self, _cmf_core.new_timeseriesETpot(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_timeseriesETpot

# Register timeseriesETpot in _cmf_core:
_cmf_core.timeseriesETpot_swigregister(timeseriesETpot)
class PenmanMonteithET(stressedET):
    r"""


    Calculates the potential evapotranspiration according to FAO(1998)

    Governing equations: 

    .. math::

         \\lambda ET &=&
        \\frac{\\Delta\\left(R_n - G\\right)+\\rho_a c_p
        \\frac{e_s - e_a}{r_a}}{\\Delta +
        \\gamma\\left(1+\\frac{r_s}{r_a}\\right)} \\mbox{ FAO 1998,
        Eq. 3} \\\\ \\mbox{With:} \\\\ \\Delta &=& 4098
        \\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\frac{kPa}{^\\circ C}
        \\mbox{   (FAO 1998, Eq. 13)} \\\\ T &=& \\mbox{Actual
        Temperature in } ^\\circ C  \\\\ R_n &=& \\mbox{net Radiation
        (see Atmosphere) in } \\frac{MJ}{m^2day}   \\\\ G &=& 0 \\
        \\frac{MJ}{m^2day} \\mbox{ if daily average (FAO 1998, Eq. 42)}
        \\\\     && 0.1 R_n \\ \\mbox{ if day time (FAO 1998, Eq. 45)}
        \\\\     && 0.5 R_n \\ \\mbox{ if night time (FAO 1998, Eq.
        46)} \\\\ \\gamma &=& \\frac{c_p P}{\\epsilon \\lambda}
        \\mbox{ (FAO 1998,Eq. 8): Psychrometric constant }
        \\frac{kPa}{^\\circ C} \\\\ c_p &=& 0.001013
        \\frac{MJ}{kg\\ ^\\circ C}\\mbox{ specific heat at constant
        pressure } \\\\ P &=& 101.3
        \\left(\\frac{293-0.0065z}{293}\\right)^{5.26}  \\mbox{ (FAO
        1998,Eq. 7)} \\\\ \\epsilon &=& 0.622 \\frac{mol/g \\mbox{
        vapor}}{mol/g \\mbox{ liquid water}} \\\\ \\lambda &=& 2.45
        \\frac{MJ}{kg} \\mbox{ (FAO 1998,Eq. 8)} \\\\ R &=& 0.287
        \\frac{kJ}{kg\\ k}\\mbox{ Spec. gas const.}        \\\\
        \\rho_a &=&     \\frac{P}{1.01(T+273)R} \\mbox{ (FAO 1998,Box.
        6)} \\\\ e_s &=& \\mbox{ Sat. vapor press. } [kPa] \\\\ e_a
        &=& \\mbox{ Act. vapor press. } [kPa] \\\\ r_a &=&
        \\frac{\\ln\\left(\\frac{2-d}{z_{om}}\\right)\\ln\\left(\\frac{2-d}{z_{oh}}\\right)}{k^2
        u_2} \\mbox{ (FAO 1998, Eq. 4/Box 4} \\frac s m \\\\ &&
        d=\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1 z_{om}, k=0.41 \\\\ h
        &=& \\mbox{ Vegetation height in }m \\\\ u_2 &=& \\mbox{
        Windspeed in 2m above canopy } \\frac m s \\\\ r_s &=&
        \\frac{r_l}{LAI_{Active}} \\mbox{ (FAO 1998, Eq. 5/Box 5)}
        \\frac s m \\\\ && r_l=100 \\frac s m, LAI_{Active}=0.5 LAI




    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    daily = property(_cmf_core.PenmanMonteithET_daily_get, _cmf_core.PenmanMonteithET_daily_set, doc=r"""daily : bool""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PenmanMonteithET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target) -> PenmanMonteithET
        PenmanMonteithET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target)
        cmf::upslope::ET::PenmanMonteithET::PenmanMonteithET
        """
        _cmf_core.PenmanMonteithET_swiginit(self, _cmf_core.new_PenmanMonteithET(*args, **kwargs))
    r_s = _swig_new_static_method(_cmf_core.PenmanMonteithET_r_s)
    r_a = _swig_new_static_method(_cmf_core.PenmanMonteithET_r_a)
    use_for_cell = _swig_new_static_method(_cmf_core.PenmanMonteithET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_PenmanMonteithET

# Register PenmanMonteithET in _cmf_core:
_cmf_core.PenmanMonteithET_swigregister(PenmanMonteithET)
class PriestleyTaylorET(stressedET):
    r"""


    Calculates the Evapotranspiration using Priestley-Taylor equation.



    .. math::

        lambda ET = \\alpha \\frac{\\Delta}{\\Delta + \\gamma}
        \\left(R_n - G\\right)

    where:  :math:`\\Delta = 4098 \\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\frac{kPa}{^\\circ C}`,
    the slope of the vapor pressure/ temperature curve

    :math:`\\gamma = \\frac{c_p P}{\\epsilon \\lambda} \\frac{kPa}{^\\circ C}` Psychrometric constant

    :math:`\\lambda = 2.45 \\frac{MJ}{kg}` the latent heat of vaporization

    :math:`R_n \\frac{MJ}{m^2day}` net Radiation (see Atmosphere)

    :math:`G` Ground heat flux

    :math:`\\alpha` the Priestley-Taylor constant (default 1.26 for humid
    climates)

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    daily = property(_cmf_core.PriestleyTaylorET_daily_get, _cmf_core.PriestleyTaylorET_daily_set, doc=r"""daily : bool""")
    alpha = property(_cmf_core.PriestleyTaylorET_alpha_get, _cmf_core.PriestleyTaylorET_alpha_set, doc=r"""alpha : real""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PriestleyTaylorET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, real alpha=1.26) -> PriestleyTaylorET
        PriestleyTaylorET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, real alpha=1.26)
        cmf::upslope::ET::PriestleyTaylorET::PriestleyTaylorET
        """
        _cmf_core.PriestleyTaylorET_swiginit(self, _cmf_core.new_PriestleyTaylorET(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.PriestleyTaylorET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_PriestleyTaylorET

# Register PriestleyTaylorET in _cmf_core:
_cmf_core.PriestleyTaylorET_swigregister(PriestleyTaylorET)
class HargreaveET(stressedET):
    r"""


    Calculates the Evapotranspiration using Hargreave's equation.



    .. math::

        ET_{rc} = 0.0135 K_T\\ s_0 \\sqrt{\\Delta T} (T +
        17.8)

    where:  :math:`ET_{rc}` the reference crop evapotranspiration
    in mm/day

    :math:`K_T = 0.00185{\\Delta T}^2 - 0.0433 \\Delta T + 0.4023`
    Continentality factor as given in the reference

    :math:`\\Delta T = |T_{max} - T_{min}|[K]` Daily temperature range

    :math:`T [^\\circ C]` daily mean temperature

    :math:`s_0 = 15.392 d_r \\left(\\omega_s\\sin(\\Phi) \\sin{\\gamma} + \\cos{\\Phi}\\cos{\\gamma} * \\sin(\\omega_s)\\right)` the extraterrestrial solar radiation
    in mm/day

    :math:`d_r = 1 + 0.0033 \\cos(DOY\\frac{2 \\pi}{365})` relative
    distance between earth and sun

    :math:`\\omega_s = \\arccos(-\\tan{\\Phi} \\tan{\\gamma})`
    sunset hour angle (radians)

    :math:`\\gamma = 0.4039 \\sin(DOY\\frac{2 \\pi}{365} - 1.405)`
    solar declination (radians)

    :math:`\\Phi` geographic latitude (radians)

    See:  SAMANI, Zohrab.Estimating solar radiation and evapotranspiration
    using minimum climatological data. Journal of Irrigation and Drainage
    Engineering, 2000, 126. Jg., Nr. 4, S. 265-267.  Crop specific
    potential evapotranspiration is scaled by LAI: :math:`ET_{pot} = ET_{rc} \\frac{LAI}{2.88}`.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(HargreaveET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target) -> HargreaveET
        HargreaveET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target)
        cmf::upslope::ET::HargreaveET::HargreaveET
        """
        _cmf_core.HargreaveET_swiginit(self, _cmf_core.new_HargreaveET(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.HargreaveET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_HargreaveET

# Register HargreaveET in _cmf_core:
_cmf_core.HargreaveET_swigregister(HargreaveET)
class OudinET(stressedET):
    r"""


    Calculates ETpot after Oudin et al 2005.

    https://doi.org/10.1016/j.jhydrol.2004.08.026 This ETpot formula is a
    generalization of two older approaches by introducing parameters to
    shape the dependency of ETpot from temperature and extraterrestrial
    radiation

    :math:`\\lambda ET_{pot} = R_{a} \\cdot \\frac{T_{a} + K_2}{K_1}`

    Oudin et al (2005) found an optimum for :math:`K_1=100, K_2=5`. The origin
    of this formula lays in Jensen & Haise (1963) with :math:`K_1=40, K_2=0` and
    McGuiness-Bordne (1972) with :math:`K_1=68, K_2=5`.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(OudinET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, double K1=100, double K2=5) -> OudinET
        OudinET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, double K1=100, double K2=5)
        cmf::upslope::ET::OudinET::OudinET
        """
        _cmf_core.OudinET_swiginit(self, _cmf_core.new_OudinET(*args, **kwargs))
    JensenHaise1963 = _swig_new_static_method(_cmf_core.OudinET_JensenHaise1963)
    McGuinessBordne1972 = _swig_new_static_method(_cmf_core.OudinET_McGuinessBordne1972)
    K1 = property(_cmf_core.OudinET_K1_get, _cmf_core.OudinET_K1_set, doc=r"""K1 : double""")
    K2 = property(_cmf_core.OudinET_K2_get, _cmf_core.OudinET_K2_set, doc=r"""K2 : double""")
    use_for_cell = _swig_new_static_method(_cmf_core.OudinET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_OudinET

# Register OudinET in _cmf_core:
_cmf_core.OudinET_swigregister(OudinET)
class TurcET(stressedET):
    r"""


    Calculates ETpot after Turc (DVWK).

    :math:`ET_{act}` is calculated using a WaterStressFunction



    .. math::

         ET_{pot,Turc} = 0.0031 C(rH) (R_G + 209) \\frac{T}{T + 15}


    where:  :math:`T` is the mean daily temperature

    :math:`C(rH) = \\begin{cases} 1 + \\frac{50\\% - rH}{70\\%}, & rH < 50\\% \\\\ 1 & rH > 50\\% \\end{cases}`, a modification
    parameter for low humidity

    :math:`rH` relative Humidity in %

    :math:`R_G` global radiation in :math:`J/cm^2`

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(TurcET self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target) -> TurcET
        TurcET(cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
        ET_target) cmf::upslope::ET::TurcET::TurcET
        """
        _cmf_core.TurcET_swiginit(self, _cmf_core.new_TurcET(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.TurcET_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_TurcET

# Register TurcET in _cmf_core:
_cmf_core.TurcET_swigregister(TurcET)
class CanopyStorageEvaporation(flux_connection):
    r"""


    Calculates the evaporation from a canopy storage.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(CanopyStorageEvaporation self, cmf::water::WaterStorage::ptr CanopyStorage, cmf::water::flux_node::ptr ET_target, Cell cell) -> CanopyStorageEvaporation
        CanopyStorageEvaporation(cmf::water::WaterStorage::ptr CanopyStorage,
        cmf::water::flux_node::ptr ET_target, cmf::upslope::Cell &cell)
        cmf::upslope::ET::CanopyStorageEvaporation::CanopyStorageEvaporation
        """
        _cmf_core.CanopyStorageEvaporation_swiginit(self, _cmf_core.new_CanopyStorageEvaporation(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_CanopyStorageEvaporation

# Register CanopyStorageEvaporation in _cmf_core:
_cmf_core.CanopyStorageEvaporation_swigregister(CanopyStorageEvaporation)
class PenmanEvaporation(flux_connection):
    r"""


    Calculates evaporation from an open water body.

    C++ includes: ET.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(PenmanEvaporation self, cmf::river::OpenWaterStorage::ptr source, cmf::water::flux_node::ptr Evap_target, Meteorology meteo) -> PenmanEvaporation
        PenmanEvaporation(cmf::river::OpenWaterStorage::ptr source,
        cmf::water::flux_node::ptr Evap_target, const
        cmf::atmosphere::Meteorology &meteo)
        cmf::upslope::ET::PenmanEvaporation::PenmanEvaporation
        """
        _cmf_core.PenmanEvaporation_swiginit(self, _cmf_core.new_PenmanEvaporation(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_PenmanEvaporation

# Register PenmanEvaporation in _cmf_core:
_cmf_core.PenmanEvaporation_swigregister(PenmanEvaporation)
class ShuttleworthWallace(aerodynamic_resistance):
    r"""


    Calculates the sum of soil evaporation and transpiration according to
    Shuttleworth & Wallace 1985, as implemented in BROOK 90 (Federer 1990)

    The difference to BROOK90 is, that the actual transpiration is not
    calculated by plant resitance and potential gradient between plant and
    soil, but by an piecewise linear function of the pF value :math:`pF = \\log_{10}\\left(-\\Psi [hPa]\\right)`: 

    .. math::


        \\frac{T_{act}}{T_{pot}} = \\begin{cases}1 & pF \\le 3.35
        \\\\  \\frac{pF - 4.2}{3.35 - 4.2} & pF \\in [3.35 .. 4.2]
        \\\\ 0 & pF \\ge 4.2\\end{cases} 

    Calculation procedure, as in BROOK 90:

    Evapotranspiration from the canopy: :math:`\\lambda ET_{canopy} = \\frac{r_{ac} \\Delta\\ R_{n,canopy} + c_p\\rho D_0}{\\Delta \\gamma r_{ac} + \\gamma r_{sc}}`

    Evaporation from the ground: :math:`\\lambda E_{ground} = \\frac{r_{as} \\Delta\\ R_{n,ground} + c_p\\rho D_0}{\\Delta \\gamma r_{as} + \\gamma r_{ss}}`

    In case of a complete surface water covered ground, the surface
    resistance :math:`r_{ss}` becomes 0. (GIR)

    with  :math:`\\Delta = \\frac{de_s}{dT} = 4098\\ 0.6108 \\exp\\left(\\frac{17.27 T}{T+237.3}\\right)(T+237.3)^{-2}`,
    the slope of the sat. vap. press. T function

    :math:`R_{n,ground} = R_n \\exp(-C_R LAI)`, the net radiation flux to
    the ground

    :math:`R_{n,canopy} = R_n - R_{n,ground}`, the net radiation flux to the
    canopy

    :math:`\\lambda,c_p\\rho,\\gamma` latent heat of vaporization, heat
    capacity of air, psychrometer constant

    :math:`D_0` vapor pressure deficit at effective source height, see
    function D0

    :math:`r_{ac}, r_{sc}, r_{as}, r_{ss}` Resistances for the vapor pressure
    (see below)

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    RAA = property(_cmf_core.ShuttleworthWallace_RAA_get, _cmf_core.ShuttleworthWallace_RAA_set, doc=r"""RAA : double""")
    RAC = property(_cmf_core.ShuttleworthWallace_RAC_get, _cmf_core.ShuttleworthWallace_RAC_set, doc=r"""RAC : double""")
    RSC = property(_cmf_core.ShuttleworthWallace_RSC_get, _cmf_core.ShuttleworthWallace_RSC_set, doc=r"""RSC : double""")
    RAS = property(_cmf_core.ShuttleworthWallace_RAS_get, _cmf_core.ShuttleworthWallace_RAS_set, doc=r"""RAS : double""")
    RSS = property(_cmf_core.ShuttleworthWallace_RSS_get, _cmf_core.ShuttleworthWallace_RSS_set, doc=r"""RSS : double""")
    refresh_counter = property(_cmf_core.ShuttleworthWallace_refresh_counter_get, _cmf_core.ShuttleworthWallace_refresh_counter_set, doc=r"""refresh_counter : int""")
    refresh = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_refresh)
    PTR = property(_cmf_core.ShuttleworthWallace_PTR_get, _cmf_core.ShuttleworthWallace_PTR_set, doc=r"""PTR : double""")
    PSNVP = property(_cmf_core.ShuttleworthWallace_PSNVP_get, _cmf_core.ShuttleworthWallace_PSNVP_set, doc=r"""PSNVP : double""")
    ASNVP = property(_cmf_core.ShuttleworthWallace_ASNVP_get, _cmf_core.ShuttleworthWallace_ASNVP_set, doc=r"""ASNVP : double""")
    GER = property(_cmf_core.ShuttleworthWallace_GER_get, _cmf_core.ShuttleworthWallace_GER_set, doc=r"""GER : double""")
    PIR = property(_cmf_core.ShuttleworthWallace_PIR_get, _cmf_core.ShuttleworthWallace_PIR_set, doc=r"""PIR : double""")
    AIR = property(_cmf_core.ShuttleworthWallace_AIR_get, _cmf_core.ShuttleworthWallace_AIR_set, doc=r"""AIR : double""")
    ATR_sum = property(_cmf_core.ShuttleworthWallace_ATR_sum_get, _cmf_core.ShuttleworthWallace_ATR_sum_set, doc=r"""ATR_sum : double""")
    ATR = property(_cmf_core.ShuttleworthWallace_ATR_get, _cmf_core.ShuttleworthWallace_ATR_set, doc=r"""ATR : cmf::math::num_array""")
    KSNVP = property(_cmf_core.ShuttleworthWallace_KSNVP_get, _cmf_core.ShuttleworthWallace_KSNVP_set, doc=r"""KSNVP : double""")
    allow_dew = property(_cmf_core.ShuttleworthWallace_allow_dew_get, _cmf_core.ShuttleworthWallace_allow_dew_set, doc=r"""allow_dew : bool""")
    transp_from_layer = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_transp_from_layer)
    evap_from_layer = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_evap_from_layer)
    evap_from_surfacewater = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_evap_from_surfacewater)
    evap_from_canopy = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_evap_from_canopy)
    evap_from_snow = _swig_new_instance_method(_cmf_core.ShuttleworthWallace_evap_from_snow)
    set_RSS_parameters = _swig_new_static_method(_cmf_core.ShuttleworthWallace_set_RSS_parameters)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(ShuttleworthWallace self, Cell cell, bool allow_dew=True) -> ShuttleworthWallace
        ShuttleworthWallace(cmf::upslope::Cell &cell, bool allow_dew=true)
        cmf::upslope::ET::ShuttleworthWallace::ShuttleworthWallace Calculates
        the transpiration and the soil evaporation from dry surfaces. 
        """
        _cmf_core.ShuttleworthWallace_swiginit(self, _cmf_core.new_ShuttleworthWallace(*args, **kwargs))
    use_for_cell = _swig_new_static_method(_cmf_core.ShuttleworthWallace_use_for_cell)
    __swig_destroy__ = _cmf_core.delete_ShuttleworthWallace

# Register ShuttleworthWallace in _cmf_core:
_cmf_core.ShuttleworthWallace_swigregister(ShuttleworthWallace)
class SW_transpiration(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace transpiration.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_transpiration self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_transpiration
        SW_transpiration(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
        cmf::upslope::ET::SW_transpiration::SW_transpiration
        """
        _cmf_core.SW_transpiration_swiginit(self, _cmf_core.new_SW_transpiration(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_transpiration

# Register SW_transpiration in _cmf_core:
_cmf_core.SW_transpiration_swigregister(SW_transpiration)
class SW_evap_from_layer(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace ground evaporation.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_evap_from_layer self, cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_evap_from_layer
        SW_evap_from_layer(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
        cmf::upslope::ET::SW_evap_from_layer::SW_evap_from_layer
        """
        _cmf_core.SW_evap_from_layer_swiginit(self, _cmf_core.new_SW_evap_from_layer(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_evap_from_layer

# Register SW_evap_from_layer in _cmf_core:
_cmf_core.SW_evap_from_layer_swigregister(SW_evap_from_layer)
class SW_evap_from_canopy(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace canopy interception evaporation.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_evap_from_canopy self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_evap_from_canopy
        SW_evap_from_canopy(cmf::water::WaterStorage::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
        cmf::upslope::ET::SW_evap_from_canopy::SW_evap_from_canopy
        """
        _cmf_core.SW_evap_from_canopy_swiginit(self, _cmf_core.new_SW_evap_from_canopy(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_evap_from_canopy

# Register SW_evap_from_canopy in _cmf_core:
_cmf_core.SW_evap_from_canopy_swigregister(SW_evap_from_canopy)
class SW_evap_from_snow(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace canopy interception evaporation.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_evap_from_snow self, cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_evap_from_snow
        SW_evap_from_snow(cmf::water::WaterStorage::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
        cmf::upslope::ET::SW_evap_from_snow::SW_evap_from_snow
        """
        _cmf_core.SW_evap_from_snow_swiginit(self, _cmf_core.new_SW_evap_from_snow(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_evap_from_snow

# Register SW_evap_from_snow in _cmf_core:
_cmf_core.SW_evap_from_snow_swigregister(SW_evap_from_snow)
class SW_evap_from_surfacewater(flux_connection):
    r"""


    Connection for Shuttleworth-Wallace canopy interception evaporation.

    C++ includes: ShuttleworthWallace.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(SW_evap_from_surfacewater self, cmf::river::OpenWaterStorage::ptr source, cmf::water::flux_node::ptr ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) -> SW_evap_from_surfacewater
        SW_evap_from_surfacewater(cmf::river::OpenWaterStorage::ptr source,
        cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
        cmf::upslope::ET::SW_evap_from_surfacewater::SW_evap_from_surfacewater
        """
        _cmf_core.SW_evap_from_surfacewater_swiginit(self, _cmf_core.new_SW_evap_from_surfacewater(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_SW_evap_from_surfacewater

# Register SW_evap_from_surfacewater in _cmf_core:
_cmf_core.SW_evap_from_surfacewater_swigregister(SW_evap_from_surfacewater)

class project_list_wrapper:
    def __init__(self,getitem,getlen,name):
        self.__get = getitem
        self.__len = getlen
        self.name = name
    def __len__(self):
        return int(self.__len())
    def __getitem__(self,index):
        if (type(index)==slice):
             return [self.__get(i) for i in range(*index.indices(len(self)))]
        try:
             gen=iter(index)
             return [self.__get(it) for it in gen]
        except TypeError:
             return self.__get(index)
    def __iter__(self):
        for i in range(len(self)):
            yield self.__get(i)
    def __repr__(self):
        return '[%i %s of project]' % (len(self),self.name)


class _Options(object):
    r"""


    Holds global options for specific cmf behaviour, accessbile via
    cmf.options.

    C++ includes: project.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    diffusive_slope_singularity_protection = property(_cmf_core._Options_diffusive_slope_singularity_protection_get, _cmf_core._Options_diffusive_slope_singularity_protection_set, doc=r"""diffusive_slope_singularity_protection : double""")
    richards_lateral_base_flow = property(_cmf_core._Options_richards_lateral_base_flow_get, _cmf_core._Options_richards_lateral_base_flow_set, doc=r"""richards_lateral_base_flow : bool""")

    def __init__(self, *args, **kwargs):
        r"""__init__(_Options self) -> _Options"""
        _cmf_core._Options_swiginit(self, _cmf_core.new__Options(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete__Options

# Register _Options in _cmf_core:
_cmf_core._Options_swigregister(_Options)
class project(object):
    r"""


    The study area, holding all cells, outlets and streams.

    C++ includes: project.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    remove_node = _swig_new_instance_method(_cmf_core.project_remove_node)
    solutes = property(_cmf_core.project_solutes_get, doc=r"""solutes : q(const).cmf::water::solute_vector""")
    meteo_stations = property(_cmf_core.project_meteo_stations_get, _cmf_core.project_meteo_stations_set, doc=r"""meteo_stations : cmf::atmosphere::MeteoStationList""")
    rainfall_stations = property(_cmf_core.project_rainfall_stations_get, _cmf_core.project_rainfall_stations_set, doc=r"""rainfall_stations : cmf::atmosphere::RainfallStationList""")
    use_IDW_meteo = _swig_new_instance_method(_cmf_core.project_use_IDW_meteo)
    use_nearest_meteo = _swig_new_instance_method(_cmf_core.project_use_nearest_meteo)
    use_IDW_rainfall = _swig_new_instance_method(_cmf_core.project_use_IDW_rainfall)
    use_nearest_rainfall = _swig_new_instance_method(_cmf_core.project_use_nearest_rainfall)
    get_cell = _swig_new_instance_method(_cmf_core.project_get_cell)
    size = _swig_new_instance_method(_cmf_core.project_size)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(project self, std::string solute_names="") -> project
        project(std::string
        solute_names="") cmf::project::project Creates a new project.

        Parameters:
        -----------

        solute_names:  A string representing the names of the solutes to be
        used in the project. Sepereate solute names with space. 
        """
        _cmf_core.project_swiginit(self, _cmf_core.new_project(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_project
    NewCell = _swig_new_instance_method(_cmf_core.project_NewCell)
    NewOutlet = _swig_new_instance_method(_cmf_core.project_NewOutlet)
    NewStorage = _swig_new_instance_method(_cmf_core.project_NewStorage)
    NewOpenStorage = _swig_new_instance_method(_cmf_core.project_NewOpenStorage)
    NewNeumannBoundary = _swig_new_instance_method(_cmf_core.project_NewNeumannBoundary)
    NewReach = _swig_new_instance_method(_cmf_core.project_NewReach)
    get_reach = _swig_new_instance_method(_cmf_core.project_get_reach)
    reach_count = _swig_new_instance_method(_cmf_core.project_reach_count)
    get_node = _swig_new_instance_method(_cmf_core.project_get_node)
    node_count = _swig_new_instance_method(_cmf_core.project_node_count)
    get_storages = _swig_new_instance_method(_cmf_core.project_get_storages)
    __cmf_state_list_interface__ = _swig_new_instance_method(_cmf_core.project___cmf_state_list_interface__)
    cells = property(_cmf_core.project_cells_get, doc=r"""cells : cmf::upslope::cell_vector""")

    def __repr__(self):
        return "cmf.project(%i cells, %i meteo stations, %i project nodes)" % (len(self.cells),len(self.meteo_stations),len(self.nodes))
    def __len__(self):
        return self.size()
    def __getitem__(self,index):
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(self)))]
        else:
            return self.get_cell(index)        
    def __iter__(self):
        for i in range(self.size()):
            yield self.get_cell(i)
    @property
    def reaches(self):
        "Returns the reaches of the project"
        return project_list_wrapper(self.get_reach,self.reach_count,'reaches')
    @property
    def nodes(self):
        "Returns the nodes of the project"
        return project_list_wrapper(self.get_node,self.node_count,'nodes')


# Register project in _cmf_core:
_cmf_core.project_swigregister(project)

options = cvar.options

class Integrator(object):
    r"""


    Base class for any kind of integrator.

    Pure virtual functions: Integrate

    copy Please provide a custom copy constructor

    C++ includes: integrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_Integrator
    set_system = _swig_new_instance_method(_cmf_core.Integrator_set_system)
    size = _swig_new_instance_method(_cmf_core.Integrator_size)
    __getitem = _swig_new_instance_method(_cmf_core.Integrator___getitem)
    __cmf_state_list_interface__ = _swig_new_instance_method(_cmf_core.Integrator___cmf_state_list_interface__)
    to_string = _swig_new_instance_method(_cmf_core.Integrator_to_string)
    get_t = _swig_new_instance_method(_cmf_core.Integrator_get_t)
    set_t = _swig_new_instance_method(_cmf_core.Integrator_set_t)
    get_dt = _swig_new_instance_method(_cmf_core.Integrator_get_dt)
    reset = _swig_new_instance_method(_cmf_core.Integrator_reset)
    copy = _swig_new_instance_method(_cmf_core.Integrator_copy)
    integrate = _swig_new_instance_method(_cmf_core.Integrator_integrate)
    integrate_until = _swig_new_instance_method(_cmf_core.Integrator_integrate_until)

    def __repr__(self):
        return self.to_string()

    __len__ = _swig_new_instance_method(_cmf_core.Integrator___len__)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

    def __getitem__(self, index):

        if isinstance(index,slice):
            res = type(self)()
            for i in range(*index.indices(len(self))):
                res.append(self.__getitem(i))
            return res
        else:
            try:
                it=iter(index)
                res = type(self)()
                for o in it:
                    res.append(self.__getitem(o))
                return res
            except:
                return self.__getitem(index)



    t = property(get_t,set_t,doc="Sets the actual time of the solution")
    dt = property(get_dt,doc="Get the current time step of the solver")
    def __call__(self, t, dt=None, reset=False):
        """
        Advances the integration until `t`

        A shortcut to .integrate_until

        Parameters
        ----------
        t : cmf.Time
            The time step to advance to. If t < current time, the solver will
            advance to self.t + t
        dt : cmf.Time, optional
            The timestep for the integration. If not given try to integrate in one step
        reset : bool, optional
            If True, the solver will perform a reset before starting

        Returns
        -------
        cmf.Time
            The new time stamp
        """
        if t < self.t:
            t += self.t
        if dt is None:
            dt = t - self.t
        self.integrate_until(t, dt, reset=reset)
        return self.t

    def run(self, start=None, end=None, step=day*1, max_errors=0, reset=False):
        """
        Returns an iterator over the timesteps start..end

        **Examples:**

        >>> solver=cmf.CVodeIntegrator(...)
        >>> for t in solver.run(solver.t, solver.t + cmf.week, cmf.h):
        >>>    print(t, solver[0].state)
        or with list comprehension
        >>> states = [solver[0].state for t in solver.run(solver.t, solver.t + cmf.week, cmf.h)]

        Parameters
        ----------
        start : cmf.Time, optional
                Start time for the solver iteration
        end : cmf.Time, optional
                End time of the iteration
        step : cmf.Time, optional
                Step size for the integration
        max_errors: int
                Number of tolerated errors. If >0, up to these number of runtime errors
                will be saved with their time and the integration proceeds after a reset
                of the solver. Some systems operate with values close to their physical
                limits and inifinite values in the integration can easily occur. For
                these kind of systems set max_errors to eg. 10. A larger number of errors
                should be eliminated usually.
        reset: bool
                If True, the solver performs a `reset` at every time step

        Yields
        ------
        cmf.Time
             the actual timestep
        """
        from logging import warning
        if not start is None:
            self.t = start
        if end is None:
            end = self.t + 100*step
        errors = []
        t = self.t
        while self.t < end:
            try:
                t = self(self.t+step, step, reset=reset)
            except Exception as e:
                if len(errors) < max_errors:
                    errors.append((t, e))
                    self.reset()
                    warning(str(t) + ': ' + str(e))
                else:
                    raise
            yield t


# Register Integrator in _cmf_core:
_cmf_core.Integrator_swigregister(Integrator)
class BDF2(Integrator):
    r"""


    An order 2 BDF-Method with fixed-point iteration and variable step
    size.

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8 and

    Eckert S., Baaser H., Gross D. and Scherf O. (2004) "A BDF2
    integration method with step size control for elasto-plasticity",
    Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1

    Most important function: Integrate

    C++ includes: bdf2.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    get_error_position = _swig_new_instance_method(_cmf_core.BDF2_get_error_position)
    max_order = property(_cmf_core.BDF2_max_order_get, _cmf_core.BDF2_max_order_set, doc=r"""max_order : int""")

    def __init__(self, *args):
        r"""
        __init__(BDF2 self, real epsilon=1e-9, Time tStepMin=cmf::math::timespan(10)) -> BDF2
        __init__(BDF2 self, state_list states, real epsilon=1e-9, Time tStepMin=cmf::math::timespan(10)) -> BDF2
        __init__(BDF2 self, Integrator templ) -> BDF2
        BDF2(const Integrator
        &templ) cmf::math::BDF2::BDF2 Constructs a new BDF2 integrator.

        Parameters:
        -----------

        templ:  Template to be used to construct a BDF2 method 
        """
        _cmf_core.BDF2_swiginit(self, _cmf_core.new_BDF2(*args))
    __swig_destroy__ = _cmf_core.delete_BDF2

# Register BDF2 in _cmf_core:
_cmf_core.BDF2_swigregister(BDF2)
class ExplicitEuler_fixed(Integrator):
    r"""


    An explicit Euler integrator, with a fixed time step.

    C++ includes: explicit_euler.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ExplicitEuler_fixed self, state_list states) -> ExplicitEuler_fixed
        __init__(ExplicitEuler_fixed self) -> ExplicitEuler_fixed
        __init__(ExplicitEuler_fixed self, Integrator copy) -> ExplicitEuler_fixed
        ExplicitEuler_fixed(const Integrator &copy)
        cmf::math::ExplicitEuler_fixed::ExplicitEuler_fixed copy constructor

        """
        _cmf_core.ExplicitEuler_fixed_swiginit(self, _cmf_core.new_ExplicitEuler_fixed(*args))
    __swig_destroy__ = _cmf_core.delete_ExplicitEuler_fixed

# Register ExplicitEuler_fixed in _cmf_core:
_cmf_core.ExplicitEuler_fixed_swigregister(ExplicitEuler_fixed)
class HeunIntegrator(Integrator):
    r"""


    A simple predictor - corrector solver.

    Not tested and very experimentally :math:`y^{n+1} = y^n + \\alpha f(y^n + f(y^n)dt)dt + (1-\\alpha)f(y^n)dt`

    C++ includes: explicit_euler.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    alpha = property(_cmf_core.HeunIntegrator_alpha_get, _cmf_core.HeunIntegrator_alpha_set, doc=r"""alpha : real""")

    def __init__(self, *args):
        r"""
        __init__(HeunIntegrator self, state_list states, real Alpha=0.5) -> HeunIntegrator
        __init__(HeunIntegrator self, real Alpha=0.5) -> HeunIntegrator
        __init__(HeunIntegrator self, Integrator copy) -> HeunIntegrator
        HeunIntegrator(real Alpha=0.5)
        cmf::math::HeunIntegrator::HeunIntegrator Constructs a new Heun
        integrator.

        Parameters:
        -----------

        Alpha:  Weight factor :math:`\\alpha` to weight :math:`f(y^n)` and :math:`f(y^{n+1})`

        """
        _cmf_core.HeunIntegrator_swiginit(self, _cmf_core.new_HeunIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_HeunIntegrator

# Register HeunIntegrator in _cmf_core:
_cmf_core.HeunIntegrator_swigregister(HeunIntegrator)
class ImplicitEuler(Integrator):
    r"""


    An implicit (backward) Euler integrator using fixpoint iteration.

    C++ includes: implicit_euler.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dt_min = property(_cmf_core.ImplicitEuler_dt_min_get, _cmf_core.ImplicitEuler_dt_min_set, doc=r"""dt_min : cmf::math::Time""")

    def __init__(self, *args):
        r"""
        __init__(ImplicitEuler self, state_list states, real epsilon=1e-9, Time tStepMin=cmf::math::timespan(10)) -> ImplicitEuler
        __init__(ImplicitEuler self, real epsilon=1e-9, Time tStepMin=cmf::math::timespan(10)) -> ImplicitEuler
        __init__(ImplicitEuler self, Integrator arg2) -> ImplicitEuler
        ImplicitEuler(const Integrator &)
        cmf::math::ImplicitEuler::ImplicitEuler copy constructor 
        """
        _cmf_core.ImplicitEuler_swiginit(self, _cmf_core.new_ImplicitEuler(*args))
    __swig_destroy__ = _cmf_core.delete_ImplicitEuler

# Register ImplicitEuler in _cmf_core:
_cmf_core.ImplicitEuler_swigregister(ImplicitEuler)
class RKFIntegrator(Integrator):
    r"""


    Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
    Fehlberg (RKF54) method.

    C++ includes: RKFintegrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RKFIntegrator self, state_list states, real epsilon=1e-9, Time dt_min=cmf::math::timespan(1000)) -> RKFIntegrator
        __init__(RKFIntegrator self, real epsilon=1e-9, Time dt_min=cmf::math::timespan(1000)) -> RKFIntegrator
        RKFIntegrator(real epsilon=1e-9, cmf::math::Time
        dt_min=cmf::math::timespan(1000))
        cmf::math::RKFIntegrator::RKFIntegrator Constructs a new
        RKFIntegrator.

        Parameters:
        -----------

        epsilon:  relative error tolerance per time step (default=1e-9)

        dt_min:  minimum time step (default=1s) 
        """
        _cmf_core.RKFIntegrator_swiginit(self, _cmf_core.new_RKFIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_RKFIntegrator

# Register RKFIntegrator in _cmf_core:
_cmf_core.RKFIntegrator_swigregister(RKFIntegrator)
class CVodeOptions(object):
    r"""


    A set of options for all CVode3 solver.

    Negative numbers indicate that this option stays on the default value.
    For the meaning of the options see CVODE-UD, section 4.5.6

    See Hindmarsh, A., Serban, R. and Reynolds, D.: User Documentation for
    cvode v3.1.0, 2017, UCRL-SM-208108

    Usage example:

    >solver = CVodeDens(p, 1e-9) >solver.options.max_order = 2

    C++ includes: cvode.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    max_order = property(_cmf_core.CVodeOptions_max_order_get, _cmf_core.CVodeOptions_max_order_set, doc=r"""max_order : int""")
    max_non_linear_iterations = property(_cmf_core.CVodeOptions_max_non_linear_iterations_get, _cmf_core.CVodeOptions_max_non_linear_iterations_set, doc=r"""max_non_linear_iterations : int""")
    max_error_test_failures = property(_cmf_core.CVodeOptions_max_error_test_failures_get, _cmf_core.CVodeOptions_max_error_test_failures_set, doc=r"""max_error_test_failures : int""")
    max_convergence_failures = property(_cmf_core.CVodeOptions_max_convergence_failures_get, _cmf_core.CVodeOptions_max_convergence_failures_set, doc=r"""max_convergence_failures : int""")
    max_num_steps = property(_cmf_core.CVodeOptions_max_num_steps_get, _cmf_core.CVodeOptions_max_num_steps_set, doc=r"""max_num_steps : int""")
    max_hnil_warnings = property(_cmf_core.CVodeOptions_max_hnil_warnings_get, _cmf_core.CVodeOptions_max_hnil_warnings_set, doc=r"""max_hnil_warnings : int""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(CVodeOptions self) -> CVodeOptions
        CVodeOptions() cmf::math::CVodeOptions::CVodeOptions
        """
        _cmf_core.CVodeOptions_swiginit(self, _cmf_core.new_CVodeOptions(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_CVodeOptions

# Register CVodeOptions in _cmf_core:
_cmf_core.CVodeOptions_swigregister(CVodeOptions)
class CVodeInfo(object):
    r"""


    Reports the current state of a CVode solver.

    C++ includes: cvode.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size = property(_cmf_core.CVodeInfo_size_get, _cmf_core.CVodeInfo_size_set, doc=r"""size : long""")
    workspace_real = property(_cmf_core.CVodeInfo_workspace_real_get, _cmf_core.CVodeInfo_workspace_real_set, doc=r"""workspace_real : long""")
    workspace_int = property(_cmf_core.CVodeInfo_workspace_int_get, _cmf_core.CVodeInfo_workspace_int_set, doc=r"""workspace_int : long""")
    workspace_byte = property(_cmf_core.CVodeInfo_workspace_byte_get, _cmf_core.CVodeInfo_workspace_byte_set, doc=r"""workspace_byte : long""")
    steps = property(_cmf_core.CVodeInfo_steps_get, _cmf_core.CVodeInfo_steps_set, doc=r"""steps : long""")
    current_order = property(_cmf_core.CVodeInfo_current_order_get, _cmf_core.CVodeInfo_current_order_set, doc=r"""current_order : long""")
    rhs_evaluations = property(_cmf_core.CVodeInfo_rhs_evaluations_get, _cmf_core.CVodeInfo_rhs_evaluations_set, doc=r"""rhs_evaluations : long""")
    linear_solver_setups = property(_cmf_core.CVodeInfo_linear_solver_setups_get, _cmf_core.CVodeInfo_linear_solver_setups_set, doc=r"""linear_solver_setups : long""")
    error_test_fails = property(_cmf_core.CVodeInfo_error_test_fails_get, _cmf_core.CVodeInfo_error_test_fails_set, doc=r"""error_test_fails : long""")
    order_reductions = property(_cmf_core.CVodeInfo_order_reductions_get, _cmf_core.CVodeInfo_order_reductions_set, doc=r"""order_reductions : long""")
    nonlinear_solver_iterations = property(_cmf_core.CVodeInfo_nonlinear_solver_iterations_get, _cmf_core.CVodeInfo_nonlinear_solver_iterations_set, doc=r"""nonlinear_solver_iterations : long""")
    nonlinear_solver_convergence_failures = property(_cmf_core.CVodeInfo_nonlinear_solver_convergence_failures_get, _cmf_core.CVodeInfo_nonlinear_solver_convergence_failures_set, doc=r"""nonlinear_solver_convergence_failures : long""")
    dxdt_method_calls = property(_cmf_core.CVodeInfo_dxdt_method_calls_get, _cmf_core.CVodeInfo_dxdt_method_calls_set, doc=r"""dxdt_method_calls : long""")
    sundials_version = property(_cmf_core.CVodeInfo_sundials_version_get, _cmf_core.CVodeInfo_sundials_version_set, doc=r"""sundials_version : std::string""")
    to_string = _swig_new_instance_method(_cmf_core.CVodeInfo_to_string)

    def __repr__(self):
        return self.to_string()


    def __init__(self, *args, **kwargs):
        r"""__init__(CVodeInfo self) -> CVodeInfo"""
        _cmf_core.CVodeInfo_swiginit(self, _cmf_core.new_CVodeInfo(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_CVodeInfo

# Register CVodeInfo in _cmf_core:
_cmf_core.CVodeInfo_swigregister(CVodeInfo)
class CVodeBase(Integrator):
    r"""


    Abstract base class for different modes of the CVode solver.

    Initantiate one of the child classes to gain different modes of the
    CVode solver

    C++ includes: cvode.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    options = property(_cmf_core.CVodeBase_options_get, _cmf_core.CVodeBase_options_set, doc=r"""options : cmf::math::CVodeOptions""")
    initialize = _swig_new_instance_method(_cmf_core.CVodeBase_initialize)
    set_error_msg = _swig_new_instance_method(_cmf_core.CVodeBase_set_error_msg)
    copy = _swig_new_instance_method(_cmf_core.CVodeBase_copy)
    error_msg = property(_cmf_core.CVodeBase_error_msg_get, _cmf_core.CVodeBase_error_msg_set, doc=r"""error_msg : std::string""")
    get_info = _swig_new_instance_method(_cmf_core.CVodeBase_get_info)
    get_error = _swig_new_instance_method(_cmf_core.CVodeBase_get_error)
    _get_jacobian = _swig_new_instance_method(_cmf_core.CVodeBase__get_jacobian)
    __swig_destroy__ = _cmf_core.delete_CVodeBase

    def get_jacobian(self):
        return self._get_jacobian().reshape((self.size(), self.size()), order='F')
    info = property(get_info)


# Register CVodeBase in _cmf_core:
_cmf_core.CVodeBase_swigregister(CVodeBase)
class CVodeDense(CVodeBase):
    r"""


    implicit BDF CVode solver with full Jacobian approximation

    Use this solver for small but stiff systems (<20 state variables)

    The solver calculates for each step the full Jacobian matrix of the
    system using a difference quotient approximation of the real Jacobian

    C++ includes: cvode.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(CVodeDense self, state_list states, real epsilon=1e-9) -> CVodeDense
        __init__(CVodeDense self, real epsilon=1e-9) -> CVodeDense
        CVodeDense(real epsilon=1e-9) cmf::math::CVodeDense::CVodeDense
        """
        _cmf_core.CVodeDense_swiginit(self, _cmf_core.new_CVodeDense(*args))
    copy = _swig_new_instance_method(_cmf_core.CVodeDense_copy)
    __swig_destroy__ = _cmf_core.delete_CVodeDense

# Register CVodeDense in _cmf_core:
_cmf_core.CVodeDense_swigregister(CVodeDense)
class CVodeAdams(CVodeBase):
    r"""


    Explizit multistep solver using CVode.

    C++ includes: cvode.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(CVodeAdams self, real epsilon=1e-9) -> CVodeAdams
        __init__(CVodeAdams self, state_list states, real epsilon=1e-9) -> CVodeAdams
        CVodeAdams(real epsilon=1e-9) cmf::math::CVodeAdams::CVodeAdams
        """
        _cmf_core.CVodeAdams_swiginit(self, _cmf_core.new_CVodeAdams(*args))
    copy = _swig_new_instance_method(_cmf_core.CVodeAdams_copy)
    __swig_destroy__ = _cmf_core.delete_CVodeAdams

# Register CVodeAdams in _cmf_core:
_cmf_core.CVodeAdams_swigregister(CVodeAdams)
class CVodeBanded(CVodeBase):
    r"""


    implicit BDF CVode solver with a banded Jacobian approximation

    C++ includes: cvode.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bandwidth = property(_cmf_core.CVodeBanded_bandwidth_get, _cmf_core.CVodeBanded_bandwidth_set, doc=r"""bandwidth : int""")

    def __init__(self, *args):
        r"""
        __init__(CVodeBanded self, real epsilon=1e-9, int w=5) -> CVodeBanded
        __init__(CVodeBanded self, state_list states, real epsilon=1e-9, int w=5) -> CVodeBanded
        CVodeBanded(real epsilon=1e-9, int w=5)
        cmf::math::CVodeBanded::CVodeBanded
        """
        _cmf_core.CVodeBanded_swiginit(self, _cmf_core.new_CVodeBanded(*args))
    copy = _swig_new_instance_method(_cmf_core.CVodeBanded_copy)
    __swig_destroy__ = _cmf_core.delete_CVodeBanded

# Register CVodeBanded in _cmf_core:
_cmf_core.CVodeBanded_swigregister(CVodeBanded)
class CVodeDiag(CVodeBase):
    r"""


    implicit BDF CVode solver with a one line diagonal Jacobian
    approximation

    C++ includes: cvode.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(CVodeDiag self, state_list states, real epsilon=1e-9) -> CVodeDiag
        __init__(CVodeDiag self, real epsilon=1e-9) -> CVodeDiag
        CVodeDiag(real epsilon=1e-9) cmf::math::CVodeDiag::CVodeDiag
        """
        _cmf_core.CVodeDiag_swiginit(self, _cmf_core.new_CVodeDiag(*args))
    copy = _swig_new_instance_method(_cmf_core.CVodeDiag_copy)
    __swig_destroy__ = _cmf_core.delete_CVodeDiag

# Register CVodeDiag in _cmf_core:
_cmf_core.CVodeDiag_swigregister(CVodeDiag)
class CVodeKrylov(CVodeBase):
    r"""


    implicit BDF CVode solver with a Krylov preconditioner

    C++ includes: cvode.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bandwidth = property(_cmf_core.CVodeKrylov_bandwidth_get, _cmf_core.CVodeKrylov_bandwidth_set, doc=r"""bandwidth : int""")
    preconditioner = property(_cmf_core.CVodeKrylov_preconditioner_get, _cmf_core.CVodeKrylov_preconditioner_set, doc=r"""preconditioner : char""")

    def __init__(self, *args):
        r"""
        __init__(CVodeKrylov self, state_list states, real epsilon=1e-9, int w=5, char p='L') -> CVodeKrylov
        __init__(CVodeKrylov self, real epsilon=1e-9, int w=5, char p='L') -> CVodeKrylov
        CVodeKrylov(real epsilon=1e-9, int w=5, char p='L')
        cmf::math::CVodeKrylov::CVodeKrylov
        """
        _cmf_core.CVodeKrylov_swiginit(self, _cmf_core.new_CVodeKrylov(*args))
    copy = _swig_new_instance_method(_cmf_core.CVodeKrylov_copy)
    __swig_destroy__ = _cmf_core.delete_CVodeKrylov

# Register CVodeKrylov in _cmf_core:
_cmf_core.CVodeKrylov_swigregister(CVodeKrylov)
class CVodeKLU(CVodeBase):
    r"""Proxy of C++ cmf::math::CVodeKLU class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(CVodeKLU self, real epsilon=1e-9) -> CVodeKLU
        __init__(CVodeKLU self, state_list states, real epsilon=1e-9) -> CVodeKLU
        CVodeKLU(real
        epsilon=1e-9) cmf::math::CVodeKLU::CVodeKLU
        """
        _cmf_core.CVodeKLU_swiginit(self, _cmf_core.new_CVodeKLU(*args))
    copy = _swig_new_instance_method(_cmf_core.CVodeKLU_copy)
    __swig_destroy__ = _cmf_core.delete_CVodeKLU

# Register CVodeKLU in _cmf_core:
_cmf_core.CVodeKLU_swigregister(CVodeKLU)
class MultiIntegrator(Integrator):
    r"""


    The MultiIntegrator is a wrapper for a bunch integrators. The states
    of the integrators should not have direct connections over integrator
    boundaries.

    C++ includes: multiintegrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    copy = _swig_new_instance_method(_cmf_core.MultiIntegrator_copy)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(MultiIntegrator self, Integrator template_integrator, int count) -> MultiIntegrator
        MultiIntegrator(const cmf::math::Integrator &template_integrator, int
        count) cmf::math::MultiIntegrator::MultiIntegrator Creates a new
        MultiIntegrator.

        Parameters:
        -----------

        template_integrator:  Template for the integrators

        count:  Number of integrators 
        """
        _cmf_core.MultiIntegrator_swiginit(self, _cmf_core.new_MultiIntegrator(*args, **kwargs))
    __swig_destroy__ = _cmf_core.delete_MultiIntegrator

# Register MultiIntegrator in _cmf_core:
_cmf_core.MultiIntegrator_swigregister(MultiIntegrator)
class SoluteWaterIntegrator(Integrator):
    r"""


    A SoluteWaterIntegrator implements the cmf::math::Integrator
    interface, but consists of two independent ODE-solvers.

    Added statevariables are sorted by waterstorages and solute storages
    and assigned to the correct solver.

    C++ includes: WaterSoluteIntegrator.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    copy = _swig_new_instance_method(_cmf_core.SoluteWaterIntegrator_copy)

    def __init__(self, *args):
        r"""
        __init__(SoluteWaterIntegrator self, solute_vector solutes, Integrator water_integrator, Integrator solute_integrator) -> SoluteWaterIntegrator
        __init__(SoluteWaterIntegrator self, solute_vector solutes, Integrator water_integrator, Integrator solute_integrator, state_list states) -> SoluteWaterIntegrator
        SoluteWaterIntegrator(const cmf::water::solute_vector &solutes, const
        cmf::math::Integrator &water_integrator, const cmf::math::Integrator
        &solute_integrator, const cmf::math::state_list &states)
        cmf::math::SoluteWaterIntegrator::SoluteWaterIntegrator Creates a new
        SoluteWaterIntegrator.

        Parameters:
        -----------

        solutes:  Solutes of the project

        water_integrator:  Template for the integrator of WaterStorage state
        variables

        solute_integrator:  Template for the integrator of soluteStorage state
        variables

        states:  States to be added to the integrators 
        """
        _cmf_core.SoluteWaterIntegrator_swiginit(self, _cmf_core.new_SoluteWaterIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_SoluteWaterIntegrator

# Register SoluteWaterIntegrator in _cmf_core:
_cmf_core.SoluteWaterIntegrator_swigregister(SoluteWaterIntegrator)

