<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.10.0"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>cmf: Choosing a solver</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cmf-logo-2018.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
  <div id="projectnumber">2.0.0b10</div>
   <div id="projectbrief">catchment modelling framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('cmf_tut_solver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Choosing a solver</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>cmf uses the <a class="el" href="finite_volume_method.html">finite volume method</a> to set up a wide range of models of water flow through your study area. The result of the finite volume method discretization in space is an ordinary differential equation (ODE) system, that needs to be integrated in time. Several solvers are available for this task, each with its own advantages and disadvantages.</p>
<h2>Euler's method</h2>
<p>Generally the simplest method to solve an ODE system is the explicit Euler's method. It advances the system state to the next time step by a linear extrapolation of the current change rate of the system.</p>
<p class="formulaDsp">
\[
\vec{u}(t_{i+1}) = \vec{u}(t_{i}) + h \vec{f}(\vec{u}(t_{i}),t_{i})
\]
</p>
<p>where:</p><ul>
<li>\(\vec{u}(t)\) is the system state at the given timestep (water and solute storages)</li>
<li>\(t_i\) is the actual time step</li>
<li>\(t_{i+1}\) is the time step to be calculated</li>
<li>\(h = t_{i+1}-t_{i}\) is the length of the time step</li>
<li>\( \frac{d\vec u}{dt} = \vec{f}(\vec{u}(t),t)\) is the ODE.</li>
</ul>
<p>Since Euler's method is so simple, it is the fastest method to solve an ODE. However, by using a finite time step, an error occurs if the system does not behave linearly. The solver is not error controlled, hence these errors might accumulate and create a completely chaotic behavior. The solver is not stable. In fact, many (if not all) systems set up with cmf, are so badly extrapolated, that even extremely small timesteps will still behave unstable. However, if you want to try the simple Euler method, <a class="el" href="classcmf_1_1math_1_1_explicit_euler__fixed.html">ExplicitEuler_fixed</a> can be used.</p>
<p>There are two approaches to solve this problem:</p>
<ul>
<li>Use several time steps to make a polynomial based prediction of the future time step (a solver with an higher <b>order</b>)</li>
<li>or use an <b>implicit</b> formulation of the next timestep, where \(u(t_{i+1})\) appears on both sides of the equation.</li>
</ul>
<p>Both approaches can be combined by using a higher order, implicit method.</p>
<h2>Stiff systems</h2>
<p><a href="http://en.wikipedia.org/wiki/Stiff_equation">Stiffness</a> is a property of an ODE, which occurs often when equations of different timescales need to be solved together in one system. Due to the high order of the conductivity/water content relation of porous media, any cmf model using "physical" water retention is a stiff system. Such a system cannot be solved effectively with an explicit solver, regardless of its order. Implicit methods of a higher order than 2 also do have a constraint stability and may fail on a stiff system. The simplest way to decide how stiff your cmf model is, is not to try to calculate the stiffness ratio, as given in the Wikipedia link, but just to try out different methods. If one of the implicit methods solves your system faster than the <a class="el" href="classcmf_1_1math_1_1_r_k_f_integrator.html">RKFIntegrator</a>, your system is stiff enough to use an implicit method. If the RKF solver is faster, you can try the <a class="el" href="classcmf_1_1math_1_1_explicit_euler__fixed.html">ExplicitEuler_fixed</a> with a timestep near to the lowest time step the RKF method has used, but in most cases the timestep will be so small, that using the explicit Euler method is not an effective option.</p>
<h2>Higher order</h2>
<p>A solver that is predicting the next timestep using a polynom of a certain order can work in two different ways. One option is for the solver to remember the last states and fit the polynomial in the last states (so called <a href="http://en.wikipedia.org/wiki/Linear_multistep_method">linear multistep methods</a> or Adams-Bashfort method) the other one is to introduce sub-steps in between the actual step and the "real" next step, the family of <a href="http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta methods</a>.</p>
<p>In cmf the well known <a href="http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method">Runge-Kutta-Fehlberg 4/5</a> method is implemented as <a class="el" href="classcmf_1_1math_1_1_r_k_f_integrator.html">RKFIntegrator</a>. This method uses a Runge Kutta method of order 4 to predict the next timestep and a Runge Kutta method of order 5 for comparison. If the two methods yield different results, the time step is reduced until the difference between both methods is below a given error tolerance. As such, the error of the integration is controlled and the step size is chosen adaptivly. Hence, this method is solver of choice for non-stiff problems.</p>
<p><a href="http://en.wikipedia.org/wiki/Predictor%E2%80%93corrector_method">Preditor-Corrector methods</a> are somewhat in between explicit and implicit methods. These methods do one timestep with an explicit method and repeat the timestep using the states of the initial guess as an corrector of the first timestep. CMF implements the simple PECE method after Heun as <a class="el" href="classcmf_1_1math_1_1_heun_integrator.html">HeunIntegrator</a>. However, this solver has no adaptive timestepping scheme, like the RKF method, hence the evaluation of the integration error using RKF or an implicit method shoud be done.</p>
<h2>Implicit solvers</h2>
<p>The equation for a 1st order, implicit solver (implicit Euler's method) is only marginally different to the explicit formulation:</p>
<p class="formulaDsp">
\[
\vec{u}(t_{i+1}) = \vec{u}(t_{i}) + h \vec{f}(\vec{u}(t_{i+1}),t_{i+1})
\]
</p>
<p>Clark and Kavetski (2010) state that even for lumped models, implicit schemes should be used.</p>
<p>However, the equation above cannot be directly solved, since \(\vec{u}(t_{i+1})\) is on both sides of the equation sign. To solve the equation, one needs an iterative approach which raises the computational demand. For stiff systems, the higher demand for a single step is compensated by the larger step size.</p>
<p>In principle, the iteration to yield \(\vec{u}(t_{i+1})\) can be done using a Newton iteration or fixpoint iteration.</p>
<h3>Fixpoint iteration</h3>
<p>The <a href="http://en.wikipedia.org/wiki/Fixpoint">fixpoint iteration</a> is simpler to implement and needs only the right hand side function \(f(\vec u,t)\), however usually more iteration steps are needed. In that case you start with an explicit method, and repeat the left hand side by exchanging \(\vec u\) in \(f(\vec u,t)\) with the newly generated state, until the \(\vec u\) is not changing anymore (comes to a fix point). However, if the first guess is not "near enough" to the fixpoint, the iteration may not converge. In that case the process starts new with a smaller timestep. The implicit Euler method with fixpoint iteration is implemented in cmf as <a class="el" href="classcmf_1_1math_1_1_implicit_euler.html">ImplicitEuler</a>, and a 2nd order Gears method with fixpoint iteration is implemented as <a class="el" href="classcmf_1_1math_1_1_b_d_f2.html">BDF2</a>. Both methods are a good choice for systems not using the Richards equation with solute transport.</p>
<h3>Newton iteration</h3>
<p>The other option is to iterate using the <a href="http://en.wikipedia.org/wiki/Newton%27s_method">Newton iteration</a>. To use it, the Jacobian matrix \(\frac{d\vec f}{d\vec u}\) of the system needs to be known. Since it is quite difficult to calculate the exact Jacobian for a flexible system like cmf, only an numerical approximation is feasible to use. A second problem is, that the size of the Jacobian is \(N^2\), where \(N\) is the number of states. On the other hand, only few places of the Jacobian may have values different from zero (the connections). Advanced solvers can make use of the sparse structure to reduce the computational demand. One general purpose solver for ODE's using a simplified Newton iteration and an advanced error control mechanism is the CVODE solver by Hindmarsh et al. (2005). It uses an up to order 5 Gears method, but checks the stability constraint to reduce the order in very stiff cases. The freely available CVODE code is integrated into cmf. The solver is called and managed by the derivations of the <a class="el" href="classcmf_1_1math_1_1_c_vode_base.html">CVodeBase</a> class.</p>
<p>Due to the high stiffness of models using the Richards equation, the CVODE solver is the choice for all models with physical based transport with variable saturation.</p>
<h2>References</h2>
<ul>
<li>Clark, M. P. and Kavetski, D.: Ancient numerical daemons of conceptual hydrological modeling: 1. Fidelity and efficiency of time stepping schemes, Water Resour. Res., 46(10), W10510, 2010. 2.</li>
<li>Hindmarsh, A. C., Brown, P. N., Grant, K. E., Lee, S. L., Serban, R., Shumaker, D. E. and Woodward, C. S.: SUNDIALS: Suite of nonlinear and differential/algebraic equation solvers, ACM Trans. Math. Softw., 31(3), 363–396, &lt;doi:10.1145/1089014.1089020&gt;, 2005.</li>
</ul>
<p>author: konrad, version: 6 Tue Dec 15 13:17:28 2015 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<hr class="footer"/><address class="footer"><small>
<div>&copy 2008-2017 by 
<a class="el" href="http://www.uni-giessen.de/hydro/kraft"> Philipp Kraft</a> and
<a class="el" href="http://www.uni-giessen.de/hydro"> 
Institute of Landscape Ecology and Resources Management,University of Gie&szlig;en</a>
</h3></td>
<td>Generated: Fri Jan 19 2024 16:10:56</td>
</tr></table>
</small></address>
</body>
</html>
