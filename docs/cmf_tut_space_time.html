<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.10.0"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>cmf: Space and time in cmf</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cmf-logo-2018.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
  <div id="projectnumber">2.0.0b10</div>
   <div id="projectbrief">catchment modelling framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('cmf_tut_space_time.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Space and time in cmf</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="cmf_tut_units.html">back...</a> <a class="el" href="cmf_tut_cell.html">next...</a></p>
<h2>Note for Python 2 users</h2>
<p>To show our results, we are using Python's print statement / function. However, "print" has changed between python 2 and 3. To run our examples python 2 users should always start their programs with the following line:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function, division</div>
</div><!-- fragment --><p>This import the behaviour of the python3 print function as well as the improved handling of integer division into python 2. Using this line in python3 is fine and changes nothing.</p>
<h2>Space</h2>
<p>Many objects in cmf have a position in space given as coordinates. Such spatial position is crucial for spatial explicit models, like distributed models. You can either use a local reference system (you declare a point as the origin of the coordinate system) or you can use a spatial reference system with GPS coordinates The spatial reference system you prefer is your choice, as long as the following conditions are met:</p>
<ul>
<li>The reference system must be a cartesian system (projected). - Length needs to be measured in m</li>
</ul>
<p>Or, simply put, UTM coordinates are fine, decimal degrees are not.</p>
<p>If you need to provide a position in cmf, in most cases a <a class="el" href="classcmf_1_1geometry_1_1point.html">point</a> is expected. However, any sequence (tuple, list, numpy array) with three numbers and any object providing x,y and z properties will be accepted by cmf as a point. In the tutorials, a tuple like <code>(54321,2456.2,3.2)</code>, or more often <code>(0,0,0)</code> is used.</p>
<h2>Time</h2>
<p>CMF uses the <a class="el" href="classcmf_1_1math_1_1_time.html">Time</a> and the <a class="el" href="structcmf_1_1math_1_1_date.html">Date</a> class for calculations with time.</p>
<p>Time is used both for absolute time stamps as well as for time differences. CMF accepts python's <code>datetime</code> and <code>timedelta</code> objects also and converts the m internally to cmf.Time. The Date class exists only for some features that are valid for absolute time spans. Every Time is convertable to a Date and vice versa.</p>
<p>The cmf.Time can be used with some operators, like +,-,*,/,% (modulo). Not all operations are sensible, of course. The addition of two absolute timestamps is not meaningful, but the addition of an absolute timestamp and a time span. To simplify programming some time span constants are defined: <code>cmf.year, cmf.month, cmf.week, cmf.day, cmf.hour, cmf.min, cmf.sec, cmf.ms</code>.</p>
<h2>Timeseries</h2>
<p>Forcing data for hydrological models is organized in timeseries. To use time series data in cmf effectivly, cmf provides the <a class="el" href="classcmf_1_1math_1_1timeseries.html">timeseries</a> class. Timeseries objects in cmf have always a fixed step size (<code>step</code>) and a defined time for the first data entry (<code>begin</code>). The data is stored as a sequence of values. The end time of the time series is calculated from <code>begin</code>, <code>step</code> and the number of entries in the series.</p>
<p><code>timeseries</code> objects are queried with a time and return the value for that time. If the time is before <code>begin</code> or after <code>end</code>, the first resp. last entry in the dataset is returned. Hence, constant "timeseries", with only one scalar entry containing the constant can be used. These "timeseries" return the scalar value regardless of the time. Values between the timesteps are interpolated using a linear or a nearest neighbor interpolation.</p>
<h3>Creating timeseries</h3>
<h4>The standard way</h4>
<p>The simplest and most common way to use timeseries in cmf is to create an empty timeseries (no entry) with a begin and a step size. After creation the <code>add</code> method is used to fill the timeseries with data.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> cmf</div>
<div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,timedelta</div>
<div class="line"><span class="comment"># Create an empty timeseries, with a 30 min time step. Alternativly you can write the </span></div>
<div class="line"><span class="comment"># time step as step = timedelta(minutes=30). </span></div>
<div class="line"><span class="comment"># The interpolation method is by default linear interpolation</span></div>
<div class="line">data = cmf.timeseries(begin = datetime(2010,1,1), step = cmf.min * 30)</div>
<div class="line"><span class="comment"># Add data for two days, alternating between 0 and 1</span></div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(96):</div>
<div class="line">    data.add(i % 2)</div>
<div class="line"><span class="comment"># Print some values</span></div>
<div class="line"><span class="comment"># Value at a certain time step</span></div>
<div class="line">print(data[datetime(2010,1,1,6)]) <span class="comment"># returns 0.0</span></div>
<div class="line"><span class="comment"># Value between time steps, 15 minutes late</span></div>
<div class="line">print(data[datetime(2010,1,1,6,15)]) <span class="comment"># returns 0.5</span></div>
<div class="line"><span class="comment"># Value before begin</span></div>
<div class="line">print(data[datetime(2009,12,24)]) <span class="comment"># returns 0.0</span></div>
<div class="line"><span class="comment"># Value after end</span></div>
<div class="line">print(data[datetime(2010,1,5)]) <span class="comment"># returns 1.0</span></div>
</div><!-- fragment --><h4>Scalar timeseries</h4>
<p>Objects that expect a timeseries, but should have in your model a constant in time are represented as a single value timeseries. To reduce the number of lines needed to define a constant timeseries, the static method <code>from_scalar</code> exists:</p>
<div class="fragment"><div class="line"><span class="comment"># Create a constant timeseries</span></div>
<div class="line">data = cmf.timeseries.from_scalar(0.5)</div>
</div><!-- fragment --><p>However, some objects expecting timeseries will do the conversion from a scalar to a timeseries gracefully behind the scences and accept a number instead of the timeseries object. Just try it</p>
<h4>From numpy arrays and other sequences</h4>
<p>If the data you want to store in a timeseries is in a Python iterable (list, tuple, generators, etc.) the timeseries can be created in one step, with out the need to write a loop yourself. A shorter replacement for the example above is:</p>
<div class="fragment"><div class="line">data = cmf.timeseries.from_sequence(begin=datetime(2010,1,1), </div>
<div class="line">                                    step=cmf.min*30, </div>
<div class="line">                                    sequence=(i % 2 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(96)))</div>
</div><!-- fragment --><p>If you have already stored your data in a numpy array, a very fast (C/C++ based) method exists to copy the array into a timeseries object. As an example we store random normal distributed values for 50 days in 30 minute stepsize in a timeseries:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> cmf</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line">data = cmf.timeseries.from_array(begin=datetime(2010,1,1), </div>
<div class="line">                                 step=cmf.min*30, </div>
<div class="line">                                 data = np.random.normal(0,1.,2400))</div>
</div><!-- fragment --><p>However, you do not gain speed or simplicity if you fill the array beforehand with a Python loop.</p>
<h4>From a binary file</h4>
<p>In general, cmf is file format agnostic. As shown above you can read your data from any datasource and add it with your code to the timeseries objects. However, if you are calibrating a fast conceptual model on a super computer, reading from the files can be quite an overhead. You can (but do not have to) write timeseries in a specific binary format to disk and read it afterwards.</p>
<div class="fragment"><div class="line"><span class="comment"># Load a timeseries from the file named &#39;my.timeseries&#39;</span></div>
<div class="line">data = cmf.timeseries.from_file(<span class="stringliteral">&#39;my.timeseries&#39;</span>)</div>
<div class="line"><span class="comment"># Save the timeseries to a file named &#39;my2nd.timeseries&#39;</span></div>
<div class="line">data.to_file(<span class="stringliteral">&#39;my2nd.timeseries&#39;</span>)</div>
</div><!-- fragment --><p>The file format is described in the docstring of the <code>to_file</code> method. For interprocess exchange, the <code>to_buffer</code> and <code>from_buffer</code> method uses the same format as for files, but write the data to a binary string in memory instead of the file.</p>
<h3>Removing no-data values within timeseries</h3>
<p>Because your model will create odd results with common no-data values as e.g. ‘-999’, you should first examine your data and in case interpolate it. CMF gives the following function:</p>
<div class="fragment"><div class="line">data.remove_nodata(nodata_value)</div>
</div><!-- fragment --><p>By using this function, CMF will take the preceding and following value of the no-data value in the timeseries and return the mean of it.</p>
<h3>Calculations with timeseries</h3>
<h4>Arithmetic operation</h4>
<p>You can do calculations with timeseries. This especially handy, if you need to transform a timeseries from one unit to another. Let us assume a timeseries of rainfall data in mm/h. Instead of changing your database, you can just write in your script:</p>
<div class="fragment"><div class="line">rain = data * 24</div>
<div class="line"><span class="comment"># Or if you do not need the old timeseries for something else:</span></div>
<div class="line">data *= 24</div>
</div><!-- fragment --><p>The basic arithmetic operators (+,-+,*,/) are defined for timeseries and scalars, as well as for timeseries on both side of the operand. If you calculate with two timeseries, the timestep and begin of the left side operand is used. The values of the right side are sampled using the inter- and extrapolation rules from above.</p>
<p>Beside the arithmetic operators, there are methods to apply the exponential function (<code>exp</code>), logarithm (<code>log</code>,<code>log10</code>), to raise the timeseries to a scalar power (<code>pow</code>) and to get the inverse of the timeseries (<code>inv</code>).</p>
<div class="fragment"><div class="line">exp_data=data.exp()</div>
<div class="line">square_data = data.pow(2.)</div>
<div class="line">...</div>
</div><!-- fragment --><h4>Statistical analysis</h4>
<p>To get the statistics of a timeseries, use the <code>mean</code>, <code>max</code>, <code>min</code>. For other statistical information, numpy treats cmf timeseries as an array, therefore all functions for numpy arrays are available for cmf timeseries, eg. <code>np.std(data)</code>, <code>np.percentile(data,0.1)</code> and all functions from the scipy.stats module (if scipy is available). If you need the time axis for your analysis (or for plotting) you can get the time axis in days since 30.12.1899 as a list by</p>
<div class="fragment"><div class="line">data_t = [t/cmf.day <span class="keywordflow">for</span> t <span class="keywordflow">in</span> data.iter_time()]</div>
</div><!-- fragment --><p>To smooth timeseries the methods <code>floating_avg</code>, <code>floating_max</code>,<code>floating_min</code> are available for floating window statistics. The functions need the number of entries to be included in the window.</p>
<p>If you need to reduce the frequency of the timeseries, use the methods <code>reduce_avg</code>, <code>reduce_max</code>, <code>reduce_min</code> to retrieve a new timeseries with the average, resp. min or max value in the new timesteps. A common use case is the retrieval of the daily min/max temperature from high frequency data for meteorological station data.</p>
<p>For comparison of timeseries containing model results and observations, you can use the <a class="el" href="namespacecmf_1_1math.html#afd2ff6bb516cbeb38944d88a973d0a79">nash_sutcliffe</a> efficiency integrated in cmf:</p>
<div class="fragment"><div class="line">E  = cmf.nash_sutcliffe(model, observation)</div>
</div><!-- fragment --><h3>Plotting timeseries</h3>
<p>Using matplotlib, you can plot timeseries. To make this more convient, cmf has plotting functions integrated, dedicated for timeseries, a function for line graphs and a function for bar graphs. The helper functions to draw cmf objects using matplotlib are in the namespace <code>cmf.draw</code> you need to import seperately.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespacecmf_1_1draw.html">cmf.draw</a></div>
<div class="line">cmf.draw.plot_timeseries(data)</div>
<div class="line">cmf.draw.bar_timeseries(data)</div>
<div class="ttc" id="anamespacecmf_1_1draw_html"><div class="ttname"><a href="namespacecmf_1_1draw.html">cmf.draw</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<hr class="footer"/><address class="footer"><small>
<div>&copy 2008-2017 by 
<a class="el" href="http://www.uni-giessen.de/hydro/kraft"> Philipp Kraft</a> and
<a class="el" href="http://www.uni-giessen.de/hydro"> 
Institute of Landscape Ecology and Resources Management,University of Gie&szlig;en</a>
</h3></td>
<td>Generated: Fri Jan 19 2024 16:10:56</td>
</tr></table>
</small></address>
</body>
</html>
