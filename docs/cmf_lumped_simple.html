<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.10.0"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>cmf: Lumped Model with Spotpy Tutorial</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cmf-logo-2018.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
  <div id="projectnumber">2.0.0b10</div>
   <div id="projectbrief">catchment modelling framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('cmf_lumped_simple.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Lumped Model with Spotpy Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Downloads</h2>
<p>Here all data files needed for the tutorial can be downloaded: -</p><ul>
<li><a href="http://fb09-pasig.umwelt.uni-giessen.de/spotpy/download/cmf_lumped/prec.txt">Precipitation</a></li>
<li><a href="http://fb09-pasig.umwelt.uni-giessen.de/spotpy/download/cmf_lumped/discharge.txt">Discharge</a></li>
<li><a href="http://fb09-pasig.umwelt.uni-giessen.de/spotpy/download/cmf_lumped/max_min_avg_temp.txt">Temperature</a></li>
</ul>
<h2>Getting started</h2>
<p>In a former tutorial we learned how we can use CMF to build a simple lumped model. There, we also learned that calibration by hand is quite difficult. As we are not the first persons who discover this, smart people have devised solutions for this problem. One of those solutions is <a href="http://fb09-pasig.umwelt.uni-giessen.de/spotpy/">Spotpy</a>. Spotpy allows the automated calibration of models with many different algorithms and objective functions. This tutorial here is meant to show you how to use CMF with Spotpy. For this we will be using classes (object oriented programming). So if you do not yet know what classes are, it might be helpful to take a <a href="https://docs.python.org/3/tutorial/classes.html">look</a>. Though, for our purposes it is enough when you understand classes are just a fancy way to organize the structure of you code. Obviously you need to have <a href="http://fb09-pasig.umwelt.uni-giessen.de/spotpy/#installation">SPOTPY</a> and <a href="http://fb09-pasig.umwelt.uni-giessen.de/cmf/wiki/CmfInstall">CMF</a> installed on your computer to make this work. To run the model we will also need data. For the tutorial semi randomly generated data can be downloaded here: <a href="http://fb09-pasig.umwelt.uni-giessen.de/spotpy/download/cmf_lumped/discharge.txt">discharge</a>, <a href="http://fb09-pasig.umwelt.uni-giessen.de/spotpy/download/cmf_lumped/max_min_avg_temp.txt">temperature</a> and <a href="http://fb09-pasig.umwelt.uni-giessen.de/spotpy/download/cmf_lumped/prec.txt">precipitation</a>.</p>
<h2>Spotpy Interface</h2>
<p>Spotpy makes some assumptions about your model. So to make your model compatible to Spotpy, you need some additional methods which work as an interface to Spotpy. To make them easier recycable it can be handy to shift them to an additional class. You do not neccesary have to fully grasp what those methods do, if you simply want a quick calibration done.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SpotpyInterface:</div>
</div><!-- fragment --><p>The first method calls your model and makes it run with the parameters Spotpy provides and returns the results the model calculated.</p>
<div class="fragment"><div class="line"><span class="keyword">def</span> simulation(self,vector):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    SpotPy expects a method simulation. This methods calls setparameters</span></div>
<div class="line"><span class="stringliteral">    and runmodels, so SpotPy is satisfied        </span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span>                  </div>
<div class="line">    paramdict = dict((pp.name,v) <span class="keywordflow">for</span> pp,v <span class="keywordflow">in</span> zip(self.params,vector))</div>
<div class="line">    self.setparameters(**paramdict)</div>
<div class="line">    resQ = self.runmodel()</div>
<div class="line">    <span class="keywordflow">return</span> np.array(resQ)</div>
</div><!-- fragment --><p>The second method is needed by Spotpy to generate the data with which the model is evaluated. In our case this is the measured discharge.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>evaluation(self):</div>
<div class="line">    end = self.begin + cmf.day * len(self.Q)</div>
<div class="line">    <span class="keywordflow">return</span> np.array(self.Q[self.begin:end])</div>
</div><!-- fragment --><p>The third method calls Spotpy's own method for parameter generation. This means the values for the parameters we need in our model are generated here.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>parameters(self):</div>
<div class="line">    <span class="keywordflow">return</span> spotpy.parameter.generate(self.params)</div>
</div><!-- fragment --><p>The final method of the interface is used to define the objective function. This means on what criteria the model should be judged. In our case we are using the Nash-Sutcliffe Efficieny, which focusses on peak flows.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>objectivefunction(self,simulation,evaluation): </div>
<div class="line">    <span class="keywordflow">return</span> spotpy.objectivefunctions.nashsutcliffe(evaluation,simulation)</div>
</div><!-- fragment --><h2>The actual model</h2>
<p>The structure of the model is the same as the one we used in the first lumped tutorial. Therefore it should already be a bit familiar. The main difference is that the model code is now structured in a class, instead of writing one line under the next one. For this a class is used. To make use of the Interface we created, we let our model class inherit the methods from the SpotpyInterface class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CMFLumped(SpotpyInterface):</div>
</div><!-- fragment --><p>The first method of the model class initializes all things we need for the model, meaning the project, the cell, the layer, an outlet and out date.</p>
<div class="fragment"><div class="line"><span class="keyword">def</span> __init__(self):</div>
<div class="line">    <span class="comment"># create the project</span></div>
<div class="line">    self.project = <a class="code hl_class" href="classcmf_1_1project.html">cmf.project</a>()</div>
<div class="line">    <span class="comment"># For the cell we do not need to specify the x,y,z data as their will only be one cell. </span></div>
<div class="line">    <span class="comment"># A cell size of 1000 comes in handy because then our data is in m³ the same as in mm.</span></div>
<div class="line">    self.cell = self.project.NewCell(0,0,0,1000)</div>
<div class="line">    <span class="comment"># Also we need to define how when our model begins and in what timesteps it should act</span></div>
<div class="line">    self.begin = datetime.datetime(1979,1,1)</div>
<div class="line">    self.step = datetime.timedelta(days = 1)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Add the soil. The parameter is the depth of the layer. In this case the soil is 2 m deep.</span></div>
<div class="line">    self.soil = self.cell.add_layer(2.0)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Create the outlet were all the water of the catchment will be directed to. </span></div>
<div class="line">    self.outlet = self.project.NewOutlet(<span class="stringliteral">&quot;Out&quot;</span>, 10,0,0)</div>
<div class="line">    <span class="comment"># Evaporation</span></div>
<div class="line">    cmf.HargreaveET(self.soil, self.cell.transpiration)</div>
<div class="ttc" id="aclasscmf_1_1project_html"><div class="ttname"><a href="classcmf_1_1project.html">cmf::project</a></div><div class="ttdoc">The study area, holding all cells, outlets and streams.</div><div class="ttdef"><b>Definition</b> project.h:53</div></div>
</div><!-- fragment --><p>This method is also used to define our parameters and their range. For this we need to import a distribution from spotpy. For our case Uniform is sufficient.</p>
<div class="fragment"><div class="line">param = spotpy.parameter.Uniform</div>
<div class="line"><span class="comment"># define all parameters and their range</span></div>
<div class="line">self.params = [param(<span class="stringliteral">&quot;Q0&quot;</span>, 1., 500), </div>
<div class="line">               param(<span class="stringliteral">&quot;beta&quot;</span>,0.3, 5.),                        </div>
<div class="line">               param(<span class="stringliteral">&quot;ETV1&quot;</span>, 0., 200), </div>
<div class="line">               param(<span class="stringliteral">&quot;fEVT0&quot;</span>, 0., 1)]</div>
<div class="line">P, Q, T, Tmin, Tmax = self.loadPETQ()</div>
</div><!-- fragment --><p>Finally the method the method loads in the forcing data and initializes the rainfall and the meteo station by calling another method (described below).</p>
<div class="fragment"><div class="line">P, Q, T, Tmin, Tmax = self.loadPETQ()</div>
<div class="line">self.Q = Q</div>
<div class="line">self.create_stations(P, Q, T, Tmin, Tmax)</div>
</div><!-- fragment --><p>The method to load in the weather data works the same way as in the model without spotpy.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>loadPETQ(self):</div>
<div class="line">    <span class="comment"># Data (plain text files)</span></div>
<div class="line">    fnQ = <span class="stringliteral">&#39;discharge.txt&#39;</span> <span class="comment"># enter the name of your discharge data here in m³/day</span></div>
<div class="line">    fnT = <span class="stringliteral">&#39;max_min_avg_temp.txt&#39;</span> <span class="comment"># enter the name of your max, min and average temperature here in °C</span></div>
<div class="line">    fnP = <span class="stringliteral">&#39;prec.txt&#39;</span> <span class="comment"># enter the name of your precipitation data here in mm/day</span></div>
<div class="line">    <span class="comment"># create a empty time series that starts at the begin</span></div>
<div class="line">    <span class="comment"># and goes by step for all elements in the file</span></div>
<div class="line">    P = cmf.timeseries(self.begin, self.step)</div>
<div class="line">    P.extend(float(Pstr) <span class="keywordflow">for</span> Pstr <span class="keywordflow">in</span> open(fnP))        </div>
<div class="line">    Q = cmf.timeseries(self.begin,self.step)</div>
<div class="line">    Q.extend(float(Qstr) <span class="keywordflow">for</span> Qstr <span class="keywordflow">in</span> open(fnQ))</div>
<div class="line">    <span class="comment"># Convert m3/s to mm/day</span></div>
<div class="line">    Q *= 86400 * 1e3 / (2976.41 * 1e6)</div>
<div class="line">    T = cmf.timeseries(self.begin, self.step)</div>
<div class="line">    Tmin = cmf.timeseries(self.begin, self.step)</div>
<div class="line">    Tmax = cmf.timeseries(self.begin, self.step)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Go through all lines in the file</span></div>
<div class="line">    <span class="keywordflow">for</span> line <span class="keywordflow">in</span> open(fnT):</div>
<div class="line">        columns = line.split(<span class="stringliteral">&#39;\t&#39;</span>)</div>
<div class="line">        <span class="keywordflow">if</span> len(columns) == 3:</div>
<div class="line">            Tmax.add(float(columns[0]))                 Tmin.add(float(columns[1]))</div>
<div class="line">            T.add(float(columns[2]))</div>
<div class="line">    <span class="keywordflow">return</span> P, Q, T, Tmin, Tmax</div>
</div><!-- fragment --><p>Same goes for the method to create the stations.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>create_stations(self, P, Q, T, Tmin, Tmax):</div>
<div class="line">    <span class="comment"># Create the rainstation and give it the freshly loaded precipitaton data</span></div>
<div class="line">    self.project.rainfall_stations.add(<span class="stringliteral">&#39;Rain&#39;</span>,P,(0,0,0))</div>
<div class="line">    <span class="comment"># This tells every cell in the model (in our case one) to use the rainfall station</span></div>
<div class="line">    <span class="comment"># that is nearest to it. </span></div>
<div class="line">    self.project.use_nearest_rainfall()</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Create the meteo station</span></div>
<div class="line">    meteo = self.project.meteo_stations.add_station(<span class="stringliteral">&#39;Meteo&#39;</span>,(0,0,0))</div>
<div class="line">    <span class="comment"># add all data to the station</span></div>
<div class="line">    meteo.T = T</div>
<div class="line">    meteo.Tmin = Tmin</div>
<div class="line">    meteo.Tmax = Tmax</div>
<div class="line">    <span class="comment"># Tell the cell to use the nearest station</span></div>
<div class="line">    self.project.use_nearest_meteo()</div>
</div><!-- fragment --><p>One significant difference to the model without Spotpy is the method to set the values for the parameters. We need this method as we cannot simply hardcode the values as we did in the model without Spotpy. Instead the parameters must be flexibly be filled with the values Spotpy provides. Therefore, we need to create this method to be able to do this.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>setparameters(self, **params):</div>
<div class="line">    <span class="comment"># Flux from soil to outlet (interflow)</span></div>
<div class="line">    cmf.PowerLawConnection(self.cell.layers[0], self.outlet,  </div>
<div class="line">                         params[<span class="stringliteral">&quot;Q0&quot;</span>], V0=500, exponent=params[<span class="stringliteral">&quot;beta&quot;</span>])</div>
<div class="line">    <span class="comment"># Adjustment of the evapotranspiration</span></div>
<div class="line">    self.cell.set_uptakestress(cmf.VolumeStress(params[<span class="stringliteral">&quot;ETV1&quot;</span>],                                                     params[<span class="stringliteral">&quot;ETV1&quot;</span>]] * params[<span class="stringliteral">&quot;fEVT0&quot;</span>))</div>
</div><!-- fragment --><p>Finally, we need a method which lets the model run and creates an array of the output. Here we also create the CMF solver, which solves the differential equations.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>runmodel(self):</div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="comment"># create the solver, tell him which project it should solve and what its </span></div>
<div class="line">        <span class="comment"># maximal error should be</span></div>
<div class="line">        <span class="comment">#print(cmf.describe(self.project))</span></div>
<div class="line">        solver = cmf.CVodeDense(self.project, 1e-8)</div>
<div class="line">        <span class="comment"># create an list to save all discharge data</span></div>
<div class="line">        discharge = []</div>
<div class="line">        <span class="comment"># let the solver run for the given timeperiode (this may take some time)</span></div>
<div class="line">        <span class="keywordflow">for</span> t <span class="keywordflow">in</span> solver.run(self.begin, self.begin + cmf.day * len(self.Q), self.step):</div>
<div class="line">            <span class="comment"># save the discharge for every timestep</span></div>
<div class="line">            discharge.append(self.outlet.waterbalance(t))</div>
<div class="line">        <span class="keywordflow">return</span> discharge</div>
<div class="line">    <span class="keywordflow">except</span> RuntimeError:</div>
<div class="line">        <span class="keywordflow">return</span> np.array(self.Q[self.begin:self.end + datetime.timedelta(days=1)])*np.nan</div>
</div><!-- fragment --><h2>Running the model</h2>
<p>Now the model is ready to be used with Spotpy. The handling is rather straightforward. We simply have to create an instance of our model and forward it to Spotpy. Spotpy additionally needs to know what output format we want and what our file should be called. Here we can also define how often the model should run.</p>
<div class="fragment"><div class="line">model = CMFLumped()</div>
<div class="line">sampler = spotpy.algorithms.lhs(model, dbformat =<span class="stringliteral">&quot;csv&quot;</span>, dbname = <span class="stringliteral">&quot;model&quot;</span>)</div>
<div class="line">runs = 100</div>
<div class="line">sampler.sample(runs)</div>
</div><!-- fragment --><p>We you know start this model you should get a Nash-Sutcliffe Efficieny of about ~ 0.3. You can play around with other objective functions and add additional storages and connections, to test wether you can improve the model. The output you get should be similar to this:</p>
<p><img src="spotpy_output.jpg" alt="" class="inline"/></p>
<p>Spotpy tells you what algorithm it is using and how much it as progressed in calculating all the runs we asked it for. When its done, Spotpy informs us about the beste run (In this case NS = 0.57) and what parameter set was used for this best run (In our case <a href="74.41,">64.4,..., 3.44, 0.66</a>. The order in this parameter set is the one we have defined in the model.</p>
<h2>Old tutorial</h2>
<p>In case someone is missing the old tutorial, it can still be found here: <a href="http://fb09-pasig.umwelt.uni-giessen.de/cmf/wiki/Cmflumped">http://fb09-pasig.umwelt.uni-giessen.de/cmf/wiki/Cmflumped</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<hr class="footer"/><address class="footer"><small>
<div>&copy 2008-2017 by 
<a class="el" href="http://www.uni-giessen.de/hydro/kraft"> Philipp Kraft</a> and
<a class="el" href="http://www.uni-giessen.de/hydro"> 
Institute of Landscape Ecology and Resources Management,University of Gie&szlig;en</a>
</h3></td>
<td>Generated: Fri Jan 19 2024 16:10:56</td>
</tr></table>
</small></address>
</body>
</html>
