LangSubDir: python
Search paths:
   .\
   .\swig_lib\python\
   C:\Programme\swig\Lib\python\
   \python\
   .\swig_lib\
   C:\Programme\swig\Lib\
   \
Preprocessing...
%includefile "C:\\Programme\\swig\\Lib\\swig.swg" [
/* -----------------------------------------------------------------------------
 * swig.swg
 *
 * Common macro definitions for various SWIG directives.  This file is always 
 * included at the top of each input file.
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * User Directives 
 * ----------------------------------------------------------------------------- */

/* Deprecated SWIG directives */



















/* Code insertion directives such as %wrapper %{ ... %} */






/* Class extension */



/* %ignore directive */




/* Access control directives */









/* Generation of default constructors/destructors (old form, don't use) */





/* Disable the generation of implicit default constructor */




/* Disable the generation of implicit default destructor (dangerous) */




/* Enable the generation of copy constructor */




/* Force the old nodefault behavior, ie disable both constructor and destructor */




/* the %exception directive */








/* the %allowexception directive allows the %exception feature to
   be applied to set/get variable methods */




/* the %exceptionvar directive, as %exception but it is only applied
   to set/get variable methods. You don't need to use the
   %allowexception directive when using %exceptionvar.
*/








/* the %catches directive */



/* the %exceptionclass directive */




/* the %newobject directive */




/* the %delobject directive */




/* the %refobject/%unrefobject directives */








/* Directives for callback functions (experimental) */




/* the %fastdispatch directive */




/* directors directives */




/* naturalvar directives */




/* valuewrapper directives */





/* Contract support - Experimental and undocumented */




/* Macro for setting a dynamic cast function */






/* aggregation support */
/*
  This macro performs constant aggregation.  Basically the idea of
  constant aggregation is that you can group a collection of constants
  together.  For example, suppose you have some code like this:

       #define UP  1
       #define DOWN 2
       #define LEFT 3
       #define RIGHT 4

  Now, suppose you had a function like this:

       int move(int direction)

  In this case, you might want to restrict the direction argument to
  one of the supplied constant names. To do this, you could write some
  typemap code by hand.  Alternatively, you can use the
  %aggregate_check macro defined here to create a simple check
  function for you.  Here is an example:

    %aggregate_check(int, check_direction, UP, DOWN, LEFT, RIGHT);

  Now, using a typemap

    %typemap(check) int direction {
      if (!check_direction($1)) SWIG_exception(SWIG_ValueError,"Bad direction.");
    }

  or a contract (better)

    %contract move(int x) {
    require:
        check_direction(x);
    }

*/
   















/* -----------------------------------------------------------------------------
 * %rename predicates
 * ----------------------------------------------------------------------------- */
/* 
   Predicates to be used with %rename, for example:

   - to rename all the functions:

     %rename("%(utitle)s", %$isfunction) "";

   - to rename only the member methods:

     %rename("m_%(utitle)s", %$isfunction, %$ismember) "";

   - to rename only the global functions:

      %rename("m_%(utitle)s", %$isfunction, %$not %$ismember) "";

     or

      %rename("g_%(utitle)s", %$isfunction, %$isglobal) "";

   - to ignore the enumitems in a given class:

     %rename("$ignore", %$isenumitem, %$classname="MyClass") "";

   we use the prefix '%$' to avoid clashings with other swig
   macros/directives.

*/

 










  /* %constant definition */





























/* -----------------------------------------------------------------------------
 * Include all the warnings labels and macros 
 * ----------------------------------------------------------------------------- */

%includefile "C:\\Programme\\swig\\Lib\\swigwarnings.swg" [
/*
  Include the internal swig macro codes. These macros correspond to
  the one found in Source/Include/swigwarn.h plus the 'SWIG' prefix.
  
  For example, in the include file 'swigwarn.h' you will find

    #define WARN_TYPEMAP_CHARLEAK ...

  and in the 'swigwarn.swg' interface, you will see

    %define SWIGWARN_TYPEMAP_CHARLEAK ...

  This code can be used in warning filters as follows:

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  Warnings messages used in typemaps. Message names will be the same
  as those in Lib/swigwarn.swg but with the suffix _MSG.
   
  For example, for the code SWIGWARN_TYPEMAP_CHARLEAK, once you use

    %typemapmsg(CHARLEAK,<msg>);

  you use the message in your typemap as

    %typemap(varin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) char * 

  while you suppress the warning using

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  as described above.
*/

/* -----------------------------------------------------------------------------
 * SWIG warning codes
 * ----------------------------------------------------------------------------- */

%includefile "C:\\Programme\\swig\\Lib\\swigwarn.swg" [
/* Automatically generated file containing all the swig warning codes.  */
/* Do not modify this file by hand, change 'Source/Include/swigwarn.h'  */
/* and use the command 'make Lib/swigwarn.swg' instead.                 */


/* ----------------------------------------------------------------------------- 
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * swigwarn.h
 *
 * SWIG warning message numbers
 * This file serves as the main registry of warning message numbers.  Some of these
 * numbers are used internally in the C/C++ source code of SWIG.   However, some
 * of the numbers are used in SWIG configuration files (swig.swg and others).
 *
 * The numbers are roughly organized into a few different classes by functionality.
 *
 * Even though symbolic constants are used in the SWIG source, this is
 * not always the case in SWIG interface files.  Do not change the
 * numbers in this file.
 * ----------------------------------------------------------------------------- */

/* $Id: swigwarn.h 10969 2008-12-06 23:15:20Z wsfulton $ */




/* -- Deprecated features -- */



























/* -- Preprocessor -- */







/* -- C/C++ Parser -- */

























 /* new */
 /* delete */
 /* + */
 /* - */
 /* * */
 /* / */
 /* % */
 /* ^ */
 /* & */
 /* | */
 /* ~ */
 /* ! */
 /* = */
 /* < */
 /* > */
 /* += */
 /* -= */
 /* *= */
 /* /= */
 /* %= */
 /* ^= */
 /* &= */
 /* |= */
 /* << */
 /* >> */
 /* <<= */
 /* >>= */
 /* == */
 /* != */
 /* <= */
 /* >= */
 /* && */
 /* || */
 /* ++ */
 /* -- */
 /* , */
 /* ->* */
 /* -> */
 /* () */
 /* [] */
 /* + */
 /* - */
 /* * */
 /* & */
 /* new [] */
 /* delete [] */
 /* operator *() */

/* 394-399 are reserved */

/* -- Type system and typemaps -- */






















 /* mostly used in directorout typemaps */






/* -- Fragments -- */


/* -- General code generation -- */





















/* -- Reserved (600-799) -- */

/* -- Language module specific warnings (800 - 999) -- */




















/* please leave 810-829 free for Java */































/* please leave 850-869 free for Modula 3 */

/* These are needed for backward compatibility, but you don't need to add
 * PHP4 versions of new warnings since existing user interface files can't
 * be using them.
 */






/* please leave 870-889 free for PHP */


/* Feel free to claim any number in this space that's not currently being used. Just make sure you
   add an entry here */


]

/* -----------------------------------------------------------------------------
 * Auxiliary macros
 * ----------------------------------------------------------------------------- */

/* Macro to define warning messages */



/* -----------------------------------------------------------------------------
 *  Typemap related warning messages
 * ----------------------------------------------------------------------------- */






/* -----------------------------------------------------------------------------
 * Operator related warning messages 
 * ----------------------------------------------------------------------------- */



















































/* -----------------------------------------------------------------------------
 * Macros for keyword and built-in names 
 * ----------------------------------------------------------------------------- */





/* -----------------------------------------------------------------------------
 * Warning filter feature
 * ----------------------------------------------------------------------------- */







]

/* -----------------------------------------------------------------------------
 * Default handling of certain overloaded operators 
 * ----------------------------------------------------------------------------- */


%rename("$ignore:"        "350:operator new ignored"  )     operator new;
%rename("$ignore:"     "351:operator delete ignored"  )  operator delete;
%rename("$ignore:"     "394:operator new[] ignored"  )  operator new[];
%rename("$ignore:"     "395:operator delete[] ignored"  )  operator delete[];

/* add C++ operator aliases */
%rename("operator &&") operator and;    // `and'    `&&'
%rename("operator ||") operator or;     // `or'     `||'
%rename("operator !")  operator not;    // `not'     `!'
%rename("operator &=") operator and_eq; // `and_eq'  `&='
%rename("operator &")  operator bitand; // `bitand'  `&'
%rename("operator |")  operator bitor;  // `bitor'   `|'
%rename("operator ~")  operator compl;  // `compl'   `~'
%rename("operator !=") operator not_eq; // `not_eq'  `!='
%rename("operator |=") operator or_eq;  // `or_eq'   `|='
%rename("operator ^")  operator xor;    // `xor'     `^'
%rename("operator ^=") operator xor_eq; // `xor_eq'  `^='

/* Smart pointer handling */

%rename(__deref__) *::operator->;
%rename(__ref__)   *::operator*();
%rename(__ref__)   *::operator*() const;

/* Define std namespace */
namespace std {
}


/* -----------------------------------------------------------------------------
 * Default char * and C array typemaps
 * ----------------------------------------------------------------------------- */

/* Set up the typemap for handling new return strings */


%typemap(newfree) char * "delete [] $1;";




/* Default typemap for handling char * members */


%typemap(memberin) char * {
  if ($1) delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(memberin,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin) char * {
  if ($1) delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}






































/* Character array handling */

%typemap(memberin) char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(globalin) char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(memberin) char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

%typemap(globalin) char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

/* memberin/globalin typemap for arrays. */

%typemap(memberin) SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

%typemap(globalin) SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

/* memberin/globalin typemap for double arrays. */

%typemap(memberin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$dim1] = ($basetype (*)[$dim1])($input);
  $basetype (*dest)[$dim1] = ($basetype (*)[$dim1])($1);
  size_t ii = 0;
  for (; ii < $dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $dim1; ++jj) dp[jj] = ip[jj];
  }
}

%typemap(globalin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$dim1] = ($basetype (*)[$dim1])($input);
  $basetype (*dest)[$dim1] = ($basetype (*)[$dim1])($1);
  size_t ii = 0;
  for (; ii < $dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $dim1; ++jj) dp[jj] = ip[jj];
  }
}

/* Typemap for variable length arguments sentinel value.  Used
   by the %varargs directive. */

%typemap(in,numinputs=0) SWIGTYPE *VARARGS_SENTINEL, SWIGTYPE VARARGS_SENTINEL "";


/* -----------------------------------------------------------------------------
 * Overloading support
 * ----------------------------------------------------------------------------- */

/*
 * Function/method overloading support.   This is done through typemaps,
 * but also involve a precedence level. 
 */

/* Macro for overload resolution */



/* Macros for precedence levels */





































































/* -----------------------------------------------------------------------------
 *  Runtime code
 * ----------------------------------------------------------------------------- */

/*  The SwigValueWrapper class  */

/*  
 * This template wrapper is used to handle C++ objects that are passed or 
 * returned by value.   This is necessary to handle objects that define
 * no default-constructor (making it difficult for SWIG to properly declare
 * local variables).
 *
 * The wrapper is used as follows.  First consider a function like this:
 *
 *      Vector cross_product(Vector a, Vector b)
 *
 * Now, if Vector is defined as a C++ class with no default constructor, 
 * code is generated as follows:
 *
 *     Vector *wrap_cross_product(Vector *inarg1, Vector *inarg2) {
 *          SwigValueWrapper<Vector>  arg1;
 *          SwigValueWrapper<Vector>  arg2;
 *          SwigValueWrapper<Vector> result;
 *
 *          arg1 = *inarg1;
 *          arg2 = *inarg2;
 *          ...            
 *          result = cross_product(arg1,arg2);
 *          ...
 *          return new Vector(result);
 *    }
 *         
 * In the wrappers, the template SwigValueWrapper simply provides a thin
 * layer around a Vector *.  However, it does this in a way that allows
 * the object to be bound after the variable declaration (which is not possible
 * with the bare object when it lacks a default constructor).  
 *
 * An observant reader will notice that the code after the variable declarations
 * is *identical* to the code used for classes that do define default constructors.
 * Thus, this neat trick allows us to fix this special case without having to
 * make massive changes to typemaps and other parts of the SWIG code generator.
 *
 * Note: this code is not included when SWIG runs in C-mode, when classes
 * define default constructors, or when pointers and references are used.
 * SWIG tries to avoid doing this except in very special circumstances.
 *
 * Note: This solution suffers from making a large number of copies
 * of the underlying object.  However, this is needed in the interest of
 * safety and in order to cover all of the possible ways in which a value
 * might be assigned.  For example:
 *
 *       arg1 = *inarg1;       // Assignment from a pointer
 *       arg1 = Vector(1,2,3); // Assignment from a value  
 *
 * The class offers a strong guarantee of exception safety.
 * With regards to the implementation, the private SwigMovePointer nested class is 
 * a simple smart pointer with move semantics, much like std::auto_ptr.
 *
 * This wrapping technique was suggested by William Fulton and is henceforth
 * known as the "Fulton Transform" :-).
 */


%insert("runtime") %{
#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};%}

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
%insert("runtime") %{
template <typename T> T SwigValueInit() {
  return T();
}
#endif
%}


/*  The swiglabels  */

%insert("runtime") "swiglabels.swg"



]

%includefile "C:\\Programme\\swig\\Lib\\python\\python.swg" [
/* ------------------------------------------------------------
 * python.swg
 *
 * Python configuration module.
 * ------------------------------------------------------------ */

/* ------------------------------------------------------------
 *  Inner macros
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pymacros.swg" [
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\swigmacros.swg" [
/* -----------------------------------------------------------------------------
 * SWIG API. Portion only visible from SWIG
 * ----------------------------------------------------------------------------- */
/*
  This file implements the internal macros of the 'SWIG API', which
  are useful to implement all the SWIG target languges.

  Basic preprocessor macros:
  --------------------------

    %arg(Arg)               Safe argument wrap
    %str(Arg)               Stringtify the argument 
    %begin_block            Begin a execution block  
    %end_block              End a execution block   
    %block(Block)           Execute Block as a excecution block
    %define_as(Def, Val)    Define 'Def' as 'Val', expanding Def and Val first
    %ifcplusplus(V1, V2)    if C++ Mode; then V1; else V2; fi


  Casting Operations:
  -------------------
  
  Swig provides the following casting macros, which implement the
  corresponding C++ casting operations:

    %const_cast(a, Type)         const_cast<Type >(a)			       
    %static_cast(a, Type)      	 static_cast<Type >(a)			       
    %reinterpret_cast(a, Type) 	 reinterpret_cast<Type >(a)		       
    %numeric_cast(a, Type)     	 static_cast<Type >(a)			       
    %as_voidptr(a)            	 const_cast<void *>(static_cast<const void *>(a)) 
    %as_voidptrptr(a)        	 reinterpret_cast<void **>(a)                     
  
  or their C unsafe versions. In C++ we use the safe version unless
  SWIG_NO_CPLUSPLUS_CAST is defined (usually via the -nocppcast swig flag).


  Memory allocation:
  ------------------
  
  These allocation/freeing macros are safe to use in C or C++ and
  dispatch the proper new/delete/delete[] or free/malloc calls as
  needed.
  
    %new_instance(Type)             Allocate a new instance of given Type
    %new_copy(value,Type)           Allocate and initialize a new instance with 'value'
    %new_array(size,Type)           Allocate a new array with given size and Type
    %new_copy_array(cptr,size,Type) Allocate and initialize a new array from 'cptr'
    %delete(cptr)                   Delete an instance  
    %delete_array(cptr)             Delete an array


  Auxiliary loop macros:
  ----------------------

    %formacro(Macro, Args...) or %formacro_1(Macro, Args...)
       for i in Args
       do 
          Macro($i)
       done

    %formacro_2(Macro2, Args...)
       for i,j in Args
       do 
          Macro2($i, $j)
       done


  Flags and conditional macros:
  -----------------------------

     %mark_flag(flag)
       flag := True

     %evalif(flag,expr) 
       if flag; then
         expr
       fi

     %evalif_2(flag1 flag2,expr) 
       if flag1 and flag2; then
         expr
       fi


*/
/* -----------------------------------------------------------------------------
 * Basic preprocessor macros 
 * ----------------------------------------------------------------------------- */











/* define a new macro */


/* include C++ or else value */








/* insert the SWIGVERSION in the interface and the wrapper code */

%insert("header") {
#define SWIGVERSION 0x010338 
#define SWIG_VERSION SWIGVERSION
}




/* -----------------------------------------------------------------------------
 * Casting operators
 * ----------------------------------------------------------------------------- */
























%insert("header") {
#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
}


/* -----------------------------------------------------------------------------
 * Allocating/freeing elements 
 * ----------------------------------------------------------------------------- */

















/* -----------------------------------------------------------------------------
 * Swig names and mangling
 * ----------------------------------------------------------------------------- */








/* -----------------------------------------------------------------------------
 * Auxiliary loop macros 
 * ----------------------------------------------------------------------------- */


/* for loop for macro with one argument */






/* for loop for macro with one argument */



/* for loop for macro with two arguments */






/* for loop for macro with two arguments */


/* -----------------------------------------------------------------------------
 * Swig flags
 * ----------------------------------------------------------------------------- */

/* 
  mark a flag, ie, define a macro name but ignore it in
  the interface. 
  
  the flag can be later used with %evalif
*/




/*
  %evalif and %evalif_2 are use to evaluate or process 
  an expression if the given predicate is 'true' (1).
*/

















]




]


/* ------------------------------------------------------------
 *  The runtime part
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pyruntime.swg" [
%insert(runtime) %{
/* Python.h has to appear first */
#include <Python.h>
%}

%insert(runtime) "swigrun.swg";         /* SWIG API */
%insert(runtime) "swigerrors.swg";      /* SWIG errors */   
%insert(runtime) "pyhead.swg";          /* Python includes and fixes */
%insert(runtime) "pyerrors.swg";        /* Python errors */
%insert(runtime) "pythreads.swg";       /* Python thread code */
%insert(runtime) "pyapi.swg";           /* Python API */
%insert(runtime) "pyrun.swg";           /* Python run-time code */


]

/* ------------------------------------------------------------
 *  Special user directives
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pyuserdir.swg" [
/* -------------------------------------------------------------------------
 *  Special user directives
 * ------------------------------------------------------------------------- */

/* ------------------------------------------------------------------------- */

/* shadow code */




/* ------------------------------------------------------------------------- */
/* 
Use the "nondynamic" feature to make a wrapped class behave as a "nondynamic"
one, ie, a python class that doesn't dynamically add new attributes.

For example, for the class

%pythonnondynamic A;
struct A
{
  int a;
  int b;
};

you will get:

 aa = A()
 aa.a = 1  # Ok
 aa.b = 1  # Ok
 aa.c = 3  # error

Since nondynamic is a feature, if you use it like

 %pythonnondynamic;

it will make all the wrapped classes nondynamic ones.

The implementation is based on this recipe:

   http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252158

and works for modern (-modern) and plain python. We do not use __slots__, 
so, it works with old python versions.

*/







/* ------------------------------------------------------------------------- */
/*

Use %pythonmaybecall to flag a method like __add__ or __radd__.  These
don't produce an error when called, they just return NotImplemented.

These methods "may be called" if needed.

*/





/* ------------------------------------------------------------------------- */
/*
  The %pythoncallback feature produce a more natural callback wrapper
  than the %callback mechanism, ie, it uses the original name for
  the callback and callable objects. 

  Just use it as

    %pythoncallback(1) foo;
    int foo(int a);

    %pythoncallback(1) A::foo;
    struct A {
     static int foo(int a);
    };

    int bar(int, int (*pf)(int));

  then, you can use it as:

   a = foo(1)
   b = bar(2, foo)

   c = A.foo(3)
   d = bar(4, A.foo)


   If you use it with a member method
   %pythoncallback(1) A::foom;
   struct A {
      int foom(int a);
   };

   then you can use it as

     r = a.foom(3)             # eval the method
     mptr = A.foom_cb_ptr      # returns the callback pointer

   where the '_cb_ptr' suffix is added for the callback pointer.

*/





/* ------------------------------------------------------------------------- */
/*
  Support for the old %callback directive name
*/
















/* ------------------------------------------------------------------------- */
/*
  Thread support - Advance control
  
*/














/* ------------------------------------------------------------------------- */
/*
  Implicit Conversion using the C++ constructor mechanism
*/






/* ------------------------------------------------------------------------- */
/*
  Enable keywords paramaters
*/





/* ------------------------------------------------------------------------- */
/*
  Add python code to the proxy/shadow code 
  
   %pythonprepend   - Add code before the C++ function is called
   %pythonappend    - Add code after the C++ function is called
*/









/* ------------------------------------------------------------------------- */
/* 
   %extend_smart_pointer extend the smart pointer support.

   For example, if you have a smart pointer as:
	    
     template <class Type> class RCPtr {
     public:
       ...
       RCPtr(Type *p);
   	Type * operator->() const;
   	...
     };
     
   you use the %extend_smart_pointer directive as:
   
     %extend_smart_pointer(RCPtr<A>);
     %template(RCPtr_A)  RCPtr<A>;
   
   then, if you have something like:

     RCPtr<A> make_ptr();
     int foo(A *);

   you can do the following:

     a = make_ptr();
     b = foo(a);

   ie, swig will accept a RCPtr<A> object where a 'A *' is
   expected.

   Also, when using vectors
   
     %extend_smart_pointer(RCPtr<A>);
     %template(RCPtr_A) RCPtr<A>;
     %template(vector_A) std::vector<RCPtr<A> >;
   	
   you can type

     a = A();
     v = vector_A(2)
     v[0] = a

   ie, an 'A *' object is accepted, via implicit conversion, 
   where a RCPtr<A> object is expected. Additionally

     x = v[0]

   returns (and sets 'x' as) a copy of v[0], making reference
   counting possible and consistent.
*/







]

/* ------------------------------------------------------------
 *  Typemap specializations
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pytypemaps.swg" [
/* ------------------------------------------------------------
 *  Typemap specializations for Python
 * ------------------------------------------------------------ */

/* ------------------------------------------------------------
 *  Fragment section
 * ------------------------------------------------------------ */
/* bool is dangerous in Python, change precedence */



/* Include fundamental fragemt definitions */
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg" [
/*
  Fragments:
  ==========

  Second to typemaps, fragments are one the most powerful and
  dangerous swig features. So, if you are starting to read about them,
  make sure you read all of this document.

  Basics:
  =======

  Fragments provide a way to include or generate code into "on-demand"
  as the typemaps could require.

  For example, if you have a very long typemap

  %typemap(in) MyClass * {
    MyClass *value = 0;

    <very long typemap>
    ....
    value = somewhere_converted_from_input_object_here($input);
    ...
    <very long typemap>
  
    $result = value;
  }

  very soon you will discover yourself copying the same long
  conversion code in several typemaps, such as varin, directorout,
  etc. Also, you will discover that swig copes verbatim the same very
  long conversion code for every argument that requires it, making the
  code very large too.

  To eliminate this automatic or manual code copying, we define a
  fragment that includes the common conversion code:

  %fragment("AsMyClass","header") {
     MyClass *AsMyClass(PyObject *obj) {
        MyClass *value = 0;
        <very long conversion>
        ....
        value = somewhere_converted_from_input_object_here(obj);
        ...
        <very long conversion>
  
        return value;
     }
  }

  %typemap(in,fragment="AsMyClass") MyClass * {
    $result = AsMyClass($input);
  }

  %typemap(varin,fragment="AsMyClass") MyClass * {
    $result = AsMyClass($input);
  }

  When the 'in' or 'varin' typemaps for MyClass are invoked, the
  fragment "AsMyClass" is added to the "header" section, and then the
  typemap code is emitted. Hence, the method AsMyClass will be
  included in the wrapping code and it will be available at the time
  the typemap is applied.

  To define a fragment then you need a name, a section where it goes,
  and the code. Usually the section refers to the "header" part, and
  both string and braces forms are accepted, ie:

    %fragment("my_name","header") { ... }
    %fragment("my_name","header") "...";

  To ensure all the fragment/typemap engine works as expected, there
  are some rules that fragments follow:

  1.- A fragment is added to the wrapping code only once, ie, for the
      method:
      
        int foo(MyClass *a, MyClass *b);

     the wrapped code will look as much as:

      MyClass *AsMyClass(PyObject *obj) {
        .....
      }
      
      int _wrap_foo(...) {
        ....
        arg1 = AsMyClass(obj1);
        arg2 = AsMyClass(obj2);
        ...
	result = foo(arg1, arg2);
      }


     even when there will be duplicated typemap to process 'a' and
     'b', the 'AsMyClass' method will be defined only once.

     
  2.- A fragment can only defined once, and the first definition
      is the only one taking in account. All other definitions of the
      same fragments are silently ignored. For example, you can have


        %fragment("AsMyClass","header") { <definition 1> }
	....
        %fragment("AsMyClass","header") { <definition 2> }
     
      and then only the first definition is considered. In this way
      you can change the 'system' fragments by including yours first.

      Note that this behavior is opposite to the typemaps, where the
      last typemap applied or defined prevails. Fragment follows the
      first-in-first-out convention since they are intended to be
      "global", while typemaps intend to be "locally" specialized.
      
  3.- Fragments names can not contain commas.
 	

  A fragment can include one or more additional fragments, for example:

    %fragment("<limits.h>", "header")  {
      #include <limits.h>
    }


    %fragment("AsMyClass", "header", fragment="<limits.h>") {
      MyClass *AsMyClass(PyObject *obj) {
        MyClass *value = 0;
	int ival = somewhere_converted_from_input_object_here(obj)
	...
        if  (ival < CHAR_MIN) {
	   value = something_from_ival(ival);
        } else {
	...
	}
	...
        return value;
      }
    }

  in this case, when the "AsMyClass" fragment is emitted, it also
  trigger the inclusion of the "<limits.h>" fragment.

  You can add as many fragments as you want, for example

    %fragment("bigfragment","header", fragment="frag1", fragment="frag2", fragment="frag3") "";

  here, when the "bigfragment" is included, the three fragments "frag1",
  "frag2" and "frag3" are included. Note that as "bigframent" is defined
  empty, "", it does not add any code by itself, buy only trigger the
  inclusion of the other fragments.
  
  In a typemap you can also include more than one fragment, but since the
  syntax is different, you need to specify them in a 'comma separated'
  list, for example, considering the previous example:
 
     %typemap(in,fragment="frag1,frag2,frag3") {...}

  is equivalent to

     %typemap(in,fragment="bigfragment") {...}

  
  Finally, you can force the inclusion of a fragment at any moment as follow:

     %fragment("bigfragment");

  which is very useful inside a template class, for example. 


  Fragment type specialization
  ============================
  
  Fragments can be "type specialized". The syntax is as follows
 									   
    %fragment("name","header") { a type independent fragment }
    %fragment("name" {Type}, "header") { a type dependent fragment  }
 									   
  and they can also, as typemaps, be used inside templates, for exampe:
 									   
     template <class T>					              
     struct A {						              
        %fragment("incode"{A<T>},"header") {			              
 	  'incode' specialized fragment 
 	}							   	    
 									   
 	%typemap(in,fragment="incode"{A<T>}) {		   	    
           here we use the 'type specialized' 		   	    
           fragment "incode"{A<T>}			              
 	}
     };							              
  
   which could seems a not much interesting feature, but is
   fundamental for automatic typemap and template specialization.


  Fragments and automatic typemap specialization:
  ===============================================

  Since fragments can be type specialized, they can be elegantly used
  to specialized typemaps .

  For example, if you have something like:

    %fragment("incode"{float}, "header") {
      float in_method_float(PyObject *obj) {
        ...
      }
    }

    %fragment("incode"{long}, "header") {
      float in_method_long(PyObject *obj) {
        ...
      }
    }
    
    %define %my_typemaps(Type) 
    %typemaps(in,fragment="incode"{Type}) {
      value = in_method_##Type(obj);
    }
    %enddef

    %my_typemaps(float);
    %my_typemaps(long);

  then the proper "incode"{float,double} fragment will be included,
  and the proper in_method_{float,double} will be called.

  Since this is a recurrent fragment use, we provide a couple of
  macros that make the automatic generation of typemaps easier:


  Consider for example the following code:

      %fragment(SWIG_From_frag(bool),"header") {     
      static PyObject*		      
      SWIG_From_dec(bool)(bool value)	       
      {					       
        PyObject *obj = value ? Py_True : Py_False;  
        Py_INCREF(obj);			       
        return obj;				       
      }					       
      }					       
      					 
      %typemap(out,fragment=SWIG_From_frag(bool)) bool {
        $result = SWIG_From(bool)($1));
      }

  Here the macros

      SWIG_From_frag  => fragment 
      SWIG_From_dec   => declaration 
      SWIG_From       => call 
      
  allow you to define/include a fragment, and declare and call the
  'from-bool' method as needed. In the simpler case, these macros 
  just return something like

      SWIG_From_frag(bool)  => "SWIG_From_bool"
      SWIG_From_dec(bool)   =>  SWIG_From_bool
      SWIG_From(bool)       =>  SWIG_From_bool

  But they are specialized for the different languages requirements,
  such as perl or tcl that requires passing the interpreter pointer,
  and also they can manage C++ ugly types, for example:
  
      SWIG_From_frag(std::complex<double>)  => "SWIG_From_std_complex_Sl_double_Sg_"
      SWIG_From_dec(std::complex<double>)   =>  SWIG_From_std_complex_Sl_double_Sg_
      SWIG_From(std::complex<double>)       =>  SWIG_From_std_complex_Sl_double_Sg_


  Hence, to declare methods to use with typemaps, always use the
  SWIG_From* macros. In the same way, the SWIG_AsVal* and SWIG_AsPtr*
  set of macros are provided.
    
*/


/* -----------------------------------------------------------------------------
 * Define the basic macros to 'normalize' the type fragments
 * ----------------------------------------------------------------------------- */




































/* ------------------------------------------------------------
 * common fragments 
 * ------------------------------------------------------------ */

/* Default compiler options for gcc allow long_long but not LLONG_MAX. 
 * Define SWIG_NO_LLONG_MAX if this added limits support is not wanted. */
%fragment("<limits.h>","header") %{
#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif
%}

%fragment("<math.h>","header") %{
#include <math.h>
%}

%fragment("<wchar.h>","header") %{
#include <wchar.h>
#include <limits.h>
#ifndef WCHAR_MIN
#  define WCHAR_MIN 0
#endif
#ifndef WCHAR_MAX
#  define WCHAR_MAX 65535
#endif
%}

%fragment("<float.h>","header") %{
#include <float.h>
%}

%fragment("<stdio.h>","header") %{
#include <stdio.h>
#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
# ifndef snprintf
#  define snprintf _snprintf
# endif
#endif
%}

%fragment("<stdlib.h>","header") %{
#include <stdlib.h>
#ifdef _MSC_VER
# ifndef strtoull
#  define strtoull _strtoui64
# endif
# ifndef strtoll
#  define strtoll _strtoi64
# endif
#endif
%}

/* -----------------------------------------------------------------------------
 * special macros for fragments
 * ----------------------------------------------------------------------------- */

/* Macros to derive numeric types */








































/* Macro for 'signed long' derived types */






/* Macro for 'unsigned long' derived types */







/* Macro for 'double' derived types */







/* Macros for missing fragments */
















]

/* Look for user fragments file. */
%includefile "C:\\Programme\\swig\\Lib\\python\\pyfragments.swg" [
/*

  Create a file with this name, 'pyfragments.swg', in your working
  directory and add all the %fragments you want to take precedence
  over the default ones defined by swig.

  For example, if you add:
  
  %fragment(SWIG_AsVal_frag(int),"header") {
   SWIGINTERNINLINE int
   SWIG_AsVal(int)(PyObject *obj, int *val)
   { 
     <your code here>;
   }
  }
  
  this will replace the code used to retrieve an integer value for all
  the typemaps that need it, including:
  
    int, std::vector<int>, std::list<std::pair<int,int> >, etc.

    
*/

]

/* Python fragments for fundamental types */
%includefile "C:\\Programme\\swig\\Lib\\python\\pyprimtypes.swg" [
/* ------------------------------------------------------------
 * Primitive Types
 * ------------------------------------------------------------ */

/* boolean */

%fragment("SWIG_" "From" "_" {bool},"header") {
SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}
}

%fragment("SWIG_" "AsVal" "_" {bool},"header",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}
}

/* long */

%fragment("SWIG_" "From" "_" {long},"header") {
  #define SWIG_From_long   PyInt_FromLong 
}

%fragment("SWIG_" "AsVal" "_" {long},"header",
	  fragment="SWIG_CanCastAsInteger") {
SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}
}

/* unsigned long */

%fragment("SWIG_" "From" "_" {unsigned long},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value)); 
}
}

%fragment("SWIG_" "AsVal" "_" {unsigned long},"header",
	  fragment="SWIG_CanCastAsInteger") {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}
}

/* long long */

%fragment("SWIG_" "From" "_" {long long},"header",
	  fragment="SWIG_" "From" "_" {long},
	  fragment="<limits.h>") {
SWIGINTERNINLINE PyObject* 
SWIG_From_long_SS_long  (long long value)
{
  return ((value < LONG_MIN) || (value > LONG_MAX)) ?
    PyLong_FromLongLong(value) : PyInt_FromLong(static_cast< long >(value)); 
}
}

%fragment("SWIG_" "AsVal" "_" {long long},"header",
	  fragment="SWIG_" "AsVal" "_" {long},
	  fragment="SWIG_CanCastAsInteger",
	  fragment="<limits.h>") {
SWIGINTERN int
SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  } else {
    long v;
    res = SWIG_AsVal_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    const double mant_min = -mant_max;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
      if (val) *val = (long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
}

/* unsigned long long */

%fragment("SWIG_" "From" "_" {unsigned long long},"header",
	  fragment="SWIG_" "From" "_" {long long},
	  fragment="<limits.h>") {
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyInt_FromLong(static_cast< long >(value)); 
}
}

%fragment("SWIG_" "AsVal" "_" {unsigned long long},"header",
	  fragment="SWIG_" "AsVal" "_" {unsigned long},
	  fragment="SWIG_CanCastAsInteger",
	  fragment="<limits.h>") {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
}

/* double */

%fragment("SWIG_" "From" "_" {double},"header") {
  #define SWIG_From_double   PyFloat_FromDouble 
}

%fragment("SWIG_" "AsVal" "_" {double},"header") {
SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
  } else if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}
}




]

/* Python fragments for char* strings */
%includefile "C:\\Programme\\swig\\Lib\\python\\pystrings.swg" [
/* ------------------------------------------------------------
 *  utility methods for char strings 
 * ------------------------------------------------------------ */
%fragment("SWIG_AsCharPtrAndSize","header",fragment="SWIG_pchar_descriptor") {
SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
  if (PyUnicode_Check(obj)) 
#else  
  if (PyString_Check(obj)) 
#endif
  {
    char *cstr; Py_ssize_t len;
#if PY_VERSION_HEX>=0x03000000
    obj = PyUnicode_AsUTF8String(obj);
    PyBytes_AsStringAndSize(obj, &cstr, &len);
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) { 
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
#else
	if (*alloc == SWIG_NEWOBJ) 
#endif
	  {
	    *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
	    *alloc = SWIG_NEWOBJ;
	  }
	else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
	*cptr = SWIG_Python_str_AsChar(obj);
      }
    }
    if (psize) *psize = len + 1;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}
}

%fragment("SWIG_FromCharPtrAndSize","header",fragment="SWIG_pchar_descriptor") {
SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
      return PyUnicode_FromStringAndSize(carray, static_cast< int >(size));
#else
      return PyString_FromStringAndSize(carray, static_cast< int >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}
}



]

/* Backward compatibility output helper */
%fragment("t_output_helper","header") %{
#define t_output_helper SWIG_Python_AppendOutput
%}


/* ------------------------------------------------------------
 *  Unified typemap section
 * ------------------------------------------------------------ */

/* directors are supported in Python */





/* Python types */



/* Python allows implicit conversion */



/* Overload of the output/constant/exception/dirout handling */

/* append output */


/* set constant */


/* raise */


/* Include the unified typemap library */
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\swigtypemaps.swg" [
/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * swigtypemaps.swg
 *
 * Unified Typemap Library frontend
 * ----------------------------------------------------------------------------- */

/*
  This file provides the frontend to the Unified Typemap Library.

  When using this library in a SWIG target language, you need to
  define a minimum set of fragments, specialize a couple of macros,
  and then include this file.

  Typically you will create a 'mytypemaps.swg' file in each target
  languge, where you will have the following sections:

    === mytypemaps.swg ===

    //  Fragment section 
    %include <typemaps/fragments.swg>
    <include target language fragments>

    // Unified typemap section 
    <specialized the typemap library macros>
    %include <typemaps/swigtypemaps.swg>

    // Local typemap section 
    <add/replace extra target language typemaps>

    === mytypemaps.swg ===

  While we add more docs, please take a look at the following cases
  to see how you specialized the unified typemap library for a new
  target language:

      Lib/python/pytypemaps.swg
      Lib/tcl/tcltypemaps.swg
      Lib/ruby/rubytypemaps.swg
      Lib/perl5/perltypemaps.swg
    
*/



/* -----------------------------------------------------------------------------
 *   Language specialization section. 
 *
 *   Tune these macros for each language as needed.
 * ----------------------------------------------------------------------------- */

/*
  The SWIG target language object must be provided.
  For example in python you define:

    #define SWIG_Object PyObject *
*/





/*==== flags for new/convert methods ====*/














/*==== set output ====*/


/* simple set output operation */



/*==== set variable output  ====*/


/* simple set varoutput operation */



/*==== append output ====*/



/* simple append operation */






/*==== set constant ====*/



/* simple set constant operation */






/*==== raise an exception ====*/



/* simple raise operation */






/*==== director output exception ====*/








/* -----------------------------------------------------------------------------
 *  Language independent definitions
 * ----------------------------------------------------------------------------- */













/* -----------------------------------------------------------------------------
 *  All the typemaps
 * ----------------------------------------------------------------------------- */



%includefile "C:\\Programme\\swig\\Lib\\typemaps\\exception.swg" [
/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * exceptions.swg
 *
 * This SWIG library file provides language independent exception handling
 * ----------------------------------------------------------------------------- */




/* macros for error manipulation */












/* setting an error */





%insert("runtime") {

#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 

}


/*
  You can use the SWIG_CATCH_STDEXCEPT macro with the %exception
  directive as follows:

  %exception {
    try {
      $action
    }
    catch (my_except& e) {
      ...
    }
    SWIG_CATCH_STDEXCEPT // catch std::exception
    catch (...) {
     SWIG_exception_fail(SWIG_UnknownError, "Unknown exception");
    }
  }
*/
%{
#include <stdexcept>
%}






























]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\swigtype.swg" [
/* -----------------------------------------------------------------------------
 * --- Input arguments --- 
 * ----------------------------------------------------------------------------- */
/* Pointers and arrays */
%typemap(in, noblock=1) SWIGTYPE *(void  *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp,$descriptor, $disown |  0 );
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg) SWIGTYPE * "";

%typemap(in, noblock=1) SWIGTYPE [] (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp,$descriptor, $disown |  0 );
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  } 
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg) SWIGTYPE [] "";


%typemap(in, noblock=1) SWIGTYPE* const&  (void *argp = 0, int res = 0, $*ltype temp) {
  res = SWIG_ConvertPtr($input, &argp, $*descriptor, $disown |  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'"); 
  }
  temp = reinterpret_cast< $*ltype >(argp);
  $1 = &temp;
}
%typemap(freearg) SWIGTYPE* const& "";


/* Reference */
%typemap(in, noblock=1) SWIGTYPE & (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg) SWIGTYPE & "";


%typemap(in,noblock=1,implicitconv=1) const SWIGTYPE & (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg,noblock=1,match="in",implicitconv=1) const SWIGTYPE &
{
  if (SWIG_IsNewObj(res$argnum)) delete $1;
}











/* By value */

%typemap(in,implicitconv=1) SWIGTYPE (void *argp, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $&descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }  
  if (!argp) { 
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  } else {
    $&ltype temp = reinterpret_cast< $&ltype >(argp);
    $1 = *temp;
    if (SWIG_IsNewObj(res)) delete temp;
  }
}















/* -----------------------------------------------------------------------------
 * --- Output arguments --- 
 * ----------------------------------------------------------------------------- */

/* Pointers, references */
%typemap(out,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE[] {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor, $owner |  0 );
}

%typemap(out, noblock=1) SWIGTYPE* const& {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr(*$1), $*descriptor, $owner |  0 );
}

/* Return by value */
%typemap(out, noblock=1) SWIGTYPE {
  $result = SWIG_NewPointerObj((new $ltype(static_cast< const $ltype& >($1))), $&descriptor, SWIG_POINTER_OWN |  0 );
}

/* -----------------------------------------------------------------------------
 * --- Variable input --- 
 * ----------------------------------------------------------------------------- */

/* memberin/globalin/varin, for fix arrays. */

%typemap(memberin) SWIGTYPE [ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$dim0; ++ii) $1[ii] = $input[ii];
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(globalin) SWIGTYPE [ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$dim0; ++ii) $1[ii] = $input[ii];
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(varin) SWIGTYPE [ANY] {
  $basetype *inp = 0;
  int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&inp), $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  } else if (inp) {
    size_t ii = 0;
    for (; ii < (size_t)$dim0; ++ii) $1[ii] = inp[ii];
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}


/* memberin/globalin/varin, for fix double arrays. */

%typemap(memberin) SWIGTYPE [ANY][ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$dim0; ++ii) {
      if ($input[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$dim1; ++jj) $1[ii][jj] = $input[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(globalin) SWIGTYPE [ANY][ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$dim0; ++ii) {
      if ($input[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$dim1; ++jj) $1[ii][jj] = $input[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(varin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$dim1] = 0;
  int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&inp), $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  } else if (inp) {
    size_t ii = 0;
    for (; ii < (size_t)$dim0; ++ii) {
      if (inp[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$dim1; ++jj) $1[ii][jj] = inp[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

/* Pointers, references, and variable size arrays */

%typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE * {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );  
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = reinterpret_cast< $ltype >(argp);
}

%typemap(varin,noblock=1,warning="462:Unable to set dimensionless array variable") SWIGTYPE []
{
  SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only $name""' of type '""$type""'");
}

%typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE & {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (!argp) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
  $1 = *(reinterpret_cast< $ltype >(argp));
}


%typemap(varin,implicitconv=1) SWIGTYPE {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $&descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (!argp) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  } else {
    $&type temp;
    temp  = reinterpret_cast< $&type >(argp);
    $1 = *temp;
    if (SWIG_IsNewObj(res)) delete temp;
  }
}















/* -----------------------------------------------------------------------------
 * --- Variable output --- 
 * ----------------------------------------------------------------------------- */

/* Pointers and arrays */
%typemap(varout, noblock=1) SWIGTYPE * {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
}

%typemap(varout, noblock=1) SWIGTYPE [] {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
}

/* References */
%typemap(varout, noblock=1) SWIGTYPE & {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $descriptor,  0 );
}

/* Value */
%typemap(varout, noblock=1) SWIGTYPE {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $&descriptor,  0 );
}

/* ------------------------------------------------------------
 * --- Typechecking rules ---
 * ------------------------------------------------------------ */

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE * {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE & {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
  $1 = SWIG_CheckState(res);
}


%typemap(typecheck,precedence=      0     ,noblock=1,implicitconv=1) const SWIGTYPE & {
  int res = SWIG_ConvertPtr($input, 0, $descriptor, $implicitconv);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1,implicitconv=1) SWIGTYPE {
  int res = SWIG_ConvertPtr($input, 0, $&descriptor, $implicitconv);
  $1 = SWIG_CheckState(res);
}














/* -----------------------------------------------------------------------------
 * --- Director typemaps --- *  
 * ----------------------------------------------------------------------------- */



/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE*, SWIGTYPE* const& {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr($1_name), $descriptor,  0 );
}

%typemap(directorin,noblock=1) SWIGTYPE {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr(&$1_name), $&descriptor,  0 );
}

%typemap(directorin,noblock=1) SWIGTYPE& {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr(&$1_name), $descriptor,  0 );
}

/* directorout */

%typemap(directorout,noblock=1,implicitconv=1) SWIGTYPE (void * swig_argp, int swig_res = 0) {
  swig_res = SWIG_ConvertPtr($input,&swig_argp,$&descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
  $result = *(reinterpret_cast< $&ltype >(swig_argp));
  if (SWIG_IsNewObj(swig_res)) delete reinterpret_cast< $&ltype >(swig_argp);
}










%typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
  SWIGTYPE *(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor,  0  | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
  $result = reinterpret_cast< $ltype >(swig_argp);
  swig_acquire_ownership_obj(SWIG_as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE * {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr($input)));
  }
}

%typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
  SWIGTYPE &(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor,  0  | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
  if (!swig_argp) { Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'"); }
  $result = reinterpret_cast< $ltype >(swig_argp);
  swig_acquire_ownership_obj(SWIG_as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE & {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr($input)));
  }
}




/* ------------------------------------------------------------
 * --- Constants ---
 * ------------------------------------------------------------ */

%typemap(constcode,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE []{ 
  SWIG_Python_SetConstant(d, "$symname",SWIG_NewPointerObj(SWIG_as_voidptr($value),$descriptor, 0 ));
}

%typemap(constcode,noblock=1) SWIGTYPE {
  SWIG_Python_SetConstant(d, "$symname",SWIG_NewPointerObj(SWIG_as_voidptr(&$value),$&descriptor, 0 ));
}

/* ------------------------------------------------------------
 * --- Exception handling ---
 * ------------------------------------------------------------ */

%typemap(throws,noblock=1) SWIGTYPE {
  SWIG_Python_Raise(SWIG_NewPointerObj((new $ltype(static_cast< const $ltype& >($1))),$&descriptor,SWIG_POINTER_OWN), "$type", $&descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) SWIGTYPE * {
  SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr($1),$descriptor,0), "$type", $descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) SWIGTYPE [ANY] {
  SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr($1),$descriptor,0), "$type", $descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) SWIGTYPE & {
  SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr(&$1),$descriptor,0), "$type", $descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) (...) {
  SWIG_exception_fail(SWIG_RuntimeError,"unknown exception");
}

/* ------------------------------------------------------------
 * --- CLASS::* typemaps --- 
 * ------------------------------------------------------------ */

%typemap(in) SWIGTYPE (CLASS::*) {  
  int res = SWIG_ConvertMember($input, SWIG_as_voidptr(&$1), sizeof($type),$descriptor);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}

%typemap(out,noblock=1) SWIGTYPE (CLASS::*) {
  $result = SWIG_NewMemberObj(SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
}

%typemap(varin) SWIGTYPE (CLASS::*) {
  int res = SWIG_ConvertMember($input,SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'"); 
  }
}

%typemap(varout,noblock=1) SWIGTYPE (CLASS::*) {
  $result = SWIG_NewMemberObj(SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
}

%typemap(constcode,noblock=1) SWIGTYPE (CLASS::*) {
  SWIG_Python_SetConstant(d, "$symname",SWIG_NewMemberObj(SWIG_as_voidptr(&$value), sizeof($type), $descriptor));
}



/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE (CLASS::*) {
  $input = SWIG_NewMemberObj(SWIG_as_voidptr(&$1_name), sizeof($type), $descriptor);
}

/* directorout */

%typemap(directorout) SWIGTYPE (CLASS::*) {
  int swig_res = SWIG_ConvertMember($input,SWIG_as_voidptr(&$result), sizeof($type), $descriptor);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
}


/* ------------------------------------------------------------
 * --- function ptr typemaps --- 
 * ------------------------------------------------------------ */

/*
  ISO C++ doesn't allow direct casting of a function ptr to a object
  ptr. So, maybe the ptr sizes are not the same, and we need to take
  some providences.
 */
%typemap(in) SWIGTYPE ((*)(ANY)) {
  int res = SWIG_ConvertFunctionPtr($input, (void**)(&$1), $descriptor);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}

 %typemap(typecheck, precedence=      0     ,noblock=1)  SWIGTYPE ((*)(ANY)) {
  void *ptr = 0;
  int res = SWIG_ConvertFunctionPtr($input, &ptr, $descriptor);
  $1 = SWIG_CheckState(res);
}


%typemap(out, noblock=1) SWIGTYPE ((*)(ANY)) {
  $result = SWIG_NewFunctionPtrObj((void *)($1), $descriptor);
}

%typemap(varin) SWIGTYPE ((*)(ANY)) {
  int res = SWIG_ConvertFunctionPtr($input, (void**)(&$1), $descriptor);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'"); 
  }
}

%typemap(varout,noblock=1) SWIGTYPE ((*)(ANY)) {  
  $result = SWIG_NewFunctionPtrObj((void *)($1), $descriptor);
}

%typemap(constcode, noblock=1) SWIGTYPE ((*)(ANY)){
  SWIG_Python_SetConstant(d, "$symname",SWIG_NewFunctionPtrObj((void *)$value, $descriptor));
}



/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE ((*)(ANY)) {
  $input = SWIG_NewFunctionPtrObj((void*)($1_name), $descriptor);
}

/* directorout */

%typemap(directorout) SWIGTYPE ((*)(ANY)) {
  int swig_res = SWIG_ConvertFunctionPtr($input,(void**)(&$result),$descriptor);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
}



/* ------------------------------------------------------------
 * --- Special typemaps ---
 * ------------------------------------------------------------ */

/* VARARGS_SENTINEL typemap. Used by the %varargs directive. */

%typemap(in,numinputs=0) SWIGTYPE *VARARGS_SENTINEL, SWIGTYPE VARARGS_SENTINEL "";


/* DISOWN typemap */

%typemap(in, noblock=1) SWIGTYPE *DISOWN (int res = 0) {
  res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&$1), $descriptor, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
}

%typemap(varin) SWIGTYPE *DISOWN {
  void *temp = 0;
  int res = SWIG_ConvertPtr($input, &temp, $descriptor, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = ($ltype) temp;
}

/* DYNAMIC typemap */

%typemap(out,noblock=1) SWIGTYPE *DYNAMIC, SWIGTYPE &DYNAMIC {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), SWIG_TypeDynamicCast($descriptor, SWIG_as_voidptrptr(&$1)), $owner |  0 );
}

/* INSTANCE typemap */

%typemap(out,noblock=1) SWIGTYPE INSTANCE {
  $result = SWIG_NewInstanceObj((new $1_ltype(static_cast< const $1_ltype& >($1))), $&1_descriptor, SWIG_POINTER_OWN | 0 );
}

%typemap(out,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE &INSTANCE, SWIGTYPE INSTANCE[] {
  $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, $owner | 0 );
}

%typemap(varout,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE INSTANCE[] {
  $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, 0 );
}

%typemap(varout,noblock=1) SWIGTYPE &INSTANCE {
  $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, 0 );
}

%typemap(varout,noblock=1) SWIGTYPE INSTANCE {
  $result = SWIG_NewInstanceObj(SWIG_as_voidptr(&$1), $&1_descriptor, 0 );
}

]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\void.swg" [
/* ------------------------------------------------------------
 * Void * -  Accepts any kind of pointer
 * ------------------------------------------------------------ */

/* in */

%typemap(in,noblock=1) void * (int res) {
  res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1), 0, $disown);
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}
%typemap(freearg) void * "";

%typemap(in,noblock=1) void * const& ($*ltype temp = 0, int res) {
  res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&temp), 0, $disown);
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "Stype""'"); 
  }
  $1 =  &temp;
}
%typemap(freearg) void * const& "";


/* out */


%typemap(out,noblock=1) void { $result = SWIG_Py_Void(); }




/* varin */

%typemap(varin) void * {
  void *temp = 0;
  int res = SWIG_ConvertPtr($input, &temp, 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = ($1_ltype) temp;
}

/* typecheck */

 %typemap(typecheck, precedence=      10    ,noblock=1)  void *
{
  void *ptr = 0;
  int res = SWIG_ConvertPtr($input, &ptr, 0, 0);
  $1 = SWIG_CheckState(res);
}



/* directorin */

%typemap(directorin,noblock=1) void *, void const*, void *const, void const *const, 
  void const *&, void *const &, void const *const & {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr($1_name), $descriptor,  0 );
}

/* directorout */

%typemap(directorout,noblock=1) void * (void *argp, int res) {
  res = SWIG_ConvertPtr($input, &argp, 0, 0);
  if (!SWIG_IsOK(res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  $result = reinterpret_cast< $ltype >(argp);
}

%typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) void * const& (void *argp, int res) {
  res = SWIG_ConvertPtr($input, &argp, 0, $disown);
  if (!SWIG_IsOK(res)) { 
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  static $*ltype temp = reinterpret_cast< $*ltype >(argp);
  $result =  &temp;
}






]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\swigobject.swg" [
/* ------------------------------------------------------------
 * Language Object *  - Just pass straight through unmodified
 * ------------------------------------------------------------ */

%typemap(in)   PyObject * "$1 = $input;";

%typemap(in,noblock=1)   PyObject * const & ($*ltype temp)
{
  temp = static_cast< $*ltype >($input);
  $1 = &temp;
}

%typemap(out,noblock=1) PyObject * {
  $result = $1;
}

%typemap(out,noblock=1)  PyObject * const & {
  $result = *$1;
}

 %typemap(typecheck, precedence=       5000    )  PyObject * "$1 = ($input != 0);";

%typemap(throws,noblock=1) PyObject * {
  SWIG_Python_Raise($1, "$type", 0); SWIG_fail;
}

%typemap(constcode,noblock=1) PyObject * {
  SWIG_Python_SetConstant(d, "$symname",$value);
}



%typemap(directorin) PyObject * "$input = $1_name";
%typemap(directorout) PyObject * "$result = $input;";




]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg" [
/*---------------------------------------------------------------------
 * Value typemaps (Type, const Type&) for value types, such as
 * fundamental types (int, double), that define the AsVal/From
 * methods.
 *
 * To apply them, just use one of the following macros:
 *
 *   %typemaps_from(FromMeth, FromFrag, Type)
 *   %typemaps_asval(CheckCode, AsValMeth, AsValFrag, Type)
 *   %typemaps_asvalfrom(CheckCode, AsValMeth, FromMeth, AsValFrag, FromFrag, Type)
 *
 * or the simpler and normalize form:
 *
 *   %typemaps_asvalfromn(CheckCode, Type)
 *
 * Also, you can use the individual typemap definitions:
 *
 *    %value_in_typemap(asval_meth,frag,Type)
 *    %value_varin_typemap(asval_meth,frag,Type)
 *    %value_typecheck_typemap(checkcode,asval_meth,frag,Type)
 *    %value_directorout_typemap(asval_meth,frag,Type)
 *
 *    %value_out_typemap(from_meth,frag,Type)
 *    %value_varout_typemap(from_meth,frag,Type)
 *    %value_constcode_typemap(from_meth,frag,Type)
 *    %value_directorin_typemap(from_meth,frag,Type)
 *    %value_throws_typemap(from_meth,frag,Type)
 *
 *---------------------------------------------------------------------*/

/* in */





















/* out */










/* varin */












/* varout */







/* constant installation code */










/* directorin */










/* directorout */












































/* throws */







/* typecheck */








/*---------------------------------------------------------------------
 * typemap definition for types with AsVal methods
 *---------------------------------------------------------------------*/









/*---------------------------------------------------------------------
 * typemap definition for types with from method
 *---------------------------------------------------------------------*/










/*---------------------------------------------------------------------
 * typemap definition for types with alval/from method
 *---------------------------------------------------------------------*/









/*---------------------------------------------------------------------
 * typemap definition for types  with for 'normalized' asval/from methods
 *---------------------------------------------------------------------*/









]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg" [
/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * ptrtypes.swg
 *
 * Value typemaps (Type, const Type&) for "Ptr" types, such as swig
 * wrapped classes, that define the AsPtr/From methods
 *
 * To apply them, just use one of the following macros:
 *
 *    %typemaps_asptr(CheckCode, AsPtrMeth, AsPtrFrag, Type)
 *    %typemaps_asptrfrom(CheckCode, AsPtrMeth, FromMeth, AsPtrFrag, FromFrag, Type)
 *
 * or the simpler and normalize form:
 *
 *    %typemaps_asptrfromn(CheckCode, Type)
 *
 * Also, you can use the individual typemap definitions:
 *
 *    %ptr_in_typemap(asptr_meth,frag,Type)
 *    %ptr_varin_typemap(asptr_meth,frag,Type)
 *    %ptr_typecheck_typemap(check,asptr_meth,frag,Type)
 *    %ptr_directorout_typemap(asptr_meth,frag,Type)
 * ----------------------------------------------------------------------------- */



/* in */
























/* varin */














/* directorout */










































































/* typecheck */














/*---------------------------------------------------------------------
 * typemap definition for types with asptr method
 *---------------------------------------------------------------------*/



























/*---------------------------------------------------------------------
 * typemap definition for types with asptr/from methods
 *---------------------------------------------------------------------*/








/*---------------------------------------------------------------------
 * typemap definition for types  with for 'normalized' asptr/from methods
 *---------------------------------------------------------------------*/










]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg" [
/*  ------------------------------------------------------------
 *
 * Define the IN/OUTPUT typemaps assuming the output parameters are
 * returned in a list, i.e., they are not directly modified.
 *
 * The user should provide the %append_output(result, obj) method,
 * via a macro, which append a particular object to the result.
 *
 *
 * In Tcl, for example, the file is used as:
 *
 *   #define %append_output(obj) Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),obj);
 *   %include <typemaps/inoutlist.swg>
 *
 * while in Python it is used as:
 *
 *   #define %append_output(obj) $result = SWIG_Python_AppendResult($result, obj)
 *   %include <typemaps/inoutlist.swg>
 *
 * where the method SWIG_Python_AppendResult is defined inside the
 * %append_output fragment.
 *
 * If you forget to define %append_output, this file will generate
 * an error.
 *
 * ------------------------------------------------------------ */


//
// Uncomment the following definition if you don't want the in/out
// typemaps by default, ie, you prefer to use typemaps.i.
//
//#define SWIG_INOUT_NODEF

//
// Use the following definition to enable the INPUT parameters to
// accept both 'by value' and 'pointer' objects.
//


// ------------------------------------------------------------------------
// Pointer handling
//
// These mappings provide support for input/output arguments and common
// uses for C/C++ pointers.
// ------------------------------------------------------------------------

// INPUT typemaps.
// These remap a C pointer to be an "INPUT" value which is passed by value
// instead of reference.

/* 
The following methods can be applied to turn a pointer into a simple
"input" value.  That is, instead of passing a pointer to an object,
you would use a real value instead.
         
To use these, suppose you had a C function like this :

        double fadd(double *a, double *b) {
               return *a+*b;
        }

You could wrap it with SWIG as follows :

        double fadd(double *INPUT, double *INPUT);

or you can use the %apply directive :

        %apply double *INPUT { double *a, double *b };
        double fadd(double *a, double *b);

*/







































































// OUTPUT typemaps.   These typemaps are used for parameters that
// are output only.   The output value is appended to the result as
// a list element.

/* 
The following methods can be applied to turn a pointer into an "output"
value.  When calling a function, no input value would be given for
a parameter, but an output value would be returned.  In the case of
multiple output values, they are returned in the form of a list.

         
For example, suppose you were trying to wrap the modf() function in the
C math library which splits x into integral and fractional parts (and
returns the integer part in one of its parameters):

        double modf(double x, double *ip);

You could wrap it with SWIG as follows :

        double modf(double x, double *OUTPUT);

or you can use the %apply directive :

        %apply double *OUTPUT { double *ip };
        double modf(double x, double *ip);

The output of the function would be a list containing both output
values.

*/


















// INOUT
// Mappings for an argument that is both an input and output
// parameter

/*
The following methods can be applied to make a function parameter both
an input and output value.  This combines the behavior of both the
"INPUT" and "OUTPUT" methods described earlier.  Output values are
returned in the form of a list.  
         
For example, suppose you were trying to wrap the following function :

        void neg(double *x) {
             *x = -(*x);
        }

You could wrap it with SWIG as follows :

        void neg(double *INOUT);

or you can use the %apply directive :

        %apply double *INOUT { double *x };
        void neg(double *x);

Unlike C, this mapping does not directly modify the input value.
Rather, the modified input value shows up as the return value of the
function.  Thus, to apply this function to a variable you might do
this :

       x = neg(x)

Note : previous versions of SWIG used the symbol 'BOTH' to mark
input/output arguments.   This is still supported, but will be slowly
phased out in future releases.

*/















































/*----------------------------------------------------------------------
  Front ends.
  
  use the following macros to define your own IN/OUTPUT/INOUT typemaps
  
  ------------------------------------------------------------------------*/
















]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg" [
/* ------------------------------------------------------------
 * Primitive type fragments and macros 
 * ------------------------------------------------------------ */

/*
  This file provide fragments and macros for the C/C++ primitive types. 

  The file defines default fragments for the following types:

    bool
    signed char
    unsigned char
    signed wchar_t     // in C++
    unsigned wchar_t   // in C++
    short
    unsigned short
    int
    unsigned int
    float
    size_t
    ptrdiff_t

  which can always be redefined in the swig target language if needed.
  
  The fragments for the following types, however, need to be defined
  in the target language always:

    long
    unsigned long
    long long
    unsigned long long
    double
 
  If they are not provided, an #error directive will appear in the
  wrapped code.

  --------------------------------------------------------------------
  
  This file provides the macro

    %typemaps_primitive(CheckCode, Type)

  which generate the typemaps for a primitive type with a given
  checkcode. It is assumed that the primitive type is 'normalized' and
  the corresponding SWIG_AsVal(Type) and SWIG_From(Type) methods are
  provided via fragments.
  
   
  The following auxiliary macros (explained with bash pseudo code) are
  also defined:

    %apply_ctypes(Macro)
      for i in C Type
      do
        Macro($i)
      done

    %apply_cpptypes(Macro)
      for i in C++ Type
      do
        Macro($i)
      done

    %apply_ctypes_2(Macro2)
       for i in C Type
       do
         for j in C Type
         do
            Macro_2($i, $j)
         done
       done

    %apply_cpptypes_2(Macro2)
       for i in C++ Type
       do
         for j in C++ Type
         do
            Macro_2($i, $j)
         done
       done

    %apply_checkctypes(Macro2)
       for i in Check Type
       do
         Macro2(%checkcode($i), $i)
       done

*/


/* ------------------------------------------------------------
 * Primitive type fragments 
 * ------------------------------------------------------------ */
/* boolean */

%fragment("SWIG_" "From" "_" {bool},"header",fragment="SWIG_" "From" "_" {long}) {
SWIGINTERN PyObject *
SWIG_From_bool  (bool value)
{    
  return SWIG_From_long  (value ? 1 : 0);
}
}

%fragment("SWIG_" "AsVal" "_" {bool},"header",fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_bool (PyObject * obj, bool *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res)) {    
    if (val) *val = v ? true : false;
    return res;
  }  
  return SWIG_TypeError;
}
}

/* signed/unsigned char */

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,422,%numeric_slong@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {signed char},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_signed_SS_char  (signed char value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {signed char},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_signed_SS_char (PyObject * obj, signed char *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SCHAR_MIN || v > SCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< signed char >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,429,%numeric_ulong@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned char},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_char  (unsigned char value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned char},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_char (PyObject * obj, unsigned char *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned char >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* short/unsigned short */

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,422,%numeric_slong@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {short},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_short  (short value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {short},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_short (PyObject * obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< short >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,429,%numeric_ulong@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned short},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned short},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (PyObject * obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned short >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* int/unsigned int */

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,422,%numeric_slong@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {int},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {int},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,429,%numeric_ulong@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned int},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned int},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* signed/unsigned wchar_t */


/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,422,%numeric_slong@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {signed wchar_t},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_signed_SS_wchar_t  (signed wchar_t value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {signed wchar_t},"header",
	  fragment="<wchar.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_signed_SS_wchar_t (PyObject * obj, signed wchar_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < WCHAR_MIN || v > WCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< signed wchar_t >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,429,%numeric_ulong@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned wchar_t},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_wchar_t  (unsigned wchar_t value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned wchar_t},"header",
	  fragment="<wchar.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_wchar_t (PyObject * obj, unsigned wchar_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UWCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned wchar_t >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/


/* float */

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,437,%numeric_double@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,381,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {float},"header",
	  fragment="SWIG_" "From" "_" {double}) {
SWIGINTERNINLINE PyObject *
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}
}
/*@SWIG@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,392,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {float},"header",
	  fragment="<float.h>",
	  fragment="SWIG_" "AsVal" "_" {double}) {
SWIGINTERN int
SWIG_AsVal_float (PyObject * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < -FLT_MAX || v > FLT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< float >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* long/unsigned long */

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,451,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {long},"header") {
#error "Swig language implementation must provide a SWIG_From_frag(long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {long},"header") {
#error "Swig language implementation must provide a SWIG_AsVal_frag(long) fragment"
}
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,451,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {unsigned long},"header") {
#error "Swig language implementation must provide a SWIG_From_frag(unsigned long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {unsigned long},"header") {
#error "Swig language implementation must provide a SWIG_AsVal_frag(unsigned long) fragment"
}
/*@SWIG@*/

/* long long/unsigned long long */

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,451,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {long long},"header") {
#error "Swig language implementation must provide a SWIG_From_frag(long long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {long long},"header") {
#error "Swig language implementation must provide a SWIG_AsVal_frag(long long) fragment"
}
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,451,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {unsigned long long},"header") {
#error "Swig language implementation must provide a SWIG_From_frag(unsigned long long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {unsigned long long},"header") {
#error "Swig language implementation must provide a SWIG_AsVal_frag(unsigned long long) fragment"
}
/*@SWIG@*/

/* double */

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,451,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {double},"header") {
#error "Swig language implementation must provide a SWIG_From_frag(double) fragment"
}
%fragment("SWIG_" "AsVal" "_" {double},"header") {
#error "Swig language implementation must provide a SWIG_AsVal_frag(double) fragment"
}
/*@SWIG@*/

/* size_t */

%fragment("SWIG_" "From" "_" {size_t},"header",fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}
}

%fragment("SWIG_" "AsVal" "_" {size_t},"header",fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  return res;
}
}

/* ptrdiff_t */

%fragment("SWIG_" "From" "_" {ptrdiff_t},"header",fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
  return SWIG_From_long  (static_cast< long >(value));
}
}

%fragment("SWIG_" "AsVal" "_" {ptrdiff_t},"header",fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  return res;
}
}


%fragment("SWIG_CanCastAsInteger","header",
	  fragment="SWIG_" "AsVal" "_" {double},
	  fragment="<float.h>",
	  fragment="<math.h>") {
SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}
}

/* ------------------------------------------------------------
 * Generate the typemaps for primitive type 
 * ------------------------------------------------------------ */



/* ------------------------------------------------------------
 * Primitive Type Macros
 * ------------------------------------------------------------ */

/* useful macros to derive typemap declarations from primitive types */









/* Apply macro to the C-types */




















/* apply the Macro2(Type1, Type2) to all  C types  */



/* apply the Macro(Type) to all  C++ types  */










/* apply the Macro2(Type1, Type2) to all  C++ types  */


/* apply the Macro2(CheckCode,Type) to all  Checked Types */





















/* ------------------------------------------------------------
 * Generate the typemaps for all the primitive types with checkcode
 * ------------------------------------------------------------ */

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,295,%apply_checkctypes@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool (bool val, int ecode = 0) {
    ecode = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) bool "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) const bool & ($*ltype temp, bool val, int ecode = 0) {  
    ecode = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const bool& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {bool}) bool {
    bool val;
    int res = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool *DIRECTOROUT {
    bool swig_val;
    int swig_res = SWIG_AsVal_bool($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool {
    bool swig_val;
    int swig_res = SWIG_AsVal_bool($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const bool& {  
    bool swig_val;
    int swig_res = SWIG_AsVal_bool($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const bool & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {bool}) bool &DIRECTOROUT = bool
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=10000,fragment="SWIG_" "AsVal" "_" {bool}) bool, const bool& {
    int res = SWIG_AsVal_bool($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      bool val; 
      int ecode = SWIG_AsVal_bool($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      bool val;
      int ecode = SWIG_AsVal_bool($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") bool *INPUT, bool &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=10000,fragment="SWIG_" "AsVal" "_" {bool}) bool *INPUT, bool &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_bool($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool {
    $result = SWIG_From_bool(static_cast< bool >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {bool}) const bool& {
    $result = SWIG_From_bool(static_cast< bool >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool&  {
    $result = SWIG_From_bool(static_cast< bool >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_bool(static_cast< bool >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool *DIRECTORIN {
    $input = SWIG_From_bool(static_cast< bool >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool& {
    $input = SWIG_From_bool(static_cast< bool >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool {
    SWIG_Python_Raise(SWIG_From_bool(static_cast< bool >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   bool *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   bool &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool *OUTPUT, bool &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_bool((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) bool *INOUT = bool *INPUT;
 %typemap(in) bool &INOUT = bool &INPUT;
 %typemap(typecheck) bool *INOUT = bool *INPUT;
 %typemap(typecheck) bool &INOUT = bool &INPUT;
 %typemap(argout) bool *INOUT = bool *OUTPUT;
 %typemap(argout) bool &INOUT = bool &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char (signed char val, int ecode = 0) {
    ecode = SWIG_AsVal_signed_SS_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) signed char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) const signed char & ($*ltype temp, signed char val, int ecode = 0) {  
    ecode = SWIG_AsVal_signed_SS_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const signed char& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {signed char}) signed char {
    signed char val;
    int res = SWIG_AsVal_signed_SS_char($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *DIRECTOROUT {
    signed char swig_val;
    int swig_res = SWIG_AsVal_signed_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char {
    signed char swig_val;
    int swig_res = SWIG_AsVal_signed_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const signed char& {  
    signed char swig_val;
    int swig_res = SWIG_AsVal_signed_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const signed char & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {signed char}) signed char &DIRECTOROUT = signed char
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=25,fragment="SWIG_" "AsVal" "_" {signed char}) signed char, const signed char& {
    int res = SWIG_AsVal_signed_SS_char($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      signed char val; 
      int ecode = SWIG_AsVal_signed_SS_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      signed char val;
      int ecode = SWIG_AsVal_signed_SS_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") signed char *INPUT, signed char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=25,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *INPUT, signed char &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_signed_SS_char($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char {
    $result = SWIG_From_signed_SS_char(static_cast< signed char >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {signed char}) const signed char& {
    $result = SWIG_From_signed_SS_char(static_cast< signed char >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char&  {
    $result = SWIG_From_signed_SS_char(static_cast< signed char >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_signed_SS_char(static_cast< signed char >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char *DIRECTORIN {
    $input = SWIG_From_signed_SS_char(static_cast< signed char >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char& {
    $input = SWIG_From_signed_SS_char(static_cast< signed char >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char {
    SWIG_Python_Raise(SWIG_From_signed_SS_char(static_cast< signed char >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   signed char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   signed char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char *OUTPUT, signed char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_signed_SS_char((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) signed char *INOUT = signed char *INPUT;
 %typemap(in) signed char &INOUT = signed char &INPUT;
 %typemap(typecheck) signed char *INOUT = signed char *INPUT;
 %typemap(typecheck) signed char &INOUT = signed char &INPUT;
 %typemap(argout) signed char *INOUT = signed char *OUTPUT;
 %typemap(argout) signed char &INOUT = signed char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char (unsigned char val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) const unsigned char & ($*ltype temp, unsigned char val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned char& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char {
    unsigned char val;
    int res = SWIG_AsVal_unsigned_SS_char($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *DIRECTOROUT {
    unsigned char swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char {
    unsigned char swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned char& {  
    unsigned char swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned char & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char &DIRECTOROUT = unsigned char
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=20,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char, const unsigned char& {
    int res = SWIG_AsVal_unsigned_SS_char($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned char val; 
      int ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned char val;
      int ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned char *INPUT, unsigned char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=20,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *INPUT, unsigned char &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_char($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char {
    $result = SWIG_From_unsigned_SS_char(static_cast< unsigned char >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) const unsigned char& {
    $result = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char&  {
    $result = SWIG_From_unsigned_SS_char(static_cast< unsigned char >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_char(static_cast< unsigned char >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char& {
    $input = SWIG_From_unsigned_SS_char(static_cast< unsigned char >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_char(static_cast< unsigned char >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char *OUTPUT, unsigned char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_char((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned char *INOUT = unsigned char *INPUT;
 %typemap(in) unsigned char &INOUT = unsigned char &INPUT;
 %typemap(typecheck) unsigned char *INOUT = unsigned char *INPUT;
 %typemap(typecheck) unsigned char &INOUT = unsigned char &INPUT;
 %typemap(argout) unsigned char *INOUT = unsigned char *OUTPUT;
 %typemap(argout) unsigned char &INOUT = unsigned char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short (short val, int ecode = 0) {
    ecode = SWIG_AsVal_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) short "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) const short & ($*ltype temp, short val, int ecode = 0) {  
    ecode = SWIG_AsVal_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const short& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {short}) short {
    short val;
    int res = SWIG_AsVal_short($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short *DIRECTOROUT {
    short swig_val;
    int swig_res = SWIG_AsVal_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short {
    short swig_val;
    int swig_res = SWIG_AsVal_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {short},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const short& {  
    short swig_val;
    int swig_res = SWIG_AsVal_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const short & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {short}) short &DIRECTOROUT = short
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=35,fragment="SWIG_" "AsVal" "_" {short}) short, const short& {
    int res = SWIG_AsVal_short($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      short val; 
      int ecode = SWIG_AsVal_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      short val;
      int ecode = SWIG_AsVal_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") short *INPUT, short &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=35,fragment="SWIG_" "AsVal" "_" {short}) short *INPUT, short &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_short($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short {
    $result = SWIG_From_short(static_cast< short >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {short}) const short& {
    $result = SWIG_From_short(static_cast< short >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short&  {
    $result = SWIG_From_short(static_cast< short >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {short}) short {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_short(static_cast< short >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {short}) short *DIRECTORIN {
    $input = SWIG_From_short(static_cast< short >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short& {
    $input = SWIG_From_short(static_cast< short >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {short}) short {
    SWIG_Python_Raise(SWIG_From_short(static_cast< short >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   short *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   short &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {short}) short *OUTPUT, short &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_short((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) short *INOUT = short *INPUT;
 %typemap(in) short &INOUT = short &INPUT;
 %typemap(typecheck) short *INOUT = short *INPUT;
 %typemap(typecheck) short &INOUT = short &INPUT;
 %typemap(argout) short *INOUT = short *OUTPUT;
 %typemap(argout) short &INOUT = short &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short (unsigned short val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned short "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) const unsigned short & ($*ltype temp, unsigned short val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned short& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short {
    unsigned short val;
    int res = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *DIRECTOROUT {
    unsigned short swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short {
    unsigned short swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned short& {  
    unsigned short swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned short & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short &DIRECTOROUT = unsigned short
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=30,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short, const unsigned short& {
    int res = SWIG_AsVal_unsigned_SS_short($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned short val; 
      int ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned short val;
      int ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned short *INPUT, unsigned short &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=30,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *INPUT, unsigned short &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_short($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short {
    $result = SWIG_From_unsigned_SS_short(static_cast< unsigned short >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) const unsigned short& {
    $result = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short&  {
    $result = SWIG_From_unsigned_SS_short(static_cast< unsigned short >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_short(static_cast< unsigned short >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short& {
    $input = SWIG_From_unsigned_SS_short(static_cast< unsigned short >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_short(static_cast< unsigned short >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned short *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned short &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short *OUTPUT, unsigned short &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_short((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned short *INOUT = unsigned short *INPUT;
 %typemap(in) unsigned short &INOUT = unsigned short &INPUT;
 %typemap(typecheck) unsigned short *INOUT = unsigned short *INPUT;
 %typemap(typecheck) unsigned short &INOUT = unsigned short &INPUT;
 %typemap(argout) unsigned short *INOUT = unsigned short *OUTPUT;
 %typemap(argout) unsigned short &INOUT = unsigned short &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int (int val, int ecode = 0) {
    ecode = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) int "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) const int & ($*ltype temp, int val, int ecode = 0) {  
    ecode = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const int& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {int}) int {
    int val;
    int res = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int *DIRECTOROUT {
    int swig_val;
    int swig_res = SWIG_AsVal_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int {
    int swig_val;
    int swig_res = SWIG_AsVal_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {int},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const int& {  
    int swig_val;
    int swig_res = SWIG_AsVal_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const int & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {int}) int &DIRECTOROUT = int
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=45,fragment="SWIG_" "AsVal" "_" {int}) int, const int& {
    int res = SWIG_AsVal_int($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      int val; 
      int ecode = SWIG_AsVal_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      int val;
      int ecode = SWIG_AsVal_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") int *INPUT, int &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=45,fragment="SWIG_" "AsVal" "_" {int}) int *INPUT, int &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_int($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int {
    $result = SWIG_From_int(static_cast< int >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {int}) const int& {
    $result = SWIG_From_int(static_cast< int >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int&  {
    $result = SWIG_From_int(static_cast< int >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {int}) int {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_int(static_cast< int >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {int}) int *DIRECTORIN {
    $input = SWIG_From_int(static_cast< int >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int& {
    $input = SWIG_From_int(static_cast< int >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {int}) int {
    SWIG_Python_Raise(SWIG_From_int(static_cast< int >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   int *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   int &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {int}) int *OUTPUT, int &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_int((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) int *INOUT = int *INPUT;
 %typemap(in) int &INOUT = int &INPUT;
 %typemap(typecheck) int *INOUT = int *INPUT;
 %typemap(typecheck) int &INOUT = int &INPUT;
 %typemap(argout) int *INOUT = int *OUTPUT;
 %typemap(argout) int &INOUT = int &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int (unsigned int val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned int "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) const unsigned int & ($*ltype temp, unsigned int val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned int& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int {
    unsigned int val;
    int res = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *DIRECTOROUT {
    unsigned int swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int {
    unsigned int swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned int& {  
    unsigned int swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned int & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int &DIRECTOROUT = unsigned int
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=40,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int, const unsigned int& {
    int res = SWIG_AsVal_unsigned_SS_int($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned int val; 
      int ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned int val;
      int ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned int *INPUT, unsigned int &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=40,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *INPUT, unsigned int &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_int($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int {
    $result = SWIG_From_unsigned_SS_int(static_cast< unsigned int >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) const unsigned int& {
    $result = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int&  {
    $result = SWIG_From_unsigned_SS_int(static_cast< unsigned int >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_int(static_cast< unsigned int >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int& {
    $input = SWIG_From_unsigned_SS_int(static_cast< unsigned int >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_int(static_cast< unsigned int >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned int *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned int &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int *OUTPUT, unsigned int &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_int((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned int *INOUT = unsigned int *INPUT;
 %typemap(in) unsigned int &INOUT = unsigned int &INPUT;
 %typemap(typecheck) unsigned int *INOUT = unsigned int *INPUT;
 %typemap(typecheck) unsigned int &INOUT = unsigned int &INPUT;
 %typemap(argout) unsigned int *INOUT = unsigned int *OUTPUT;
 %typemap(argout) unsigned int &INOUT = unsigned int &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long (long val, int ecode = 0) {
    ecode = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) const long & ($*ltype temp, long val, int ecode = 0) {  
    ecode = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const long& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {long}) long {
    long val;
    int res = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long *DIRECTOROUT {
    long swig_val;
    int swig_res = SWIG_AsVal_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long {
    long swig_val;
    int swig_res = SWIG_AsVal_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const long& {  
    long swig_val;
    int swig_res = SWIG_AsVal_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const long & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {long}) long &DIRECTOROUT = long
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=55,fragment="SWIG_" "AsVal" "_" {long}) long, const long& {
    int res = SWIG_AsVal_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      long val; 
      int ecode = SWIG_AsVal_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      long val;
      int ecode = SWIG_AsVal_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") long *INPUT, long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=55,fragment="SWIG_" "AsVal" "_" {long}) long *INPUT, long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long {
    $result = SWIG_From_long(static_cast< long >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long}) const long& {
    $result = SWIG_From_long(static_cast< long >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long&  {
    $result = SWIG_From_long(static_cast< long >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {long}) long {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_long(static_cast< long >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long}) long *DIRECTORIN {
    $input = SWIG_From_long(static_cast< long >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long& {
    $input = SWIG_From_long(static_cast< long >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {long}) long {
    SWIG_Python_Raise(SWIG_From_long(static_cast< long >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {long}) long *OUTPUT, long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_long((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) long *INOUT = long *INPUT;
 %typemap(in) long &INOUT = long &INPUT;
 %typemap(typecheck) long *INOUT = long *INPUT;
 %typemap(typecheck) long &INOUT = long &INPUT;
 %typemap(argout) long *INOUT = long *OUTPUT;
 %typemap(argout) long &INOUT = long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long (unsigned long val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) const unsigned long & ($*ltype temp, unsigned long val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned long& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long {
    unsigned long val;
    int res = SWIG_AsVal_unsigned_SS_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *DIRECTOROUT {
    unsigned long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long {
    unsigned long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned long& {  
    unsigned long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned long & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long &DIRECTOROUT = unsigned long
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=50,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long, const unsigned long& {
    int res = SWIG_AsVal_unsigned_SS_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned long val; 
      int ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned long val;
      int ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned long *INPUT, unsigned long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=50,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *INPUT, unsigned long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long {
    $result = SWIG_From_unsigned_SS_long(static_cast< unsigned long >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) const unsigned long& {
    $result = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long&  {
    $result = SWIG_From_unsigned_SS_long(static_cast< unsigned long >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_long(static_cast< unsigned long >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long& {
    $input = SWIG_From_unsigned_SS_long(static_cast< unsigned long >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_long(static_cast< unsigned long >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long *OUTPUT, unsigned long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_long((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned long *INOUT = unsigned long *INPUT;
 %typemap(in) unsigned long &INOUT = unsigned long &INPUT;
 %typemap(typecheck) unsigned long *INOUT = unsigned long *INPUT;
 %typemap(typecheck) unsigned long &INOUT = unsigned long &INPUT;
 %typemap(argout) unsigned long *INOUT = unsigned long *OUTPUT;
 %typemap(argout) unsigned long &INOUT = unsigned long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long (long long val, int ecode = 0) {
    ecode = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) long long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) const long long & ($*ltype temp, long long val, int ecode = 0) {  
    ecode = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const long long& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {long long}) long long {
    long long val;
    int res = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long *DIRECTOROUT {
    long long swig_val;
    int swig_res = SWIG_AsVal_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long {
    long long swig_val;
    int swig_res = SWIG_AsVal_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const long long& {  
    long long swig_val;
    int swig_res = SWIG_AsVal_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const long long & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {long long}) long long &DIRECTOROUT = long long
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=65,fragment="SWIG_" "AsVal" "_" {long long}) long long, const long long& {
    int res = SWIG_AsVal_long_SS_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      long long val; 
      int ecode = SWIG_AsVal_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      long long val;
      int ecode = SWIG_AsVal_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") long long *INPUT, long long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=65,fragment="SWIG_" "AsVal" "_" {long long}) long long *INPUT, long long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_long_SS_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long {
    $result = SWIG_From_long_SS_long(static_cast< long long >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long long}) const long long& {
    $result = SWIG_From_long_SS_long(static_cast< long long >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long&  {
    $result = SWIG_From_long_SS_long(static_cast< long long >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_long_SS_long(static_cast< long long >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long *DIRECTORIN {
    $input = SWIG_From_long_SS_long(static_cast< long long >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long& {
    $input = SWIG_From_long_SS_long(static_cast< long long >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long {
    SWIG_Python_Raise(SWIG_From_long_SS_long(static_cast< long long >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   long long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   long long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long *OUTPUT, long long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_long_SS_long((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) long long *INOUT = long long *INPUT;
 %typemap(in) long long &INOUT = long long &INPUT;
 %typemap(typecheck) long long *INOUT = long long *INPUT;
 %typemap(typecheck) long long &INOUT = long long &INPUT;
 %typemap(argout) long long *INOUT = long long *OUTPUT;
 %typemap(argout) long long &INOUT = long long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long (unsigned long long val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned long long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) const unsigned long long & ($*ltype temp, unsigned long long val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned long long& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long {
    unsigned long long val;
    int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *DIRECTOROUT {
    unsigned long long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long {
    unsigned long long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned long long& {  
    unsigned long long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned long long & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long &DIRECTOROUT = unsigned long long
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=60,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long, const unsigned long long& {
    int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned long long val; 
      int ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned long long val;
      int ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned long long *INPUT, unsigned long long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=60,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *INPUT, unsigned long long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long {
    $result = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) const unsigned long long& {
    $result = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long&  {
    $result = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long& {
    $input = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned long long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned long long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long *OUTPUT, unsigned long long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_long_SS_long((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned long long *INOUT = unsigned long long *INPUT;
 %typemap(in) unsigned long long &INOUT = unsigned long long &INPUT;
 %typemap(typecheck) unsigned long long *INOUT = unsigned long long *INPUT;
 %typemap(typecheck) unsigned long long &INOUT = unsigned long long &INPUT;
 %typemap(argout) unsigned long long *INOUT = unsigned long long *OUTPUT;
 %typemap(argout) unsigned long long &INOUT = unsigned long long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float (float val, int ecode = 0) {
    ecode = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) float "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) const float & ($*ltype temp, float val, int ecode = 0) {  
    ecode = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const float& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {float}) float {
    float val;
    int res = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float *DIRECTOROUT {
    float swig_val;
    int swig_res = SWIG_AsVal_float($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float {
    float swig_val;
    int swig_res = SWIG_AsVal_float($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {float},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const float& {  
    float swig_val;
    int swig_res = SWIG_AsVal_float($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const float & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {float}) float &DIRECTOROUT = float
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=80,fragment="SWIG_" "AsVal" "_" {float}) float, const float& {
    int res = SWIG_AsVal_float($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      float val; 
      int ecode = SWIG_AsVal_float($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      float val;
      int ecode = SWIG_AsVal_float($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") float *INPUT, float &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=80,fragment="SWIG_" "AsVal" "_" {float}) float *INPUT, float &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_float($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float {
    $result = SWIG_From_float(static_cast< float >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {float}) const float& {
    $result = SWIG_From_float(static_cast< float >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float&  {
    $result = SWIG_From_float(static_cast< float >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {float}) float {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_float(static_cast< float >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {float}) float *DIRECTORIN {
    $input = SWIG_From_float(static_cast< float >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float& {
    $input = SWIG_From_float(static_cast< float >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {float}) float {
    SWIG_Python_Raise(SWIG_From_float(static_cast< float >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   float *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   float &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {float}) float *OUTPUT, float &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_float((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) float *INOUT = float *INPUT;
 %typemap(in) float &INOUT = float &INPUT;
 %typemap(typecheck) float *INOUT = float *INPUT;
 %typemap(typecheck) float &INOUT = float &INPUT;
 %typemap(argout) float *INOUT = float *OUTPUT;
 %typemap(argout) float &INOUT = float &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double (double val, int ecode = 0) {
    ecode = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) double "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) const double & ($*ltype temp, double val, int ecode = 0) {  
    ecode = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const double& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {double}) double {
    double val;
    int res = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double *DIRECTOROUT {
    double swig_val;
    int swig_res = SWIG_AsVal_double($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double {
    double swig_val;
    int swig_res = SWIG_AsVal_double($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {double},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const double& {  
    double swig_val;
    int swig_res = SWIG_AsVal_double($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const double & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {double}) double &DIRECTOROUT = double
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=90,fragment="SWIG_" "AsVal" "_" {double}) double, const double& {
    int res = SWIG_AsVal_double($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      double val; 
      int ecode = SWIG_AsVal_double($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      double val;
      int ecode = SWIG_AsVal_double($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") double *INPUT, double &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=90,fragment="SWIG_" "AsVal" "_" {double}) double *INPUT, double &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_double($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double {
    $result = SWIG_From_double(static_cast< double >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {double}) const double& {
    $result = SWIG_From_double(static_cast< double >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double&  {
    $result = SWIG_From_double(static_cast< double >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {double}) double {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_double(static_cast< double >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {double}) double *DIRECTORIN {
    $input = SWIG_From_double(static_cast< double >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double& {
    $input = SWIG_From_double(static_cast< double >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {double}) double {
    SWIG_Python_Raise(SWIG_From_double(static_cast< double >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   double *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   double &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {double}) double *OUTPUT, double &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_double((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) double *INOUT = double *INPUT;
 %typemap(in) double &INOUT = double &INPUT;
 %typemap(typecheck) double *INOUT = double *INPUT;
 %typemap(typecheck) double &INOUT = double &INPUT;
 %typemap(argout) double *INOUT = double *OUTPUT;
 %typemap(argout) double &INOUT = double &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char (char val, int ecode = 0) {
    ecode = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) const char & ($*ltype temp, char val, int ecode = 0) {  
    ecode = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const char& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {char}) char {
    char val;
    int res = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *DIRECTOROUT {
    char swig_val;
    int swig_res = SWIG_AsVal_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char {
    char swig_val;
    int swig_res = SWIG_AsVal_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const char& {  
    char swig_val;
    int swig_res = SWIG_AsVal_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const char & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {char}) char &DIRECTOROUT = char
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char, const char& {
    int res = SWIG_AsVal_char($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      char val; 
      int ecode = SWIG_AsVal_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      char val;
      int ecode = SWIG_AsVal_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") char *INPUT, char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT, char &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_char($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char {
    $result = SWIG_From_char(static_cast< char >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) const char& {
    $result = SWIG_From_char(static_cast< char >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char&  {
    $result = SWIG_From_char(static_cast< char >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_char(static_cast< char >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {char}) char *DIRECTORIN {
    $input = SWIG_From_char(static_cast< char >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char& {
    $input = SWIG_From_char(static_cast< char >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
    SWIG_Python_Raise(SWIG_From_char(static_cast< char >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {char}) char *OUTPUT, char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_char((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) char *INOUT = char *INPUT;
 %typemap(in) char &INOUT = char &INPUT;
 %typemap(typecheck) char *INOUT = char *INPUT;
 %typemap(typecheck) char &INOUT = char &INPUT;
 %typemap(argout) char *INOUT = char *OUTPUT;
 %typemap(argout) char &INOUT = char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t (wchar_t val, int ecode = 0) {
    ecode = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) wchar_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) const wchar_t & ($*ltype temp, wchar_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const wchar_t& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t {
    wchar_t val;
    int res = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *DIRECTOROUT {
    wchar_t swig_val;
    int swig_res = SWIG_AsVal_wchar_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t {
    wchar_t swig_val;
    int swig_res = SWIG_AsVal_wchar_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const wchar_t& {  
    wchar_t swig_val;
    int swig_res = SWIG_AsVal_wchar_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const wchar_t & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t &DIRECTOROUT = wchar_t
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=110,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t, const wchar_t& {
    int res = SWIG_AsVal_wchar_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      wchar_t val; 
      int ecode = SWIG_AsVal_wchar_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      wchar_t val;
      int ecode = SWIG_AsVal_wchar_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") wchar_t *INPUT, wchar_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=110,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *INPUT, wchar_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_wchar_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t {
    $result = SWIG_From_wchar_t(static_cast< wchar_t >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) const wchar_t& {
    $result = SWIG_From_wchar_t(static_cast< wchar_t >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t&  {
    $result = SWIG_From_wchar_t(static_cast< wchar_t >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_wchar_t(static_cast< wchar_t >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t *DIRECTORIN {
    $input = SWIG_From_wchar_t(static_cast< wchar_t >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t& {
    $input = SWIG_From_wchar_t(static_cast< wchar_t >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t {
    SWIG_Python_Raise(SWIG_From_wchar_t(static_cast< wchar_t >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   wchar_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   wchar_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t *OUTPUT, wchar_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_wchar_t((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) wchar_t *INOUT = wchar_t *INPUT;
 %typemap(in) wchar_t &INOUT = wchar_t &INPUT;
 %typemap(typecheck) wchar_t *INOUT = wchar_t *INPUT;
 %typemap(typecheck) wchar_t &INOUT = wchar_t &INPUT;
 %typemap(argout) wchar_t *INOUT = wchar_t *OUTPUT;
 %typemap(argout) wchar_t &INOUT = wchar_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t (size_t val, int ecode = 0) {
    ecode = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) size_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) const size_t & ($*ltype temp, size_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const size_t& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {size_t}) size_t {
    size_t val;
    int res = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *DIRECTOROUT {
    size_t swig_val;
    int swig_res = SWIG_AsVal_size_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t {
    size_t swig_val;
    int swig_res = SWIG_AsVal_size_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const size_t& {  
    size_t swig_val;
    int swig_res = SWIG_AsVal_size_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const size_t & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {size_t}) size_t &DIRECTOROUT = size_t
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=47,fragment="SWIG_" "AsVal" "_" {size_t}) size_t, const size_t& {
    int res = SWIG_AsVal_size_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      size_t val; 
      int ecode = SWIG_AsVal_size_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      size_t val;
      int ecode = SWIG_AsVal_size_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") size_t *INPUT, size_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=47,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *INPUT, size_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_size_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t {
    $result = SWIG_From_size_t(static_cast< size_t >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {size_t}) const size_t& {
    $result = SWIG_From_size_t(static_cast< size_t >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t&  {
    $result = SWIG_From_size_t(static_cast< size_t >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_size_t(static_cast< size_t >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t *DIRECTORIN {
    $input = SWIG_From_size_t(static_cast< size_t >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t& {
    $input = SWIG_From_size_t(static_cast< size_t >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t {
    SWIG_Python_Raise(SWIG_From_size_t(static_cast< size_t >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   size_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   size_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t *OUTPUT, size_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_size_t((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) size_t *INOUT = size_t *INPUT;
 %typemap(in) size_t &INOUT = size_t &INPUT;
 %typemap(typecheck) size_t *INOUT = size_t *INPUT;
 %typemap(typecheck) size_t &INOUT = size_t &INPUT;
 %typemap(argout) size_t *INOUT = size_t *OUTPUT;
 %typemap(argout) size_t &INOUT = size_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t (ptrdiff_t val, int ecode = 0) {
    ecode = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) ptrdiff_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) const ptrdiff_t & ($*ltype temp, ptrdiff_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const ptrdiff_t& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t {
    ptrdiff_t val;
    int res = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *DIRECTOROUT {
    ptrdiff_t swig_val;
    int swig_res = SWIG_AsVal_ptrdiff_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t {
    ptrdiff_t swig_val;
    int swig_res = SWIG_AsVal_ptrdiff_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const ptrdiff_t& {  
    ptrdiff_t swig_val;
    int swig_res = SWIG_AsVal_ptrdiff_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const ptrdiff_t & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t &DIRECTOROUT = ptrdiff_t
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=48,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t& {
    int res = SWIG_AsVal_ptrdiff_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      ptrdiff_t val; 
      int ecode = SWIG_AsVal_ptrdiff_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      ptrdiff_t val;
      int ecode = SWIG_AsVal_ptrdiff_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") ptrdiff_t *INPUT, ptrdiff_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=48,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *INPUT, ptrdiff_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_ptrdiff_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t {
    $result = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) const ptrdiff_t& {
    $result = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t&  {
    $result = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t *DIRECTORIN {
    $input = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t& {
    $input = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t {
    SWIG_Python_Raise(SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   ptrdiff_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   ptrdiff_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t *OUTPUT, ptrdiff_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_ptrdiff_t((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) ptrdiff_t *INOUT = ptrdiff_t *INPUT;
 %typemap(in) ptrdiff_t &INOUT = ptrdiff_t &INPUT;
 %typemap(typecheck) ptrdiff_t *INOUT = ptrdiff_t *INPUT;
 %typemap(typecheck) ptrdiff_t &INOUT = ptrdiff_t &INPUT;
 %typemap(argout) ptrdiff_t *INOUT = ptrdiff_t *OUTPUT;
 %typemap(argout) ptrdiff_t &INOUT = ptrdiff_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;


]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\string.swg" [
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,445,%ensure_fragment@*/
%fragment("SWIG_AsCharPtrAndSize","header") {
#error "Swig language implementation must provide the SWIG_AsCharPtrAndSize fragment"
}
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\fragments.swg,445,%ensure_fragment@*/
%fragment("SWIG_FromCharPtrAndSize","header") {
#error "Swig language implementation must provide the SWIG_FromCharPtrAndSize fragment"
}
/*@SWIG@*/

%types(char *);

%fragment("SWIG_pchar_descriptor","header") {
SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}
}


%includefile "C:\\Programme\\swig\\Lib\\typemaps\\strings.swg" [
//
// Use the macro SWIG_PRESERVE_CARRAY_SIZE if you prefer to preserve
// the size of char arrays, ie
//  ------------------------------------------
//       C Side             =>   Language Side
//  ------------------------------------------
//   char name[5] = "hola"  =>   'hola\0'
//
// the default behaviour is 
//
//   char name[5] = "hola"  =>   'hola'
//
//
//#define SWIG_PRESERVE_CARRAY_SIZE

/* ------------------------------------------------------------
 *  String typemaps for type Char (char or wchar_t)
 * ------------------------------------------------------------ */


























































































































































































































































































































































































































































































/* ------------------------------------------------------------
 * --- String fragment methods ---
 * ------------------------------------------------------------ */




































































































]
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\strings.swg,498,%typemaps_string@*/
  
%fragment("SWIG_From""Char""Ptr","header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}
}

%fragment("SWIG_From""Char""Array","header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE PyObject * 
SWIG_FromCharArray(const char *cptr, size_t size)
{ 
  return SWIG_FromCharPtrAndSize(cptr, size);
}
}

%fragment("SWIG_As""Char" "Ptr","header",fragment="SWIG_AsCharPtrAndSize") {

}

%fragment("SWIG_As""Char" "Array","header",fragment="SWIG_AsCharPtrAndSize") {
SWIGINTERN int
SWIG_AsCharArray(PyObject * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}
}

/* char */

%fragment("SWIG_" "From" "_" {char},"header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE PyObject *
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}
}

%fragment("SWIG_" "AsVal" "_" {char},"header",
	  fragment="SWIG_As""Char""Array",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_char (PyObject * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}
}

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,209,%typemaps_asvalfromn@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char (char val, int ecode = 0) {
    ecode = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) const char & ($*ltype temp, char val, int ecode = 0) {  
    ecode = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const char& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {char}) char {
    char val;
    int res = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *DIRECTOROUT {
    char swig_val;
    int swig_res = SWIG_AsVal_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char {
    char swig_val;
    int swig_res = SWIG_AsVal_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const char& {  
    char swig_val;
    int swig_res = SWIG_AsVal_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const char & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {char}) char &DIRECTOROUT = char
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char, const char& {
    int res = SWIG_AsVal_char($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      char val; 
      int ecode = SWIG_AsVal_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      char val;
      int ecode = SWIG_AsVal_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") char *INPUT, char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT, char &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_char($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char {
    $result = SWIG_From_char(static_cast< char >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) const char& {
    $result = SWIG_From_char(static_cast< char >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char&  {
    $result = SWIG_From_char(static_cast< char >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_char(static_cast< char >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {char}) char *DIRECTORIN {
    $input = SWIG_From_char(static_cast< char >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char& {
    $input = SWIG_From_char(static_cast< char >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
    SWIG_Python_Raise(SWIG_From_char(static_cast< char >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {char}) char *OUTPUT, char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_char((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) char *INOUT = char *INPUT;
 %typemap(in) char &INOUT = char &INPUT;
 %typemap(typecheck) char *INOUT = char *INPUT;
 %typemap(typecheck) char &INOUT = char &INPUT;
 %typemap(argout) char *INOUT = char *OUTPUT;
 %typemap(argout) char &INOUT = char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\strings.swg,20,%_typemap_string@*/

/* in */

%typemap(in,noblock=1,fragment="SWIG_AsCharPtr") 
  char * (int res, char *buf = 0, int alloc = 0),
  const char * (int res, char *buf = 0, int alloc = 0) {
  res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = reinterpret_cast< $1_ltype >(buf);
}
%typemap(freearg,noblock=1,match="in") char *, const char * {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}

%typemap(in,noblock=1,fragment="SWIG_AsCharPtr") char const*& (int res, char *buf = 0, int alloc = 0) {
  res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = &buf;
}    
%typemap(freearg, noblock=1,match="in") char const*& {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}

/* out */

%typemap(out,noblock=1,fragment="SWIG_FromCharPtr") char *, const char* {
  $result = SWIG_FromCharPtr((const char *)$1);
}


%typemap(out,noblock=1,fragment="SWIG_FromCharPtr") char const*& {
  $result = SWIG_FromCharPtr(*$1);
}

%typemap(newfree,noblock=1) char * {
  delete[] $1;
}

/* varin */

%typemap(varin,fragment="SWIG_AsCharPtrAndSize") char * {
  char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
  int res = SWIG_AsCharPtrAndSize($input, &cptr, &csize, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if ($1) delete[] $1;
  if (alloc == SWIG_NEWOBJ) {
    $1 = cptr;
  } else {
    $1 = csize ? ($1_type)reinterpret_cast< char* >(memcpy((new char[csize]), cptr, sizeof(char)*(csize))) : 0;
  }
}

%typemap(varin,fragment="SWIG_AsCharPtrAndSize",warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
  int res = SWIG_AsCharPtrAndSize($input, &cptr, &csize, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (alloc == SWIG_NEWOBJ) {
    $1 = cptr;
  } else {
    $1 = csize ? ($1_type)reinterpret_cast< char* >(memcpy((new char[csize]), cptr, sizeof(char)*(csize))) : 0;
  }
}

/* varout */

%typemap(varout,noblock=1,fragment="SWIG_FromCharPtr") char*, const char* {
  $result = SWIG_FromCharPtr($1);
}

/* memberin */

%typemap(memberin,noblock=1) char * {
  if ($1) delete[] $1;
  if ($input) {
    size_t size = strlen(reinterpret_cast< const char * >($input)) + 1;
    $1 = ($1_type)reinterpret_cast< char* >(memcpy((new char[size]), reinterpret_cast< const char * >($input), sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

%typemap(memberin,noblock=1,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
    size_t size = strlen(reinterpret_cast< const char * >(reinterpret_cast< const char * >($input))) + 1;
    $1 = ($1_type)reinterpret_cast< char* >(memcpy((new char[size]), $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

/* globalin */

%typemap(globalin,noblock=1) char * {
  if ($1) delete[] $1;
  if ($input) {
    size_t size = strlen(reinterpret_cast< const char * >(reinterpret_cast< const char * >($input))) + 1;
    $1 = ($1_type)reinterpret_cast< char* >(memcpy((new char[size]), $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

%typemap(globalin,noblock=1,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
    size_t size = strlen($input) + 1;
    $1 = ($1_type)reinterpret_cast< char* >(memcpy((new char[size]), $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

/* constant */

%typemap(constcode,noblock=1,fragment="SWIG_FromCharPtr")
  char *, char const*, char * const, char const* const {
  SWIG_Python_SetConstant(d, "$symname",SWIG_FromCharPtr($value));
}




/* directorin */

%typemap(directorin,noblock=1,fragment="SWIG_FromCharPtr")
  char *, char const*, char *const, char const *const, 
  char const *&, char *const &, char const *const & {
  $input = SWIG_FromCharPtr((const char *)$1_name);
}


/* directorout */

%typemap(directorout,noblock=1,fragment="SWIG_AsCharPtr",warning= "473:Returning a pointer or reference in a director method is not recommended." )
  char * (int res, char* buf = 0, int alloc = SWIG_NEWOBJ) {
  res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
  if (!SWIG_IsOK(res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  if (alloc == SWIG_NEWOBJ) {
    swig_acquire_ownership_array(buf);
  }
  $result = reinterpret_cast< $1_ltype >(buf);
}
%typemap(directorfree,noblock=1) char *
{
  if (director) {
    director->swig_release_ownership(SWIG_as_voidptr($input));
  }
}


%typemap(directorout,noblock=1,fragment="SWIG_AsCharPtr",warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
  char * const& (int res, char* buf = 0, int alloc = SWIG_NEWOBJ),
  char const* const& (int res, char* buf = 0, int alloc = SWIG_NEWOBJ) { 
  res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
  if (!SWIG_IsOK(res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  static $*1_ltype tmp = buf;
  $result = &tmp;
  if (alloc == SWIG_NEWOBJ) {
    swig_acquire_ownership_array(buf);
  }
}
%typemap(directorfree,noblock=1)
  char * const&, char const* const& {
  if (director) {
    director->swig_release_ownership(SWIG_as_voidptr(*$input));
  }
}



/* typecheck */

%typemap(typecheck,noblock=1,precedence=140,
	 fragment="SWIG_AsCharPtr") char *, char const*& {
  int res = SWIG_AsCharPtrAndSize($input, 0, NULL, 0);
  $1 = SWIG_CheckState(res);
}


/* throws */

%typemap(throws,noblock=1,fragment="SWIG_FromCharPtr") char * {
  SWIG_Python_Raise(SWIG_FromCharPtr($1), "$type", 0); SWIG_fail;
}


/* ------------------------------------------------------------
 *  Unknown size const Character array char[ANY] handling
 * ------------------------------------------------------------ */

%apply char* { char [] };
%apply const char* { const char [] };

%typemap(varin,noblock=1,warning="462:Unable to set variable of type char []") char []
{
  SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only $name""' of type '""$type""'");
}


/* ------------------------------------------------------------
 *  Fixed size Character array char[ANY] handling
 * ------------------------------------------------------------ */

/*  memberin and globalin typemaps  */

%typemap(memberin,noblock=1) char [ANY]
{
  if ($input) memcpy($1,$input,$1_dim0*sizeof(char));
  else memset($1,0,$1_dim0*sizeof(char));
}

%typemap(globalin,noblock=1) char [ANY]
{
  if ($input) memcpy($1,$input,$1_dim0*sizeof(char));
  else memset($1,0,$1_dim0*sizeof(char));
}

/* in */

%typemap(in,noblock=1,fragment="SWIG_AsCharArray")
  char [ANY] (char temp[$1_dim0], int res), 
  const char [ANY](char temp[$1_dim0], int res)
{  
  res = SWIG_AsCharArray($input, temp, $1_dim0);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = reinterpret_cast< $1_ltype >(temp);
}
%typemap(freearg) char [ANY], const char [ANY] "";

%typemap(in,noblock=1,fragment="SWIG_AsCharArray") const char (&)[ANY] (char temp[$1_dim0], int res)
{  
  res = SWIG_AsCharArray($input, temp, $1_dim0);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = &temp;
}
%typemap(freearg) const char (&)[ANY] "";

%typemap(out,fragment="SWIG_FromCharPtrAndSize")
  char [ANY], const char[ANY] 
{
  size_t size = $1_dim0;

  while (size && ($1[size - 1] == '\0')) --size;

   $result = SWIG_FromCharPtrAndSize($1, size);
}

/* varin */

%typemap(varin,fragment="SWIG_AsCharArray") char [ANY]
{
  int res = SWIG_AsCharArray($input, $1, $1_dim0);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
}

/* varout */

%typemap(varout,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char [ANY], const char [ANY] {
  size_t size = $1_dim0;

  while (size && ($1[size - 1] == '\0')) --size;

  $result = SWIG_FromCharPtrAndSize($1, size);
}

/* constant */

%typemap(constcode,fragment="SWIG_FromCharPtrAndSize")
  char [ANY], const char [ANY]
{
  size_t size = $value_dim0;

  while (size && ($value[size - 1] == '\0')) --size;

  SWIG_Python_SetConstant(d, "$symname",SWIG_FromCharPtrAndSize($value,size));
}




/* directorin */
%typemap(directorin,fragment="SWIG_FromCharPtrAndSize")
  char [ANY], const char [ANY] 
{
  size_t size = $1_dim0;

  while (size && ($1_name[size - 1] == '\0')) --size;

  $input = SWIG_FromCharPtrAndSize($1_name, size);
}

/* directorout */

%typemap(directorout,noblock=1,fragment="SWIG_AsCharArray")
  char [ANY] (char temp[$result_dim0]),
  const char [ANY] (char temp[$result_dim0], int res)
{ 
  res = SWIG_AsCharArray($input, temp, $result_dim0);
  if (!SWIG_IsOK(res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  $result = temp;
}



/* typecheck */

%typemap(typecheck,noblock=1,precedence=140,
	 fragment="SWIG_AsCharArray")  
  char [ANY], const char[ANY] {
  int res = SWIG_AsCharArray($input, (char *)0, 0);
  $1 = SWIG_CheckState(res);
}


/* throws */

%typemap(throws,fragment="SWIG_FromCharPtrAndSize")
  char [ANY], const char[ANY]
{
  size_t size = $1_dim0;

  while (size && ($1[size - 1] == '\0')) --size;

  SWIG_Python_Raise(SWIG_FromCharPtrAndSize($1, size), "$type", 0); SWIG_fail; 
}

/* -------------------------------------------------------------------
 * --- Really fix size char arrays, including '\0'chars at the end ---
 * ------------------------------------------------------------------- */

%typemap(varout,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY]
{
  $result = SWIG_FromCharPtrAndSize($1, $1_dim0);
}

%typemap(out,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY]
{
  $result = SWIG_FromCharPtrAndSize($1, $1_dim0);
}



%typemap(directorin,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY]
{
  $input = SWIG_FromCharPtrAndSize($1_name, $1_dim0);
}



%typemap(throws,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY] {
  SWIG_Python_Raise(SWIG_FromCharPtrAndSize($1, $1_dim0), "$type", 0); SWIG_fail; 
}

/* ------------------------------------------------------------
 * --- String & length ---
 * ------------------------------------------------------------ */

/* Here len doesn't include the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize") 
  (char *STRING, size_t LENGTH) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (const char *STRING, size_t LENGTH) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }  
  $1 = reinterpret_cast< $1_ltype >(buf);
  $2 = static_cast< $2_ltype >(size - 1);
}
%typemap(freearg,noblock=1,match="in") (char *STRING, size_t LENGTH) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (char *STRING, int LENGTH) = (char *STRING, size_t LENGTH);
%typemap(freearg) (char *STRING, int LENGTH) = (char *STRING, size_t LENGTH);


/* Here size includes the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize")
  (char *STRING, size_t SIZE) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (const char *STRING, size_t SIZE) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = reinterpret_cast< $1_ltype >(buf);
  $2 = static_cast< $2_ltype >(size);
}
%typemap(freearg,noblock=1,match="in") (char *STRING, size_t SIZE) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (char *STRING, int SIZE) = (char *STRING, size_t SIZE);
%typemap(freearg) (char *STRING, int SIZE) = (char *STRING, size_t SIZE);


/* reverse order versions */

/* Here len doesn't include the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize") 
  (size_t LENGTH, char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (size_t LENGHT, const char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }  
  $2 = reinterpret_cast< $2_ltype >(buf) ;
  $1 = static_cast< $1_ltype >(size - 1) ;
}
%typemap(freearg, noblock=1, match="in") (size_t LENGTH, char *STRING) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (int LENGTH, char *STRING) = (size_t LENGTH, char *STRING);
%typemap(freearg) (int LENGTH, char *STRING) = (size_t LENGTH, char *STRING);

/* Here size includes the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize")
  (size_t SIZE, char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (size_t SIZE, const char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $2 = reinterpret_cast< $2_ltype >(buf) ;
  $1 = static_cast< $1_ltype >(size) ;
}
%typemap(freearg, noblock=1, match="in") (size_t SIZE, char *STRING) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (int SIZE, char *STRING) = (size_t SIZE, char *STRING);
%typemap(freearg) (int SIZE, char *STRING) = (size_t SIZE, char *STRING);


/*@SWIG@*/

/*@SWIG@*/

]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\misctypes.swg" [

/* ------------------------------------------------------------
 * --- ANSI/Posix C/C++ types ---
 * ------------------------------------------------------------ */




%apply size_t { std::size_t };
%apply const size_t& { const std::size_t& };

%apply ptrdiff_t { std::ptrdiff_t };
%apply const ptrdiff_t& { const std::ptrdiff_t& };


%apply size_t& { std::size_t& };
%apply ptrdiff_t& { std::ptrdiff_t& };





]
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\enumint.swg" [
/* ------------------------------------------------------------
 *  Enums mapped as integer values
 * ------------------------------------------------------------ */

%apply int { enum SWIGTYPE };
%apply const int& { const enum SWIGTYPE& };

%typemap(in,fragment="SWIG_" "AsVal" "_" {int},noblock=1) const enum SWIGTYPE& (int val, int ecode, $basetype temp) {  
  ecode = SWIG_AsVal_int ($input, &val);
  if (!SWIG_IsOK(ecode)) {
    SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  } else {
    temp = static_cast< $basetype >(val);
    $1 = &temp;
  }
}

%typemap(varin,fragment="SWIG_" "AsVal" "_" {int},noblock=1) enum SWIGTYPE {
  if (sizeof(int) != sizeof($1)) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""arch, read-only $name""' of type '""$type""'");
  }  else {
    int ecode = SWIG_AsVal_int ($input, reinterpret_cast< int* >(&$1));
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in variable '""$name""' of type '""$type""'");
    }
  }
}


]



]


/*  ------------------------------------------------------------
 *  Python extra typemaps
 * ------------------------------------------------------------ */

/* Get the address of the 'python self' object */

%typemap(in,numinputs=0,noblock=1) PyObject **PYTHON_SELF {
  $1 = &$self;
}


/* Consttab, needed for callbacks, it should be removed later */

%typemap(consttab) SWIGTYPE ((*)(ANY))  
{ SWIG_PY_POINTER, (char*)"$symname", 0, 0, (void *)($value), &$descriptor }

%typemap(constcode) SWIGTYPE ((*)(ANY)) "";


/* Smart Pointers */
%typemap(out,noblock=1) const SWIGTYPE & SMARTPOINTER  {
  $result = SWIG_NewPointerObj((new $*ltype(static_cast< const $*ltype& >(*$1))), $descriptor, SWIG_POINTER_OWN |  0 );
}

%typemap(ret,noblock=1) const SWIGTYPE & SMARTPOINTER, SWIGTYPE SMARTPOINTER {
  if ($result) {
    PyObject *robj = PyObject_CallMethod($result, (char *)"__deref__", NULL);
    if (robj && !PyErr_Occurred()) {
      SwigPyObject_append((PyObject *) SWIG_Python_GetSwigThis($result), 
			  (PyObject *) SWIG_Python_GetSwigThis(robj));
      Py_DECREF(robj);
    }
  }
}



]

/* ------------------------------------------------------------
 *  Overloaded operator support
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pyopers.swg" [
/* ------------------------------------------------------------
 * Overloaded operator support
 * ------------------------------------------------------------ */






%rename(__add__) *::operator+; %feature("python:maybecall", "1") *::operator+;
%rename(__pos__) *::operator+(); %feature("python:maybecall", "1") *::operator+();
%rename(__pos__) *::operator+() const; %feature("python:maybecall", "1") *::operator+() const;
%rename(__sub__) *::operator-; %feature("python:maybecall", "1") *::operator-;
%rename(__neg__) *::operator-(); %feature("python:maybecall", "1") *::operator-();
%rename(__neg__) *::operator-() const; %feature("python:maybecall", "1") *::operator-() const;
%rename(__mul__) *::operator*; %feature("python:maybecall", "1") *::operator*;
%rename(__div__) *::operator/; %feature("python:maybecall", "1") *::operator/;
%rename(__mod__) *::operator%; %feature("python:maybecall", "1") *::operator%;
%rename(__lshift__) *::operator<<; %feature("python:maybecall", "1") *::operator<<;
%rename(__rshift__) *::operator>>; %feature("python:maybecall", "1") *::operator>>;
%rename(__and__) *::operator&; %feature("python:maybecall", "1") *::operator&;
%rename(__or__) *::operator|; %feature("python:maybecall", "1") *::operator|;
%rename(__xor__) *::operator^; %feature("python:maybecall", "1") *::operator^;
%rename(__lt__) *::operator<; %feature("python:maybecall", "1") *::operator<;
%rename(__le__) *::operator<=; %feature("python:maybecall", "1") *::operator<=;
%rename(__gt__) *::operator>; %feature("python:maybecall", "1") *::operator>;
%rename(__ge__) *::operator>=; %feature("python:maybecall", "1") *::operator>=;
%rename(__eq__) *::operator==; %feature("python:maybecall", "1") *::operator==;
%rename(__ne__) *::operator!=; %feature("python:maybecall", "1") *::operator!=;



/* Special cases */
%rename(__invert__)     *::operator~;
%rename(__call__)       *::operator();

%feature("shadow")      *::operator bool %{
def __nonzero__(self):
    return $action(self)
__bool__ = __nonzero__
%};
%rename(__nonzero__)    *::operator bool;

/* Ignored operators */
%rename("$ignore:"       "361:operator! ignored"  )       operator!;
%rename("$ignore:"       "381:operator&& ignored"  )       operator&&;
%rename("$ignore:"        "382:operator|| ignored"  )        operator||;
%rename("$ignore:"         "362:operator= ignored"  )         *::operator=;
%rename("$ignore:"   "383:operator++ ignored"  )   *::operator++;
%rename("$ignore:" "384:operator-- ignored"  ) *::operator--;
%rename("$ignore:"  "386:operator->* ignored"  )  *::operator->*;
%rename("$ignore:"      "389:operator[] ignored (consider using %%extend)"  )      *::operator[];

/*
  Inplace operator declarations.

  They translate the inplace C++ operators (+=, -=, ...)  into the
  corresponding python equivalents(__iadd__,__isub__), etc,
  disabling the ownership of the input 'self' pointer, and assigning
  it to the returning object:  

     %feature("del") *::Operator;
     %feature("new") *::Operator;
  
  This makes the most common case safe, ie:

     A&  A::operator+=(int i) { ...; return *this; }
    ^^^^                                    ^^^^^^

  will work fine, even when the resulting python object shares the
  'this' pointer with the input one. The input object is usually
  deleted after the operation, including the shared 'this' pointer,
  producing 'strange' seg faults, as reported by Lucriz
  (lucriz@sitilandia.it).

  If you have an interface that already takes care of that, ie, you
  already are using inplace operators and you are not getting
  seg. faults, with the new scheme you could end with 'free' elements
  that never get deleted (maybe, not sure, it depends). But if that is
  the case, you could recover the old behaviour using

     %feature("del","") A::operator+=;
     %feature("new","") A::operator+=;

  which recovers the old behaviour for the class 'A', or if you are
  100% sure your entire system works fine in the old way, use:

    %feature("del","") *::operator+=;
    %feature("new","") *::operator+=;

*/



%feature("del") *::operator +=; %feature("new") *::operator +=; %rename(__iadd__) *::operator +=;
%feature("del") *::operator -=; %feature("new") *::operator -=; %rename(__isub__) *::operator -=;
%feature("del") *::operator *=; %feature("new") *::operator *=; %rename(__imul__) *::operator *=;
%feature("del") *::operator /=; %feature("new") *::operator /=; %rename(__idiv__) *::operator /=;
%feature("del") *::operator %=; %feature("new") *::operator %=; %rename(__imod__) *::operator %=;
%feature("del") *::operator &=; %feature("new") *::operator &=; %rename(__iand__) *::operator &=;
%feature("del") *::operator |=; %feature("new") *::operator |=; %rename(__ior__) *::operator |=;
%feature("del") *::operator ^=; %feature("new") *::operator ^=; %rename(__ixor__) *::operator ^=;
%feature("del") *::operator <<=; %feature("new") *::operator <<=; %rename(__ilshift__) *::operator <<=;
%feature("del") *::operator >>=; %feature("new") *::operator >>=; %rename(__irshift__) *::operator >>=;


/* Finally, in python we need to mark the binary operations to fail as
 'maybecall' methods */



%feature("python:maybecall", "1") __add__;  %feature("python:maybecall", "1") __radd__;
%feature("python:maybecall", "1") __pos__;  %feature("python:maybecall", "1") __rpos__;
%feature("python:maybecall", "1") __pos__;  %feature("python:maybecall", "1") __rpos__;
%feature("python:maybecall", "1") __sub__;  %feature("python:maybecall", "1") __rsub__;
%feature("python:maybecall", "1") __neg__;  %feature("python:maybecall", "1") __rneg__;
%feature("python:maybecall", "1") __neg__;  %feature("python:maybecall", "1") __rneg__;
%feature("python:maybecall", "1") __mul__;  %feature("python:maybecall", "1") __rmul__;
%feature("python:maybecall", "1") __div__;  %feature("python:maybecall", "1") __rdiv__;
%feature("python:maybecall", "1") __mod__;  %feature("python:maybecall", "1") __rmod__;
%feature("python:maybecall", "1") __lshift__;  %feature("python:maybecall", "1") __rlshift__;
%feature("python:maybecall", "1") __rshift__;  %feature("python:maybecall", "1") __rrshift__;
%feature("python:maybecall", "1") __and__;  %feature("python:maybecall", "1") __rand__;
%feature("python:maybecall", "1") __or__;  %feature("python:maybecall", "1") __ror__;
%feature("python:maybecall", "1") __xor__;  %feature("python:maybecall", "1") __rxor__;
%feature("python:maybecall", "1") __lt__;  %feature("python:maybecall", "1") __rlt__;
%feature("python:maybecall", "1") __le__;  %feature("python:maybecall", "1") __rle__;
%feature("python:maybecall", "1") __gt__;  %feature("python:maybecall", "1") __rgt__;
%feature("python:maybecall", "1") __ge__;  %feature("python:maybecall", "1") __rge__;
%feature("python:maybecall", "1") __eq__;  %feature("python:maybecall", "1") __req__;
%feature("python:maybecall", "1") __ne__;  %feature("python:maybecall", "1") __rne__;






]

/* ------------------------------------------------------------
 * Warnings for Python keywords 
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pythonkw.swg" [
/*
  Warnings for Python keywords, built-in names and bad names.
*/





/*
  Warnings for Python keywords 
  http://www.fnorb.org/docs/1.2/Fnorb-Guide/node62.html
*/

%namewarn("314"":""'" "and" "' is a python keyword, renaming to '_" "and" "'",rename="_%s")  "and";
%namewarn("314"":""'" "assert" "' is a python keyword, renaming to '_" "assert" "'",rename="_%s")  "assert";
%namewarn("314"":""'" "break" "' is a python keyword, renaming to '_" "break" "'",rename="_%s")  "break";
%namewarn("314"":""'" "class" "' is a python keyword, renaming to '_" "class" "'",rename="_%s")  "class";
%namewarn("314"":""'" "continue" "' is a python keyword, renaming to '_" "continue" "'",rename="_%s")  "continue";
%namewarn("314"":""'" "def" "' is a python keyword, renaming to '_" "def" "'",rename="_%s")  "def";
%namewarn("314"":""'" "del" "' is a python keyword, renaming to '_" "del" "'",rename="_%s")  "del";
%namewarn("314"":""'" "elif" "' is a python keyword, renaming to '_" "elif" "'",rename="_%s")  "elif";
%namewarn("314"":""'" "else" "' is a python keyword, renaming to '_" "else" "'",rename="_%s")  "else";
%namewarn("314"":""'" "except" "' is a python keyword, renaming to '_" "except" "'",rename="_%s")  "except";
%namewarn("314"":""'" "exec" "' is a python keyword, renaming to '_" "exec" "'",rename="_%s")  "exec";
%namewarn("314"":""'" "finally" "' is a python keyword, renaming to '_" "finally" "'",rename="_%s")  "finally";
%namewarn("314"":""'" "for" "' is a python keyword, renaming to '_" "for" "'",rename="_%s")  "for";
%namewarn("314"":""'" "from" "' is a python keyword, renaming to '_" "from" "'",rename="_%s")  "from";
%namewarn("314"":""'" "global" "' is a python keyword, renaming to '_" "global" "'",rename="_%s")  "global";
%namewarn("314"":""'" "if" "' is a python keyword, renaming to '_" "if" "'",rename="_%s")  "if";
%namewarn("314"":""'" "import" "' is a python keyword, renaming to '_" "import" "'",rename="_%s")  "import";
%namewarn("314"":""'" "in" "' is a python keyword, renaming to '_" "in" "'",rename="_%s")  "in";
%namewarn("314"":""'" "is" "' is a python keyword, renaming to '_" "is" "'",rename="_%s")  "is";
%namewarn("314"":""'" "lambda" "' is a python keyword, renaming to '_" "lambda" "'",rename="_%s")  "lambda";
%namewarn("314"":""'" "not" "' is a python keyword, renaming to '_" "not" "'",rename="_%s")  "not";
%namewarn("314"":""'" "or" "' is a python keyword, renaming to '_" "or" "'",rename="_%s")  "or";
%namewarn("314"":""'" "pass" "' is a python keyword, renaming to '_" "pass" "'",rename="_%s")  "pass";
%namewarn("314"":""'" "print" "' is a python keyword, renaming to '_" "print" "'",rename="_%s")  "print";
%namewarn("314"":""'" "raise" "' is a python keyword, renaming to '_" "raise" "'",rename="_%s")  "raise";
%namewarn("314"":""'" "return" "' is a python keyword, renaming to '_" "return" "'",rename="_%s")  "return";
%namewarn("314"":""'" "try" "' is a python keyword, renaming to '_" "try" "'",rename="_%s")  "try";
%namewarn("314"":""'" "while" "' is a python keyword, renaming to '_" "while" "'",rename="_%s")  "while";
%namewarn("314"":""'" "yield" "' is a python keyword, renaming to '_" "yield" "'",rename="_%s")  "yield";

/*
  built-in functions
  http://www.zvon.org/other/python/doc21/lib/built-in-funcs.html
 */ 

%namewarn("321"":""'" "abs" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""abs";
%namewarn("321"":""'" "apply" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""apply";
%namewarn("321"":""'" "bool" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""bool";
%namewarn("321"":""'" "buffer" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""buffer";
%namewarn("321"":""'" "callable" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""callable";
%namewarn("321"":""'" "chr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""chr";
%namewarn("321"":""'" "classmethod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""classmethod";
%namewarn("321"":""'" "cmp" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""cmp";
%namewarn("321"":""'" "coerce" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""coerce";
%namewarn("321"":""'" "compile" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""compile";
%namewarn("321"":""'" "complex" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""complex";
%namewarn("321"":""'" "delattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""delattr";
%namewarn("321"":""'" "dict" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""dict";
%namewarn("321"":""'" "dir" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""dir";
%namewarn("321"":""'" "divmod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""divmod";
%namewarn("321"":""'" "enumerate" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""enumerate";
%namewarn("321"":""'" "eval" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""eval";
%namewarn("321"":""'" "execfile" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""execfile";
%namewarn("321"":""'" "file" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""file";
%namewarn("321"":""'" "filter" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""filter";
%namewarn("321"":""'" "float" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""float";
%namewarn("321"":""'" "frozenset" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""frozenset";
%namewarn("321"":""'" "getattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""getattr";
%namewarn("321"":""'" "globals" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""globals";
%namewarn("321"":""'" "hasattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""hasattr";
%namewarn("321"":""'" "hash" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""hash";
%namewarn("321"":""'" "hex" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""hex";
%namewarn("321"":""'" "id" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""id";
%namewarn("321"":""'" "input" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""input";
%namewarn("321"":""'" "int" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""int";
%namewarn("321"":""'" "intern" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""intern";
%namewarn("321"":""'" "isinstance" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""isinstance";
%namewarn("321"":""'" "issubclass" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""issubclass";
%namewarn("321"":""'" "iter" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""iter";
%namewarn("321"":""'" "len" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""len";
%namewarn("321"":""'" "list" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""list";
%namewarn("321"":""'" "locals" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""locals";
%namewarn("321"":""'" "long" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""long";
%namewarn("321"":""'" "map" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""map";
%namewarn("321"":""'" "max" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""max";
%namewarn("321"":""'" "min" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""min";
%namewarn("321"":""'" "object" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""object";
%namewarn("321"":""'" "oct" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""oct";
%namewarn("321"":""'" "open" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""open";
%namewarn("321"":""'" "ord" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""ord";
%namewarn("321"":""'" "pow" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""pow";
%namewarn("321"":""'" "property" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""property";
%namewarn("321"":""'" "range" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""range";
%namewarn("321"":""'" "raw_input" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""raw_input";
%namewarn("321"":""'" "reduce" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""reduce";
%namewarn("321"":""'" "reload" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""reload";
%namewarn("321"":""'" "repr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""repr";
%namewarn("321"":""'" "reversed" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""reversed";
%namewarn("321"":""'" "round" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""round";
%namewarn("321"":""'" "set" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""set";
%namewarn("321"":""'" "setattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""setattr";
%namewarn("321"":""'" "slice" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""slice";
%namewarn("321"":""'" "sorted" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""sorted";
%namewarn("321"":""'" "staticmethod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""staticmethod";
%namewarn("321"":""'" "staticmethod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""staticmethod";
%namewarn("321"":""'" "str" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""str";
%namewarn("321"":""'" "sum" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""sum";
%namewarn("321"":""'" "super" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""super";
%namewarn("321"":""'" "tuple" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""tuple";
%namewarn("321"":""'" "type" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""type";
%namewarn("321"":""'" "unichr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""unichr";
%namewarn("321"":""'" "unicode" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""unicode";
%namewarn("321"":""'" "vars" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""vars";
%namewarn("321"":""'" "xrange" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""xrange";
%namewarn("321"":""'" "zip" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""zip";


/* 
   built-in names
   boolean type and None
*/
%namewarn("321"":""'" "True" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""True";
%namewarn("321"":""'" "False" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""False";
%namewarn("321"":""'" "None" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""None";


/* 
   'self' is also a bad Name
*/
%namewarn("321"":""'" "self" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "::""self";




]

/* ------------------------------------------------------------
 * The Python autodoc support
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pydocs.swg" [

// basic doc for primitive types....







%typemap(doc) SWIGTYPE "$1_name: $1_type value";
%typemap(doc) SWIGTYPE* "$1_name: $1_type value";
%typemap(doc) const SWIGTYPE& "$1_name: $1_type value";
%typemap(doc) enum SWIGTYPE "$1_name: enum $1_type value";

%typemap(doc) SWIGTYPE *INOUT "$1_name: $1_type input/ouput value";
%typemap(doc) SWIGTYPE *INPUT "$1_name: $1_type input value";
%typemap(doc) SWIGTYPE *OUTPUT "$1_name: $1_type output value";


]

/* ------------------------------------------------------------
 * The Python classes, for C++
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pyclasses.swg" [


/*
  SwigPtr_PyObject is used as a replacement of PyObject *, where
  the INCREF/DECREF are applied as needed.

  You can use SwigPtr_PyObject in a container, such as
  
     std::vector<SwigPtr_PyObject>;

  or as a member variable:
  
     struct A {
       SwigPtr_PyObject obj;
       A(PyObject *o) : _obj(o) {
       }
     };

   or as a input/output value 

     SwigPtr_PyObject func(SwigPtr_PyObject obj) {     
       SwigPtr_PyObject out = PyString_FromFormat("hello %s", PyObject_AsString(obj));
       Py_DECREF(out);
       return out;
     }

   just remember to pair the object creation with the proper DECREF,
   the same as with plain PyObject *ptr, since SwigPtr_PyObject always add
   one reference at construction.

   SwigPtr_PyObject is 'visible' at the wrapped side, so you can do:


      %template(pyvector) std::vector<swig::SwigPtr_PyObject>;

   and all the proper typemaps will be used.
   
*/

namespace swig {
  %rename($ignore) SwigPtr_PyObject;
  struct SwigPtr_PyObject {};
  %apply PyObject * {SwigPtr_PyObject};
  %apply PyObject * const& {SwigPtr_PyObject const&};

  /* For output */
  %typemap(out,noblock=1)  SwigPtr_PyObject {
    $result = (PyObject *)$1;
    Py_INCREF($result);
  }
  
  %typemap(out,noblock=1)  SwigPtr_PyObject const & {
    $result = (PyObject *)*$1;
    Py_INCREF($result);
  }
  
}

%{
namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      Py_XINCREF(_obj);      
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        Py_XINCREF(_obj);
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      Py_XDECREF(_obj);
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}
%}

/*
  SwigVar_PyObject is used to manage 'in the scope' PyObject * variables,
  as in

  int func () {
    SwigVar_PyObject obj = PyString_FromString("hello");
  }

  ie, 'obj' is created and destructed in the same scope from
  a python object that carries at least one reference value.
  
  SwigVar_PyObject just take care of applying the proper Py_DECREF.

  Hence, this class is purely internal and not visible at the wrapped side.
 */
namespace swig {
  %rename($ignore) SwigVar_PyObject;
  struct SwigVar_PyObject {};
  %apply PyObject * {SwigVar_PyObject};
  %apply PyObject * const& {SwigVar_PyObject const&};
}

%{
namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}
%}




]

/* ------------------------------------------------------------
 * The Python initialization function 
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pyinit.swg" [
/* ------------------------------------------------------------
 * The start of the Python initialization function 
 * ------------------------------------------------------------ */

%insert(init) "swiginit.swg"

%insert("init") %{

#ifdef __cplusplus
extern "C" {
#endif

/* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
 
/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */
 
typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

SWIGINTERN PyObject *
swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_InternFromString("<Swig global variables>");
#else
  return PyString_FromString("<Swig global variables>");
#endif
}

SWIGINTERN PyObject *
swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
  PyObject *str = PyUnicode_InternFromString("(");
  PyObject *tail;
  PyObject *joined;
  swig_globalvar *var;
  for (var = v->vars; var; var=var->next) {
    tail = PyUnicode_FromString(var->name);
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
    if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
    }
  }
  tail = PyUnicode_InternFromString(")");
  joined = PyUnicode_Concat(str, tail);
  Py_DecRef(str);
  Py_DecRef(tail);
  str = joined;
#else
  PyObject *str = PyString_FromString("(");
  swig_globalvar *var;
  for (var = v->vars; var; var=var->next) {
    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
  }
  PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
  return str;
}

SWIGINTERN int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
  PyObject *str = swig_varlink_str(v);
  fprintf(fp,"Swig global variables ");
  fprintf(fp,"%s\n", SWIG_Python_str_AsChar(str));
  Py_DECREF(str);
  return 0;
}

SWIGINTERN void
swig_varlink_dealloc(swig_varlinkobject *v) {
  swig_globalvar *var = v->vars;
  while (var) {
    swig_globalvar *n = var->next;
    free(var->name);
    free(var);
    var = n;
  }
}

SWIGINTERN PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  PyObject *res = NULL;
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      res = (*var->get_attr)();
      break;
    }
    var = var->next;
  }
  if (res == NULL && !PyErr_Occurred()) {
    PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  }
  return res;
}

SWIGINTERN int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  int res = 1;
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      res = (*var->set_attr)(p);
      break;
    }
    var = var->next;
  }
  if (res == 1 && !PyErr_Occurred()) {
    PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  }
  return res;
}

SWIGINTERN PyTypeObject*
swig_varlink_type(void) {
  static char varlink__doc__[] = "Swig var link object";
  static PyTypeObject varlink_type;
  static int type_init = 0;  
  if (!type_init) {
    const PyTypeObject tmp
      = {
      /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                  /* Number of items in variable part (ob_size) */
#endif
      (char *)"swigvarlink",              /* Type name (tp_name) */
      sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
      0,                                  /* Itemsize (tp_itemsize) */
      (destructor) swig_varlink_dealloc,   /* Deallocator (tp_dealloc) */ 
      (printfunc) swig_varlink_print,     /* Print (tp_print) */
      (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
      (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
      0,                                  /* tp_compare */
      (reprfunc) swig_varlink_repr,       /* tp_repr */
      0,                                  /* tp_as_number */
      0,                                  /* tp_as_sequence */
      0,                                  /* tp_as_mapping */
      0,                                  /* tp_hash */
      0,                                  /* tp_call */
      (reprfunc)swig_varlink_str,        /* tp_str */
      0,                                  /* tp_getattro */
      0,                                  /* tp_setattro */
      0,                                  /* tp_as_buffer */
      0,                                  /* tp_flags */
      varlink__doc__,                     /* tp_doc */
      0,                                  /* tp_traverse */
      0,                                  /* tp_clear */
      0,                                  /* tp_richcompare */
      0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
      0,0,0,0                             /* tp_alloc -> tp_next */
#endif
    };
    varlink_type = tmp;
    /* for Python 3 we already assigned the ob_type in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
    varlink_type.ob_type = &PyType_Type;
#endif
    type_init = 1;
  }
  return &varlink_type;
}

/* Create a variable linking object for use later */
SWIGINTERN PyObject *
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
  if (result) {
    result->vars = 0;
  }
  return ((PyObject*) result);
}

SWIGINTERN void 
SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v = (swig_varlinkobject *) p;
  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  if (gv) {
    size_t size = strlen(name)+1;
    gv->name = (char *)malloc(size);
    if (gv->name) {
      strncpy(gv->name,name,size);
      gv->get_attr = get_attr;
      gv->set_attr = set_attr;
      gv->next = v->vars;
    }
  }
  v->vars = gv;
}

SWIGINTERN PyObject *
SWIG_globals(void) {
  static PyObject *_SWIG_globals = 0; 
  if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
  return _SWIG_globals;
}

/* -----------------------------------------------------------------------------
 * constants/methods manipulation
 * ----------------------------------------------------------------------------- */

/* Install Constants */
SWIGINTERN void
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  PyObject *obj = 0;
  size_t i;
  for (i = 0; constants[i].type; ++i) {
    switch(constants[i].type) {
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d, constants[i].name, obj);
      Py_DECREF(obj);
    }
  }
}

/* -----------------------------------------------------------------------------*/
/* Fix SwigMethods to carry the callback ptrs when needed */
/* -----------------------------------------------------------------------------*/

SWIGINTERN void
SWIG_Python_FixMethods(PyMethodDef *methods,
		       swig_const_info *const_table,
		       swig_type_info **types,
		       swig_type_info **types_initial) {
  size_t i;
  for (i = 0; methods[i].ml_name; ++i) {
    const char *c = methods[i].ml_doc;
    if (c && (c = strstr(c, "swig_ptr: "))) {
      int j;
      swig_const_info *ci = 0;
      const char *name = c + 10;
      for (j = 0; const_table[j].type; ++j) {
	if (strncmp(const_table[j].name, name, 
		    strlen(const_table[j].name)) == 0) {
	  ci = &(const_table[j]);
	  break;
	}
      }
      if (ci) {
	size_t shift = (ci->ptype) - types;
	swig_type_info *ty = types_initial[shift];
	size_t ldoc = (c - methods[i].ml_doc);
	size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
	char *ndoc = (char*)malloc(ldoc + lptr + 10);
	if (ndoc) {
	  char *buff = ndoc;
	  void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
	  if (ptr) {
	    strncpy(buff, methods[i].ml_doc, ldoc);
	    buff += ldoc;
	    strncpy(buff, "swig_ptr: ", 10);
	    buff += 10;
	    SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
	    methods[i].ml_doc = ndoc;
	  }
	}
      }
    }
  }
} 

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
  PyObject*
#else
  void
#endif
SWIG_init(void) {
  PyObject *m, *d;
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };

  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  d = PyModule_GetDict(m);
  
  SWIG_InitializeModule(0);
  SWIG_InstallConstants(d,swig_const_table);
  
%}


]


/* ------------------------------------------------------------
 * For backward compatibility
 * ------------------------------------------------------------ */
%includefile "C:\\Programme\\swig\\Lib\\python\\pybackward.swg" [
/* 
   adding backward compatibility macros
*/








































/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,295,%apply_checkctypes@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {bool},"header", fragment="SWIG_" "AsVal" "_" {bool}) {
SWIGINTERNINLINE bool
SWIG_As_bool (PyObject* obj)
{
  bool v;
  int res = SWIG_AsVal_bool (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(bool));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {bool},"header",fragment="SWIG_" "AsVal" "_" {bool}) {
SWIGINTERNINLINE int
SWIG_Check_bool (PyObject* obj)
{
  int res = SWIG_AsVal_bool (obj, (bool*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {signed char},"header", fragment="SWIG_" "AsVal" "_" {signed char}) {
SWIGINTERNINLINE signed char
SWIG_As_signed_SS_char (PyObject* obj)
{
  signed char v;
  int res = SWIG_AsVal_signed_SS_char (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(signed char));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {signed char},"header",fragment="SWIG_" "AsVal" "_" {signed char}) {
SWIGINTERNINLINE int
SWIG_Check_signed_SS_char (PyObject* obj)
{
  int res = SWIG_AsVal_signed_SS_char (obj, (signed char*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned char},"header", fragment="SWIG_" "AsVal" "_" {unsigned char}) {
SWIGINTERNINLINE unsigned char
SWIG_As_unsigned_SS_char (PyObject* obj)
{
  unsigned char v;
  int res = SWIG_AsVal_unsigned_SS_char (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned char));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned char},"header",fragment="SWIG_" "AsVal" "_" {unsigned char}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_char (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_char (obj, (unsigned char*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {short},"header", fragment="SWIG_" "AsVal" "_" {short}) {
SWIGINTERNINLINE short
SWIG_As_short (PyObject* obj)
{
  short v;
  int res = SWIG_AsVal_short (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(short));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {short},"header",fragment="SWIG_" "AsVal" "_" {short}) {
SWIGINTERNINLINE int
SWIG_Check_short (PyObject* obj)
{
  int res = SWIG_AsVal_short (obj, (short*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned short},"header", fragment="SWIG_" "AsVal" "_" {unsigned short}) {
SWIGINTERNINLINE unsigned short
SWIG_As_unsigned_SS_short (PyObject* obj)
{
  unsigned short v;
  int res = SWIG_AsVal_unsigned_SS_short (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned short));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned short},"header",fragment="SWIG_" "AsVal" "_" {unsigned short}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_short (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_short (obj, (unsigned short*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {int},"header", fragment="SWIG_" "AsVal" "_" {int}) {
SWIGINTERNINLINE int
SWIG_As_int (PyObject* obj)
{
  int v;
  int res = SWIG_AsVal_int (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(int));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {int},"header",fragment="SWIG_" "AsVal" "_" {int}) {
SWIGINTERNINLINE int
SWIG_Check_int (PyObject* obj)
{
  int res = SWIG_AsVal_int (obj, (int*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned int},"header", fragment="SWIG_" "AsVal" "_" {unsigned int}) {
SWIGINTERNINLINE unsigned int
SWIG_As_unsigned_SS_int (PyObject* obj)
{
  unsigned int v;
  int res = SWIG_AsVal_unsigned_SS_int (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned int));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned int},"header",fragment="SWIG_" "AsVal" "_" {unsigned int}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_int (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_int (obj, (unsigned int*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {long},"header", fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERNINLINE long
SWIG_As_long (PyObject* obj)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(long));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {long},"header",fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERNINLINE int
SWIG_Check_long (PyObject* obj)
{
  int res = SWIG_AsVal_long (obj, (long*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned long},"header", fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERNINLINE unsigned long
SWIG_As_unsigned_SS_long (PyObject* obj)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned long));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned long},"header",fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_long (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_long (obj, (unsigned long*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {long long},"header", fragment="SWIG_" "AsVal" "_" {long long}) {
SWIGINTERNINLINE long long
SWIG_As_long_SS_long (PyObject* obj)
{
  long long v;
  int res = SWIG_AsVal_long_SS_long (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(long long));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {long long},"header",fragment="SWIG_" "AsVal" "_" {long long}) {
SWIGINTERNINLINE int
SWIG_Check_long_SS_long (PyObject* obj)
{
  int res = SWIG_AsVal_long_SS_long (obj, (long long*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned long long},"header", fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
SWIGINTERNINLINE unsigned long long
SWIG_As_unsigned_SS_long_SS_long (PyObject* obj)
{
  unsigned long long v;
  int res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned long long));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned long long},"header",fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_long_SS_long (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, (unsigned long long*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {float},"header", fragment="SWIG_" "AsVal" "_" {float}) {
SWIGINTERNINLINE float
SWIG_As_float (PyObject* obj)
{
  float v;
  int res = SWIG_AsVal_float (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(float));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {float},"header",fragment="SWIG_" "AsVal" "_" {float}) {
SWIGINTERNINLINE int
SWIG_Check_float (PyObject* obj)
{
  int res = SWIG_AsVal_float (obj, (float*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {double},"header", fragment="SWIG_" "AsVal" "_" {double}) {
SWIGINTERNINLINE double
SWIG_As_double (PyObject* obj)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(double));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {double},"header",fragment="SWIG_" "AsVal" "_" {double}) {
SWIGINTERNINLINE int
SWIG_Check_double (PyObject* obj)
{
  int res = SWIG_AsVal_double (obj, (double*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {char},"header", fragment="SWIG_" "AsVal" "_" {char}) {
SWIGINTERNINLINE char
SWIG_As_char (PyObject* obj)
{
  char v;
  int res = SWIG_AsVal_char (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(char));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {char},"header",fragment="SWIG_" "AsVal" "_" {char}) {
SWIGINTERNINLINE int
SWIG_Check_char (PyObject* obj)
{
  int res = SWIG_AsVal_char (obj, (char*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {wchar_t},"header", fragment="SWIG_" "AsVal" "_" {wchar_t}) {
SWIGINTERNINLINE wchar_t
SWIG_As_wchar_t (PyObject* obj)
{
  wchar_t v;
  int res = SWIG_AsVal_wchar_t (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(wchar_t));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {wchar_t},"header",fragment="SWIG_" "AsVal" "_" {wchar_t}) {
SWIGINTERNINLINE int
SWIG_Check_wchar_t (PyObject* obj)
{
  int res = SWIG_AsVal_wchar_t (obj, (wchar_t*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {size_t},"header", fragment="SWIG_" "AsVal" "_" {size_t}) {
SWIGINTERNINLINE size_t
SWIG_As_size_t (PyObject* obj)
{
  size_t v;
  int res = SWIG_AsVal_size_t (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(size_t));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {size_t},"header",fragment="SWIG_" "AsVal" "_" {size_t}) {
SWIGINTERNINLINE int
SWIG_Check_size_t (PyObject* obj)
{
  int res = SWIG_AsVal_size_t (obj, (size_t*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\python\\pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {ptrdiff_t},"header", fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) {
SWIGINTERNINLINE ptrdiff_t
SWIG_As_ptrdiff_t (PyObject* obj)
{
  ptrdiff_t v;
  int res = SWIG_AsVal_ptrdiff_t (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(ptrdiff_t));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {ptrdiff_t},"header",fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) {
SWIGINTERNINLINE int
SWIG_Check_ptrdiff_t (PyObject* obj)
{
  int res = SWIG_AsVal_ptrdiff_t (obj, (ptrdiff_t*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG@*/


]



]
%includefile(maininput="cmf.i") "cmf.i" [
// Include datetime
// %pythoncode
// {
// import datetime
// }
// Get Documentation
%includefile "docstrings.i" [

// File: index.xml

// File: a00549.xml
%feature("docstring") std::allocator "

STL class. ";


// File: a00550.xml
%feature("docstring") std::auto_ptr "

STL class. ";


// File: a00551.xml
%feature("docstring") std::bad_alloc "

STL class. ";


// File: a00552.xml
%feature("docstring") std::bad_cast "

STL class. ";


// File: a00553.xml
%feature("docstring") std::bad_exception "

STL class. ";


// File: a00554.xml
%feature("docstring") std::bad_typeid "

STL class. ";


// File: a00555.xml
%feature("docstring") std::basic_fstream "

STL class. ";


// File: a00558.xml
%feature("docstring") std::basic_ifstream "

STL class. ";


// File: a00561.xml
%feature("docstring") std::basic_ios "

STL class. ";


// File: a00566.xml
%feature("docstring") std::basic_iostream "

STL class. ";


// File: a00562.xml
%feature("docstring") std::basic_istream "

STL class. ";


// File: a00568.xml
%feature("docstring") std::basic_istringstream "

STL class. ";


// File: a00573.xml
%feature("docstring") std::basic_ofstream "

STL class. ";


// File: a00563.xml
%feature("docstring") std::basic_ostream "

STL class. ";


// File: a00576.xml
%feature("docstring") std::basic_ostringstream "

STL class. ";


// File: a00581.xml
%feature("docstring") std::basic_string "

STL class. ";


// File: a00584.xml
%feature("docstring") std::basic_string::const_iterator "

STL iterator class. ";


// File: a00585.xml
%feature("docstring") std::basic_string::const_reverse_iterator "

STL iterator class. ";


// File: a00586.xml
%feature("docstring") std::basic_string::iterator "

STL iterator class. ";


// File: a00587.xml
%feature("docstring") std::basic_string::reverse_iterator "

STL iterator class. ";


// File: a00567.xml
%feature("docstring") std::basic_stringstream "

STL class. ";


// File: a00001.xml
%feature("docstring") cmf::math::BDF2 "

An order 2 BDF-Method with fixed-point iteration and variable step
size.

Recommended integrator for CMF (so far)

Derived from Roussel C. and Roussel M. (2003) \"Generic Object-
Oriented Differential Equation Integrators\", C/C++ User Journal, Nov.
2003,http://www.ddj.com/cpp/184401724?pgno=8 and

Eckert S., Baaser H., Gross D. and Scherf O. (2004) \"A BDF2
integration method with step size control for elasto-plasticity\",
Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1

Most important function: Integrate

C++ includes: BDF2.h ";

/*  Internal data storages  */

/*  Gear functions: The following functions evaluate the Gear formulas
of specified order, loading the results into compareStates.  */

/*  Assessment of state variables for integration  */

%feature("docstring")  cmf::math::BDF2::States "cmf::math::StateVariableVector& States()

Returns the vector of StateVariable pointers. ";

%feature("docstring")  cmf::math::BDF2::States "const
cmf::math::StateVariableVector& States() const ";

/*  model time  */

%feature("docstring")  cmf::math::BDF2::ModelTime "cmf::math::Time
ModelTime() const

Returns the current model time. ";

%feature("docstring")  cmf::math::BDF2::ModelTime "void
ModelTime(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::BDF2::TimeStep "cmf::math::Time
TimeStep() const

Returns the last time step. ";

%feature("docstring")  cmf::math::BDF2::NextTimeStep "cmf::math::Time
NextTimeStep() const

Returns the next time step width. ";

%feature("docstring")  cmf::math::BDF2::NextTimeStep "void
NextTimeStep(cmf::math::Time val)

Sets the next time step width. ";

%feature("docstring")  cmf::math::BDF2::MinTimestep "const
cmf::math::Time MinTimestep() const

Returns The minimal allowed time step length. ";

%feature("docstring")  cmf::math::BDF2::Iterations "int Iterations()
const ";

%feature("docstring")  cmf::math::BDF2::ResetIterations "void
ResetIterations() ";

/*  Integrate  */

%feature("docstring")  cmf::math::BDF2::Integrate "int
Integrate(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::BDF2::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::BDF2::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables until MaxTime. ";

%feature("docstring")  cmf::math::BDF2::__call__ "void
__call__(cmf::math::Time until)

Calls IntegrateUntil. ";

/*  The state variables to integrate  */

/*  Accuracy parameters  */

%feature("docstring")  cmf::math::BDF2::AddStatesFromOwner "void
AddStatesFromOwner(cmf::math::StateVariableOwner &stateOwner)

Adds the state variables of a StateVariableOwner to the state
variables of the solver. ";

%feature("docstring")  cmf::math::BDF2::BDF2 "BDF2(const
StateVariableVector &states, real epsilon=1e-9, cmf::math::Time
tStepMin=Time::Milliseconds(10))

Constructs a new Gears_var_Step from a pointer to a vector of state
variables.

The Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::BDF2::BDF2 "BDF2(real epsilon=1e-9,
cmf::math::Time tStepMin=Time::Seconds(10))

Constructs a new Gears_var_Step.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::BDF2::BDF2 "BDF2(const Integrator
&templ) ";

%feature("docstring")  cmf::math::BDF2::Copy "virtual Integrator*
Copy() const

Returns a new Integrator, based on this (without the state variables),
e.g. same type, epsilon, model time etc. ";

%feature("docstring")  cmf::math::BDF2::Integrate "int
Integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

if $ t_{max}-t_{now}\\\\leq 2h_n $ then $ h_{n+1}= t_{max}-t_{now} $
else $ h_{n+1}= 2h_n $

Uses pastStatesArray to store $ y_n,y_{n-1} $

if more than one step is taken start iterating:  $
y_{n+1}^i=\\\\frac{1}{1+2\\\\rho }\\\\left( (\\\\rho
+1)^{2}y_{n}-\\\\rho ^{2}y_{n-1}+(\\\\rho
+1)h\\\\frac{dy}{dt}(y_{n+1}^{i-1},t_{n+1} \\\\right), y_{n+1}^0=y_n $
with $ \\\\rho = \\\\frac{h_{n+1}}{h_n} $

until $ y_{n+1}^{i} - y_{n+1}^{i-1} \\\\leq \\\\ \\\\|\\\\epsilon +
\\\\epsilon y_{n+1}\\\\|_{\\\\infty} $

If too many iterations are needed, or the error is rising, repeat
iteration with $ h_{n+1} = \\\\frac{h_{n+1}}{2} $

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed timestep, ignored by this solver ";

%feature("docstring")  cmf::math::BDF2::count "int count() const

returns the number of state variables ";

%feature("docstring")  cmf::math::BDF2::state "const real& state(int
position) const

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::BDF2::state "void state(int
position, real newState)

Simplifies the assessment of state variables. ";


// File: a00590.xml
%feature("docstring") std::bitset "

STL class. ";


// File: a00002.xml
%feature("docstring") cmf::geometry::BoundingBox "

Holds the corner coordinates of a bounding box.

C++ includes: geometry.h ";

%feature("docstring")  cmf::geometry::BoundingBox::Center "point
Center() const ";

%feature("docstring")  cmf::geometry::BoundingBox::Includes "bool
Includes(point p) const

Returns true if the point p is inside the bounding box. ";

%feature("docstring")  cmf::geometry::BoundingBox::isempty "bool
isempty() const

Returns true, if the bounding box is empty. ";

%feature("docstring")  cmf::geometry::BoundingBox::makeempty "void
makeempty()

Makes the bounding box empty. ";

%feature("docstring")  cmf::geometry::BoundingBox::extend "void
extend(point p)

Extends the BoundingBox to include the given point. ";

%feature("docstring")  cmf::geometry::BoundingBox::extend "void
extend(const BoundingBox &bbox)

Extends the bounding box to contain the given Boundingbox although. ";

%feature("docstring")  cmf::geometry::BoundingBox::AsWKT "std::string
AsWKT() const ";

%feature("docstring")  cmf::geometry::BoundingBox::BoundingBox "BoundingBox()

Creates an empty bounding box. ";

%feature("docstring")  cmf::geometry::BoundingBox::BoundingBox "BoundingBox(double X1, double Y1, double X2, double Y2)

Creates a bounding box between to coordinates. ";

%feature("docstring")  cmf::geometry::BoundingBox::BoundingBox "BoundingBox(point p1, point p2)

Creates a bounding box between to coordinates. ";

%feature("docstring")  cmf::geometry::BoundingBox::BoundingBox "BoundingBox(const BoundingBox &copy)

Copies the bounding box. ";

%feature("docstring")  cmf::geometry::BoundingBox::BoundingBox "BoundingBox(double *bbox) ";

%feature("docstring")  cmf::geometry::BoundingBox::Vertices "Points
Vertices() const ";


// File: a00003.xml
%feature("docstring") cmf::upslope::BrooksCoreyRetentionCurve "

Provides the use of the Brooks-Corey retention curve
\\\\begin{eqnarray*} K(W) &=& K_{sat} W^{2+3b} \\\\\\\\ \\\\Psi(W) &=&
\\\\Psi_X \\\\left(\\\\frac{W}{W_X}\\\\right)^{-b} \\\\\\\\ W &=&
{\\\\left( \\\\frac{\\\\Psi_X}{\\\\Psi}\\\\right)
}^{\\\\frac{1}{b}}\\\\ W_X \\\\end{eqnarray*} where:  $K$ is the
conductivity in $\\\\frac m {day}$

$W$ is the wetness (Volume of soil water per volume of pores)

$b$ is the shape of the retention curve (usually between 4 (sand) and
14 (clay))

$\\\\Psi(W)$ is the matric potential in $m H_2O$ at wetness W

$\\\\Psi_X$ is a matric potential at a known wetness in $m H_2O$

$\\\\W_X$ is the wetness with a known matric potential for dynamic
changes with depth, exponential decays of porosity and saturated
conductivity are used The decay function is: $ v(d)=v(0) (1+a)^{-d} $,
where v is the value ( $ K_{sat},\\\\Phi$), d is the depth in m and a
is the fractional decay per m. E.g. 0.1 means the value has in 1 m
depth 90% of the value at the surface.

C++ includes: RetentionCurve.h ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::K "virtual real K(real wetness, real depth) const

Returns the conductivity in m/day at a certain depth and water
content. ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::SetKsat "real SetKsat(real
ksat, real ksat_decay) ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Porosity "real Porosity(real
depth) const

real (Porosity) ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::SetPorosity "void
SetPorosity(real porosity, real porosity_decay=0)

Sets the porosity (Volume of pores per volume of soil) and the
exponential porosity decline with depth. ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::VoidVolume "real
VoidVolume(real upperDepth, real lowerDepth, real Area) const

Returns the pore volume in a region of a soil column.

If there is a porosity decay, the void volume is the integral of
porosity over depth times area ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::FillHeight "real
FillHeight(real lowerDepth, real Area, real Volume) const

Returns the thickness of a soil column with a certain pore volume. ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Transmissivity "real
Transmissivity(real upperDepth, real lowerDepth, real theta) const

Returns the transmissivity of a part of a soil column. ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::MatricPotential "real
MatricPotential(real wetness) const

Returns the suction pressure in m, use conversion functions
waterhead_to_pressure and waterhead_to_pF fro conversions. ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Wetness "real Wetness(real
suction) const

returns the wetness (volumetric water content per pore space) at a
given suction pressure ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::BrooksCoreyRetentionCurve "BrooksCoreyRetentionCurve(real ksat=15, real porosity=0.5, real _b=5,
real theta_x=0.2, real psi_x=pF_to_waterhead(2.5), real ksat_decay=0,
real porosity_decay=0)

Creates a brooks corey retention curve.

Parameters:
-----------

ksat:  Saturated conductivity $\\\\frac{m}{day}$

porosity:   $\\\\frac {m^3 Pores}{m^3 Soil}$

_b:  Shape of the retention curve (if you do not know how to
parameterize this, take a look at the other constructor)

theta_x:   $\\\\theta_X$ Water content at a specific suction pressure

psi_x:  Suction pressure for $\\\\theta_X$ in m water column, use the
conversion functions pF_to_waterhead, pressure_to_waterhead to convert
pressure in to waterhead height (default pF=2.5)

ksat_decay:  Relative decay of conductivity with depth, e.g. 0.1 means
conductivity gets 10% smaller per meter

porosity_decay:  Relative decay of porosity with depth, e.g. 0.1 means
conductivity gets 10% smaller per meter ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::BrooksCoreyRetentionCurve "BrooksCoreyRetentionCurve(real ksat, real porosity, real theta1, real
theta2, real psi_1=pF_to_waterhead(2.5), real
psi_2=pF_to_waterhead(4.2))

Creates a soiltype from two known points of the retention curve (e.g.
fieldcapacity and wilting point).

Parameters:
-----------

ksat:  Saturated conductivity $\\\\frac{m}{day}$

porosity:   $\\\\frac {m^3 Pores}{m^3 Soil}$

theta1:   $\\\\theta_1$ First water content at a specific suction
pressure (e.g. fieldcapacity)

theta2:   $\\\\theta_2$ Second water content at a specific suction
pressure (e.g. wiltingpoint)

psi_1:   $ \\\\Psi_1$ Suction pressure for $\\\\theta_1$ in m water
column, use the conversion functions pF_to_waterhead,
pressure_to_waterhead to convert pressure in to waterhead height
(default pF=2.5)

psi_2:   $ \\\\Psi_2$ Suction pressure for $\\\\theta_2$ in m water
column, use the conversion functions pF_to_waterhead,
pressure_to_waterhead to convert pressure in to waterhead height
(default pF=4.2)

The paramter b (shape of the retention curve) is calculated by: \\\\[
b =
\\\\frac{\\\\log\\\\left(\\\\frac{\\\\Psi_1}{\\\\Psi_2}\\\\right)}{\\\\log\\\\left(\\\\frac{\\\\theta_2}{\\\\theta_1}\\\\right)}
\\\\] ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::copy "virtual BrooksCoreyRetentionCurve* copy() const ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Wetness_pF "real
Wetness_pF(real pF) const

returns the volumetric water content at a given pF value ";


// File: a00591.xml
%feature("docstring") cmf::upslope::connections::CanopyOverflow "";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::CanopyOverflow "CanopyOverflow(cmf::water::WaterStorage &Canopy, cmf::water::FluxNode
&target, cmf::upslope::Cell &cell) ";

%feature("docstring")  cmf::upslope::connections::CanopyOverflow::q "real q(const FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::Target "const FluxNode&
Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::upslope::connections::CanopyOverflow::conc
"WaterQuality conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00004.xml
%feature("docstring") cmf::upslope::ET::CanopyStorageEvaporation "

Calculates the evaporation from a canopy storage.

C++ includes: ET.h ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::CanopyStorageEvaporation "CanopyStorageEvaporation(cmf::water::FluxNode &CanopyStorage,
cmf::water::FluxNode &ET_target, const cmf::atmosphere::Meteorology
&meteo, cmf::upslope::Cell &cell) ";

%feature("docstring")  cmf::upslope::ET::CanopyStorageEvaporation::q "real q(const FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::Target "const FluxNode&
Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00005.xml
%feature("docstring") cmf::Catchment "

The catchment of a reach.

C++ includes: Basin.h ";

%feature("docstring")  cmf::Catchment::Reach "cmf::river::reach&
Reach()

The reach of the catchment. ";

%feature("docstring")  cmf::Catchment::Reach "const
cmf::river::reach& Reach() const ";

%feature("docstring")  cmf::Catchment::AddCell "void
AddCell(cmf::upslope::UpslopeCell *cell)

Returns the total catchment size of this reach including the
catchments of contributing streams. For the contributing area of this
reach only use Upslope().Area() Adds a cell to the catchment. ";

%feature("docstring")  cmf::Catchment::UpdateReachQlat "void
UpdateReachQlat()

Pushes the integrated ponded water to the reach, and resets the ponded
water integration. ";

%feature("docstring")  cmf::Catchment::IntegrateQlat "void
IntegrateQlat(const cmf::math::Time &t, const cmf::math::Time &dt)

Integrates the ponded water for the given time step length.

Parameters:
-----------

t:  Current model time

dt:  Current calculation step length ";

%feature("docstring")  cmf::Catchment::Boundary "cmf::geometry::Ring
Boundary() const

Returns the geometry of the Basin boundary. ";

%feature("docstring")  cmf::Catchment::Catchment "Catchment(cmf::river::reach *_reach)

Creates a catchment without upslope area (to be added later). ";

%feature("docstring")  cmf::Catchment::Catchment "Catchment(cmf::river::reach *_reach, cmf::upslope::UpslopeVector
&upslope)

Creates a catchment from a reach and a contributing upslope area (best
created with the constructor of StudyArea). ";

%feature("docstring")  cmf::Catchment::Catchment "Catchment(const
cmf::Catchment &tocopy) ";

%feature("docstring")  cmf::Catchment::Catchment "Catchment() ";


// File: a00592.xml
%feature("docstring") cmf::upslope::Cell "";

/*  Location  */

%feature("docstring")  cmf::upslope::Cell::Center "cmf::geometry::point Center() const

Returns the location of the cell. ";

%feature("docstring")  cmf::upslope::Cell::Geometry "cmf::geometry::Polygon Geometry() const

Returns the shape of the cell. ";

%feature("docstring")  cmf::upslope::Cell::Geometry "void
Geometry(cmf::geometry::Polygon val)

Sets the shape of the cell. ";

%feature("docstring")  cmf::upslope::Cell::Area "double Area() const

Returns the area of the cell. ";

%feature("docstring")  cmf::upslope::Cell::RecalcSatDepth "void
RecalcSatDepth()

Marks the saturated depth as unvalid. ";

%feature("docstring")  cmf::upslope::Cell::SaturatedDepth "real
SaturatedDepth() ";

/*  Flux nodes of the cell  */

%feature("docstring")  cmf::upslope::Cell::ET "cmf::water::FluxNode&
ET()

Returns the end point of all evapotranspiration of this cell. ";

%feature("docstring")  cmf::upslope::Cell::Canopy "cmf::water::FluxNode& Canopy()

Returns the canopy of this cell. ";

%feature("docstring")  cmf::upslope::Cell::Snow "cmf::water::FluxNode& Snow()

Returns the snow of this cell. ";

%feature("docstring")  cmf::upslope::Cell::SnowWater "cmf::water::FluxNode& SnowWater()

Returns the snow water of this cell. ";

%feature("docstring")  cmf::upslope::Cell::SurfaceWater "cmf::water::FluxNode& SurfaceWater()

returns the surface water of this cell ";

%feature("docstring")  cmf::upslope::Cell::SetCanopy "void
SetCanopy(const cmf::water::FluxNode &newObject)

Exchanges the type of canopy storage. ";

%feature("docstring")  cmf::upslope::Cell::SetSnow "void
SetSnow(const cmf::water::FluxNode &newObject) ";

%feature("docstring")  cmf::upslope::Cell::SetSnowWater "void
SetSnowWater(const cmf::water::FluxNode &newObject) ";

%feature("docstring")  cmf::upslope::Cell::SetSurfaceWater "void
SetSurfaceWater(const cmf::water::FluxNode &newObject) ";

/*  Topology  */

/*  Layers  */

%feature("docstring")  cmf::upslope::Cell::LayerCount "int
LayerCount() const ";

%feature("docstring")  cmf::upslope::Cell::Layer "cmf::upslope::SoilWaterStorage& Layer(int ndx) ";

%feature("docstring")  cmf::upslope::Cell::Layer "const
cmf::upslope::SoilWaterStorage& Layer(int ndx) const ";

%feature("docstring")  cmf::upslope::Cell::AddLayer "void
AddLayer(cmf::upslope::SoilWaterStorage *layer)

Registers a layer at the cell. This function is used by the ctor's of
the layers and should never be used in other code. ";

%feature("docstring")  cmf::upslope::Cell::~Cell "virtual ~Cell() ";

%feature("docstring")  cmf::upslope::Cell::Cell "Cell(double x,
double y, double z, double area) ";


// File: a00006.xml
%feature("docstring") cmf::upslope::CellBuilder "

Abstract base class for Functor's creating cells for a specified
location. Specializations are holding appropriate maps for external
data.

C++ includes: UpslopeFromRaster.h ";

%feature("docstring")  cmf::upslope::CellBuilder::CreateCell "cmf::upslope::UpslopeCell* CreateCell(cmf::geometry::point p, double
Area) const ";

%feature("docstring")  cmf::upslope::CellBuilder::CreateCell "cmf::upslope::UpslopeCell* CreateCell(double x, double y, double z,
double Area) const ";


// File: a00596.xml
%feature("docstring") std::complex "

STL class. ";


// File: a00597.xml
%feature("docstring") cmf::upslope::ET::constantETpot "";

%feature("docstring")  cmf::upslope::ET::constantETpot::GetETpot "real GetETpot(cmf::math::Time t) ";

%feature("docstring")  cmf::upslope::ET::constantETpot::constantETpot
"constantETpot(cmf::upslope::SoilWaterStorage &source,
cmf::water::FluxNode &ET_target, double constantETpot_value) ";

%feature("docstring")  cmf::upslope::ET::constantETpot::GetETpot "real GetETpot(cmf::math::Time t) const =0 ";

%feature("docstring")  cmf::upslope::ET::constantETpot::q "real
q(const FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::constantETpot::Target "FluxNode& Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::constantETpot::Target "const
FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::upslope::ET::constantETpot::conc "WaterQuality conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00007.xml
%feature("docstring") cmf::upslope::vegetation::constantFluxVegetation
"

A very simple implementation of IVegetation. All fluxes are constant
Throughfall is set to 800 mm/year

Evapotranspiration is set to 200 mm/year.

C++ includes: Vegetation.h ";

/*  Root distribution  */

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::RootDepth "double
RootDepth() const

The depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::RootDepth "void
RootDepth(double val)

Sets the depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::RootDistribution "virtual double RootDistribution(double upperBoundary, double
lowerBoundary) const

Returns the relative amount of roots [0..1] in the given soil layer
This function assumes a uniform distribution of roots. ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::RootDistribution_Michealis_Menten
"virtual double RootDistribution_Michealis_Menten(double
upperBoundary, double lowerBoundary) const ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::GetETpot "virtual
double GetETpot(cmf::math::Time timestep) const

Returns the Evapotranspiration rate at a given time step [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::GetThroughfall "virtual cmf::water::WaterFlux GetThroughfall(cmf::math::Time timestep)
const

Returns the Rate of precipitation entering the soil (precipitation -
interception) [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::GetTemperature "virtual double GetTemperature(cmf::math::Time timestep) const

Returns the air temperature at the timestep. ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::constantFluxVegetation
"constantFluxVegetation(double throughfall=800.0/365.0, double
etpot=200.0/365.0, double Temperature=10)

Creates the constantFluxVegetation.

Parameters:
-----------

throughfall:  Throughfall rate in mm/day

etpot:  ETpot in mm/day

Temperature:  Air Temperature in deg C ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::constantFluxVegetation
"constantFluxVegetation(const constantFluxVegetation &forcopy) ";

%feature("docstring")
cmf::upslope::vegetation::constantFluxVegetation::copy "constantFluxVegetation* copy() const

Pure virtual method, to copy the current vegetation. ";


// File: a00008.xml
%feature("docstring") cmf::upslope::maps::ContinuousRasterMap "

Distributes a scalar value (int, float or double) with a raster
dataset. The simplest way to create a continuous raster map is to load
a raster in the ESRI ASCII format.

C++ includes: maps.h ";

%feature("docstring")
cmf::upslope::maps::ContinuousRasterMap::ContinuousRasterMap "ContinuousRasterMap(const cmf::geometry::Raster< _Ty > &raster)

Creates a new continuous map.

Parameters:
-----------

raster:  Pointer to an existing cmf::geometry::Raster ";

%feature("docstring")
cmf::upslope::maps::ContinuousRasterMap::ContinuousRasterMap "ContinuousRasterMap(std::string ASCFileName, _Ty factor=1, _Ty
nodata=-9999)

Creates a new continuous map.

Parameters:
-----------

ASCFileName:  A file name of an ESRI ASC raster dataset

factor:  Scales the raster dataset (e.g. unit conversion)

nodata:  Value returned, if the raster has no data (if Has(x,y)=false)
default: -9999 ";

%feature("docstring")  cmf::upslope::maps::ContinuousRasterMap::Get "_Ty Get(cmf::geometry::point p)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::ContinuousRasterMap::Get "_Ty Get(double x, double y)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::ContinuousRasterMap::Has "bool Has(double x, double y) ";

%feature("docstring")  cmf::upslope::maps::ContinuousRasterMap::Has "bool Has(cmf::geometry::point p) ";

%feature("docstring")
cmf::upslope::maps::ContinuousRasterMap::__call__ "_Ty
__call__(double x, double y) ";


// File: a00009.xml
%feature("docstring") cmf::upslope::connections::DarcyConnection "

Calculates the lateral flow using the gravitational potential only.

\\\\[ q_{lat} = \\\\frac{\\\\Delta \\\\Psi_G}{\\\\|C_1-C_2\\\\|}
\\\\frac12 (T(C_1)+T(C_2)) w \\\\] where  $ \\\\Delta \\\\Psi_G $ is
the gravitational potential difference

$ \\\\|C_1-C_2\\\\| $ is the distance from Cell 1 to Cell 2

$ T(C) $ is the transmissivity of cell C, calculated by
SoilType::Transmissivity

$ w $ is the width of the connection of the cells

C++ includes: FluxConnections.h ";

%feature("docstring")
cmf::upslope::connections::DarcyConnection::DarcyConnection "DarcyConnection(cmf::upslope::SoilWaterStorage &left,
cmf::upslope::SoilWaterStorage &right, real FlowArea, real Distance)
";

%feature("docstring")  cmf::upslope::connections::DarcyConnection::q "real q(const FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::DarcyConnection::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::DarcyConnection::Target "const FluxNode&
Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")
cmf::upslope::connections::DarcyConnection::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00010.xml
%feature("docstring") cmf::upslope::vegetation::DatadrivenVegetation "

A Vegetation class with measured or previously calculated Throughfall
and ETpot.

C++ includes: DatadrivenVegetation.h ";

/*  Root distribution  */

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::RootDepth "double
RootDepth() const

The depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::RootDepth "void
RootDepth(double val)

Sets the depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::RootDistribution "virtual double RootDistribution(double upperBoundary, double
lowerBoundary) const

Returns the relative amount of roots [0..1] in the given soil layer
This function assumes a uniform distribution of roots. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::RootDistribution_Michealis_Menten
"virtual double RootDistribution_Michealis_Menten(double
upperBoundary, double lowerBoundary) const ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::GetThroughfall "virtual cmf::water::WaterFlux GetThroughfall(cmf::math::Time timestep)
";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::GetETpot "virtual
double GetETpot(cmf::math::Time timestep) ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::DatadrivenVegetation "DatadrivenVegetation()

Standard constructor. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::DatadrivenVegetation "DatadrivenVegetation(cmf::math::Time begin, cmf::math::Time step)

Initializes Throughfall and ETpot and ThroughfalConcentration
timeseries with the given start and step time. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::DatadrivenVegetation "DatadrivenVegetation(cmf::math::timeseries throughfall,
cmf::math::timeseries etpot)

Uses the given timeseries for Throughfall and ETpot and initializes
the ThroughfalConcentration timeseries with the begin and step time of
Throughfall. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::DatadrivenVegetation "DatadrivenVegetation(const DatadrivenVegetation &copy)

Copy constructor. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::copy "DatadrivenVegetation* copy() ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::GetETpot "virtual
double GetETpot(cmf::math::Time timestep) const =0

Returns the Evapotranspiration rate at a given time step [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::GetThroughfall "virtual cmf::water::WaterFlux GetThroughfall(cmf::math::Time timestep)
const =0

Returns the Rate of precipitation entering the soil (precipitation -
interception) [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::GetTemperature "virtual double GetTemperature(cmf::math::Time timestep) const =0

Returns the air temperature at the timestep. ";

%feature("docstring")
cmf::upslope::vegetation::DatadrivenVegetation::copy "virtual
IVegetation* copy() const =0

Pure virtual method, to copy the current vegetation. ";


// File: a00011.xml
%feature("docstring") cmf::math::Date "

An absolute time, not for calculation. Date and Time are
interchangable.

C++ includes: Time.h ";

%feature("docstring")  cmf::math::Date::Date "Date(int _day, int
_month, int _year=2001, int _hour=0, int _minute=0, int _second=0, int
_ms=0)

Creates a new date. ";

%feature("docstring")  cmf::math::Date::Date "Date(const Time &time)

Creates a new date from time (based on the 31.12.1899, like in
Excel(TM)). ";

%feature("docstring")  cmf::math::Date::ToTime "Time ToTime()

Converts a date to Time (based on the 31.12.1899, like in Excel(TM).
";

%feature("docstring")  cmf::math::Date::DOY "int DOY()

Returns the day of year. ";

%feature("docstring")  cmf::math::Date::ToString "std::string
ToString()

Returns a string representing the date. ";


// File: a00598.xml
%feature("docstring") std::deque "

STL class. ";


// File: a00599.xml
%feature("docstring") std::deque::const_iterator "

STL iterator class. ";


// File: a00600.xml
%feature("docstring") std::deque::const_reverse_iterator "

STL iterator class. ";


// File: a00601.xml
%feature("docstring") std::deque::iterator "

STL iterator class. ";


// File: a00602.xml
%feature("docstring") std::deque::reverse_iterator "

STL iterator class. ";


// File: a00012.xml
%feature("docstring") cmf::upslope::maps::DiscreteRasterMap "

Distributes a discrete value or object as a given in an integer raster
dataset according to a lookup table. To use this, one have to provide
the dstribution raster and add id object pairs to the map prior to
use.

C++ includes: maps.h ";

%feature("docstring")  cmf::upslope::maps::DiscreteRasterMap::Add "void Add(int index, _Ty value)

Adds a value to the lookup table. ";

%feature("docstring")
cmf::upslope::maps::DiscreteRasterMap::DiscreteRasterMap "DiscreteRasterMap(geometry::Raster< int > *raster, _Ty
NoDataValue=_Ty())

Creates a new map of discrete values, for example soil types.

Parameters:
-----------

raster:  Pointer to an existing cmf::geometry::Raster<int>

NoDataValue:  Value returned, if the raster has no data
(Has(x,y)=false) ";

%feature("docstring")
cmf::upslope::maps::DiscreteRasterMap::DiscreteRasterMap "DiscreteRasterMap(std::string RasterFileName, _Ty NoDataValue=_Ty())

Creates a new map of discrete values, for example soil types.

Parameters:
-----------

RasterFileName:  File name of an ESRI ASC-raster, containing the
handles

NoDataValue:  Value returned if the handle is raster.NoData() or the
value is not found in the lookup table ";

%feature("docstring")  cmf::upslope::maps::DiscreteRasterMap::Get "_Ty Get(cmf::geometry::point p)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::DiscreteRasterMap::Get "_Ty Get(double x, double y)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::DiscreteRasterMap::Has "bool Has(double x, double y) ";

%feature("docstring")  cmf::upslope::maps::DiscreteRasterMap::Has "bool Has(cmf::geometry::point p) ";

%feature("docstring")  cmf::upslope::maps::DiscreteRasterMap::__call__
"_Ty __call__(double x, double y) ";


// File: a00603.xml
%feature("docstring") std::domain_error "

STL class. ";


// File: a00427.xml
%feature("docstring") cmf::upslope::ET::ET "";

%feature("docstring")  cmf::upslope::ET::ET::GetETpot "real
GetETpot(cmf::math::Time t) const =0 ";

%feature("docstring")  cmf::upslope::ET::ET::ET "ET(cmf::upslope::SoilWaterStorage &source, cmf::water::FluxNode
&ET_target, Vegetation veg) ";

%feature("docstring")  cmf::upslope::ET::ET::q "real q(const FluxNode
&inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::ET::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::ET::Target "const FluxNode&
Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::upslope::ET::ET::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00604.xml
%feature("docstring") std::exception "

STL class. ";


// File: a00013.xml
%feature("docstring") cmf::math::ExplicitEuler_fixed "

An explicit Euler integrator, with a fixed time step.

C++ includes: ExplicitEuler_fixed.h ";

/*  Assessment of state variables for integration  */

%feature("docstring")  cmf::math::ExplicitEuler_fixed::States "cmf::math::StateVariableVector& States()

Returns the vector of StateVariable pointers. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::States "const
cmf::math::StateVariableVector& States() const ";

/*  model time  */

%feature("docstring")  cmf::math::ExplicitEuler_fixed::ModelTime "cmf::math::Time ModelTime() const

Returns the current model time. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::ModelTime "void ModelTime(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::TimeStep "cmf::math::Time TimeStep() const

Returns the last time step. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::NextTimeStep "cmf::math::Time NextTimeStep() const

Returns the next time step width. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::NextTimeStep "void NextTimeStep(cmf::math::Time val)

Sets the next time step width. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::MinTimestep "const cmf::math::Time MinTimestep() const

Returns The minimal allowed time step length. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::Iterations "int Iterations() const ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::ResetIterations
"void ResetIterations() ";

/*  Integrate  */

%feature("docstring")  cmf::math::ExplicitEuler_fixed::Integrate "int
Integrate(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::IntegrateUntil
"void IntegrateUntil(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::IntegrateUntil
"void IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time
TimeStep)

Integrates the vector of state variables until MaxTime. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::__call__ "void
__call__(cmf::math::Time until)

Calls IntegrateUntil. ";

/*  The state variables to integrate  */

/*  Accuracy parameters  */

%feature("docstring")
cmf::math::ExplicitEuler_fixed::AddStatesFromOwner "void
AddStatesFromOwner(cmf::math::StateVariableOwner &stateOwner)

Adds the state variables of a StateVariableOwner to the state
variables of the solver. ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::ExplicitEuler_fixed "ExplicitEuler_fixed(const StateVariableVector &states, real
epsilon=1e-9, cmf::math::Time tStepMin=Time::Seconds(10))

Constructs a new ExplicitEuler_fixed from a pointer to a vector of
state variables.

The Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  (ignored) relative error tolerance per time step
(default=1e-9)

tStepMin:  (ignored) minimum time step (default=10s) ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::ExplicitEuler_fixed "ExplicitEuler_fixed(real epsilon=1e-9, cmf::math::Time
tStepMin=Time::Seconds(10))

Constructs a new ExplicitEuler_fixed.

Parameters:
-----------

epsilon:  (ignored) relative error tolerance per time step
(default=1e-9)

tStepMin:  (ignored) minimum time step (default=10s) ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::ExplicitEuler_fixed "ExplicitEuler_fixed(const Integrator &copy)

Copy constructor. ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::~ExplicitEuler_fixed "virtual
~ExplicitEuler_fixed() ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::Copy "virtual
Integrator* Copy() const

Returns a new Integrator, based on this (without the state variables),
e.g. same type, epsilon, model time etc. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::Integrate "int
Integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  (ignored) To stop the model (if running in a model
framework) at time steps of value exchange e.g. full hours, the next
value exchange time can be given

TimeStep:  Takes the proposed time step ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::count "int
count() const

returns the number of state variables ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::state "const
real& state(int position) const

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::state "void
state(int position, real newState)

Simplifies the assessment of state variables. ";


// File: a00014.xml
%feature("docstring") cmf::math::ExplicitEuler_variable "

An explicit Euler integrator with variable step size.

C++ includes: ExplicitEuler_variable.h ";

/*  Assessment of state variables for integration  */

%feature("docstring")  cmf::math::ExplicitEuler_variable::States "cmf::math::StateVariableVector& States()

Returns the vector of StateVariable pointers. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::States "const cmf::math::StateVariableVector& States() const ";

/*  model time  */

%feature("docstring")  cmf::math::ExplicitEuler_variable::ModelTime "cmf::math::Time ModelTime() const

Returns the current model time. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::ModelTime "void ModelTime(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::TimeStep "cmf::math::Time TimeStep() const

Returns the last time step. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::NextTimeStep
"cmf::math::Time NextTimeStep() const

Returns the next time step width. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::NextTimeStep
"void NextTimeStep(cmf::math::Time val)

Sets the next time step width. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::MinTimestep
"const cmf::math::Time MinTimestep() const

Returns The minimal allowed time step length. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::Iterations "int Iterations() const ";

%feature("docstring")
cmf::math::ExplicitEuler_variable::ResetIterations "void
ResetIterations() ";

/*  Integrate  */

%feature("docstring")  cmf::math::ExplicitEuler_variable::Integrate "int Integrate(cmf::math::Time MaxTime) ";

%feature("docstring")
cmf::math::ExplicitEuler_variable::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime) ";

%feature("docstring")
cmf::math::ExplicitEuler_variable::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables until MaxTime. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::__call__ "void __call__(cmf::math::Time until)

Calls IntegrateUntil. ";

/*  The state variables to integrate  */

/*  Accuracy parameters  */

%feature("docstring")
cmf::math::ExplicitEuler_variable::AddStatesFromOwner "void
AddStatesFromOwner(cmf::math::StateVariableOwner &stateOwner)

Adds the state variables of a StateVariableOwner to the state
variables of the solver. ";

%feature("docstring")
cmf::math::ExplicitEuler_variable::ExplicitEuler_variable "ExplicitEuler_variable(const StateVariableVector &states, real
epsilon=1e-9, cmf::math::Time tStepMin=Time::Seconds(10))

Constructs a new ExplicitEuler_variable from a pointer to a vector of
state variables.

The Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")
cmf::math::ExplicitEuler_variable::ExplicitEuler_variable "ExplicitEuler_variable(real epsilon=1e-9, cmf::math::Time
tStepMin=Time::Seconds(10))

Constructs a new ExplicitEuler_variable.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")
cmf::math::ExplicitEuler_variable::ExplicitEuler_variable "ExplicitEuler_variable(const Integrator &copy)

Copy constructor. ";

%feature("docstring")
cmf::math::ExplicitEuler_variable::~ExplicitEuler_variable "virtual
~ExplicitEuler_variable() ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::Copy "virtual Integrator* Copy() const

Returns a new Integrator, based on this (without the state variables),
e.g. same type, epsilon, model time etc. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::Integrate "int Integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed time step, and changes it into the
effectively used time step according to the local stiffness of the
problem and MaxTime ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::count "int
count() const

returns the number of state variables ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::state "const real& state(int position) const

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::ExplicitEuler_variable::state "void
state(int position, real newState)

Simplifies the assessment of state variables. ";


// File: a00015.xml
%feature("docstring") cmf::water::reaction::ExternalFunctionReaction "

Not yet implemented: Will take a pointer to an external function to
calculate the reaction.

C++ includes: Reaction.h ";

%feature("docstring")
cmf::water::reaction::ExternalFunctionReaction::ReactiveFlux "virtual
double ReactiveFlux(const WaterQuality &Environment)=0

Returns the reactive flux as $\\\\frac{d[X]}{dt}=f([A],[B]...)
\\\\left[\\\\frac{mol}{m^3\\\\ day}\\\\right]$. ";


// File: a00016.xml
%feature("docstring") cmf::upslope::FlexibleSizeLayer "

A soil water storage above a FlexibleSizeSaturatedLayer, can only be
created by FlexibleSaturatedLayer.

C++ includes: SoilWaterStorage.h ";

/*  Overrides of FluxNode  */

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::copy "virtual
WaterStorage* copy() const ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Empty "virtual bool Empty() ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::LowerBoundary
"virtual real LowerBoundary() ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::UpperBoundary
"virtual double UpperBoundary() const

Returns the upper boundary of the water storage below ground in m. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::LowerBoundary
"virtual double LowerBoundary() const

Returns the lower boundary of the water storage below ground in m. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Thickness "double Thickness() const ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Soil "virtual
const RetentionCurve& Soil() const

Returns the soil properties of the water storage. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Soil "virtual
RetentionCurve& Soil() ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::theta "virtual real theta() const

Returns the actual volumetric water content of the water storage. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::theta "virtual void theta(real Value) ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::K "double K()
const

Returns the actual conductivity $\\\\frac{m}{day}$. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Wetness "virtual double Wetness() const

Returns the wetness of the soil $ \\\\frac{V_{H_2O}}{V_{pores}} $. ";

%feature("docstring")
cmf::upslope::FlexibleSizeLayer::MatrixPotential "virtual real
MatrixPotential() const

Calls RetentionCurve::Matrixpotential. ";

%feature("docstring")
cmf::upslope::FlexibleSizeLayer::GravitationalPotential "real
GravitationalPotential() const

Gravitational Potential in m, reference height is sea level \\\\[
\\\\Psi_G=h \\\\]. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Capacity "virtual real Capacity()

Returns the capacity of the water storage in m3. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::SetPotential "void SetPotential(real waterhead)

Sets the potential of this soil water storage. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Potential "virtual real Potential() const

Returns the total potential in m \\\\[ \\\\Psi = \\\\Psi_M + \\\\Psi_G
\\\\]. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Potential "virtual real Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::copy "SoilWaterStorage* copy() ";

%feature("docstring")
cmf::upslope::FlexibleSizeLayer::AddStateVariables "void
AddStateVariables(cmf::math::StateVariableVector &vector)

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Solute "SoluteStorage& Solute(const cmf::water::Solute &solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Solute "const
SoluteStorage& Solute(const cmf::water::Solute &solute) const ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::conc "real
conc(const cmf::water::Solute &solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::conc "WaterQuality conc(cmf::math::Time t)

Returns the current WaterQuality (concentration of all solutes). ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::conc "void
conc(const cmf::water::Solute &solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::water "real
water() const

Returns the volume of water in this storage in m3. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::water "void
water(real newwatercontent)

Sets the volume of water in this storage in m3. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::ToString "virtual std::string ToString() const ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Derivate "virtual real Derivate(const cmf::math::Time &time)

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::State "const
real& State() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::State "void
State(const real &newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::StateIsChanged
"bool StateIsChanged()

Returns if the state was currently updated. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::FluxTo "real
FluxTo(const FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::Waterbalance "real Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::sum_inflow "cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")  cmf::upslope::FlexibleSizeLayer::sum_outflow "cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";


// File: a00017.xml
%feature("docstring") cmf::upslope::FlexibleSizeSaturatedZone "

A soil water storage with a flexible (non constant) upper boundary,
according to its fill state. This soil water storage is always
saturated.

C++ includes: SoilWaterStorage.h ";

/*  Overrides of FluxNode  */

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::copy "virtual WaterStorage* copy() const ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::RecalcFluxes "virtual bool
RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::Empty
"virtual bool Empty() ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::UpperBoundary "virtual real
UpperBoundary()

Returns the current upper boundary of this layer (function of state).
";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::FlexibleSizeSaturatedZone "FlexibleSizeSaturatedZone(Cell &cell, real maximum_upperboundary, real
lowerboundary, const RetentionCurve &r_curve)

Creates two soilwaterstorages and registers them with the owning cell.
The boundary between the two layers is flexible and changes with
saturation. The lower layer is always saturated, the upper never. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::UpperBoundary "virtual
double UpperBoundary() const

Returns the upper boundary of the water storage below ground in m. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::LowerBoundary "virtual
double LowerBoundary() const

Returns the lower boundary of the water storage below ground in m. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::Thickness "double
Thickness() const ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::Soil "virtual const RetentionCurve& Soil() const

Returns the soil properties of the water storage. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::Soil "virtual RetentionCurve& Soil() ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::theta
"virtual real theta() const

Returns the actual volumetric water content of the water storage. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::theta
"virtual void theta(real Value) ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::K "double K() const

Returns the actual conductivity $\\\\frac{m}{day}$. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::Wetness "virtual double
Wetness() const

Returns the wetness of the soil $ \\\\frac{V_{H_2O}}{V_{pores}} $. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::MatrixPotential "virtual
real MatrixPotential() const

Calls RetentionCurve::Matrixpotential. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::GravitationalPotential "real
GravitationalPotential() const

Gravitational Potential in m, reference height is sea level \\\\[
\\\\Psi_G=h \\\\]. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::Capacity "virtual real
Capacity()

Returns the capacity of the water storage in m3. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::SetPotential "void
SetPotential(real waterhead)

Sets the potential of this soil water storage. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::Potential "virtual real
Potential() const

Returns the total potential in m \\\\[ \\\\Psi = \\\\Psi_M + \\\\Psi_G
\\\\]. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::Potential "virtual real
Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::copy "SoilWaterStorage* copy() ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::AddStateVariables "void
AddStateVariables(cmf::math::StateVariableVector &vector)

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::Solute
"SoluteStorage& Solute(const cmf::water::Solute &solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::Solute
"const SoluteStorage& Solute(const cmf::water::Solute &solute) const
";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::conc "real conc(const cmf::water::Solute &solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::conc "WaterQuality conc(cmf::math::Time t)

Returns the current WaterQuality (concentration of all solutes). ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::conc "void conc(const cmf::water::Solute &solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::water
"real water() const

Returns the volume of water in this storage in m3. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::water
"void water(real newwatercontent)

Sets the volume of water in this storage in m3. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::ToString "virtual
std::string ToString() const ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::Derivate "virtual real
Derivate(const cmf::math::Time &time)

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::State
"const real& State() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::State
"void State(const real &newState)

Gives access to the state variable. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::StateIsChanged "bool
StateIsChanged()

Returns if the state was currently updated. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::upslope::FlexibleSizeSaturatedZone::FluxTo
"real FluxTo(const FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::Waterbalance "real
Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::sum_inflow "cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")
cmf::upslope::FlexibleSizeSaturatedZone::sum_outflow "cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";


// File: a00608.xml
%feature("docstring") FluxConnection "";


// File: a00018.xml
%feature("docstring") cmf::water::FluxConnection "

Represents a connection between FluxNodes, where water fluxes occur.

C++ includes: FluxConnection.h ";

%feature("docstring")  cmf::water::FluxConnection::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::FluxConnection::Target "const
FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::water::FluxConnection::q "real q(const
FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::FluxConnection::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";

%feature("docstring")  cmf::water::FluxConnection::FluxConnection "FluxConnection(FluxNode &left, FluxNode &right)

Creates a flux connection between the FLuxNode left and right.

Parameters:
-----------

left:   FluxNode on the one side of the connection

right:   FluxNode on the other side of the connection ";

%feature("docstring")  cmf::water::FluxConnection::~FluxConnection "virtual ~FluxConnection() ";


// File: a00019.xml
%feature("docstring") cmf::water::FluxNode "

Base class for everything that can be connected by fluxes. Flux nodes
can be WaterStorages, flux end points, sinks, sources and bridges to
other model domains (e.g. Ponded water to river system). The base
class can be used where a simple routing, potentially with mixing, is
needed.

C++ includes: FluxConnection.h ";

%feature("docstring")  cmf::water::FluxNode::~FluxNode "virtual
~FluxNode()

The destructor deletes all connections. ";

%feature("docstring")  cmf::water::FluxNode::RecalcFluxes "virtual
bool RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")  cmf::water::FluxNode::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::water::FluxNode::FluxTo "real
FluxTo(const FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")  cmf::water::FluxNode::Waterbalance "real
Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")  cmf::water::FluxNode::sum_inflow "cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")  cmf::water::FluxNode::conc "virtual
cmf::water::WaterQuality conc(cmf::math::Time t)

Returns the water quality of the FluxNode, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf::water::FluxNode::sum_outflow "cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";

%feature("docstring")  cmf::water::FluxNode::Potential "virtual real
Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";

%feature("docstring")  cmf::water::FluxNode::Empty "virtual bool
Empty() ";

%feature("docstring")  cmf::water::FluxNode::copy "virtual FluxNode*
copy() const ";


// File: a00556.xml
%feature("docstring") std::fstream "

STL class. ";


// File: a00020.xml
%feature("docstring") cmf::math::Gears_Fixpoint "

An up to 4 step Gears-Method with fixpoint iteration, needs bug
fixing.

Derived from Roussel C. and Roussel M. (2003) \"Generic Object-
Oriented Differential Equation Integrators\", C/C++ User Journal, Nov.
2003,http://www.ddj.com/cpp/184401724?pgno=8

C++ includes: Gears_Fixpoint.h ";

/*  Internal data storages  */

/*  Time step management  */

%feature("docstring")  cmf::math::Gears_Fixpoint::Time_reduce_stage "int Time_reduce_stage() const

Returns int Stage oof time reduction. ";

/*  Gear functions: The following functions evaluate the Gear formulas
of specified order, loading the results into compareStates.  */

/*  Assessment of state variables for integration  */

%feature("docstring")  cmf::math::Gears_Fixpoint::States "cmf::math::StateVariableVector& States()

Returns the vector of StateVariable pointers. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::States "const
cmf::math::StateVariableVector& States() const ";

/*  model time  */

%feature("docstring")  cmf::math::Gears_Fixpoint::ModelTime "cmf::math::Time ModelTime() const

Returns the current model time. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::ModelTime "void
ModelTime(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::TimeStep "cmf::math::Time TimeStep() const

Returns the last time step. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::NextTimeStep "cmf::math::Time NextTimeStep() const

Returns the next time step width. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::NextTimeStep "void
NextTimeStep(cmf::math::Time val)

Sets the next time step width. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::MinTimestep "const
cmf::math::Time MinTimestep() const

Returns The minimal allowed time step length. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::Iterations "int
Iterations() const ";

%feature("docstring")  cmf::math::Gears_Fixpoint::ResetIterations "void ResetIterations() ";

/*  Integrate  */

%feature("docstring")  cmf::math::Gears_Fixpoint::Integrate "int
Integrate(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::Gears_Fixpoint::IntegrateUntil "void IntegrateUntil(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::Gears_Fixpoint::IntegrateUntil "void IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables until MaxTime. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::__call__ "void
__call__(cmf::math::Time until)

Calls IntegrateUntil. ";

/*  The state variables to integrate  */

/*  Accuracy parameters  */

%feature("docstring")  cmf::math::Gears_Fixpoint::AddStatesFromOwner "void AddStatesFromOwner(cmf::math::StateVariableOwner &stateOwner)

Adds the state variables of a StateVariableOwner to the state
variables of the solver. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::Gears_Fixpoint "Gears_Fixpoint(const StateVariableVector &states, real epsilon=1e-9,
cmf::math::Time tStepMin=Time::Seconds(10), int maxOrder=4)

Constructs a new Gears_Fixpoint from a pointer to a vector of state
variables.

The Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s)

maxOrder:  Maximum order of method (default=4) ";

%feature("docstring")  cmf::math::Gears_Fixpoint::Gears_Fixpoint "Gears_Fixpoint(real epsilon=1e-9, cmf::math::Time
tStepMin=Time::Seconds(10), int maxOrder=4)

Constructs a new Gears_Fixpoint.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s)

maxOrder:  Maximum order of method (default=4) ";

%feature("docstring")  cmf::math::Gears_Fixpoint::Gears_Fixpoint "Gears_Fixpoint(const Integrator &)

Copy constructor. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::Copy "virtual
Integrator* Copy() const

Returns a new Integrator, based on this (without the state variables),
e.g. same type, epsilon, model time etc. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::~Gears_Fixpoint "virtual ~Gears_Fixpoint() ";

%feature("docstring")  cmf::math::Gears_Fixpoint::Integrate "int
Integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed timestep, and changes it into the
effictivly used timestep according to the local stiffness of the
problem and MaxTime ";

%feature("docstring")  cmf::math::Gears_Fixpoint::count "int count()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::Gears_Fixpoint::state "const real&
state(int position) const

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::Gears_Fixpoint::state "void
state(int position, real newState)

Simplifies the assessment of state variables. ";


// File: a00613.xml
%feature("docstring") cmf::river::georeach "";

/*  Topological relation to other reaches  */

%feature("docstring")  cmf::river::georeach::Upstreams "cmf::river::reachvector& Upstreams()

Returns A collection of Reaches, directly contributing to this. ";

%feature("docstring")  cmf::river::georeach::Upstreams "const
cmf::river::reachvector& Upstreams() const

Returns A collection of Reaches, directly contributing to this. ";

%feature("docstring")  cmf::river::georeach::DownStream "cmf::river::reach* DownStream()

Returns cmf::river::reach* (DownStream). ";

/*  Overrides of FluxNode  */

%feature("docstring")  cmf::river::georeach::RecalcFluxes "virtual
bool RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")  cmf::river::georeach::Empty "virtual bool
Empty() ";

%feature("docstring")  cmf::river::georeach::copy "virtual
WaterStorage* copy() const ";

%feature("docstring")  cmf::river::georeach::AddPart "void
AddPart(double x, double y, double z)

Adds a part o the reach. ";

%feature("docstring")  cmf::river::georeach::Line "const
cmf::geometry::Line& Line() const

Returns the vertices of the reach. ";

%feature("docstring")  cmf::river::georeach::georeach "georeach(cmf::geometry::point start, double hMin, ReachType
*typeOfReach=0)

Creates a root reach.

Parameters:
-----------

start:  Position of the first reach vertex

hMin:  Lowest height of the reach

typeOfReach:  the channel geometry ";

%feature("docstring")  cmf::river::georeach::georeach "georeach(reach
*downstream, cmf::geometry::point start, double hMin, ReachType
*typeOfReach=0)

Create a reach with a downstream connection.

Parameters:
-----------

downstream:  The downstream connected reach

start:  Position of the first vertex of the reach

hMin:  the height of the outlet reach

typeOfReach:  the channel geometry ";

%feature("docstring")  cmf::river::georeach::~georeach "virtual
~georeach() ";

%feature("docstring")  cmf::river::georeach::Type "const
cmf::river::ReachType& Type() const

Properties of the reach.

A const reference to the type of the reach ";

%feature("docstring")  cmf::river::georeach::Length "double Length()
const ";

%feature("docstring")  cmf::river::georeach::AddPart "void
AddPart(double val, double hMax) ";

%feature("docstring")  cmf::river::georeach::Slope "double Slope()
const

Returns the avg. slope of the reach. ";

%feature("docstring")  cmf::river::georeach::Volume "real Volume() ";

%feature("docstring")  cmf::river::georeach::GetQout "cmf::water::WaterFlux GetQout() ";

%feature("docstring")  cmf::river::georeach::Q_out "const
cmf::water::WaterFlux& Q_out(const cmf::math::Time &time) ";

%feature("docstring")  cmf::river::georeach::Q_in "const
cmf::water::WaterFlux& Q_in(const cmf::math::Time &time) ";

%feature("docstring")  cmf::river::georeach::Derivate "real
Derivate(const cmf::math::Time &time)

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::river::georeach::InsertReaches "void
InsertReaches(reachvector &target)

Inserts this and all upstream reaches into target. ";

%feature("docstring")  cmf::river::georeach::GetAllReaches "reachvector GetAllReaches()

returns a reachvector with all reaches (not only the root reaches) ";

%feature("docstring")  cmf::river::georeach::AddStateVariables "void
AddStateVariables(cmf::math::StateVariableVector &vector)

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::river::georeach::Solute "SoluteStorage&
Solute(const cmf::water::Solute &solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::river::georeach::Solute "const
SoluteStorage& Solute(const cmf::water::Solute &solute) const ";

%feature("docstring")  cmf::river::georeach::conc "real conc(const
cmf::water::Solute &solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::river::georeach::conc "WaterQuality
conc(cmf::math::Time t)

Returns the current WaterQuality (concentration of all solutes). ";

%feature("docstring")  cmf::river::georeach::conc "void conc(const
cmf::water::Solute &solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::river::georeach::water "real water()
const

Returns the volume of water in this storage in m3. ";

%feature("docstring")  cmf::river::georeach::water "void water(real
newwatercontent)

Sets the volume of water in this storage in m3. ";

%feature("docstring")  cmf::river::georeach::ToString "virtual
std::string ToString() const ";

%feature("docstring")  cmf::river::georeach::State "const real&
State() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::river::georeach::State "void State(const
real &newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::river::georeach::StateIsChanged "bool
StateIsChanged()

Returns if the state was currently updated. ";

%feature("docstring")  cmf::river::georeach::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::river::georeach::FluxTo "real
FluxTo(const FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")  cmf::river::georeach::Waterbalance "real
Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")  cmf::river::georeach::sum_inflow "cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")  cmf::river::georeach::sum_outflow "cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";

%feature("docstring")  cmf::river::georeach::Potential "virtual real
Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";


// File: a00021.xml
%feature("docstring") cmf::upslope::vegetation::HargreaveVegetation "

A Vegetation class with real Temperature and Precipitation data, ETpot
by Hargreave method.

The step size of the time series has to be constant Values between
data points are linear interpolated ETpot=Hargreaves(T [deg
C],Latitude [deg])

Pthroughfall = 0.8 Pbulk

C++ includes: HargreaveVegetation.h ";

/*  Time dependent water flux information  */

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::GetThroughfall "virtual cmf::water::WaterFlux GetThroughfall(cmf::math::Time timestep)
const

Returns the Rate of precipitation entering the soil (precipitation -
interception) [mm/day], using CMFclassic approach. ";

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::GetETpot "virtual
double GetETpot(cmf::math::Time timestep) const

Returns the Evapotranspiration rate at a given time step [mm/day],
using hargreave equation. ";

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::GetTemperature "double
GetTemperature(cmf::math::Time timestep) const

Returns the air temperature at the timestep. ";

/*  Constructive methods  */

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::HargreaveVegetation "HargreaveVegetation(cmf::atmosphere::Meteorology *meteorology, double
refCropFactor=1, double rootdepth=0.5)

Creates a Vegetation with the Hargreave ETpot method.

Parameters:
-----------

meteorology:  The meteorological timeseries

refCropFactor:  Factor to scale ETpot to the landuse type. Factor of
one means reference crop (short grass)

rootdepth:  Depth of the rooted zone ";

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::copy "HargreaveVegetation* copy() const

Copies the vegetation. ";

/*  Root distribution  */

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::RootDepth "double
RootDepth() const

The depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::RootDepth "void
RootDepth(double val)

Sets the depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::RootDistribution "virtual double RootDistribution(double upperBoundary, double
lowerBoundary) const

Returns the relative amount of roots [0..1] in the given soil layer
This function assumes a uniform distribution of roots. ";

%feature("docstring")
cmf::upslope::vegetation::HargreaveVegetation::RootDistribution_Michealis_Menten
"virtual double RootDistribution_Michealis_Menten(double
upperBoundary, double lowerBoundary) const ";


// File: a00366.xml
%feature("docstring") cmf::upslope::HasCellReference "";

%feature("docstring")
cmf::upslope::HasCellReference::HasCellReference "HasCellReference(Cell &_cell) ";


// File: a00612.xml
%feature("docstring") cmf::upslope::snow::hbv_snow "";

%feature("docstring")  cmf::upslope::snow::hbv_snow::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::FluxTo "real
FluxTo(const FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::Waterbalance "real Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::sum_inflow "cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::conc "virtual
cmf::water::WaterQuality conc(cmf::math::Time t)

Returns the water quality of the FluxNode, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::sum_outflow "cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::Potential "virtual real Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::Empty "virtual
bool Empty() ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::copy "virtual
FluxNode* copy() const ";

%feature("docstring")  cmf::upslope::snow::hbv_snow::AddStateVariables
"virtual void AddStateVariables(cmf::math::StateVariableVector
&vector)=0

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";


// File: a00023.xml
%feature("docstring") cmf::geometry::Histogram "

Holds the histogram for a raster.

C++ includes: Raster.h ";

%feature("docstring")  cmf::geometry::Histogram::min "double min()
const

Returns the left side of the first histogram bar. ";

%feature("docstring")  cmf::geometry::Histogram::max "double max()
const

Returns the right side of the last histogram bar. ";

%feature("docstring")  cmf::geometry::Histogram::barwidth "double
barwidth() const

Returns the width of the histogram bars. ";

%feature("docstring")  cmf::geometry::Histogram::size "int size()
const

Returns the number of the historam bars. ";

%feature("docstring")  cmf::geometry::Histogram::sum "int sum(double
until=1e308) const

Returns the number of entries with a value <= until, default is the
total number of entries. ";

%feature("docstring")  cmf::geometry::Histogram::frequency "int
frequency(double val) const

Returns the frequency of values near val. ";

%feature("docstring")  cmf::geometry::Histogram::relfrequency "double
relfrequency(double val) const

Returns the relative frequency of values near val. ";

%feature("docstring")  cmf::geometry::Histogram::frequency "int
frequency(int pos) const

Returns the frequency of bar number pos. ";

%feature("docstring")  cmf::geometry::Histogram::relfrequency "double
relfrequency(int pos) const

Returns the relative frequency of bar number pos. ";

%feature("docstring")  cmf::geometry::Histogram::pos "int pos(double
val) const

Returns the bar number, that contains value val. ";

%feature("docstring")  cmf::geometry::Histogram::barcenter "double
barcenter(double pos) const

Returns the center of the bar at position pos. ";

%feature("docstring")  cmf::geometry::Histogram::quantile "double
quantile(double Quantile=0.5) const

Returns the inexact quantile. The result gets better with higher
numbers of bars Assumes the values of each bar uniformly distributed.
";

%feature("docstring")  cmf::geometry::Histogram::CountValue "void
CountValue(double val)

Counts a value in the histogram. ";

%feature("docstring")  cmf::geometry::Histogram::Histogram "Histogram(double _min, double _max, double _width)

Creates a histogram with bars ranging from _min to _max with a width
of width. ";

%feature("docstring")  cmf::geometry::Histogram::Histogram "Histogram(double _min, double _max, size_t _count)

Creates a histogram with count bars ranging from _min to _max. ";


// File: a00559.xml
%feature("docstring") std::ifstream "

STL class. ";


// File: a00024.xml
%feature("docstring") cmf::upslope::maps::IMap "

An interface, that provides a Get(x,y) function, that returns the
value or object at the given location (x,y) in planar coordinates, and
a Has(x,y) function the returns true, if an object exists at this
location The coordination system has to be the same as used for the
UpslopeCells, since no conversion between coordinate systems is
provided In Python the name resolves to IMap_* where * is one of the
following: Int, Float, Double, SoilType, SoilProfile, Vegetation,
Meteorology. The same convention applies to the following derived
classes.

C++ includes: maps.h ";

%feature("docstring")  cmf::upslope::maps::IMap::Get "_Ty
Get(cmf::geometry::point p)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::IMap::Get "_Ty Get(double
x, double y)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::IMap::Has "bool Has(double
x, double y) ";

%feature("docstring")  cmf::upslope::maps::IMap::Has "bool
Has(cmf::geometry::point p) ";

%feature("docstring")  cmf::upslope::maps::IMap::__call__ "_Ty
__call__(double x, double y) ";


// File: a00025.xml
%feature("docstring") cmf::math::ImplicitEuler "

An implicit (backward) Euler integrator using fixpoint iteration.

C++ includes: FixpointImplicitEuler.h ";

/*  Internal data storages  */

/*  Assessment of state variables for integration  */

%feature("docstring")  cmf::math::ImplicitEuler::States "cmf::math::StateVariableVector& States()

Returns the vector of StateVariable pointers. ";

%feature("docstring")  cmf::math::ImplicitEuler::States "const
cmf::math::StateVariableVector& States() const ";

/*  model time  */

%feature("docstring")  cmf::math::ImplicitEuler::ModelTime "cmf::math::Time ModelTime() const

Returns the current model time. ";

%feature("docstring")  cmf::math::ImplicitEuler::ModelTime "void
ModelTime(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::ImplicitEuler::TimeStep "cmf::math::Time TimeStep() const

Returns the last time step. ";

%feature("docstring")  cmf::math::ImplicitEuler::NextTimeStep "cmf::math::Time NextTimeStep() const

Returns the next time step width. ";

%feature("docstring")  cmf::math::ImplicitEuler::NextTimeStep "void
NextTimeStep(cmf::math::Time val)

Sets the next time step width. ";

%feature("docstring")  cmf::math::ImplicitEuler::MinTimestep "const
cmf::math::Time MinTimestep() const

Returns The minimal allowed time step length. ";

%feature("docstring")  cmf::math::ImplicitEuler::Iterations "int
Iterations() const ";

%feature("docstring")  cmf::math::ImplicitEuler::ResetIterations "void ResetIterations() ";

/*  Integrate  */

%feature("docstring")  cmf::math::ImplicitEuler::Integrate "int
Integrate(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::ImplicitEuler::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::ImplicitEuler::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables until MaxTime. ";

%feature("docstring")  cmf::math::ImplicitEuler::__call__ "void
__call__(cmf::math::Time until)

Calls IntegrateUntil. ";

/*  The state variables to integrate  */

/*  Accuracy parameters  */

%feature("docstring")  cmf::math::ImplicitEuler::AddStatesFromOwner "void AddStatesFromOwner(cmf::math::StateVariableOwner &stateOwner)

Adds the state variables of a StateVariableOwner to the state
variables of the solver. ";

%feature("docstring")  cmf::math::ImplicitEuler::ImplicitEuler "ImplicitEuler(const StateVariableVector &states, real epsilon=1e-9,
cmf::math::Time tStepMin=Time::Seconds(10))

Constructs a new FixPointImplicitEuler from a pointer to a vector of
state variables.

The Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::ImplicitEuler::ImplicitEuler "ImplicitEuler(real epsilon=1e-9, cmf::math::Time
tStepMin=Time::Seconds(10))

Constructs a new FixPointImplicitEuler.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::ImplicitEuler::ImplicitEuler "ImplicitEuler(const Integrator &)

Copy constructor. ";

%feature("docstring")  cmf::math::ImplicitEuler::Copy "virtual
Integrator* Copy() const

Returns a new Integrator, based on this (without the state variables),
e.g. same type, epsilon, model time etc. ";

%feature("docstring")  cmf::math::ImplicitEuler::Integrate "int
Integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed timestep, and changes it into the
effictivly used timestep according to the local stiffness of the
problem and MaxTime ";

%feature("docstring")  cmf::math::ImplicitEuler::count "int count()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::ImplicitEuler::state "const real&
state(int position) const

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::ImplicitEuler::state "void
state(int position, real newState)

Simplifies the assessment of state variables. ";


// File: a00026.xml
%feature("docstring") cmf::upslope::connections::Infiltration "

Connects the surfacewater and the unsaturated zone.

If UpslopeCell::InfiltrationExcess and Cell is not saturated \\\\[ K_I
= \\\\min\\\\left(\\\\frac{\\\\rho_{wg} \\\\Delta
z-\\\\Psi_M}{\\\\Delta z \\\\rho_{wg}}
K\\\\left(\\\\theta\\\\right),\\\\sum q_{surface\\\\ in}\\\\right)
\\\\] else \\\\[ K_I = \\\\sum q_{surface\\\\ in} \\\\]

C++ includes: FluxConnections.h ";

%feature("docstring")
cmf::upslope::connections::Infiltration::Infiltration "Infiltration(cmf::upslope::SoilWaterStorage &soilwater, FluxNode
&surfacewater) ";

%feature("docstring")  cmf::upslope::connections::Infiltration::q "real q(const FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::connections::Infiltration::Target
"FluxNode& Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::connections::Infiltration::Target
"const FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::upslope::connections::Infiltration::conc "WaterQuality conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00027.xml
%feature("docstring") cmf::math::Integrator "

Base class for any kind of integrator.

Pure virtual functions: Integrate

Copy Please provide a custom copy constructorTodo Put the methods of
StateVariableVector here, and delete StateVariableVector

C++ includes: Integrator.h ";

/*  The state variables to integrate  */

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::Integrator::ModelTime "cmf::math::Time ModelTime() const

Returns the current model time. ";

%feature("docstring")  cmf::math::Integrator::ModelTime "void
ModelTime(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::Integrator::TimeStep "cmf::math::Time TimeStep() const

Returns the last time step. ";

%feature("docstring")  cmf::math::Integrator::NextTimeStep "cmf::math::Time NextTimeStep() const

Returns the next time step width. ";

%feature("docstring")  cmf::math::Integrator::NextTimeStep "void
NextTimeStep(cmf::math::Time val)

Sets the next time step width. ";

%feature("docstring")  cmf::math::Integrator::MinTimestep "const
cmf::math::Time MinTimestep() const

Returns The minimal allowed time step length. ";

%feature("docstring")  cmf::math::Integrator::Iterations "int
Iterations() const ";

%feature("docstring")  cmf::math::Integrator::ResetIterations "void
ResetIterations() ";

/*  Assessment of state variables for integration  */

%feature("docstring")  cmf::math::Integrator::States "cmf::math::StateVariableVector& States()

Returns the vector of StateVariable pointers. ";

%feature("docstring")  cmf::math::Integrator::States "const
cmf::math::StateVariableVector& States() const ";

%feature("docstring")  cmf::math::Integrator::AddStatesFromOwner "virtual void AddStatesFromOwner(cmf::math::StateVariableOwner
&stateOwner)

Adds the state variables of a StateVariableOwner to the state
variables of the solver. ";

/*  Constructors and Destructors  */

%feature("docstring")  cmf::math::Integrator::Integrator "Integrator(const StateVariableVector &states, real epsilon=1e-9,
cmf::math::Time tStepMin=10.0/(3600.0 *24.0))

Constructs a new FixPointImplicitEuler from a pointer to a vector of
state variables.

The RKF Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::Integrator::Integrator "Integrator(real epsilon=1e-9, cmf::math::Time
tStepMin=Time::Seconds(10))

Constructs a new Integrator with a new own state vector.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::Integrator::Integrator "Integrator(const Integrator &forCopy)

Copy constructor, does not copy the state variables. ";

%feature("docstring")  cmf::math::Integrator::Copy "virtual
cmf::math::Integrator* Copy() const =0

Returns a new Integrator, based on this (without the state variables),
e.g. same type, epsilon, model time etc. ";

/*  Integrate  */

%feature("docstring")  cmf::math::Integrator::Integrate "virtual int
Integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)=0

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed timestep, and changes it into the
effictivly used timestep according to the local stiffness of the
problem and MaxTime ";

%feature("docstring")  cmf::math::Integrator::Integrate "int
Integrate(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::Integrator::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::Integrator::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables until MaxTime. ";

%feature("docstring")  cmf::math::Integrator::__call__ "void
__call__(cmf::math::Time until)

Calls IntegrateUntil. ";

%feature("docstring")  cmf::math::Integrator::count "int count()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::Integrator::state "const real&
state(int position) const

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::Integrator::state "void state(int
position, real newState)

Simplifies the assessment of state variables. ";


// File: a00614.xml
%feature("docstring") std::invalid_argument "

STL class. ";


// File: a00564.xml
%feature("docstring") std::ios "

STL class. ";


// File: a00615.xml
%feature("docstring") std::ios_base "

STL class. ";


// File: a00605.xml
%feature("docstring") std::ios_base::failure "

STL class. ";


// File: a00569.xml
%feature("docstring") std::istream "

STL class. ";


// File: a00571.xml
%feature("docstring") std::istringstream "

STL class. ";


// File: a00028.xml
%feature("docstring") cmf::upslope::vegetation::IVegetation "

The abstract base class for all kinds of vegetations. Derivate classes
must override the GetETpot and GetThroughfall functions.

C++ includes: Vegetation.h ";

/*  Root distribution  */

%feature("docstring")
cmf::upslope::vegetation::IVegetation::RootDepth "double RootDepth()
const

The depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::IVegetation::RootDepth "void
RootDepth(double val)

Sets the depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::IVegetation::RootDistribution "virtual
double RootDistribution(double upperBoundary, double lowerBoundary)
const

Returns the relative amount of roots [0..1] in the given soil layer
This function assumes a uniform distribution of roots. ";

%feature("docstring")
cmf::upslope::vegetation::IVegetation::RootDistribution_Michealis_Menten
"virtual double RootDistribution_Michealis_Menten(double
upperBoundary, double lowerBoundary) const ";

%feature("docstring")  cmf::upslope::vegetation::IVegetation::GetETpot
"virtual double GetETpot(cmf::math::Time timestep) const =0

Returns the Evapotranspiration rate at a given time step [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::IVegetation::GetThroughfall "virtual
cmf::water::WaterFlux GetThroughfall(cmf::math::Time timestep) const
=0

Returns the Rate of precipitation entering the soil (precipitation -
interception) [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::IVegetation::GetTemperature "virtual double
GetTemperature(cmf::math::Time timestep) const =0

Returns the air temperature at the timestep. ";

%feature("docstring")  cmf::upslope::vegetation::IVegetation::copy "virtual IVegetation* copy() const =0

Pure virtual method, to copy the current vegetation. ";


// File: a00029.xml
%feature("docstring") cmf::math::Jacobian "

Calculates the jacobian of a system (a vector of state variables).

Code is inspired by RADAU5 method from Hairer E,Wanner G (1991)
Solving Ordinary Differential Equations II, Springer-Verlag

C++ includes: Jacobian.h ";

%feature("docstring")  cmf::math::Jacobian::Jacobian "Jacobian() ";

%feature("docstring")  cmf::math::Jacobian::Calculate "void
Calculate(StateVariableVector &vector, const cmf::math::Time
&timestep)

Calculates the jacobian for a given system at a given time step. ";

%feature("docstring")  cmf::math::Jacobian::ToFile "void
ToFile(std::string filename)

Saves the matrix in an undocumented file. Cols are tab seperated, rows
are ended with endl. ";

%feature("docstring")  cmf::math::Jacobian::~Jacobian "~Jacobian() ";


// File: a00593.xml
%feature("docstring") cmf::upslope::layered::LayeredCellBuilder "";

%feature("docstring")
cmf::upslope::layered::LayeredCellBuilder::LayeredCellBuilder "LayeredCellBuilder(cmf::upslope::maps::IMap<
cmf::upslope::vegetation::IVegetation * > *vegetationMap,
cmf::upslope::maps::IMap< cmf::upslope::SoilProfile > *soilMap,
cmf::upslope::maps::IMap< float > *soilDepthMap=0) ";

%feature("docstring")
cmf::upslope::layered::LayeredCellBuilder::CreateCell "cmf::upslope::UpslopeCell* CreateCell(cmf::geometry::point p, double
Area) const ";

%feature("docstring")
cmf::upslope::layered::LayeredCellBuilder::CreateCell "cmf::upslope::UpslopeCell* CreateCell(double x, double y, double z,
double Area) const ";


// File: a00616.xml
%feature("docstring") std::length_error "

STL class. ";


// File: a00617.xml
%feature("docstring") cmf::geometry::Line "";

%feature("docstring")  cmf::geometry::Line::Center "point Center()
const

returns the point in the middle of the line ";

%feature("docstring")  cmf::geometry::Line::PointOnLine "point
PointOnLine(double d) const

returns the point in the distance d from the start point on the line
";

%feature("docstring")  cmf::geometry::Line::Length "double Length()
const ";

%feature("docstring")  cmf::geometry::Line::AsWKT "std::string
AsWKT() const

returns the Well-Known-Text of aline with the vertices of this vector
";

%feature("docstring")  cmf::geometry::Line::AddPoint "void
AddPoint(point p)

Adds a point to the shape. ";

%feature("docstring")  cmf::geometry::Line::AddPoint "void
AddPoint(double x, double y, double z=0) ";

%feature("docstring")  cmf::geometry::Line::RemovePoint "void
RemovePoint(int pos) ";

%feature("docstring")  cmf::geometry::Line::size "int size() const ";

%feature("docstring")  cmf::geometry::Line::Vertex "point Vertex(int
i) const ";

%feature("docstring")  cmf::geometry::Line::Vertices "Points
Vertices() const ";

%feature("docstring")  cmf::geometry::Line::MaxStraight "Line
MaxStraight() const

Returns the longest straight line between two vertices of the shape.
";

%feature("docstring")  cmf::geometry::Line::boundingbox "BoundingBox
boundingbox() ";


// File: a00030.xml
%feature("docstring") cmf::water::reaction::LinearReaction "

A simple reaction with a constant linear change of the concentration.
If the constant range is $ 1\\\\frac{mol}{m^3\\\\ day}$ and the
rainfall deposition is 0, the concentration in each state equals the
time the water stayed in the system in days.

C++ includes: Reaction.h ";


// File: a00619.xml
%feature("docstring") std::list "

STL class. ";


// File: a00620.xml
%feature("docstring") std::list::const_iterator "

STL iterator class. ";


// File: a00621.xml
%feature("docstring") std::list::const_reverse_iterator "

STL iterator class. ";


// File: a00622.xml
%feature("docstring") std::list::iterator "

STL iterator class. ";


// File: a00623.xml
%feature("docstring") std::list::reverse_iterator "

STL iterator class. ";


// File: a00606.xml
%feature("docstring") std::logic_error "

STL class. ";


// File: a00625.xml
%feature("docstring") std::map "

STL class. ";


// File: a00626.xml
%feature("docstring") std::map::const_iterator "

STL iterator class. ";


// File: a00627.xml
%feature("docstring") std::map::const_reverse_iterator "

STL iterator class. ";


// File: a00628.xml
%feature("docstring") std::map::iterator "

STL iterator class. ";


// File: a00629.xml
%feature("docstring") std::map::reverse_iterator "

STL iterator class. ";


// File: a00031.xml
%feature("docstring") cmf::atmosphere::Meteorology "

In order to calculate ETpot with cmf a big amount of meteorological
data is needed, more data than usually available. The Meteorology
class can estimate missing data from a minimal set. As more data, as
one provides, the better the calculation of ETpot becomes. The minimal
data needed is Tmin and Tmax (daily) and precipitation. To calculate
the global radiation (although measured global radiation could be
inserted), the position of meteorological station in geographic
coordinates has to be set.

There are two modes for the meteorology: daily=true and daily=false.
If daily=true, Radiation is given as a daily mean value. If
daily=false, Radiation is given as an hourly mean value, which shows
the dial ETpot variation but results in erronous results if the
timestep is daily.

In the following, we will assume a meteorological station with given
Tmin, Tmax, precipitation and daily mean relative humidity. To use
other meteorological data, please consult the description of the
Meteorology class in the API documentationCreating a meteorological
station

import CMFlib as cmf                  latitude=51.2 # Latitude of
station in decimal degrees                  longitude=8.1 # Longitude
of station in decimal degrees (only needed for daily=false) timezone=1
# Timezone, pos. values mean east of GMT, negative west (Germany=1,
Pacific time=-8, only needed for daily=false) start=cmf.Time(1,1,2001)
# Creates all timeseries with this start time, one can change them
later                  step=cmf.day # s. start
name=\"Giessen\"           # A name for the station (optional)
meteo=cmf.Meteorology(latitude,longitude,timezone,start,step,name)

The daily flag is automatically set to true, since the step width is
&ge cmf.dayLoading data into the meteorological station

# MeteoData.txt is tab seperated file containing # Tmin [deg C],Tmax
[deg C],rHmean [%] and precipitation [mm/day] values for every day
f=file('MeteoData.txt') for line in file:
meteo.Tmin.Add(float(line.split('\\\\t')[0]))
meteo.Tmax.Add(float(line.split('\\\\t')[1]))
meteo.rHmean.Add(float(line.split('\\\\t')[2]))
meteo.Prec.Add(float(line.split('\\\\t')[3]))Using a meteorological
station

weather=meteo.GetData(cmf.Time(3,2,2001,14)) # Weather at Feb. 3rd,
2001, 2pm                  print 'Global Radiation: ',weather.Rs
# Daily mean Rs, since daily=true print 'Temperature:',weather.T
# Daily mean T, since nothing else in known

C++ includes: Meteorology.h ";

/*  Location and behaviour properties  */

/*  Additional properties  */

/*  Timeseries of meteorological data  */

%feature("docstring")  cmf::atmosphere::Meteorology::GetDeposition "cmf::water::WaterFlux GetDeposition(cmf::math::Time t)

Returns the rainfall with its current concentration. The concentration
is derived from Deposition. ";

/*  Data access methods  */

%feature("docstring")  cmf::atmosphere::Meteorology::GetData "Weather
GetData(cmf::math::Time t, double height) const

Returns the current Atmosphere state. Uses default values for missing
timeseries. ";

%feature("docstring")  cmf::atmosphere::Meteorology::GetRs "double
GetRs(cmf::math::Time t, double height, double sunshine_fraction)
const

Returns the global radiation at a given time step $ R_s
\\\\frac{MJ}{m^2day}$,
seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
\\\\begin{eqnarray*} \\\\phi &=& \\\\frac{(\\\\mbox{geogr.
Latitude})^\\\\circ \\\\pi}{180^\\\\circ} \\\\mbox{ Latitude in }rad
\\\\\\\\ \\\\delta &=& 0.409 \\\\sin\\\\left(\\\\frac{2\\\\pi}{365}DOY
- 1.39\\\\right) \\\\mbox{ Declination, DOY is day of year}\\\\\\\\
\\\\omega_s &=& \\\\arccos(-\\\\tan\\\\phi\\\\tan\\\\delta) \\\\mbox{
Sunset angle} \\\\\\\\ G_{sc} &=& 0.0802 \\\\frac{MJ}{m^2min}
\\\\mbox{Solar constant} \\\\\\\\ d_r &=& 1+0.033
\\\\cos\\\\left(\\\\frac{2\\\\pi}{365}DOY\\\\right) \\\\mbox{Inverse
relative distance Earth-Sun} \\\\\\\\ b &=&
\\\\frac{2\\\\pi(DOY-81)}{364}\\\\\\\\ S_c &=&
0.1645\\\\sin(2b)-0.1255\\\\cos(b)-0.025\\\\sin(b) \\\\mbox{ Seasonal
correction for solar time} \\\\\\\\ \\\\omega &=& \\\\frac {\\\\pi}
{12} \\\\left(t_h+\\\\frac{(\\\\mbox{geogr.
Longitude})^\\\\circ}{15}-\\\\mbox{Timezone}+S_c-12\\\\right)
\\\\mbox{ solar time in }rad \\\\\\\\ \\\\mbox{If daily} \\\\\\\\ R_a
&=& \\\\frac{24\\\\ 60}{\\\\pi}G_{sc}\\\\ d_r \\\\left(\\\\omega_s
\\\\sin\\\\phi \\\\sin\\\\delta + \\\\cos\\\\phi \\\\cos\\\\delta
\\\\sin\\\\omega_s\\\\right) \\\\mbox{Extraterrestrial radiation }
\\\\frac{MJ}{m^2 day} \\\\\\\\ \\\\mbox{If hourly} \\\\\\\\ R_a &=&
\\\\frac{12\\\\ 24\\\\ 60}{\\\\pi}G_{sc}\\\\ d_r
\\\\left(\\\\left(\\\\omega^+ -\\\\omega^-\\\\right) \\\\sin\\\\phi
\\\\sin\\\\delta + \\\\cos\\\\phi \\\\cos\\\\delta
\\\\left(\\\\sin\\\\omega^+ - \\\\sin\\\\omega^-\\\\right)\\\\right)
\\\\\\\\ && \\\\omega^+,\\\\omega^- = \\\\omega
\\\\pm\\\\frac{\\\\pi}{24} \\\\\\\\ \\\\frac n N &=&
\\\\mbox{Fractional sunshine duration} \\\\\\\\ R_s &=&
\\\\left(0.25+\\\\left(0.5+2\\\\
10^{-5}z\\\\right)\\\\frac{n}{N}\\\\right)R_a \\\\mbox{Global
radiation in }\\\\frac{MJ}{m^2 day} \\\\\\\\ && z=\\\\mbox{Height
a.s.l. in }m \\\\\\\\ \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::atmosphere::Meteorology::GetRn "double
GetRn(double albedo, double Rs, double Tmax, double Tmin, double T,
double e_a, double sunshine_fraction) const ";

%feature("docstring")  cmf::atmosphere::Meteorology::GetRn "double
GetRn(double albedo, Weather w)

Returns the net radiation flux at a site,
seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
\\\\begin{eqnarray*} R_{ns} &=& (1-\\\\alpha)R_s \\\\mbox{ Net
shortwave radiation in } \\\\frac{MJ}{m^2 day} \\\\\\\\ && \\\\alpha =
\\\\mbox{ Albedo} \\\\\\\\ \\\\sigma &=& 4.903\\\\ 10^{-9}
\\\\frac{MJ}{m^2 K^4 day} \\\\mbox{ Stefan-Boltzmann constant}\\\\\\\\
\\\\sigma T^4 &=&
\\\\sigma\\\\left((T_{max}+273.16)^4+(T_{min}+273.16)^4\\\\right)
\\\\mbox{ if daily} \\\\\\\\ \\\\sigma T^4 &=& \\\\sigma
\\\\left(T+273.16\\\\right)^4 \\\\mbox{ if hourly} \\\\\\\\
R_{nl}&=&\\\\sigma(T) \\\\left(0.34-0.14\\\\sqrt{e_a}\\\\right)
\\\\left(0.1+0.9\\\\frac{n}{N}\\\\right) \\\\\\\\ R_n&=& R_{ns}-R_{nl}
\\\\\\\\ \\\\end{eqnarray*}.

Parameters:
-----------

albedo:  Albedo of the surface $\\\\alpha$

w:  A Weather structure provided from GetData ";

%feature("docstring")
cmf::atmosphere::Meteorology::SetSunshineFraction "void
SetSunshineFraction(cmf::math::timeseries sunshine_duration) const

Calculates a timeseries of the sunshine fraction (to put into
Sunshine) from a timeseries of absolute sunshine duration, using the
potential sunshine duration in hours,
seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
\\\\begin{eqnarray*} \\\\phi &=& \\\\frac{(\\\\mbox{geogr.
Latitude})^\\\\circ \\\\pi}{180^\\\\circ} \\\\mbox{ Latitude in }rad
\\\\\\\\ \\\\delta &=& 0.409 \\\\sin\\\\left(\\\\frac{2\\\\pi}{365}DOY
- 1.39\\\\right) \\\\mbox{ Declination, DOY is day of year}\\\\\\\\
\\\\omega_s &=& \\\\arccos(-\\\\tan\\\\phi\\\\tan\\\\delta) \\\\mbox{
Sunset angle} \\\\\\\\ N &=& \\\\frac{24}{\\\\pi}\\\\omega_s \\\\mbox{
potential duration of sunshine in }h \\\\\\\\ \\\\frac n N &&
n\\\\mbox{Absolute sunshine duration} \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::atmosphere::Meteorology::Pressure "static
double Pressure(double height)

Calculates the mean pressure for a specific height. ";

/*  I/O  */

%feature("docstring")  cmf::atmosphere::Meteorology::Save "void
Save(const std::string &filename)

Save the Meteorology data to an ASCII File with fixed format(
uses cmf::math::timeseries::Save ). ";

%feature("docstring")  cmf::atmosphere::Meteorology::Meteorology "Meteorology(const std::string &filename)

Creates a Meterology from a File in fixed format (uses
cmf::math::timeseries::timeseries(std::istream&) ). ";

%feature("docstring")  cmf::atmosphere::Meteorology::Meteorology "Meteorology(double latitude=51, double longitude=8, double timezone=1,
double elevation=0, cmf::math::Time startTime=cmf::math::Time(1, 1,
2001), cmf::math::Time timestep=cmf::math::day, std::string name=\"\")

Constructor of the Atmosphere object.

Parameters:
-----------

latitude:  Latitude of the study area (for solar radiation)

longitude:  Longitude of the study area (for solar time)

timezone:  Time zone of the study area (e.g Germany +1,U.S. Pacific
time -8

elevation:  Height of the meterological station above sea level [m]

startTime:  Date of the beginning of the climatic data (may be changed
for each time series later)

timestep:  Frequency of climatic data (may be changed for each time
series later)

name:  Name of the station ";


// File: a00032.xml
%feature("docstring") cmf::water::reaction::MichaelisMentenReaction "

A Michaelis Menten reaction without inhibitors.

C++ includes: Reaction.h ";

%feature("docstring")
cmf::water::reaction::MichaelisMentenReaction::ReactiveFlux "virtual
double ReactiveFlux(const WaterQuality &Environment)

Reactive flux: $ \\\\frac{d[X]}{dt}=\\\\frac{v_{max}\\\\ [X]}{K_m+[X]}
$. ";


// File: a00630.xml
%feature("docstring") std::multimap "

STL class. ";


// File: a00631.xml
%feature("docstring") std::multimap::const_iterator "

STL iterator class. ";


// File: a00632.xml
%feature("docstring") std::multimap::const_reverse_iterator "

STL iterator class. ";


// File: a00633.xml
%feature("docstring") std::multimap::iterator "

STL iterator class. ";


// File: a00634.xml
%feature("docstring") std::multimap::reverse_iterator "

STL iterator class. ";


// File: a00618.xml
%feature("docstring") cmf::geometry::MultiPoint "";

%feature("docstring")  cmf::geometry::MultiPoint::AddPoint "void
AddPoint(point p)

Adds a point to the shape. ";

%feature("docstring")  cmf::geometry::MultiPoint::AddPoint "void
AddPoint(double x, double y, double z=0) ";

%feature("docstring")  cmf::geometry::MultiPoint::RemovePoint "void
RemovePoint(int pos) ";

%feature("docstring")  cmf::geometry::MultiPoint::size "int size()
const ";

%feature("docstring")  cmf::geometry::MultiPoint::Vertex "point
Vertex(int i) const ";

%feature("docstring")  cmf::geometry::MultiPoint::Vertices "Points
Vertices() const ";

%feature("docstring")  cmf::geometry::MultiPoint::Center "point
Center() const ";

%feature("docstring")  cmf::geometry::MultiPoint::MaxStraight "Line
MaxStraight() const

Returns the longest straight line between two vertices of the shape.
";

%feature("docstring")  cmf::geometry::MultiPoint::AsWKT "std::string
AsWKT() const ";

%feature("docstring")  cmf::geometry::MultiPoint::boundingbox "BoundingBox boundingbox() ";

%feature("docstring")  cmf::geometry::MultiPoint::MultiPoint "MultiPoint() ";

%feature("docstring")  cmf::geometry::MultiPoint::MultiPoint "MultiPoint(const MultiPoint &copy) ";

%feature("docstring")  cmf::geometry::MultiPoint::MultiPoint "MultiPoint(const Points &copy) ";


// File: a00636.xml
%feature("docstring") std::multiset "

STL class. ";


// File: a00637.xml
%feature("docstring") std::multiset::const_iterator "

STL iterator class. ";


// File: a00638.xml
%feature("docstring") std::multiset::const_reverse_iterator "

STL iterator class. ";


// File: a00639.xml
%feature("docstring") std::multiset::iterator "

STL iterator class. ";


// File: a00640.xml
%feature("docstring") std::multiset::reverse_iterator "

STL iterator class. ";


// File: a00033.xml
%feature("docstring") cmf::upslope::maps::NearestNeighborMap "

Registers objects with locations and returns the nearest neighbor to
the queried location. Distance is measured as: $ d =
\\\\sqrt{(x1-x2)^2+(y1-y2)^2} + w_z|z1-z2| $ with wz is the weight
factor for height differences, zWeight. A high wz may be used for
contured object distribution, where $ \\\\sqrt{(x1-x2)^2+(y1-y2)^2} $
is small compared to $ w_z|z1-z2| $.

C++ includes: maps.h ";

%feature("docstring")  cmf::upslope::maps::NearestNeighborMap::Add "void Add(cmf::geometry::point p, _Ty value)

Adds a value at a location.

Parameters:
-----------

p:  location of value

value:  Value ";

%feature("docstring")  cmf::upslope::maps::NearestNeighborMap::Add "void Add(double x, double y, _Ty value)

Adds a value at a location.

Parameters:
-----------

x:  X-Value of location

y:  Y-Value of location

value:  Value ";

%feature("docstring")  cmf::upslope::maps::NearestNeighborMap::size "int size()

Returns the number of point value pairs in this map. ";

%feature("docstring")
cmf::upslope::maps::NearestNeighborMap::Position "cmf::geometry::point& Position(int index)

Returns the position of a value. ";

%feature("docstring")  cmf::upslope::maps::NearestNeighborMap::Value "_Ty Value(int index)

Returns one of the values. ";

%feature("docstring")
cmf::upslope::maps::NearestNeighborMap::NearestNeighborMap "NearestNeighborMap(double z_Weight=0) ";

%feature("docstring")  cmf::upslope::maps::NearestNeighborMap::Get "_Ty Get(cmf::geometry::point p)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::NearestNeighborMap::Get "_Ty Get(double x, double y)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::NearestNeighborMap::Has "bool Has(double x, double y) ";

%feature("docstring")  cmf::upslope::maps::NearestNeighborMap::Has "bool Has(cmf::geometry::point p) ";

%feature("docstring")
cmf::upslope::maps::NearestNeighborMap::__call__ "_Ty __call__(double
x, double y) ";


// File: a00034.xml
%feature("docstring") cmf::upslope::Neighbor "

Contains a reference to a cell and the width of the flow between
neighboring cells.

C++ includes: UpslopeCell.h ";

%feature("docstring")  cmf::upslope::Neighbor::Neighbor "Neighbor(UpslopeCell *cell, double flowwidth) ";

%feature("docstring")  cmf::upslope::Neighbor::Neighbor "Neighbor(const Neighbor &copy) ";


// File: a00035.xml
%feature("docstring") cmf::math::NevilleInterpolator "

Interpolates between known values (of type numVector ) at given points
in time. For a polynom interpolation, temporary variables for the y
values are needed. These variables (vectors) will be allocated
beforehand in the constructor. If various interpolations for the same
number of points and the same value space are done, costly new
allocation of memory will be avoided.

C++ includes: neville_interpolator.h ";

%feature("docstring")
cmf::math::NevilleInterpolator::NevilleInterpolator "NevilleInterpolator(int NumberOfPoints, int VectorSize)

Reserves temporary space for the temporary vectors. ";

%feature("docstring")  cmf::math::NevilleInterpolator::Interpolate "void Interpolate(const numVector *y[], const Time x[], Time t, int n,
numVector &_result)

Interpolates the missing values at position t from the n values y[] at
n positions x[] and copies them to _result No memory allocation needed
(despite a bit in the stack) if the sizes of the vectors and the
number of points are equal to the last call. ";

%feature("docstring")  cmf::math::NevilleInterpolator::Interpolate "numVector Interpolate(const numVector *y[], const Time x[], Time t,
int n)

Interpolates the missing values at position t from the n values y[] at
n positions x[] and returns them. ";


// File: a00036.xml
%feature("docstring") cmf::math::numVector "

A valarray kind of vector implementation with OpenMP capabilities.

C++ includes: numVector.h ";

/*  Constructors & Destructors  */

%feature("docstring")  cmf::math::numVector::numVector "numVector(int
count, real Value=0)

Creates a new vector with size count.

Parameters:
-----------

count:  size of new vector

Value:  Value of each element (default=0) ";

%feature("docstring")  cmf::math::numVector::numVector "numVector(size_t count, real Value=0) ";

%feature("docstring")  cmf::math::numVector::numVector "numVector()

Creates a vector of size 1 with value {0}. ";

%feature("docstring")  cmf::math::numVector::numVector "numVector(const numVector &Vector)

Copy constructor. ";

%feature("docstring")  cmf::math::numVector::numVector "numVector(const std::valarray< real > &Vector)

Convert from valarray<real>. ";

%feature("docstring")  cmf::math::numVector::~numVector "~numVector()

Destructor. ";

/*  Operators  */

/* Binary operators defined as free operators:

x = {+,-,*,/}

Defined for (x is one of the operators above): vector = vector x
vector

vector = real x vector

vector = vector x real

*/

%feature("docstring")  cmf::math::numVector::power "numVector
power(const numVector &) const

Return each element to the power of each element of vector. ";

%feature("docstring")  cmf::math::numVector::power "numVector
power(real exponent) const

Return each element to the power \"exponent\". ";

%feature("docstring")  cmf::math::numVector::apply "numVector
apply(real funct(real)) const

Return funct(this).

Parameters:
-----------

funct:  a function of signature real funct(real)

Example: Return the sinus of each element of vector x ";

/*  Summarizing functions  */

%feature("docstring")  cmf::math::numVector::dot "real dot(const
numVector &) const

Return dot product of this and vector. ";

%feature("docstring")  cmf::math::numVector::sum "real sum() const

Return sum of vector. ";

%feature("docstring")  cmf::math::numVector::max "real max() const

Return max of vector. ";

%feature("docstring")  cmf::math::numVector::min "real min() const

Return min of vector. ";

%feature("docstring")  cmf::math::numVector::norm "real norm(int
normtype=0) const

Returns a norm of the vector, implemented norms: 1 - sum of abs, 2 -
Euclidean distance, 0 Maximum of abs.

Parameters:
-----------

normtype:  An integer indicating the type of norm ";

%feature("docstring")  cmf::math::numVector::size "int size() const

Size of the vector. ";

%feature("docstring")  cmf::math::numVector::resize "void resize(int
count)

Changes the size of the vector. ";

%feature("docstring")  cmf::math::numVector::resize "void
resize(size_t count) ";


// File: a00574.xml
%feature("docstring") std::ofstream "

STL class. ";


// File: a00577.xml
%feature("docstring") std::ostream "

STL class. ";


// File: a00579.xml
%feature("docstring") std::ostringstream "

STL class. ";


// File: a00624.xml
%feature("docstring") std::out_of_range "

STL class. ";


// File: a00037.xml
%feature("docstring") cmf::upslope::connections::OutOfSoilConnection "

Calculates the flow between a soil layer and any FluxNode using
Richards equation. It uses the same formula as RichardsConnection but
the conductivity is determined by the soil side only.

C++ includes: FluxConnections.h ";

%feature("docstring")
cmf::upslope::connections::OutOfSoilConnection::q "real q(const
FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::OutOfSoilConnection::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::OutOfSoilConnection::Target "const
FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")
cmf::upslope::connections::OutOfSoilConnection::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00641.xml
%feature("docstring") std::overflow_error "

STL class. ";


// File: a00038.xml
%feature("docstring") cmf::upslope::ET::PenmanMonteithET "

Calculates the potential evapotranspiration according to FAO(1998)
\\\\begin{eqnarray*} \\\\lambda ET &=& \\\\frac{\\\\Delta\\\\left(R_n
- G\\\\right)+\\\\rho_a c_p \\\\frac{e_s - e_a}{r_a}}{\\\\Delta +
\\\\gamma\\\\left(1+\\\\frac{r_s}{r_a}\\\\right)} \\\\mbox{ FAO 1998,
Eq. 3} \\\\\\\\ \\\\mbox{With:} \\\\\\\\ \\\\Delta &=& 4098
\\\\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\\\frac{kPa}{^\\\\circ C}
\\\\mbox{ (FAO 1998, Eq. 13): Slope of vapor pressure } \\\\\\\\ T &=&
\\\\mbox{Actual Temperature in } ^\\\\circ C \\\\\\\\ R_n &=&
\\\\mbox{net Radiation (see Atmosphere) in } \\\\frac{MJ}{m^2day}
\\\\\\\\ G &=& 0 \\\\ \\\\frac{MJ}{m^2day} \\\\mbox{ if daily average
(FAO 1998, Eq. 42)} \\\\\\\\ && 0.1 R_n \\\\ \\\\mbox{ if day time
(FAO 1998, Eq. 45)} \\\\\\\\ && 0.5 R_n \\\\ \\\\mbox{ if night time
(FAO 1998, Eq. 46)} \\\\\\\\ \\\\gamma &=& \\\\frac{c_p P}{\\\\epsilon
\\\\lambda} \\\\mbox{ (FAO 1998,Eq. 8): Psychrometric constant }
\\\\frac{kPa}{^\\\\circ C} \\\\\\\\ c_p &=& 0.001013
\\\\frac{MJ}{kg\\\\ ^\\\\circ C}\\\\mbox{ specific heat at constant
pressure } \\\\\\\\ P &=& 101.3
\\\\left(\\\\frac{293-0.0065z}{293}\\\\right)^{5.26} \\\\mbox{ (FAO
1998,Eq. 7): Mean pressure kPa as a function of elevation above sea
level in m} \\\\\\\\ \\\\epsilon &=& 0.622 \\\\mbox{ ratio molecular
weight of water vapour/dry air} \\\\\\\\ \\\\lambda &=& 2.45
\\\\frac{MJ}{kg} \\\\mbox{ (FAO 1998,Eq. 8): latent heat of
vaporization} \\\\\\\\ R &=& 0.287 \\\\frac{kJ}{kg\\\\ k}\\\\mbox{
Specific gas constant } \\\\\\\\ \\\\rho_a &=&
\\\\frac{P}{1.01(T+273)R} \\\\mbox{ (FAO 1998,Box. 6): Mean air
density at constant pressure} \\\\\\\\ e_s &=& \\\\mbox{ Saturated
vapor pressure (see Atmosphere) in } kPa \\\\\\\\ e_a &=& \\\\mbox{
Actual vapor pressure (see Atmosphere) in } kPa \\\\\\\\ r_a &=&
\\\\frac{\\\\ln\\\\left(\\\\frac{2-d}{z_{om}}\\\\right)\\\\ln\\\\left(\\\\frac{2-d}{z_{oh}}\\\\right)}{k^2
u_2} \\\\mbox{ (FAO 1998, Eq. 4/Box 4): Aerodynamic resitance in }
\\\\frac s m \\\\\\\\ && d=\\\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1
z_{om}, k=0.41 \\\\\\\\ h &=& \\\\mbox{ Vegetation height in }m
\\\\\\\\ u_2 &=& \\\\mbox{ Windspeed in 2m above ground (see
Atmosphere) } \\\\frac m s \\\\\\\\ r_s &=&
\\\\frac{r_l}{LAI_{Active}} \\\\mbox{ (FAO 1998, Eq. 5/Box 5): bulk
surface resistance} \\\\frac s m \\\\\\\\ && r_l=100 \\\\frac s m,
LAI_{Active}=0.5 LAI \\\\end{eqnarray*}.

C++ includes: ET.h ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::GetETpot "real GetETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::r_a "real
r_a(cmf::atmosphere::Weather A) const ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::r_s "real
r_s() const ";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::PenmanMonteithET "PenmanMonteithET(cmf::upslope::SoilWaterStorage &source,
cmf::water::FluxNode &ET_target, cmf::upslope::vegetation::Vegetation
&VegetationAttributes, cmf::atmosphere::Meteorology &meteo) ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::q "real
q(const FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::Target "FluxNode& Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::Target "const FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::conc "WaterQuality conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00039.xml
%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation "

An implementation of IVegetation using the Penman-Monteith
transpiration model, according to: FAO (1998): Crop evapotranspiration
- Guidelines for computing crop water requirements - FAO Irrigation
and drainage paper 56 ISBN 92-5-104219-5,
URL:http://www.fao.org/docrep/X0490E/x0490e00.HTM.

C++ includes: PenmanMonteithVegetation.h ";

/*  Root distribution  */

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::RootDepth "double
RootDepth() const

The depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::RootDepth "void
RootDepth(double val)

Sets the depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::RootDistribution "virtual double RootDistribution(double upperBoundary, double
lowerBoundary) const

Returns the relative amount of roots [0..1] in the given soil layer
This function assumes a uniform distribution of roots. ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::RootDistribution_Michealis_Menten
"virtual double RootDistribution_Michealis_Menten(double
upperBoundary, double lowerBoundary) const ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::PenmanMonteithVegetation
"PenmanMonteithVegetation(cmf::atmosphere::Meteorology *atm, double
rootdepth=1., double vegetationheight=0.12, double _LAI=2.88, double
Albedo=0.23, double StomatalResistance=100.0)

Constructs a Penman-Monteith-Vegetation. Prerequisite: An
cmf::atmosphere::Atmosphere.

Parameters:
-----------

atm:  Reference to atmospheric data

rootdepth:  Root depth

vegetationheight:  Height of the vegetation above ground in m

_LAI:  Leave area index in $ \\\\frac{m^2 \\\\mbox{leaves}}{m^2
\\\\mbox{ground}} $

Albedo:  Albedo of the vegetation

StomatalResistance:  Stomatal resistance in $ \\\\frac s m$ ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::copy "PenmanMonteithVegetation* copy() const

Pure virtual method, to copy the current vegetation. ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::GetAtmosphereData
"cmf::atmosphere::Weather GetAtmosphereData(cmf::math::Time t) ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::GetAtmosphereData
"cmf::atmosphere::Weather GetAtmosphereData(cmf::math::Time t) const
";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::GetThroughfall "cmf::water::WaterFlux GetThroughfall(cmf::math::Time timestep) const

Returns the Rate of precipitation entering the soil (precipitation -
interception) [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::GetETpot "double
GetETpot(cmf::math::Time timestep) const

Calculates the potential evapotranspiration according to FAO(1998)
\\\\begin{eqnarray*} \\\\lambda ET &=& \\\\frac{\\\\Delta\\\\left(R_n
- G\\\\right)+\\\\rho_a c_p \\\\frac{e_s - e_a}{r_a}}{\\\\Delta +
\\\\gamma\\\\left(1+\\\\frac{r_s}{r_a}\\\\right)} \\\\mbox{ FAO 1998,
Eq. 3} \\\\\\\\ \\\\mbox{With:} \\\\\\\\ \\\\Delta &=& 4098
\\\\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\\\frac{kPa}{^\\\\circ C}
\\\\mbox{ (FAO 1998, Eq. 13): Slope of vapor pressure } \\\\\\\\ T &=&
\\\\mbox{Actual Temperature in } ^\\\\circ C \\\\\\\\ R_n &=&
\\\\mbox{net Radiation (see Atmosphere) in } \\\\frac{MJ}{m^2day}
\\\\\\\\ G &=& 0 \\\\ \\\\frac{MJ}{m^2day} \\\\mbox{ if daily average
(FAO 1998, Eq. 42)} \\\\\\\\ && 0.1 R_n \\\\ \\\\mbox{ if day time
(FAO 1998, Eq. 45)} \\\\\\\\ && 0.5 R_n \\\\ \\\\mbox{ if night time
(FAO 1998, Eq. 46)} \\\\\\\\ \\\\gamma &=& \\\\frac{c_p P}{\\\\epsilon
\\\\lambda} \\\\mbox{ (FAO 1998,Eq. 8): Psychrometric constant }
\\\\frac{kPa}{^\\\\circ C} \\\\\\\\ c_p &=& 0.001013
\\\\frac{MJ}{kg\\\\ ^\\\\circ C}\\\\mbox{ specific heat at constant
pressure } \\\\\\\\ P &=& 101.3
\\\\left(\\\\frac{293-0.0065z}{293}\\\\right)^{5.26} \\\\mbox{ (FAO
1998,Eq. 7): Mean pressure kPa as a function of elevation above sea
level in m} \\\\\\\\ \\\\epsilon &=& 0.622 \\\\mbox{ ratio molecular
weight of water vapour/dry air} \\\\\\\\ \\\\lambda &=& 2.45
\\\\frac{MJ}{kg} \\\\mbox{ (FAO 1998,Eq. 8): latent heat of
vaporization} \\\\\\\\ R &=& 0.287 \\\\frac{kJ}{kg\\\\ K}\\\\mbox{
Specific gas constant } \\\\\\\\ \\\\rho_a &=&
\\\\frac{P}{1.01(T+273)R} \\\\mbox{ (FAO 1998,Box. 6): Mean air
density at constant pressure} \\\\\\\\ e_s &=& \\\\mbox{ Saturated
vapor pressure (see Atmosphere) in } kPa \\\\\\\\ e_a &=& \\\\mbox{
Actual vapor pressure (see Atmosphere) in } kPa \\\\\\\\ r_a &=&
\\\\frac{\\\\ln\\\\left(\\\\frac{2-d}{z_{om}}\\\\right)\\\\ln\\\\left(\\\\frac{2-d}{z_{oh}}\\\\right)}{k^2
u_2} \\\\mbox{ (FAO 1998, Eq. 4/Box 4): Aerodynamic resitance in }
\\\\frac s m \\\\\\\\ && d=\\\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1
z_{om}, k=0.41 \\\\\\\\ h &=& \\\\mbox{ Vegetation height in }m
\\\\\\\\ u_2 &=& \\\\mbox{ Windspeed in 2m above ground (see
Atmosphere) } \\\\frac m s \\\\\\\\ r_s &=&
\\\\frac{r_l}{LAI_{Active}} \\\\mbox{ (FAO 1998, Eq. 5/Box 5): bulk
surface resistance} \\\\frac s m \\\\\\\\ && r_l=100 \\\\frac s m,
LAI_{Active}=0.5 LAI \\\\end{eqnarray*}. ";

%feature("docstring")
cmf::upslope::vegetation::PenmanMonteithVegetation::GetTemperature "double GetTemperature(cmf::math::Time timestep) const

Returns the actual Temperature in deg C from the Meteorology. ";


// File: a00040.xml
%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation "

A periodic rainfall implementation of IVegetation.

C++ includes: Vegetation.h ";

/*  Root distribution  */

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::RootDepth "double RootDepth() const

The depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::RootDepth "void
RootDepth(double val)

Sets the depth of the rooted zone. ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::RootDistribution
"virtual double RootDistribution(double upperBoundary, double
lowerBoundary) const

Returns the relative amount of roots [0..1] in the given soil layer
This function assumes a uniform distribution of roots. ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::RootDistribution_Michealis_Menten
"virtual double RootDistribution_Michealis_Menten(double
upperBoundary, double lowerBoundary) const ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::copy "PeriodicRainfallVegetation* copy() const

Pure virtual method, to copy the current vegetation. ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::GetThroughfall "virtual cmf::water::WaterFlux GetThroughfall(cmf::math::Time timestep)
const

Returns the Rate of precipitation entering the soil (precipitation -
interception) [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::GetETpot "virtual double GetETpot(cmf::math::Time timestep) const

Returns the Evapotranspiration rate at a given time step [mm/day]. ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::GetTemperature "virtual double GetTemperature(cmf::math::Time timestep) const

Returns the air temperature at the timestep. ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::PeriodicRainfallVegetation
"PeriodicRainfallVegetation(cmf::water::WaterFlux AvgThroughfall,
double AvgEtPot, double freq, double duration, double Temperature=10)

Creates a new Periodic Rainfall vegetation.

Parameters:
-----------

AvgThroughfall:  Average throughfall in mm/d

AvgEtPot:  Potential ET in mm/d

freq:  Length of period in d

duration:  Length of single rainfall event in d

Temperature:  Constant air temperature in deg C ";

%feature("docstring")
cmf::upslope::vegetation::PeriodicRainfallVegetation::PeriodicRainfallVegetation
"PeriodicRainfallVegetation(const PeriodicRainfallVegetation
&forcopy) ";


// File: a00041.xml
%feature("docstring") cmf::geometry::point "

2D-Point Class.

Used as location property anywhere in the text Calculation of
distances

+,-,-=,*= Operators overloaded

C++ includes: geometry.h ";

%feature("docstring")  cmf::geometry::point::Center "point Center()
const ";

%feature("docstring")  cmf::geometry::point::point "point()

Empty Constructor. Creates an (0 0) location. ";

%feature("docstring")  cmf::geometry::point::point "point(const point
&p)

Copy Constructor. ";

%feature("docstring")  cmf::geometry::point::point "point(double x_,
double y_, double z_=0.0)

Creates a point from two doubles. ";

%feature("docstring")  cmf::geometry::point::distanceTo "double
distanceTo(point p) const

Returns the euclidian distance to another point.
$\\\\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}$. ";

%feature("docstring")  cmf::geometry::point::distance3DTo "double
distance3DTo(point p) const ";

%feature("docstring")  cmf::geometry::point::distance_max "double
distance_max(point p) const

Returns the distance by the maximum orthogonal offset. ";

%feature("docstring")  cmf::geometry::point::azimuth "double
azimuth(point p) const

Returns the azimuth angle of the line $ \\\\overline{this,p} $ to the
Azimuth in degrees. ";

%feature("docstring")  cmf::geometry::point::angleToXAxis "double
angleToXAxis(point p) const

Returns the angle between the line $ \\\\overline{this,p} $ to the
x-Axis in degrees. ";

%feature("docstring")  cmf::geometry::point::AsWKT "std::string
AsWKT() const ";

%feature("docstring")  cmf::geometry::point::Vertices "Points
Vertices() const ";

%feature("docstring")  cmf::geometry::point::Vertex "size_t Vertex()
const ";


// File: a00642.xml
%feature("docstring") cmf::geometry::Polygon "";

%feature("docstring")  cmf::geometry::Polygon::Area "double Area()
const ";

%feature("docstring")  cmf::geometry::Polygon::Center "cmf::geometry::point Center() const ";

%feature("docstring")  cmf::geometry::Polygon::size "size_t size()
const ";

%feature("docstring")  cmf::geometry::Polygon::AddPart "cmf::geometry::Ring& AddPart(const cmf::geometry::Ring &part) ";

%feature("docstring")  cmf::geometry::Polygon::AddPart "cmf::geometry::Ring& AddPart() ";

%feature("docstring")  cmf::geometry::Polygon::boundingbox "cmf::geometry::BoundingBox boundingbox() ";

%feature("docstring")  cmf::geometry::Polygon::Polygon "Polygon() ";

%feature("docstring")  cmf::geometry::Polygon::Polygon "Polygon(const
Polygon &copy) ";

%feature("docstring")  cmf::geometry::Polygon::Polygon "Polygon(const
cmf::geometry::Ring &copy) ";

%feature("docstring")  cmf::geometry::Polygon::Polygon "Polygon(const
cmf::geometry::BoundingBox &copy) ";

%feature("docstring")  cmf::geometry::Polygon::AsWKT "std::string
AsWKT() const ";

%feature("docstring")  cmf::geometry::Polygon::Includes "bool
Includes(cmf::geometry::point p) const ";

%feature("docstring")  cmf::geometry::Polygon::Includes "bool
Includes(cmf::geometry::point p)

returns true if p lies in the polygon defined by the points, and
creates the bounding box if needed

Algorithm by W. Randolph
Franklin,http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
";

%feature("docstring")  cmf::geometry::Polygon::Includes "bool
Includes(const cmf::geometry::shape &shp) const

Returns true if all vertices of mp are lying in the ring. ";

%feature("docstring")  cmf::geometry::Polygon::Includes "bool
Includes(const cmf::geometry::shape &shp) ";

%feature("docstring")  cmf::geometry::Polygon::Vertices "Points
Vertices() const ";


// File: a00042.xml
%feature("docstring") cmf::upslope::maps::PolygonMap "

Should return objects or values that are registered with a polygon, if
the queried point is in the polygon. This is not tested yet, nor
exists a really simple example. Happy Hacking!

C++ includes: maps.h ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::PolygonMap "PolygonMap(_Ty nodata=_Ty())

Creates a new map based on polygon/value pairs.

Parameters:
-----------

nodata:  Value returned, if no polygon is found at the given location
";

%feature("docstring")  cmf::upslope::maps::PolygonMap::Add "void
Add(const cmf::geometry::Ring &polygon, _Ty value)

Adds a ring with a value Makes a copy of polygon and stores it in the
list of values. ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::size "int
size()

Returns the number of point value pairs in this map. ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::Position "cmf::geometry::Ring& Position(int index)

Returns the polygon of a value. ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::Value "_Ty
Value(int index)

Returns one of the values. ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::Get "_Ty
Get(cmf::geometry::point p)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::Get "_Ty
Get(double x, double y)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::Has "bool
Has(double x, double y) ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::Has "bool
Has(cmf::geometry::point p) ";

%feature("docstring")  cmf::upslope::maps::PolygonMap::__call__ "_Ty
__call__(double x, double y) ";


// File: a00643.xml
%feature("docstring") cmf::geometry::PolyLine "";

%feature("docstring")  cmf::geometry::PolyLine::Length "double
Length() const ";

%feature("docstring")  cmf::geometry::PolyLine::Center "point
Center() const ";

%feature("docstring")  cmf::geometry::PolyLine::size "size_t size()
const ";

%feature("docstring")  cmf::geometry::PolyLine::AddPart "cmf::geometry::Line& AddPart(const cmf::geometry::Line &part) ";

%feature("docstring")  cmf::geometry::PolyLine::AddPart "cmf::geometry::Line& AddPart() ";

%feature("docstring")  cmf::geometry::PolyLine::boundingbox "cmf::geometry::BoundingBox boundingbox() ";

%feature("docstring")  cmf::geometry::PolyLine::straight_parts "cmf::geometry::PolyLine straight_parts() const ";

%feature("docstring")  cmf::geometry::PolyLine::PolyLine "PolyLine()
";

%feature("docstring")  cmf::geometry::PolyLine::PolyLine "PolyLine(const PolyLine &copy) ";

%feature("docstring")  cmf::geometry::PolyLine::PolyLine "PolyLine(const Line &copy) ";

%feature("docstring")  cmf::geometry::PolyLine::Vertices "cmf::geometry::Points Vertices() const ";

%feature("docstring")  cmf::geometry::PolyLine::AsWKT "std::string
AsWKT() const ";


// File: a00043.xml
%feature("docstring") cmf::atmosphere::Precipitation "

A connector that puts the rainfall to a FluxNode.

C++ includes: Precipitation.h ";

%feature("docstring")  cmf::atmosphere::Precipitation::Precipitation "Precipitation(PrecipitationData &rainfall, FluxNode &target, double
targetArea=1.0) ";

%feature("docstring")  cmf::atmosphere::Precipitation::q "real
q(const FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::atmosphere::Precipitation::Target "FluxNode& Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::atmosphere::Precipitation::Target "const
FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::atmosphere::Precipitation::conc "WaterQuality conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00044.xml
%feature("docstring") cmf::atmosphere::PrecipitationData "

Holds the precipitation and concentration timeseries.

C++ includes: Precipitation.h ";

%feature("docstring")
cmf::atmosphere::PrecipitationData::RecalcFluxes "virtual bool
RecalcFluxes(t)

Returns true, meaning: always use the actual data. ";

%feature("docstring")  cmf::atmosphere::PrecipitationData::conc "virtual cmf::water::WaterQuality conc(cmf::math::Time t)

Returns the concentration of the rainfall at time t. ";

%feature("docstring")
cmf::atmosphere::PrecipitationData::PrecipitationData "PrecipitationData(cmf::math::timeseries data)

Conversion constructor, taking a timeseries. ";

%feature("docstring")
cmf::atmosphere::PrecipitationData::RecalcFluxes "virtual bool
RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")
cmf::atmosphere::PrecipitationData::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::atmosphere::PrecipitationData::FluxTo "real FluxTo(const FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")
cmf::atmosphere::PrecipitationData::Waterbalance "real
Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")  cmf::atmosphere::PrecipitationData::sum_inflow
"cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")  cmf::atmosphere::PrecipitationData::sum_outflow
"cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";

%feature("docstring")  cmf::atmosphere::PrecipitationData::Potential "virtual real Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";

%feature("docstring")  cmf::atmosphere::PrecipitationData::Empty "virtual bool Empty() ";

%feature("docstring")  cmf::atmosphere::PrecipitationData::copy "virtual FluxNode* copy() const ";


// File: a00644.xml
%feature("docstring") std::priority_queue "

STL class. ";


// File: a00645.xml
%feature("docstring") std::queue "

STL class. ";


// File: a00609.xml
%feature("docstring") cmf::atmosphere::Rainfall "";

%feature("docstring")  cmf::atmosphere::Rainfall::Precipitation "Precipitation(PrecipitationData &rainfall, FluxNode &target,
cmf::geometry::point Location, const cmf::atmosphere::Meteorology
&meteo, double targetArea=1.0) ";

%feature("docstring")  cmf::atmosphere::Rainfall::q "real q(const
FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::atmosphere::Rainfall::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::atmosphere::Rainfall::Target "const
FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::atmosphere::Rainfall::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00646.xml
%feature("docstring") std::range_error "

STL class. ";


// File: a00045.xml
%feature("docstring") cmf::geometry::Raster "

Represents a raster dataset.

C++ includes: Raster.h ";

/*  Focal functions  */

%feature("docstring")  cmf::geometry::Raster::focal_min "Raster<rasterType> focal_min(int n=3)

Creates a raster, which contains for each cell the minimum of the
surrounding n x n window. ";

%feature("docstring")  cmf::geometry::Raster::focal_max "Raster<rasterType> focal_max(int n=3)

Creates a raster, which contains for each cell the maximum of the
surrounding n x n window. ";

%feature("docstring")  cmf::geometry::Raster::focal_mean "Raster<rasterType> focal_mean(int n=3)

Creates a raster, which contains for each cell the mean of the
surrounding n x n window. ";

%feature("docstring")  cmf::geometry::Raster::focal_stdev "Raster<rasterType> focal_stdev(int n=3)

Creates a raster, which contains for each cell the standard deviation
of the surrounding n x n window. ";

%feature("docstring")  cmf::geometry::Raster::focal_majority "Raster<rasterType> focal_majority(int n=3)

Creates a raster, which contains for each cell the majority value of
the surrounding n x n window (usually only used for integer raster).
";

%feature("docstring")  cmf::geometry::Raster::focal_mean_difference "Raster<rasterType> focal_mean_difference(int n=3)

Creates a raster, which contains for each cell the difference between
the actual value and the mean of the surrounding n x n window (usually
only used for integer raster) This function can be used to identify
very important points (VIP) for triangulation. ";

/*  Metadata  */

%feature("docstring")  cmf::geometry::Raster::Xllcorner "double
Xllcorner() const

x-Coordinate for the Lower Left corner (in cellsize units) ";

%feature("docstring")  cmf::geometry::Raster::Yllcorner "double
Yllcorner() const

y-Coordinate for the Lower Left corner (in cellsize units) ";

%feature("docstring")  cmf::geometry::Raster::XCellsize "double
XCellsize() const

Cellsize of the raster. ";

%feature("docstring")  cmf::geometry::Raster::YCellsize "double
YCellsize() const

Cellsize of the raster. ";

%feature("docstring")  cmf::geometry::Raster::ColumnCount "int
ColumnCount() const

Number of columns in the raster. ";

%feature("docstring")  cmf::geometry::Raster::RowCount "int
RowCount() const

Number of rows in the raster. ";

%feature("docstring")  cmf::geometry::Raster::Width "double Width()
const

Extent W-E in cellsize units. ";

%feature("docstring")  cmf::geometry::Raster::Height "double Height()
const

Extent N-S in cellsize units. ";

%feature("docstring")  cmf::geometry::Raster::NoData "rasterType
NoData() const

Returns rasterType (NoData). ";

%feature("docstring")  cmf::geometry::Raster::GetBounds "BoundingBox
GetBounds() const

Returns the bounding box of the raster. ";

/*  Data access  */

%feature("docstring")  cmf::geometry::Raster::IdentifyXY "rasterType
IdentifyXY(double x, double y) const

Returns the value of the raster at the given position. ";

%feature("docstring")  cmf::geometry::Raster::IdentifyRowCol "rasterType IdentifyRowCol(int row, int col) const

Returns the value of the raster at the given cell. ";

%feature("docstring")  cmf::geometry::Raster::IdentifyColRow "rasterType IdentifyColRow(int col, int row) const

Returns the value of the raster at the given cell. ";

%feature("docstring")  cmf::geometry::Raster::HasData "bool
HasData(double x, double y) const

Returns true if there is data at the given position. ";

%feature("docstring")  cmf::geometry::Raster::HasData "bool
HasData(int col, int row) const

Returns true if there is data at the given position. ";

%feature("docstring")  cmf::geometry::Raster::SetData "void
SetData(double x, double y, rasterType val)

Sets a value at the given position.

Parameters:
-----------

x:  X-coordinate

y:  Y-coordinate

val:  Value to set at (x,y) ";

%feature("docstring")  cmf::geometry::Raster::SetData "void
SetData(int col, int row, rasterType val)

Sets a value at the given position.

Parameters:
-----------

col:  Column of the raster

row:  Row of the raster

val:  Value to set at (col,row) ";

/*  Analysis  */

%feature("docstring")  cmf::geometry::Raster::statistics "RasterStatistics statistics()

Creates statistics for the raster. ";

%feature("docstring")  cmf::geometry::Raster::histogram "Histogram
histogram(size_t bins=100) ";

/*  Operators  */

/*  Constructors & IO-Methods  */

%feature("docstring")  cmf::geometry::Raster::Raster "Raster(int
ncols, int nrows, double xllcorner, double yllcorner, double
xcellsize, double ycellsize, rasterType nodata, rasterType
initialValue=0)

Creates an empty Raster dataset. ";

%feature("docstring")  cmf::geometry::Raster::Raster "Raster(const
Raster< rasterType > &R)

Copy constructor. ";

%feature("docstring")  cmf::geometry::Raster::Raster "Raster(const
Raster< rasterType > &R, rasterType FixedValue)

Copy constructor, creates an empty raster dataset with the same
spatial properties like the input raster. ";

%feature("docstring")  cmf::geometry::Raster::Raster "Raster(const
std::string &FileName)

Builds a new Rasterdataset and passes the ownership of the dataset to
the Raster. No external reference to the dataset should be used. Loads
an ESRI ASCII-raster data set. ";

%feature("docstring")  cmf::geometry::Raster::Raster "Raster(std::istream &ASCFile)

Loads an ESRI ASCII-raster data set. ";

%feature("docstring")  cmf::geometry::Raster::WriteToASCFile "void
WriteToASCFile(std::ostream &ASCFile)

Writes the raster to a stream in ESRI-ASC format. ";

%feature("docstring")  cmf::geometry::Raster::WriteToASCFile "void
WriteToASCFile(std::string filename)

Writes the raster to a filename. ";

%feature("docstring")  cmf::geometry::Raster::WriteToBinary "void
WriteToBinary(std::string filename) const

Writes the data to the file with the given file name and the header to
a filename with the extension .hdr.

If the filename has the extension .flt and the raster is a float
raster the saved file can be read by ArcGIS ";

/*  Conversion functions  */

%feature("docstring")  cmf::geometry::Raster::ToInt "Raster<int>
ToInt() const

Converts the raster to a raster of int. ";

%feature("docstring")  cmf::geometry::Raster::ToFloat "Raster<float>
ToFloat()

Converts the raster to a raster of float (32bit). ";

%feature("docstring")  cmf::geometry::Raster::ToDouble "Raster<double> ToDouble()

Converts the raster to a raster of float (64bit). ";

%feature("docstring")  cmf::geometry::Raster::GetXPosition "double
GetXPosition(int col)

Returns the real world x position of a column. ";

%feature("docstring")  cmf::geometry::Raster::GetYPosition "double
GetYPosition(int row)

Returns the real world y position of a row. ";

%feature("docstring")  cmf::geometry::Raster::__len__ "int __len__()
";

%feature("docstring")  cmf::geometry::Raster::__getitem__ "rasterType
__getitem__(int index) ";


// File: a00022.xml


// File: a00647.xml


// File: a00046.xml
%feature("docstring") cmf::geometry::RasterStatistics "

Holds the statistics for a raster.

C++ includes: Raster.h ";

%feature("docstring")
cmf::geometry::RasterStatistics::RasterStatistics "RasterStatistics()

Count of cells with data. ";


// File: a00047.xml
%feature("docstring") cmf::water::reaction::RateReaction "

A simple reaction with a constant reaction rate.

C++ includes: Reaction.h ";


// File: a00048.xml
%feature("docstring") cmf::river::reach "

An alternative reach calculation approach (will get the only one)
\\\\begin{eqnarray*} \\\\frac{dV}{dt} &=& \\\\sum_{i=1}^{U}(Q_{in,i})
+ Q_{lat} - Q_{Manning}(V) \\\\end{eqnarray*}.

C++ includes: reach.h ";

/*  Topological relation to other reaches  */

%feature("docstring")  cmf::river::reach::Upstreams "cmf::river::reachvector& Upstreams()

Returns A collection of Reaches, directly contributing to this. ";

%feature("docstring")  cmf::river::reach::Upstreams "const
cmf::river::reachvector& Upstreams() const

Returns A collection of Reaches, directly contributing to this. ";

%feature("docstring")  cmf::river::reach::DownStream "cmf::river::reach* DownStream()

Returns cmf::river::reach* (DownStream). ";

/*  Overrides of FluxNode  */

%feature("docstring")  cmf::river::reach::RecalcFluxes "virtual bool
RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")  cmf::river::reach::Empty "virtual bool Empty()
";

%feature("docstring")  cmf::river::reach::copy "virtual WaterStorage*
copy() const ";

%feature("docstring")  cmf::river::reach::Type "const
cmf::river::ReachType& Type() const

Properties of the reach.

A const reference to the type of the reach ";

%feature("docstring")  cmf::river::reach::Length "double Length()
const ";

%feature("docstring")  cmf::river::reach::AddPart "void
AddPart(double val, double hMax) ";

%feature("docstring")  cmf::river::reach::Slope "double Slope() const

Returns the avg. slope of the reach. ";

%feature("docstring")  cmf::river::reach::Volume "real Volume() ";

%feature("docstring")  cmf::river::reach::GetQout "cmf::water::WaterFlux GetQout() ";

%feature("docstring")  cmf::river::reach::Q_out "const
cmf::water::WaterFlux& Q_out(const cmf::math::Time &time) ";

%feature("docstring")  cmf::river::reach::Q_in "const
cmf::water::WaterFlux& Q_in(const cmf::math::Time &time) ";

%feature("docstring")  cmf::river::reach::Derivate "real
Derivate(const cmf::math::Time &time)

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::river::reach::InsertReaches "void
InsertReaches(reachvector &target)

Inserts this and all upstream reaches into target. ";

%feature("docstring")  cmf::river::reach::GetAllReaches "reachvector
GetAllReaches()

returns a reachvector with all reaches (not only the root reaches) ";

%feature("docstring")  cmf::river::reach::reach "reach(double hMin,
double length=0, cmf::river::ReachType *typeOfReach=0) ";

%feature("docstring")  cmf::river::reach::reach "reach(cmf::river::reach *downstream, double hMin, double length=0,
cmf::river::ReachType *typeOfReach=0) ";

%feature("docstring")  cmf::river::reach::AddStateVariables "void
AddStateVariables(cmf::math::StateVariableVector &vector)

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::river::reach::Solute "SoluteStorage&
Solute(const cmf::water::Solute &solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::river::reach::Solute "const
SoluteStorage& Solute(const cmf::water::Solute &solute) const ";

%feature("docstring")  cmf::river::reach::conc "real conc(const
cmf::water::Solute &solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::river::reach::conc "WaterQuality
conc(cmf::math::Time t)

Returns the current WaterQuality (concentration of all solutes). ";

%feature("docstring")  cmf::river::reach::conc "void conc(const
cmf::water::Solute &solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::river::reach::water "real water() const

Returns the volume of water in this storage in m3. ";

%feature("docstring")  cmf::river::reach::water "void water(real
newwatercontent)

Sets the volume of water in this storage in m3. ";

%feature("docstring")  cmf::river::reach::ToString "virtual
std::string ToString() const ";

%feature("docstring")  cmf::river::reach::State "const real& State()
const

Returns the current state of the variable. ";

%feature("docstring")  cmf::river::reach::State "void State(const
real &newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::river::reach::StateIsChanged "bool
StateIsChanged()

Returns if the state was currently updated. ";

%feature("docstring")  cmf::river::reach::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::river::reach::FluxTo "real FluxTo(const
FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")  cmf::river::reach::Waterbalance "real
Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")  cmf::river::reach::sum_inflow "cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")  cmf::river::reach::sum_outflow "cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";

%feature("docstring")  cmf::river::reach::Potential "virtual real
Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";


// File: a00049.xml
%feature("docstring") cmf::river::ReachType "

Structure for the description of structural parameters of a reach
Abstract base class for different channel geometries.

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::ReachType::Width "virtual double
Width(double depth) const =0

Calculates the flow width from a given actual depth [m] using the
actual channel geometry. ";

%feature("docstring")  cmf::river::ReachType::Perimeter "virtual
double Perimeter(double depth) const =0

Calculates the wetted perimeter from a given actual depth [m] using
the actual channel geometry. ";

%feature("docstring")  cmf::river::ReachType::Depth "virtual double
Depth(double area) const =0

Calculates the actual depth of the reach using the channel geometry.

Depth of the reach [m]

Parameters:
-----------

area:  Wetted area of a river cross section [m2], can be obtained by
V/l, where V is the stored volume and l is the reach length ";

%feature("docstring")  cmf::river::ReachType::Area "virtual double
Area(double depth) const =0

Calculates the wetted area from a given depth using the channel
geometry. In most cases use Area=V/l, where V is the stored volume and
l is the reach length.

Wetted area of a river cross section [m2]

Parameters:
-----------

depth:  Depth of the reach [m] ";

%feature("docstring")  cmf::river::ReachType::qManning "double
qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach
\\\\begin{eqnarray*} q_{Manning}&=& A R^{\\\\frac 23}
\\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
\\\\mbox{ Area of the wetted crossection, Volume per length}\\\\\\\\
R&=&\\\\frac A P(d) \\\\\\\\ P(d)&=& \\\\mbox{ Perimeter of the wetted
crossection, a function of reach depth} \\\\\\\\ d(V)&=& \\\\mbox{
Depth of the reach} \\\\\\\\ \\\\Delta_z&=& \\\\frac{z_{max} -
z_{min}}{l} \\\\mbox{ Slope of the reach} \\\\\\\\ \\\\end{eqnarray*}.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::ReachType::ReachType "ReachType()
";


// File: a00050.xml
%feature("docstring") cmf::water::reaction::Reaction "

An abstract type to use chemical (or other) reactions of solutes.
Override the ReactiveFlux function or use one of the child classes, if
appropriate (Have a look at the ExternalFunctionReaction, before you
start recompiling cmf).

C++ includes: Reaction.h ";

%feature("docstring")  cmf::water::reaction::Reaction::ReactiveFlux "virtual double ReactiveFlux(const WaterQuality &Environment)=0

Returns the reactive flux as $\\\\frac{d[X]}{dt}=f([A],[B]...)
\\\\left[\\\\frac{mol}{m^3\\\\ day}\\\\right]$. ";

%feature("docstring")  cmf::water::reaction::Reaction::Reaction "Reaction(const cmf::water::Solute &solute) ";


// File: a00648.xml
%feature("docstring") cmf::river::RectangularReach "";

%feature("docstring")  cmf::river::RectangularReach::Width "virtual
double Width(double depth) const

Returns the width of the stream at a given depth \\\\begin{eqnarray*}
w &=& const \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::river::RectangularReach::Perimeter "virtual double Perimeter(double depth) const

Returns the wetted perimeter at a given depth \\\\begin{eqnarray*} P
&=& 2 d + w \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::river::RectangularReach::Depth "virtual
double Depth(double area) const

Returns the depth at a given crossection area \\\\begin{eqnarray*} d
&=& \\\\frac A w \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::river::RectangularReach::Area "virtual
double Area(double depth) const

Returns the crossection area at a given depth \\\\begin{eqnarray*} A
&=& d w \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::river::RectangularReach::TriangularReach "TriangularReach(double width)

Creates a new rectangular reach type. ";

%feature("docstring")  cmf::river::RectangularReach::qManning "double
qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach
\\\\begin{eqnarray*} q_{Manning}&=& A R^{\\\\frac 23}
\\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
\\\\mbox{ Area of the wetted crossection, Volume per length}\\\\\\\\
R&=&\\\\frac A P(d) \\\\\\\\ P(d)&=& \\\\mbox{ Perimeter of the wetted
crossection, a function of reach depth} \\\\\\\\ d(V)&=& \\\\mbox{
Depth of the reach} \\\\\\\\ \\\\Delta_z&=& \\\\frac{z_{max} -
z_{min}}{l} \\\\mbox{ Slope of the reach} \\\\\\\\ \\\\end{eqnarray*}.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";


// File: a00051.xml
%feature("docstring") cmf::upslope::RetentionCurve "

Abstract base class for different types of retention curves.

This class, and its children uses wetness instead of volumetric water
content. The wetness of a soil is defined as water content per void
volume

C++ includes: RetentionCurve.h ";

%feature("docstring")  cmf::upslope::RetentionCurve::K "virtual real
K(real wetness, real depth) const =0

Returns the conductivity in m/day at a certain depth and water
content. ";

%feature("docstring")  cmf::upslope::RetentionCurve::Porosity "virtual real Porosity(real depth) const =0

Returns the porosity at a certain depth. ";

%feature("docstring")  cmf::upslope::RetentionCurve::VoidVolume "virtual real VoidVolume(real upperDepth, real lowerDepth, real Area)
const =0

Returns the void volume of a soil column. ";

%feature("docstring")  cmf::upslope::RetentionCurve::FillHeight "virtual real FillHeight(real lowerDepth, real Area, real Volume) const
=0

Returns the thickness of a soil column with a certain pore volume. ";

%feature("docstring")  cmf::upslope::RetentionCurve::Transmissivity "virtual real Transmissivity(real upperDepth, real lowerDepth, real
theta) const =0

Returns the transmissivity of a part of a soil column. ";

%feature("docstring")  cmf::upslope::RetentionCurve::Wetness "virtual
real Wetness(real suction) const =0

returns the wetness (volumetric water content per pore space) at a
given suction pressure ";

%feature("docstring")  cmf::upslope::RetentionCurve::Wetness_pF "real
Wetness_pF(real pF) const

returns the volumetric water content at a given pF value ";

%feature("docstring")  cmf::upslope::RetentionCurve::MatricPotential "virtual real MatricPotential(real wetness) const =0

returns the wetness of the soil at given water content ";

%feature("docstring")  cmf::upslope::RetentionCurve::copy "virtual
RetentionCurve* copy() const =0 ";


// File: a00052.xml
%feature("docstring") cmf::upslope::connections::RichardsConnection "

Calculates flow according to the Richards equation.

\\\\begin{eqnarray*} q_{Richards} &=& \\\\frac{\\\\Delta\\\\Psi_tot}{d
\\\\rho_{wg}} K(\\\\theta) A \\\\\\\\ \\\\Psi_tot =
\\\\Psi_{M}(\\\\theta) + \\\\frac{h}{\\\\rho_{wg}} \\\\end{eqnarray*}
where  $ \\\\Delta\\\\Psi_tot $ is the difference of the total water
potentials of the two soil layers

$ d $ is the distance between the two soil layers

$ \\\\rho_{wg}=9810 \\\\frac{Pa}{m} $ is the constant density of water
times gravitational acceleration

$ K(\\\\theta)$ is the actual conductivity (see SoilType::Kunsat)

$ A $ is the crosssectional area of the flux

$ \\\\Psi_M(\\\\theta) $ is the matrix potential (see
SoilType::MatrixPotential)

$ h $ is the height of a soil layer above see level

C++ includes: FluxConnections.h ";

%feature("docstring")
cmf::upslope::connections::RichardsConnection::q "real q(const
FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::RichardsConnection::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::RichardsConnection::Target "const
FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")
cmf::upslope::connections::RichardsConnection::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00635.xml
%feature("docstring") cmf::geometry::Ring "";

%feature("docstring")  cmf::geometry::Ring::AsWKT "std::string
AsWKT() const

returns the Well-Known-Text of a polygon with the vertices of this
ring ";

%feature("docstring")  cmf::geometry::Ring::Area "double Area() const

returns the Area of a polygon defined by the points ";

%feature("docstring")  cmf::geometry::Ring::Center "point Center()
const

returns the centroid of a polygon defined by the points ";

%feature("docstring")  cmf::geometry::Ring::Includes "bool
Includes(point p) const

returns true if p lies in the polygon defined by the points

Algorithm by W. Randolph
Franklin,http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
";

%feature("docstring")  cmf::geometry::Ring::Includes "bool
Includes(point p)

returns true if p lies in the polygon defined by the points, and
creates the bounding box if needed

Algorithm by W. Randolph
Franklin,http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
";

%feature("docstring")  cmf::geometry::Ring::Ring::Includes "bool
Ring::Includes(const shape &shp) const

Returns true if all vertices of mp are lying in the ring. ";

%feature("docstring")  cmf::geometry::Ring::Ring::Includes "bool
Ring::Includes(const shape &shp) ";

%feature("docstring")  cmf::geometry::Ring::SharedBoundary "Line
SharedBoundary(const Ring &with, double tolerance=0.1) const

Returns the shared boundary of two rings. ";

%feature("docstring")  cmf::geometry::Ring::Ring "Ring() ";

%feature("docstring")  cmf::geometry::Ring::Ring "Ring(const
cmf::geometry::Ring &copy) ";

%feature("docstring")  cmf::geometry::Ring::Ring "Ring(const
cmf::geometry::BoundingBox &bbox) ";

%feature("docstring")  cmf::geometry::Ring::Ring "Ring(const
cmf::geometry::Line &copy) ";

%feature("docstring")  cmf::geometry::Ring::AddPoint "void
AddPoint(point p)

Adds a point to the shape. ";

%feature("docstring")  cmf::geometry::Ring::AddPoint "void
AddPoint(double x, double y, double z=0) ";

%feature("docstring")  cmf::geometry::Ring::RemovePoint "void
RemovePoint(int pos) ";

%feature("docstring")  cmf::geometry::Ring::size "int size() const ";

%feature("docstring")  cmf::geometry::Ring::Vertex "point Vertex(int
i) const ";

%feature("docstring")  cmf::geometry::Ring::Vertices "Points
Vertices() const ";

%feature("docstring")  cmf::geometry::Ring::MaxStraight "Line
MaxStraight() const

Returns the longest straight line between two vertices of the shape.
";

%feature("docstring")  cmf::geometry::Ring::boundingbox "BoundingBox
boundingbox() ";


// File: a00053.xml
%feature("docstring") cmf::math::RKFIntegrator "

Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
Fehlberg (RKF54) method.

C++ includes: RKFIntegrator.h ";

/*  Assessment of state variables for integration  */

%feature("docstring")  cmf::math::RKFIntegrator::States "cmf::math::StateVariableVector& States()

Returns the vector of StateVariable pointers. ";

%feature("docstring")  cmf::math::RKFIntegrator::States "const
cmf::math::StateVariableVector& States() const ";

/*  model time  */

%feature("docstring")  cmf::math::RKFIntegrator::ModelTime "cmf::math::Time ModelTime() const

Returns the current model time. ";

%feature("docstring")  cmf::math::RKFIntegrator::ModelTime "void
ModelTime(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::RKFIntegrator::TimeStep "cmf::math::Time TimeStep() const

Returns the last time step. ";

%feature("docstring")  cmf::math::RKFIntegrator::NextTimeStep "cmf::math::Time NextTimeStep() const

Returns the next time step width. ";

%feature("docstring")  cmf::math::RKFIntegrator::NextTimeStep "void
NextTimeStep(cmf::math::Time val)

Sets the next time step width. ";

%feature("docstring")  cmf::math::RKFIntegrator::MinTimestep "const
cmf::math::Time MinTimestep() const

Returns The minimal allowed time step length. ";

%feature("docstring")  cmf::math::RKFIntegrator::Iterations "int
Iterations() const ";

%feature("docstring")  cmf::math::RKFIntegrator::ResetIterations "void ResetIterations() ";

/*  Integrate  */

%feature("docstring")  cmf::math::RKFIntegrator::Integrate "int
Integrate(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::RKFIntegrator::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime) ";

%feature("docstring")  cmf::math::RKFIntegrator::IntegrateUntil "void
IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables until MaxTime. ";

%feature("docstring")  cmf::math::RKFIntegrator::__call__ "void
__call__(cmf::math::Time until)

Calls IntegrateUntil. ";

/*  The state variables to integrate  */

/*  Accuracy parameters  */

%feature("docstring")  cmf::math::RKFIntegrator::AddStatesFromOwner "void AddStatesFromOwner(cmf::math::StateVariableOwner &stateOwner)

Adds the state variables of a StateVariableOwner to the state
variables of the solver. ";

%feature("docstring")  cmf::math::RKFIntegrator::RKFIntegrator "RKFIntegrator(const StateVariableVector &states, real epsilon=1e-9,
cmf::math::Time tStepMin=Time::Seconds(10))

Constructs a new RKFIntegrator from a pointer to a vector of state
variables.

The RKF Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::RKFIntegrator::RKFIntegrator "RKFIntegrator(real epsilon=1e-9, cmf::math::Time
tStepMin=Time::Seconds(10))

Constructs a new RKFIntegrator.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::RKFIntegrator::RKFIntegrator "RKFIntegrator(const Integrator &forCopy)

Copy constructor, does not copy. ";

%feature("docstring")  cmf::math::RKFIntegrator::Copy "virtual
Integrator* Copy() const

Returns a new Integrator, based on this (without the state variables),
e.g. same type, epsilon, model time etc. ";

%feature("docstring")  cmf::math::RKFIntegrator::Integrate "int
Integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed timestep, and changes it into the
effictivly used timestep according to the local stiffness of the
problem and MaxTime ";

%feature("docstring")  cmf::math::RKFIntegrator::count "int count()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::RKFIntegrator::state "const real&
state(int position) const

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::RKFIntegrator::state "void
state(int position, real newState)

Simplifies the assessment of state variables. ";


// File: a00611.xml
%feature("docstring") cmf::water::RouteWaterBalanceConnection "";

%feature("docstring")
cmf::water::RouteWaterBalanceConnection::RouteWaterBalanceConnection "RouteWaterBalanceConnection(FluxNode &source, FluxNode &target) ";

%feature("docstring")  cmf::water::RouteWaterBalanceConnection::q "real q(const FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::RouteWaterBalanceConnection::Target
"FluxNode& Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::RouteWaterBalanceConnection::Target
"const FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::water::RouteWaterBalanceConnection::conc "WaterQuality conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00607.xml
%feature("docstring") std::runtime_error "

STL class. ";


// File: a00650.xml
%feature("docstring") std::set "

STL class. ";


// File: a00651.xml
%feature("docstring") std::set::const_iterator "

STL iterator class. ";


// File: a00652.xml
%feature("docstring") std::set::const_reverse_iterator "

STL iterator class. ";


// File: a00653.xml
%feature("docstring") std::set::iterator "

STL iterator class. ";


// File: a00654.xml
%feature("docstring") std::set::reverse_iterator "

STL iterator class. ";


// File: a00655.xml
%feature("docstring") cmf::geometry::shape "";

%feature("docstring")  cmf::geometry::shape::Vertices "virtual Points
Vertices() const =0 ";

%feature("docstring")  cmf::geometry::shape::Center "virtual point
Center() const =0 ";

%feature("docstring")  cmf::geometry::shape::AsWKT "virtual
std::string AsWKT() const =0

Returns the OGC well known text representation of the shape as defined
in OpenGIS Implementation Specification for Geographic information -
Simple feature access - Part 1: Common
architecturehttp://www.opengeospatial.org/standards/is. ";


// File: a00054.xml
%feature("docstring") cmf::upslope::vegetation::ShuttleworthWallace "

Calculates the sum of soil evaporation and transpiration according to
Shuttleworth & Wallace 1985, as implemented in BROOK 90 (Federer
1990).

The difference to BROOK90 is, that the actual transpiration is not
calculated by plant resitance and potential gradient between plant and
soil, but by an piecewise linear function of the pF value $ pF =
\\\\log_{10}\\\\left(-\\\\Psi [hPa]\\\\right) $: \\\\[
\\\\frac{T_{act}}{T_{pot}} = \\\\left\\\\{\\\\begin{array}{cl} 1 &
\\\\mbox{if $pF \\\\le 3.35$} \\\\\\\\ \\\\frac{pF - 4.2}{3.35 - 4.2}
& \\\\mbox{if $pF \\\\in [3.35 .. 4.2] $} \\\\\\\\ 0 & \\\\mbox{if $pF
\\\\ge 4.2$} \\\\end{array}\\\\right. \\\\]

Calculation procedure, as in BROOK 90:

Evapotranspiration from the canopy: $\\\\lambda ET_{canopy} = \\\\frac
{r_{ac} \\\\Delta\\\\ R_{n,canopy} + c_p\\\\rho D_0}{\\\\Delta
\\\\gamma r_{ac} + \\\\gamma r_{sc}} $

Evaporation from the ground: $\\\\lambda E_{ground} = \\\\frac {r_{as}
\\\\Delta\\\\ R_{n,ground} + c_p\\\\rho D_0}{\\\\Delta \\\\gamma
r_{as} + \\\\gamma r_{ss}} $

with  $ \\\\Delta = \\\\frac{de_s}{dT} = 4098\\\\ 0.6108
\\\\exp\\\\left(\\\\frac{17.27 T}{T+237.3}\\\\right)(T+237.3)^{-2} $,
the slope of the sat. vap. press. T function

$ R_{n,ground} = R_n \\\\exp(-C_R LAI) $, the net radiation flux in
the ground

$ R_{n_canopy} = R_n - R_{n,ground} $, the net radiation flux in the
canopy

$ \\\\lambda,c_p\\\\rho,\\\\gamma,C_R $ constants lambda, c_p_rho,
gamma, C_R

$ D_0 $ vapor pressure deficit at effective source height, see
function D0

$ r_{ac}, r_{sc}, r_{as}, r_{ss} $ Resistances for the vapor pressure
(see below)

Aerodynamic resistances $r_{ac},r_{as},r_{aa}$  $ r_{ac} = 100 n
\\\\frac{\\\\sqrt{\\\\frac {w_{leaf}}{u_h}}}{1-\\\\exp(-\\\\frac n 2)}
$

C++ includes: ShuttleworthWallace.h ";

/*  Constants  */

/*  Private functions  */

%feature("docstring")
cmf::upslope::vegetation::ShuttleworthWallace::ET "real ET()

Actual evapotranspiration in mm/day. ";

%feature("docstring")
cmf::upslope::vegetation::ShuttleworthWallace::ShuttleworthWallace "ShuttleworthWallace(cmf::atmosphere::Weather w, real
soilwater_matrixpotential, const cmf::upslope::vegetation::Vegetation
&veg, bool CanopyStoresWater=false, real
measurement_height_above_canopy=2)

Calculates the transpiration and the soil evaporation from dry
surfaces.

Parameters:
-----------

w:  A meteorological data record

soilwater_matrixpotential:  The suction of the soil water in m water
column

veg:  The parameters of the vegetation

CanopyStoresWater:  Flag indicating wet leaves. If true, a canopy
surface resistance of 0 is assumed

measurement_height_above_canopy:  The height of the wind speed above
the canopy in m ";


// File: a00656.xml


// File: a00055.xml
%feature("docstring") cmf::upslope::ET::ShuttleworthWallaceET "

Calculates the actual transpiration and the soil evaporation from a
soil layer.

C++ includes: ET.h ";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallaceET::ShuttleworthWallaceET "ShuttleworthWallaceET(cmf::upslope::SoilWaterStorage &source,
cmf::water::FluxNode &ET_target, cmf::atmosphere::Meteorology &meteo)
";


// File: a00056.xml
%feature("docstring") cmf::upslope::maps::SingleValueMap "

A SingleValueMap is the simplest possible implementation of the IMap
interface. the Get(x,y) function returns always the same value/object
no matter what location is given.

C++ includes: maps.h ";

%feature("docstring")
cmf::upslope::maps::SingleValueMap::SingleValueMap "SingleValueMap(_Ty value) ";

%feature("docstring")  cmf::upslope::maps::SingleValueMap::Get "_Ty
Get(cmf::geometry::point p)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::SingleValueMap::Get "_Ty
Get(double x, double y)

Returns a soil type by calling the protected virtual function get. ";

%feature("docstring")  cmf::upslope::maps::SingleValueMap::Has "bool
Has(double x, double y) ";

%feature("docstring")  cmf::upslope::maps::SingleValueMap::Has "bool
Has(cmf::geometry::point p) ";

%feature("docstring")  cmf::upslope::maps::SingleValueMap::__call__ "_Ty __call__(double x, double y) ";


// File: a00610.xml
%feature("docstring") cmf::atmosphere::Snowfall "";

%feature("docstring")  cmf::atmosphere::Snowfall::Precipitation "Precipitation(PrecipitationData &rainfall, FluxNode &target,
cmf::geometry::point Location, const cmf::atmosphere::Meteorology
&meteo, double targetArea=1.0) ";

%feature("docstring")  cmf::atmosphere::Snowfall::q "real q(const
FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::atmosphere::Snowfall::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::atmosphere::Snowfall::Target "const
FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")  cmf::atmosphere::Snowfall::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00057.xml
%feature("docstring") cmf::upslope::SoilProfile "

Holds a soil profile, with one SoilType fro each layer and the
vertical boundaries of the layers.

C++ includes: SoilProfile.h ";

%feature("docstring")  cmf::upslope::SoilProfile::AddLayer "void
AddLayer(double Ksat, double Phi, double Lambda, double FieldCapacity,
double WiltingPoint, double PLE, double LowerBoundary)

Adds a Layer to the soil profile.

Parameters:
-----------

Ksat:  Water conductivity of the soil at saturation $
\\\\left[\\\\frac{m}{day}\\\\right] $

Phi:  Fraction of pore volume per soil volume $ \\\\left[\\\\frac{m^3
Pores}{m^3 Soil}\\\\right] $

Lambda:  Lambda parameter for unsaturated flow []

FieldCapacity:  Water content at pF=1.5 $ \\\\left[\\\\frac{m^3
H_2O}{m^3 Soil}\\\\right] $

WiltingPoint:  Water content at pF=4.2 $ \\\\left[\\\\frac{m^3
H_2O}{m^3 Soil}\\\\right] $

PLE:  Power Law Exponent to calculate the saturated Transmissivity []

LowerBoundary:  Lower boundary of the layer $ [m] $ ";

%feature("docstring")  cmf::upslope::SoilProfile::AddLayer "void
AddLayer(SoilType soil, double LowerBoundary) ";

%feature("docstring")  cmf::upslope::SoilProfile::size "size_t size()
";

%feature("docstring")  cmf::upslope::SoilProfile::GetSoilProperties "SoilType& GetSoilProperties(size_t index) ";

%feature("docstring")  cmf::upslope::SoilProfile::GetLowerBoundary "double GetLowerBoundary(size_t index) ";

%feature("docstring")  cmf::upslope::SoilProfile::GetUpperBoundary "double GetUpperBoundary(size_t index) ";

%feature("docstring")  cmf::upslope::SoilProfile::GetThickness "double GetThickness(size_t index) ";

%feature("docstring")  cmf::upslope::SoilProfile::Average "SoilType
Average() ";


// File: a00058.xml
%feature("docstring") cmf::upslope::SoilType "

Soil description for CMF.

C++ includes: soil.h ";

/*  Description of Pores  */

%feature("docstring")  cmf::upslope::SoilType::PoreVolume "real
PoreVolume(real soildepth, real area) const

The total pore volume, exponential drain to include?

[m3]

Parameters:
-----------

soildepth:  Depth of porose soil [m]

area:  [m2] ";

/*  Parameters and methods for water flow  */

%feature("docstring")  cmf::upslope::SoilType::Kunsat "real
Kunsat(real theta) const

Returns the unsaturated conductivity of a soil, using Brooks-Corey
\\\\[ K_{unsat}(\\\\theta) = K_{sat} \\\\left(\\\\frac{\\\\theta -
\\\\theta_r}{\\\\theta_s - \\\\theta_r}\\\\right)^{3+2\\\\lambda^{-1}}
\\\\left[\\\\frac{m}{day}\\\\right] \\\\].

Parameters:
-----------

theta:   $ \\\\theta $ actual water content in $\\\\frac{m^3 H_2O}{m^3
\\\\mbox{Soil}}$

Might get extended through different Kunsat approaches. The approach
will be chosen by a static variable of soil ";

%feature("docstring")  cmf::upslope::SoilType::Kunsat2 "real
Kunsat2(real theta) const

Van Genuchten/Mualem $ \\\\theta - K_{sat} $ relationship \\\\[
K_{unsat} = K_{sat} \\\\sqrt{W}\\\\left(1-\\\\left(1-W^{\\\\frac 1
m}\\\\right)^m\\\\right)^2 \\\\]. ";

%feature("docstring")  cmf::upslope::SoilType::Transmissivity "real
Transmissivity(real z_sat, real z_soil) const

Calculates the transmissivity \\\\[ T(z_{sat},z_{soil}) = K_{sat}
z_{soil}\\\\left(1-\\\\frac{z_{sat}}{z_{soil}}\\\\right)^{PLE}
\\\\left[\\\\frac{m^2}{day}\\\\right] \\\\] Transmissivity of a layer
with upper and lower boundary $z_{upper},z_{lower}$ \\\\[
T_{layer}(z_{upper},z_{lower}) =
T\\\\left(\\\\max\\\\left(z_{upper},z_{sat}\\\\right),z_{soil}\\\\right)
- T\\\\left(z_{lower},z_{soil}\\\\right) \\\\].

Transmissivity

Parameters:
-----------

z_sat:   $ z_{sat} $ depth in m below ground of the saturated zone

z_soil:   $ z_{soil} $ total soil depth

Taken from Wigmosta et al 1999, but changed. Original eq.: $
T(z_{sat},z_{soil}) = K_{sat}
\\\\frac{z_{soil}}{PLE}\\\\left(1-\\\\frac{z_{sat}}{z_{soil}}\\\\right)^{PLE}
$ ";

%feature("docstring")  cmf::upslope::SoilType::Transmissivity "real
Transmissivity(real K, real z_upper, real z_lower, real z_soil) const

Calculates the transmissivity for a layer that is not necessarily
saturated \\\\[ T(z_{upper},z_{lower},z_{soil}) = K
\\\\left(z_{soil}\\\\left(1-\\\\frac{z_{upper}}{z_{soil}}\\\\right)^{PLE}
-
z_{soil}\\\\left(1-\\\\frac{z_{upper}}{z_{soil}}\\\\right)^{PLE}\\\\right)
\\\\].

Parameters:
-----------

K:  Conductivity (e.g. Ksat or Kunsat(theta)

z_upper:  Upper depth of the boundary (m)

z_lower:  Lower depth of the boundary (m)

z_soil:  Soil depth ";

/*  BROOK90 Parameters  */

%feature("docstring")  cmf::upslope::SoilType::Wetness "real
Wetness(real theta) const

Returns the wetness of a soil \\\\[ W(\\\\theta) =\\\\frac{\\\\theta -
\\\\theta_r}{\\\\theta_s - \\\\theta_r} \\\\]. ";

%feature("docstring")  cmf::upslope::SoilType::Wetness_inf "real
Wetness_inf() const

Wetness at dry end of near-saturation range for soil layer $
W_i=\\\\max\\\\left(0.92+\\\\frac {0.01} {\\\\sqrt{\\\\lambda}},
\\\\frac \\\\lambda {1+\\\\lambda}\\\\right) $. ";

%feature("docstring")  cmf::upslope::SoilType::b_exp "real b_exp()
const

Calculates the b exponent of the matric potential equation from two
known points on the $ \\\\theta(\\\\Psi) $ function
\\\\begin{eqnarray*} b &=&
\\\\frac{\\\\log\\\\left(\\\\frac{\\\\Psi_f}{\\\\Psi_w}\\\\right)}{\\\\log\\\\left(\\\\frac{\\\\theta_f}{\\\\theta_w}\\\\right)}
\\\\\\\\ \\\\Psi_f,\\\\Psi_w &=& \\\\mbox{ Matric potential at
fieldcapacity / wilting point } 10^{2.5}/10^{4.2} hPa \\\\\\\\
\\\\theta_f,\\\\theta_w &=& \\\\mbox{ Water content at fieldcapacity /
wilting point } \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::upslope::SoilType::MatrixPotential "real
MatrixPotential(real theta) const

Matrix potential $\\\\Psi$ of the soil at a water content $\\\\theta$
in Pa (always negative) \\\\begin{eqnarray*} \\\\mbox{if }
W(\\\\theta)<W_i : \\\\\\\\ \\\\Psi &=& \\\\Psi_f\\\\left(\\\\frac
{W(\\\\theta)} {W(\\\\theta_f)} \\\\right)^{-b} \\\\\\\\ \\\\mbox{if }
W(\\\\theta) \\\\ge W_i : \\\\\\\\ \\\\Psi &=&-m (W - n)(1-W) \\\\\\\\
&& m = -\\\\frac{\\\\Psi_i}{(1-W_i)^2}-\\\\lambda \\\\frac {\\\\Psi_i}
{W_i (1-W_i)} \\\\\\\\ && n = 2 W_i - 1+ \\\\lambda \\\\frac
{\\\\Psi_i}{m} W_i \\\\\\\\ && \\\\Psi_i = \\\\Psi_f
\\\\left(\\\\frac{W_i}{W(\\\\theta_f)}\\\\right)^{2b+3} \\\\\\\\
\\\\end{eqnarray*}  $ W(\\\\theta) $ is defined in Wetness()

$ W_i=\\\\max\\\\left(0.92+\\\\frac {0.01} {\\\\sqrt{\\\\lambda}},
\\\\frac \\\\lambda {1+\\\\lambda}\\\\right) $ is defined in
Wetness_inf()

$\\\\Psi_f=- 10^{2.5} hPa = - 10^{4.5} Pa = -32000 Pa $.

Todo Precalculation of $ W_i,m,n,\\\\Psi_i,\\\\Psi_f$ for better
perfomance ";

/*  Constructors  */

%feature("docstring")  cmf::upslope::SoilType::SoilType "SoilType()

Creates a solid rock soil. ";

%feature("docstring")  cmf::upslope::SoilType::SoilType "SoilType(real ksat, real phi, real lambda, real fieldCap, real
wiltPoint, real ple, real stonefraction=0.0)

Complete Constructor.

Parameters:
-----------

ksat:  Water conductivity of the soil at saturation [m/day]

phi:  Fraction of pore volume per soil volume []

lambda:  Lambda parameter for unsaturated flow []

fieldCap:  Water content at pF=1.5 $ \\\\left[\\\\frac{m^3 H_2O}{m^3
Soil}\\\\right] $

wiltPoint:  Volume of Water/(Phi*Soilvolume) at pF=4.2 []

ple:  Power Law Exponent to calculate the saturated Transmissivity

stonefraction:  Fraction of stones in the soil [0..1] ";


// File: a00059.xml
%feature("docstring") cmf::upslope::SoilWaterStorage "

A representation of a Layer.

C++ includes: SoilWaterStorage.h ";

/*  Overrides of FluxNode  */

%feature("docstring")  cmf::upslope::SoilWaterStorage::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Empty "virtual
bool Empty() ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::copy "virtual
WaterStorage* copy() const ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::UpperBoundary "virtual double UpperBoundary() const

Returns the upper boundary of the water storage below ground in m. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::LowerBoundary "virtual double LowerBoundary() const

Returns the lower boundary of the water storage below ground in m. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Thickness "double Thickness() const ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Soil "virtual
const RetentionCurve& Soil() const

Returns the soil properties of the water storage. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Soil "virtual
RetentionCurve& Soil() ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::theta "virtual
real theta() const

Returns the actual volumetric water content of the water storage. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::theta "virtual
void theta(real Value) ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::K "double K()
const

Returns the actual conductivity $\\\\frac{m}{day}$. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Wetness "virtual double Wetness() const

Returns the wetness of the soil $ \\\\frac{V_{H_2O}}{V_{pores}} $. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::MatrixPotential
"virtual real MatrixPotential() const

Calls RetentionCurve::Matrixpotential. ";

%feature("docstring")
cmf::upslope::SoilWaterStorage::GravitationalPotential "real
GravitationalPotential() const

Gravitational Potential in m, reference height is sea level \\\\[
\\\\Psi_G=h \\\\]. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Capacity "virtual real Capacity()

Returns the capacity of the water storage in m3. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::SetPotential "void SetPotential(real waterhead)

Sets the potential of this soil water storage. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Potential "virtual real Potential() const

Returns the total potential in m \\\\[ \\\\Psi = \\\\Psi_M + \\\\Psi_G
\\\\]. ";

%feature("docstring")
cmf::upslope::SoilWaterStorage::SoilWaterStorage "SoilWaterStorage(cmf::upslope::Cell &_cell, real lowerboundary, const
RetentionCurve &r_curve, real saturateddepth=-10) ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::copy "SoilWaterStorage* copy() ";

%feature("docstring")
cmf::upslope::SoilWaterStorage::AddStateVariables "void
AddStateVariables(cmf::math::StateVariableVector &vector)

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Solute "SoluteStorage& Solute(const cmf::water::Solute &solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Solute "const
SoluteStorage& Solute(const cmf::water::Solute &solute) const ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::conc "real
conc(const cmf::water::Solute &solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::conc "WaterQuality conc(cmf::math::Time t)

Returns the current WaterQuality (concentration of all solutes). ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::conc "void
conc(const cmf::water::Solute &solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::water "real
water() const

Returns the volume of water in this storage in m3. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::water "void
water(real newwatercontent)

Sets the volume of water in this storage in m3. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::ToString "virtual std::string ToString() const ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Derivate "virtual real Derivate(const cmf::math::Time &time)

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::State "const
real& State() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::State "void
State(const real &newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::StateIsChanged
"bool StateIsChanged()

Returns if the state was currently updated. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::FluxTo "real
FluxTo(const FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Waterbalance "real Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::sum_inflow "cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::sum_outflow "cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";

%feature("docstring")  cmf::upslope::SoilWaterStorage::Potential "virtual real Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";


// File: a00060.xml
%feature("docstring") cmf::upslope::SolidRockCell "

A class for debugging the routing model, equals the ponded flow and
the inflow, equals solid rock.

C++ includes: SolidRockCell.h ";

/*  Spatial Properties.  */

/* Properties of UpslopeCell that are describing the spatial
distribution of the Cells

*/

%feature("docstring")  cmf::upslope::SolidRockCell::Area "double
Area() const

Area of UpslopeCell in m2. ";

%feature("docstring")  cmf::upslope::SolidRockCell::Center "cmf::geometry::point& Center()

Center of the Cell. ";

%feature("docstring")  cmf::upslope::SolidRockCell::Center "cmf::geometry::point Center() const ";

%feature("docstring")  cmf::upslope::SolidRockCell::Height "double
Height() const

Mean height of Cell a.s.l. ";

%feature("docstring")  cmf::upslope::SolidRockCell::GetSlopeTo "double GetSlopeTo(cmf::upslope::UpslopeCell &other) const

Calculates the topographic slope to another cell in m/m. ";

/*  Neighborhood.  */

/* Methods to handle and describe the topological relation to other
Cells

*/

%feature("docstring")  cmf::upslope::SolidRockCell::NeighborCount "int NeighborCount() const ";

%feature("docstring")  cmf::upslope::SolidRockCell::GetNeighbor "Neighbor& GetNeighbor(int index)

The Neighborhood of a cell, this acces is quite slow, in C++ use the
NeighborIterator for cycling.

Parameters:
-----------

index:  Index of the neighbor ";

%feature("docstring")  cmf::upslope::SolidRockCell::GetNeighbor "NeighborIterator GetNeighbor()

Returns an NeighborIterator for fast cycling (only C++ API). ";

%feature("docstring")  cmf::upslope::SolidRockCell::GetNeighbor "NeighborIterator GetNeighbor(const UpslopeCell &cell) ";

%feature("docstring")  cmf::upslope::SolidRockCell::AddNeighbor "bool
AddNeighbor(UpslopeCell &cell, double flowwidth)

Adds a Neighbor cell to the neighborhood.

True if cell was added, false if cell was already defiened as neighbor

Parameters:
-----------

cell:  Neighboring cell

flowwidth:  Lenght of intersection [m] ";

%feature("docstring")  cmf::upslope::SolidRockCell::IsNeighbor "bool
IsNeighbor(const UpslopeCell &cell)

Returns true if the given cell is a neighbor of this. ";

%feature("docstring")  cmf::upslope::SolidRockCell::RemoveNeighbor "void RemoveNeighbor(int index)

Removes a neighbor at an specified index. ";

%feature("docstring")  cmf::upslope::SolidRockCell::RemoveNeighbor "bool RemoveNeighbor(const UpslopeCell &cell)

Removes a specific cell. ";

%feature("docstring")  cmf::upslope::SolidRockCell::JoinCell "void
JoinCell(UpslopeCell &cell)

Creates a union from the given cell and this. Changes area and
neighborhood relations, any other properties stay the same. Don't
forget to remove the joined cell from any collection and delete it! ";

%feature("docstring")  cmf::upslope::SolidRockCell::MainOutlet "Neighbor MainOutlet(bool ForceCalculation)

Gets the downslope cell with steepest slope (terrain), calculated at
first call of the function. ";

%feature("docstring")  cmf::upslope::SolidRockCell::MainOutlet "Neighbor MainOutlet() const ";

%feature("docstring")
cmf::upslope::SolidRockCell::GetNeighborhoodType "cmf::upslope::UpslopeCell::NeighborhoodType GetNeighborhoodType()

Returns the type of neighborhood. ";

%feature("docstring")
cmf::upslope::SolidRockCell::SortNeighborhoodClockwise "void
SortNeighborhoodClockwise()

Sorts the neighbors in clockwise direction. ";

/*  Interface to the soil water storages  */

%feature("docstring")  cmf::upslope::SolidRockCell::InFlow "virtual
cmf::water::WaterFlux InFlow(const cmf::math::Time &time)

Returns the incoming water (e.g. throughfall, snow melting rate).

Parameters:
-----------

time:  Time step of the model ";

%feature("docstring")  cmf::upslope::SolidRockCell::ETpot "double
ETpot(const cmf::math::Time &time)

Returns the potential evapotranspiration (from the vegetation) in
m3/day.

Parameters:
-----------

time:  Time step of the model ";

/*  Flow Accumulation  */

%feature("docstring")  cmf::upslope::SolidRockCell::CatchmentSize "double CatchmentSize() const

Public Get-Method of the catchment size. ";

%feature("docstring")  cmf::upslope::SolidRockCell::AddToCatchmentSize
"void AddToCatchmentSize(const cmf::upslope::UpslopeCell &upc)

Adds a cell to the catchment, not for external use. ";

/*  References to Map-based properties (like Vegetation and Soil)  */

%feature("docstring")  cmf::upslope::SolidRockCell::Vegetation "const
cmf::upslope::vegetation::IVegetation& Vegetation() const

Vegetation of the UpslopeCell ";

%feature("docstring")  cmf::upslope::SolidRockCell::Vegetation "void
Vegetation(const cmf::upslope::vegetation::IVegetation &vegetation)

Sets the vegetation of the cell. The vegetation is copied to the cell,
therefore each cell owns an extra copy of vegetation.

Parameters:
-----------

vegetation:  Vegetation that should be referenced by UpslopeCell

Vegetation does not mean the Vegetation type, like forest, arable land
etc., but the special vegetation patch at the location of the
UpslopeCell. The IVegetation object can (and should) know about its
vegetation type, but for the UpslopeCell the Vegetation-object acts as
the upper boundary of the model. For coupling with biogeochemical plot
models derivations of the IVegetation-Interface can be used. ";

%feature("docstring")  cmf::upslope::SolidRockCell::Snowpack "const
cmf::upslope::snow::Snowpack& Snowpack() const ";

%feature("docstring")  cmf::upslope::SolidRockCell::Snowpack "cmf::upslope::snow::Snowpack& Snowpack() ";

%feature("docstring")  cmf::upslope::SolidRockCell::Snowpack "void
Snowpack(const cmf::upslope::snow::Snowpack &snowpack) ";

/*  Metadata  */

%feature("docstring")  cmf::upslope::SolidRockCell::AddStateVariables
"void AddStateVariables(cmf::math::StateVariableVector &vector)

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::SolidRockCell::AverageSaturation
"double AverageSaturation(double integrationDepth=-1)

Pure virtual function, returns the average Saturation [0..1] of the
soil.

average Saturation [0..1] in m3 H2O m-3 pores

Parameters:
-----------

integrationDepth:  Depth of the zone to include into the calculation,
negative Values will use the overall depth of the soil ";

%feature("docstring")  cmf::upslope::SolidRockCell::SaturatedDepth "double SaturatedDepth()

Pure virtual function, returns the current saturated depth [m]. ";

%feature("docstring")  cmf::upslope::SolidRockCell::SetSaturation "void SetSaturation(double newSat)

Pure virtual function, sets the average saturation. ";

%feature("docstring")  cmf::upslope::SolidRockCell::ETact "cmf::water::WaterFlux ETact(const cmf::math::Time &Time)

Pure virtual function, returns the actual evapotranspiration [m3/d].
";

%feature("docstring")  cmf::upslope::SolidRockCell::GetPondedFlow "cmf::water::WaterFlux GetPondedFlow(cmf::math::Time timestep)

Returns the flow of ponded water [m3/s].

Parameters:
-----------

time:  ( cmf::math::Time) ";

%feature("docstring")  cmf::upslope::SolidRockCell::SetSaturatedDepth
"void SetSaturatedDepth(double depth)

Sets the saturated depth. ";

%feature("docstring")  cmf::upslope::SolidRockCell::SolidRockCell "SolidRockCell(double x, double y, double z, double Area,
cmf::upslope::vegetation::IVegetation *Veg) ";

%feature("docstring")  cmf::upslope::SolidRockCell::ToString "std::string ToString() const

Converts a cell to a string. ";


// File: a00061.xml
%feature("docstring") cmf::water::Solute "

A structure to identify a solute.

C++ includes: Solute.h ";

%feature("docstring")  cmf::water::Solute::Solute "Solute(const
Solute &copy) ";


// File: a00062.xml
%feature("docstring") cmf::water::Solutes "

Manages the solutes of the whole model. The static member All is the
only instance. Before you are creating any cmf object (like
UpslopeCell, Reach or IVegetation or Meteorology), make sure you have
added all solutes you are interest in to Solutes::All Generally you
are free to add any kind of Solute to the model, but each additional
will slow down calculations remarkably, and if you intend to use one
or more ExternalFunctionReaction special requirements apply.

C++ includes: Solute.h ";

%feature("docstring")  cmf::water::Solutes::add "const Solute&
add(const std::string &name, const std::string &unit=\"\", double
uptake=1)

Creates a solute in Solute::All.

Parameters:
-----------

name:  the name of the solute, e.g. 'Tracer', 'NO3'

unit:  Used unit for amount of solute e.g. 'mol','mmol','g','mg' etc.

uptake:  Fraction of the available concentration, that is taken up by
vegetation ";

%feature("docstring")  cmf::water::Solutes::size "size_t size() ";

%feature("docstring")  cmf::water::Solutes::SetInUse "void SetInUse()

If the Solutes of the model are marked as \"InUse\", no more solutes
may be added. They get marked as \"InUse\" as soon as an object
depending on the number of solutes is created (e.g. an UpslopeCell,
Reach, IVegetation or Meteorology). ";

%feature("docstring")  cmf::water::Solutes::begin "iterator begin()
";

%feature("docstring")  cmf::water::Solutes::end "iterator end() ";

%feature("docstring")  cmf::water::Solutes::begin "const_iterator
begin() const ";

%feature("docstring")  cmf::water::Solutes::end "const_iterator end()
const ";


// File: a00063.xml
%feature("docstring") cmf::water::SoluteStorage "

A class for the storage of any tracer. The state is the amount (mol,
kg etc. see cmf::water) of the tracer in the storage
\\\\begin{eqnarray*} \\\\frac{dX}{dt}&=&\\\\sum_{f=1}^{F}\\\\left( q_f
[X]_f\\\\right) +
\\\\sum_{r=1}^R\\\\left(f_r\\\\left([A],...,[Z]\\\\right)\\\\
V\\\\right) \\\\left[\\\\frac{mol}{day}\\\\right]\\\\\\\\ F&=&
\\\\mbox{Number of fluxes in water storage} \\\\\\\\ q_f&=&
\\\\mbox{Water flux in } \\\\frac{m^3}{day} \\\\\\\\
\\\\left[X\\\\right]_f &=& \\\\mbox{Concentration of solute X in flux
}q_f \\\\mbox{ in } \\\\frac{mol}{m^3} \\\\\\\\ R&=& \\\\mbox{Number
of reactions defined for this solute storage} \\\\\\\\
f_r\\\\left([A],...,[Z]\\\\right)&=& \\\\mbox{Reactive flux of }[X]
\\\\mbox{ in environment } [A],...,[Z] \\\\left[\\\\frac{mol}{m^3\\\\
day}\\\\right] \\\\\\\\ V &=& \\\\mbox{Volume of water in water
storage }\\\\left[m^3\\\\right] \\\\end{eqnarray*}.

C++ includes: SoluteStorage.h ";

%feature("docstring")  cmf::water::SoluteStorage::conc "real conc()
const

Returns the concentration of the solute. ";

%feature("docstring")  cmf::water::SoluteStorage::Derivate "virtual
real Derivate(const cmf::math::Time &time)

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::water::SoluteStorage::State "const real&
State() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::water::SoluteStorage::State "void
State(const real &newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::water::SoluteStorage::StateIsChanged "bool StateIsChanged()

Returns if the state was currently updated. ";


// File: a00064.xml
%feature("docstring") cmf::water::SoluteTimeseries "

A map of concentration time series for solutes.

C++ includes: Solute.h ";

%feature("docstring")  cmf::water::SoluteTimeseries::begin "iterator
begin() ";

%feature("docstring")  cmf::water::SoluteTimeseries::end "iterator
end() ";

%feature("docstring")  cmf::water::SoluteTimeseries::begin "const_iterator begin() const ";

%feature("docstring")  cmf::water::SoluteTimeseries::end "const_iterator end() const ";

%feature("docstring")  cmf::water::SoluteTimeseries::conc "WaterQuality conc(cmf::math::Time t) ";

%feature("docstring")  cmf::water::SoluteTimeseries::size "size_t
size() const

Returns the number of solutes in the solution. ";

%feature("docstring")  cmf::water::SoluteTimeseries::SoluteTimeseries
"SoluteTimeseries() ";

%feature("docstring")  cmf::water::SoluteTimeseries::SoluteTimeseries
"SoluteTimeseries(cmf::math::Time begin, cmf::math::Time step) ";

%feature("docstring")  cmf::water::SoluteTimeseries::SoluteTimeseries
"SoluteTimeseries(const cmf::water::SoluteTimeseries &sts) ";


// File: a00657.xml
%feature("docstring") std::stack "

STL class. ";


// File: a00065.xml
%feature("docstring") cmf::math::StateVariable "

Abstract class state variable

Simple exponential system class header implementing a state variable:

C++ includes: StateVariable.h ";

%feature("docstring")  cmf::math::StateVariable::Derivate "virtual
real Derivate(const cmf::math::Time &time)=0

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::math::StateVariable::State "const real&
State() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::math::StateVariable::State "void
State(const real &newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::math::StateVariable::StateIsChanged "bool
StateIsChanged()

Returns if the state was currently updated. ";

%feature("docstring")  cmf::math::StateVariable::StateVariable "StateVariable(real InitialState=0)

ctor ";


// File: a00066.xml
%feature("docstring") cmf::math::StateVariableOwner "

An abstract class, that owns one or more state variables, that can add
them to a vector of state variables in a certain order.

C++ includes: StateVariable.h ";

%feature("docstring")
cmf::math::StateVariableOwner::AddStateVariables "virtual void
AddStateVariables(cmf::math::StateVariableVector &vector)=0

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")
cmf::math::StateVariableOwner::StateVariableOwner "StateVariableOwner() ";


// File: a00067.xml
%feature("docstring") cmf::math::StateVariableVector "

A vector of state variables, can be solved by RKFIntegrator.

C++ includes: StateVariable.h ";

%feature("docstring")  cmf::math::StateVariableVector::CopyStates "void CopyStates(numVector &destination) const

Copies the states to a numeric vector using OpenMP. ";

%feature("docstring")  cmf::math::StateVariableVector::SetStates "void SetStates(const numVector &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::StateVariableVector::CopyDerivs "void CopyDerivs(Time time, numVector &destination, real factor=1)
const

Copies the derivatives at time step \"time\" to a numeric vector using
OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::StateVariableVector::GetStates "numVector GetStates() const

Returns the states in a numeric vector using :CopyStates, but is
slower because of additional memory allocation. ";

%feature("docstring")  cmf::math::StateVariableVector::GetDerivs "numVector GetDerivs(Time time) const

Returns the derivatives at time step \"time\" in a numeric vector
using :CopyDerivs, but is slower because of additional memory
allocation. ";


// File: a00582.xml
%feature("docstring") std::string "

STL class. ";


// File: a00658.xml
%feature("docstring") std::string::const_iterator "

STL iterator class. ";


// File: a00659.xml
%feature("docstring") std::string::const_reverse_iterator "

STL iterator class. ";


// File: a00660.xml
%feature("docstring") std::string::iterator "

STL iterator class. ";


// File: a00661.xml
%feature("docstring") std::string::reverse_iterator "

STL iterator class. ";


// File: a00588.xml
%feature("docstring") std::stringstream "

STL class. ";


// File: a00068.xml
%feature("docstring") cmf::StudyArea "

The whole study area, consisting of several catchments.

A study area consists of one or more subbasins (called Catchment). A
catchment consists of a reach and the contributing upslope area. The
upslope area is divided into cells of any shape with defined
connections to calculate subsurface flow. The cells are the central
concept of cmf.

In general you have the choice between layered cells, where you can
assign different soil properties in different layers or the vertical
homogenous cell, with constant soil properties throughout the profile.
While layered cells provide a more realistic description of soil
properties and hydrological processes, since they can provide a finer
vertical discretization of the soil, they demand much more calculation
power.

C++ includes: Basin.h ";

%feature("docstring")  cmf::StudyArea::StudyArea "StudyArea(cmf::upslope::UpslopeVector &upslopes, double
CatchmentAreaThreshold, cmf::upslope::UpslopeCell *pourPoint=0, double
maxReachLength=0)

Creates a study area from a vector of connected upslope cells
(automatic reach & catchment creation).

Parameters:
-----------

upslopes:  The DEM as a collection of UpslopeCells (
cmf::upslope::UpslopeVector *)

CatchmentAreaThreshold:  If the CatchmentSize of a cell is larger than
this value, a new Reach/Subbasin is created

pourPoint:  Defines a cell where the routing network should start. If
NULL (or None in Python), every possible reach is build

maxReachLength:  If the length of a reach is larger than this, a new
Reach/Subbasin is created (0 if there is no length boundary) ";

%feature("docstring")  cmf::StudyArea::StudyArea "StudyArea()

Creates an empty StudyArea (no catchments). ";

%feature("docstring")  cmf::StudyArea::FindCatchment "cmf::Catchment&
FindCatchment(cmf::river::reach &reach)

Finds the catchment of a reach (slow). ";

%feature("docstring")  cmf::StudyArea::FindCatchment "const
cmf::Catchment& FindCatchment(const cmf::river::reach &reach) const ";

%feature("docstring")  cmf::StudyArea::Cells "cmf::upslope::UpslopeVector Cells()

Creates a vector of all upslope cells. ";


// File: a00069.xml
%feature("docstring") cmf::StudyAreaSolver "

A solver for a complete study area. Consists of an Integrator for the
surface water system and some SubsurfaceSolver.

C++ includes: StudyAreaSolver.h ";

%feature("docstring")  cmf::StudyAreaSolver::StudyArea "cmf::StudyArea& StudyArea()

Provides access to the study area of this solver. ";

%feature("docstring")  cmf::StudyAreaSolver::StudyAreaSolver "StudyAreaSolver(cmf::StudyArea &studyarea, double
TargetSystemArea=0.0)

Creates a StudyAreaSolver.

Parameters:
-----------

studyarea:  The study area to be solved

TargetSystemArea:  The area in m2, each SubsurfaceSystem should have.
Any value smaller than the smallest catchment (e.g. 0) leads to one
system per catchment, any value greater than the biggest catchment
(e.g. 1e308) leads to one SubsurfaceSolver for the whole study area.
Values in between will pack some SubsurfaceSolver together. Your
mileage may vary. ";

%feature("docstring")  cmf::StudyAreaSolver::~StudyAreaSolver "~StudyAreaSolver() ";

%feature("docstring")  cmf::StudyAreaSolver::Run "int
Run(cmf::math::Time Until, cmf::math::Time ReachTimeStep)

Runs the whole system to an synchronization time.

Parameters:
-----------

Until:  Syncronization time of the system

ReachTimeStep:  Time step of the surface water system (usually < 10
min) ";

%feature("docstring")  cmf::StudyAreaSolver::ModelTime "cmf::math::Time ModelTime() const

Returns the current model time. ";

%feature("docstring")  cmf::StudyAreaSolver::ModelTime "void
ModelTime(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::StudyAreaSolver::ChangeReachIntegrator "void ChangeReachIntegrator(const cmf::math::Integrator
&IntegratorTemplate)

Changes the integrator for the surface water system to an integrator
of the given type. ";

%feature("docstring")
cmf::StudyAreaSolver::ChangeSubsurfaceIntegrators "void
ChangeSubsurfaceIntegrators(const cmf::math::Integrator
&IntegratorTemplate)

Changes the integrators for the subsurface systems to an integrator of
the given type. ";

%feature("docstring")  cmf::StudyAreaSolver::UnionSubsurfaceSolvers "cmf::SubsurfaceSolver& UnionSubsurfaceSolvers(int
SubsurfacesolverIndex1, int SubsurfacesolverIndex2)

Pushes the catchments of subsurface solver at index 2 to the
subsurface solver at index 1 and removes subsurface solver 2 and
returns subsurface solver at index 1. ";

%feature("docstring")  cmf::StudyAreaSolver::UnionSubsurfaceSolvers "cmf::SubsurfaceSolver& UnionSubsurfaceSolvers(const
cmf::SubsurfaceSolver &Solver1, const cmf::SubsurfaceSolver &Solver2)

Pushes the catchments of subsurface solver 2 to the subsurface solver
1 and removes subsurface solver 2 and returns subsurface solver 1. ";


// File: a00070.xml
%feature("docstring") cmf::SubsurfaceSolver "

Combines an cmf::math::Integrator with some Catchments. These
Catchments are one subsurface system. All Neighborhood relations of
the cells inside the system are switched on and all relations outside
this system are switched off (cmf::Upslope::Neighbor::Active flag)
automatically. Note: Adding a catchment to a SubsurfaceSolver effects
the Catchment!

C++ includes: StudyAreaSolver.h ";

%feature("docstring")  cmf::SubsurfaceSolver::SubsurfaceSolver "SubsurfaceSolver(const cmf::math::Integrator &Integrator)

Constructor for specified integrator (catchments have to be added). ";

%feature("docstring")  cmf::SubsurfaceSolver::SubsurfaceSolver "SubsurfaceSolver()

Std. constructor (empty catchment list, BDF2 integrator). ";

%feature("docstring")  cmf::SubsurfaceSolver::SubsurfaceSolver "SubsurfaceSolver(Catchment &catchment)

Solver for a single catchment (may be extended), BDF2 integrator. ";

%feature("docstring")  cmf::SubsurfaceSolver::~SubsurfaceSolver "~SubsurfaceSolver() ";

%feature("docstring")  cmf::SubsurfaceSolver::Integrator "cmf::math::Integrator& Integrator()

Access to the integrator. ";

%feature("docstring")  cmf::SubsurfaceSolver::Integrator "const
cmf::math::Integrator& Integrator() const ";

%feature("docstring")  cmf::SubsurfaceSolver::Add "void Add(Catchment
&catchment)

Adds the catchment to the solver and updates the neighborhood
relations of the complete upslope area. ";

%feature("docstring")  cmf::SubsurfaceSolver::ChangeIntegrator "void
ChangeIntegrator(const cmf::math::Integrator &IntegratorTemplate)

Changes the integrator to another type. ";

%feature("docstring")  cmf::SubsurfaceSolver::ModelTime "cmf::math::Time ModelTime() const

Returns the model time of the Integrator. ";

%feature("docstring")  cmf::SubsurfaceSolver::ModelTime "void
ModelTime(cmf::math::Time newTime)

Sets the model time of the Integrator. ";

%feature("docstring")  cmf::SubsurfaceSolver::Cells "const
cmf::upslope::UpslopeVector Cells() const ";

%feature("docstring")  cmf::SubsurfaceSolver::Run "int
Run(cmf::math::Time Until)

Runs the subsurface system and updates the lateral in flow to the
reaches. ";

%feature("docstring")  cmf::SubsurfaceSolver::min_dt "cmf::math::Time
min_dt() ";

%feature("docstring")  cmf::SubsurfaceSolver::size "size_t size()
const

returns the number of catchments of this integrator ";

%feature("docstring")  cmf::SubsurfaceSolver::__getitem__ "cmf::Catchment& __getitem__(int i) ";


// File: a00071.xml
%feature("docstring") cmf::river::SWATReachType "

Structure for the description of structural parameters of a reach.

Uses the SWAT channel geometry (see SWAT Theoretical Documentation,
Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
plain is not plain, but has a small slope=0.5%, but has an infinite
width

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::SWATReachType::Width "virtual
double Width(double depth) const

Calculates the flow width from a given actual depth [m] using the
actual channel geometry \\\\begin{eqnarray*} \\\\mbox{If } d\\\\le
d_{channel} && \\\\\\\\ w &=& w_{bottom} + 2 \\\\Delta_{bank} d
\\\\\\\\ \\\\mbox{else, } && \\\\mbox{if the river floods the flood
plain} \\\\\\\\ w &=& w_{bank} + 2 \\\\Delta_{Floodplain}
(d-d_{channel} \\\\\\\\ \\\\end{eqnarray*}.

See:  SWATtheoDoc eq. 7:1.1.3 ";

%feature("docstring")  cmf::river::SWATReachType::Perimeter "virtual
double Perimeter(double depth) const

Calculates the wetted perimeter from a given actual depth [m] using
the actual channel geometry \\\\begin{eqnarray*} \\\\mbox{If } d\\\\le
d_{channel} && \\\\\\\\ P &=& w_{bottom} + 2 \\\\sqrt{1+
{\\\\Delta_{bank}}^2} d \\\\\\\\ \\\\mbox{else, } && \\\\mbox{if the
river floods the flood plain} \\\\\\\\ P &=& P(d_{channel} + 2
\\\\sqrt{1+ {\\\\Delta_{flood\\\\ plain}}^2} (d-d_{channel}) \\\\\\\\
\\\\end{eqnarray*}.

See:  SWATtheoDoc eq. 7:1.1.5

Parameters:
-----------

depth:  Actual depth of the reach [m] ";

%feature("docstring")  cmf::river::SWATReachType::Depth "virtual
double Depth(double area) const

Calculates the actual depth of the reach using the channel geometry
\\\\begin{eqnarray*} d &=& \\\\sqrt{\\\\frac{A}{\\\\Delta_{bank}} +
\\\\frac{{w_{bottom}}^2}{4 {\\\\Delta_{bank}}^2}} -
\\\\frac{w_{bottom}}{2 \\\\Delta_{bank}} \\\\\\\\ \\\\mbox{If }
d>d_{channel} &&\\\\\\\\
d&=&d_{channel}+\\\\sqrt{\\\\frac{A-A(d_{channel})}{\\\\Delta_{flood\\\\
plain}} + \\\\frac{{w(d_{channel})}^2}{4 {\\\\Delta_{flood\\\\
plain}}^2}} - \\\\frac{w(d_{channel})}{2 \\\\Delta_{flood\\\\ plain}}
\\\\\\\\ \\\\end{eqnarray*}.

See:  SWATtheoDoc eq. 7:1.2.4

Depth of the reach [m]

Parameters:
-----------

area:  Wetted area of a river cross section [m2], can be obtained by
V/l, where V is the stored volume and l is the reach length ";

%feature("docstring")  cmf::river::SWATReachType::Area "virtual
double Area(double depth) const

Calculates the wetted area from a given depth using the channel
geometry. In most cases use Area=V/l, where V is the stored volume and
l is the reach length \\\\begin{eqnarray*} \\\\mbox{If } d>d_{channel}
&&\\\\\\\\ A &=& \\\\left(w_{bottom} + \\\\Delta_{bank} d\\\\right) d
\\\\\\\\ \\\\mbox{else, } && \\\\mbox{if the river floods the flood
plain} \\\\\\\\ A &=& A(d_{channel}) + \\\\left(w(d_{channel} +
\\\\Delta_{flood\\\\ plain} \\\\left(d-d_{channel}\\\\right)\\\\right)
(d-d_{channel}) \\\\\\\\ \\\\end{eqnarray*}.

See:  SWATtheoDoc eq. 7:1.1.4

Wetted area of a river cross section [m2]

Parameters:
-----------

depth:  Depth of the reach [m] ";

%feature("docstring")  cmf::river::SWATReachType::SWATReachType "SWATReachType()

Creates a new reach structure with standard values (small natural
river) BottomWidth = 3m, ChannelDepth = 0.5m, BankSlope = 2, nManning
= 0.0035, FloodPlainSlope = 200. ";

%feature("docstring")  cmf::river::SWATReachType::SWATReachType "SWATReachType(double BankWidth, double Depth)

Creates a new reach structure from a give width and depth.

Parameters:
-----------

BankWidth:  Width of the reach from bank to bank [m]

Depth:  Depth of the reach [m] ";

%feature("docstring")  cmf::river::SWATReachType::qManning "double
qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach
\\\\begin{eqnarray*} q_{Manning}&=& A R^{\\\\frac 23}
\\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
\\\\mbox{ Area of the wetted crossection, Volume per length}\\\\\\\\
R&=&\\\\frac A P(d) \\\\\\\\ P(d)&=& \\\\mbox{ Perimeter of the wetted
crossection, a function of reach depth} \\\\\\\\ d(V)&=& \\\\mbox{
Depth of the reach} \\\\\\\\ \\\\Delta_z&=& \\\\frac{z_{max} -
z_{min}}{l} \\\\mbox{ Slope of the reach} \\\\\\\\ \\\\end{eqnarray*}.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";


// File: a00072.xml
%feature("docstring") cmf::math::Time "

A time class, used to pass around current modelling times.

Timespans and dates in cmf are used with a special object, called
Time. The advantage of an extra class has the advantage, that the user
does not has to rememember, which unit of time he or she uses or what
time unit is accepted by a specific function of the model. Arithmetic
and boolean operators are supported by Time. Internally the time
classes stores the time as integer milliseconds, therefore rounding
issues will only appear at very small time ranges. Absolute time (like
dates) are represented as milliseconds gone by from Dec, 31st 1899.
Microsoft Excel dates are represented as days from that time, using
floating point numbers, therefore it is very simple to convert Excel
time representations to cmf time.

Another object is Date, which is doesn't provide the operators, but
has a nice printed version and some special date functions, like day
of year (DOY) and provides access to the current hour of day and so
on, which only applyto dates and not to time spans. You can convert
Time to Date an vice versa. The printing is not culture aware and uses
the European representation. If you use the Python standard library
datetime, conversion between Python time and cmf time is
possibleCreating absolute time values (dates)

import CMFlib as cmf                 # Create the time: Jan, 5th 2001,
2:30 pm, 20s, 412 ms                 t=cmf.Time(5,1,2001,14,30,20,412)
print t # Prints: '36896d:14:30:20.412h'                 print
t.AsDate() # Prints: '05.01.2001 14:30:20.412'Creating time spans

In principle, there are three ways to create time spans. One is to use
one of the static functions, another is to multiply an existing time
span (like one of the build in constants) or to substrate two absolute
times.Available static functions, the default value is always 1

Milliseconds(): t=cmf.Time.Milliseconds(4100), create a timespan of
4.1 seconds

Seconds(): t=cmf. Time.Seconds(4.1), create a timespan of 4.1 seconds

Minutes(): t=cmf.Time.Minutes(138), create a timespan of 2.3 hours
(138 min)

Hours(): t=cmf. Time.Hours(2.3), create a timespan of 2.3 hours (138
min)

Days(): t=cmf. Time.Days(2.5), create a timespan of 60 hours

Years(): t=cmf. Time.Years(), create a timespan of 365 days Available
constants

cmf.sec * 4.1: 4.1 seconds

cmf.min * 138: 2.3 hours (138 min)

cmf.h * 2.3: 2.3 hours (138 min)

cmf.day * 2.5: 60 hours (2.5 days)

cmf.week: 7 days

cmf.month: 365/12 days (30.4167 days)

cmf.year: 365 days Available operators:

time + time = time, time - time = time

time * float = time ,time / float = time

time/time=float

&gt, &lt, ==, != Conversions

Converting to python datetime

import CMFlib as cmf                 pythontime = cmf.year.AsPython()
cmftime=cmf.AsCMFTime(pythontime)                 print
type(pythontime) # '<type 'datetime.datetime'>'                 print
type(cmftime)    # '<class 'CMFLib.Time'>'Converting to numbers

t.AsMilliseconds()

t.AsSeconds()

t.AsMinutes()

t.AsHours()

t.AsDays()

t.AsYears() Creating time ranges

import CMFLib as cmf                 start=cmf.Time(5,1,2001)
end=cmf.Time(6,1,2001)                 step=cmf.h * 6 for t in
cmf.timerange(start,end,step):                     print t.AsDate()
# Prints:                 # 05.01.2001 # 05.01.2001 06:00
# 05.01.2001 12:00 # 05.01.2001 18:00

C++ includes: Time.h ";

/*  Constructors  */

%feature("docstring")  cmf::math::Time::Time "Time(double days)

Conversion constructor. ";

%feature("docstring")  cmf::math::Time::Time "Time(int day, int
month, int year=2001, int hour=0, int minute=0, int second=0, int
ms=0)

Construction from date and stores the time as Excel-Time (0 =
31.12.1899 0:00:00). ";

%feature("docstring")  cmf::math::Time::Time "Time(Date date)

Conversion constructor. ";

%feature("docstring")  cmf::math::Time::Time "Time(const Time &t)

Copy constructor. ";

%feature("docstring")  cmf::math::Time::Time "Time()

Standard constructor. ";

/*  Time unit conversion  */

%feature("docstring")  cmf::math::Time::AsDays "double AsDays() const

Time in days. ";

%feature("docstring")  cmf::math::Time::AsHours "double AsHours()
const

Time in hours. ";

%feature("docstring")  cmf::math::Time::AsMinutes "double AsMinutes()
const

Time in minutes. ";

%feature("docstring")  cmf::math::Time::AsSeconds "double AsSeconds()
const

Time in seconds. ";

%feature("docstring")  cmf::math::Time::AsMilliseconds "long long
AsMilliseconds() const

Time in milliseconds. ";

%feature("docstring")  cmf::math::Time::AsDate "Date AsDate() const
";

%feature("docstring")  cmf::math::Time::ToString "std::string
ToString(char seperator=':') ";

/*  Arithmetic operators  */

/*  Boolean Operators  */

%feature("docstring")  cmf::math::Time::NextDay "Time NextDay() const

Returns the beginning of the next day. ";

%feature("docstring")  cmf::math::Time::NextFullHour "Time
NextFullHour() const

Returns the next full hour. ";


// File: a00073.xml
%feature("docstring") cmf::math::timeseries "

A timeseries is a list of values, equally distributed over time. To
create one, one have to provide as start date and a step size. The end
time is calculated from the number of values. Values queried for times
before the start time are returned as the first item, values after the
end time equal the last item. A timeseries with only one item reacts
like a scalar value.

Creating a time series

import CMFLib as cmf                 # Start date is the January 5th
2001 at 2:30 pm start=cmf.Time(5,1,2001,14,30)
# time step of the timeseries is 20 minutes
step=cmf.min*20                 # Type of interpolation between values
# 0 - Nearest neighbor,                 # 1 - Linear,
# 2 - Squared, # 3 - Cubic, etc.                 interpolation=1 #
Create timeseries
timeseries=cmf.timeseries(start,step,interpolation) # Add data
timeseries.Add(0.1) # Value at 2001/5/1 2:30pm is 0.1
timeseries.Add(0.2) # Value at 2001/5/1 2:50pm is 0.2
timeseries.Add(0.1) # Value at 2001/5/1 3:10pm is 0.1

With this technic it is simple to read files or databases to fill
timeseries.Using a timeseries

# Query every minute between 2:15 and 3:14 pm for t in
cmf.timerange(start,start+cmf.h,cmf.min): print
\"Time:\",t.AsDate(),\"Value:\", timeseries[t]                 # Query
a specific position of the timeseries                 print
timeseries[2]

C++ includes: timeseries.h ";

/*  Operators  */

/* Binary operators defined as free operators:

x = {+,-,*,/}

Defined for (x is one of the operators above):  timeseries =
timeseries x timeseries

timeseries = double x timeseries

timeseries = timeseries x double

*/

%feature("docstring")  cmf::math::timeseries::power "timeseries&
power(double)

raises the timeseries to a power ";

%feature("docstring")  cmf::math::timeseries::reduce_min "timeseries
reduce_min(cmf::math::Time begin, cmf::math::Time step) const ";

%feature("docstring")  cmf::math::timeseries::reduce_max "timeseries
reduce_max(cmf::math::Time begin, cmf::math::Time step) const

Creates a timeseries with a bigger timestep, containing the minimum.
";

%feature("docstring")  cmf::math::timeseries::reduce_sum "timeseries
reduce_sum(cmf::math::Time begin, cmf::math::Time step) const

Creates a timeseries with a bigger timestep, containing the maximum.
";

%feature("docstring")  cmf::math::timeseries::reduce_avg "timeseries
reduce_avg(cmf::math::Time begin, cmf::math::Time step) const

Creates a timeseries with a bigger timestep, containing the sum. ";

/*  I/O  */

/* Creates a timeseries with a bigger timestep, containing the average

*/

%feature("docstring")  cmf::math::timeseries::Save "void
Save(std::ostream &file)

Save the Meteorology data to an ASCII File with fixed format. ";

%feature("docstring")  cmf::math::timeseries::timeseries "timeseries(std::istream &file)

Creates a Meterology from a File in fixed format. ";

%feature("docstring")  cmf::math::timeseries::end "cmf::math::Time
end() const

Last date of measurements. ";

%feature("docstring")  cmf::math::timeseries::Add "void Add(double
Value)

Appends a measurement. ";

%feature("docstring")  cmf::math::timeseries::isempty "bool isempty()
const

returns true if no values are added to the timeseries ";

%feature("docstring")  cmf::math::timeseries::clear "void clear() ";

%feature("docstring")  cmf::math::timeseries::size "int size() const
";

%feature("docstring")  cmf::math::timeseries::timeseries "timeseries(cmf::math::Time _begin, cmf::math::Time _step, int
_interpolationmethod=0)

Constructor of a time series.

Parameters:
-----------

_begin:  First date of measurement

_step:   Time between measurements

_interpolationmethod:  Method for the interpolation (0 - Nearest
neighbor, 1- linear, 2 - cubic spline (not implemented yet) ";

%feature("docstring")  cmf::math::timeseries::timeseries "timeseries(cmf::math::Time _begin, cmf::math::Time _step, int size,
int _interpolationmethod) ";

%feature("docstring")  cmf::math::timeseries::timeseries "timeseries() ";

%feature("docstring")  cmf::math::timeseries::timeseries "timeseries(const cmf::math::timeseries &ts) ";


// File: a00074.xml
%feature("docstring") cmf::upslope::TotalFlux "

A simple structure holding a water flux for throughfall, ETact and
ponded flux.

C++ includes: UpslopeVector.h ";

%feature("docstring")  cmf::upslope::TotalFlux::TotalFlux "TotalFlux() ";


// File: a00075.xml
%feature("docstring") cmf::river::TriangularReach "

Structure for the description of reaches with a triangular cross
section.

Although real triangular cross section reach are rarely met, a
triangular reach does scale with its water load, and is therefore
preferable in case where nothing about channel geometry is known

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::TriangularReach::Width "virtual
double Width(double depth) const

Returns the width of the stream at a given depth \\\\begin{eqnarray*}
w &=& 2 \\\\Delta\\\\ d \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::river::TriangularReach::Perimeter "virtual double Perimeter(double depth) const

Returns the wetted perimeter at a given depth \\\\begin{eqnarray*} P
&=& 2 d \\\\sqrt{1+\\\\Delta^2} \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::river::TriangularReach::Depth "virtual
double Depth(double area) const

Returns the depth at a given crossection area \\\\begin{eqnarray*} d
&=& \\\\sqrt{\\\\frac{A}{\\\\Delta}} \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::river::TriangularReach::Area "virtual
double Area(double depth) const

Returns the crossection area at a given depth \\\\begin{eqnarray*} A
&=& d^2 \\\\Delta \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::river::TriangularReach::TriangularReach "TriangularReach(double bankSlope=2)

Creates a new triangular reach type. ";

%feature("docstring")  cmf::river::TriangularReach::qManning "double
qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach
\\\\begin{eqnarray*} q_{Manning}&=& A R^{\\\\frac 23}
\\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
\\\\mbox{ Area of the wetted crossection, Volume per length}\\\\\\\\
R&=&\\\\frac A P(d) \\\\\\\\ P(d)&=& \\\\mbox{ Perimeter of the wetted
crossection, a function of reach depth} \\\\\\\\ d(V)&=& \\\\mbox{
Depth of the reach} \\\\\\\\ \\\\Delta_z&=& \\\\frac{z_{max} -
z_{min}}{l} \\\\mbox{ Slope of the reach} \\\\\\\\ \\\\end{eqnarray*}.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";


// File: a00649.xml
%feature("docstring") std::underflow_error "

STL class. ";


// File: a00076.xml
%feature("docstring") cmf::upslope::connections::UnsatSatConnection "

Calculates the flux from the unsaturated zone to the saturated zone by
vertical outflow from the unsaturated zone and water exchange by water
table changes.

\\\\begin{eqnarray*} K_u &=& K(\\\\theta) A \\\\\\\\ Ex_w &=&
\\\\frac{dz_{sat}}{dt\\\\ \\\\Delta Z_{layer}} V_{layer} \\\\\\\\
\\\\frac{dz_{sat}}{dt} &=& \\\\frac{ \\\\sum q_{Saturated}}{ A
\\\\Phi} \\\\\\\\ \\\\end{eqnarray*} where:  $ A $ is the area of the
cell

$ K(\\\\theta) $ is the unsaturated conductivity (see SoilType::Kunsat
)

$ \\\\Delta Z $ is the thickness of a layer

$ V $ is the volume of water in a layer

$ layer $ is the unsaturated zone if $ \\\\frac{dz_{sat}}{dt} $ is
positive, otherwise layer is the saturated zone

$ \\\\sum q $ is the water balance of the saturated zone

$ \\\\Phi $ is the porosity

C++ includes: FluxConnections.h ";

%feature("docstring")
cmf::upslope::connections::UnsatSatConnection::UnsatSatConnection "UnsatSatConnection(cmf::upslope::FlexibleSizeLayer &unsat,
cmf::upslope::FlexibleSizeSaturatedZone &sat)

Creates a connection between unsaturated and saturated zone. ";

%feature("docstring")
cmf::upslope::connections::UnsatSatConnection::q "real q(const
FluxNode &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::UnsatSatConnection::Target "FluxNode&
Target(const FluxNode &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::UnsatSatConnection::Target "const
FluxNode& Target(const FluxNode &inquirer) const

Returns the other end of a connection than the asking end (const). ";

%feature("docstring")
cmf::upslope::connections::UnsatSatConnection::conc "WaterQuality
conc(const FluxNode &inquirer, cmf::math::Time t)

Returns the concentration of the flux. If not overridden, it returns
the concentration of the source of the flux (direction depending). ";


// File: a00077.xml
%feature("docstring") cmf::upslope::UpslopeCell "

Abstract class Upslope cell, encapsulation for subsurface flows.

This class holds the position of the cell in space, subsurface
neighborhood relations, main outlet for surface flows and provides a
connection to a vegetation object, for water exchange with the
atmosphere

Required and proposed overrides in Derivates  Required:
AddStateVariables - Adds the Statevariables of this upslope cell to a
vector of state variables

Required: GetPondedFlow - Returns the flow rate of ponded water

Required: AverageSaturation - Returns the average Saturation of the
soil in the rooting zone

Required: SetSaturation - Set an initial saturation of the cell

Required: SaturatedDepth - Returns the depth of the water table

Proposed: Derived* AsDerived(cell*) - A standalone function that
perfoms a dynamic cast of a UpslopeCell pointer (e.g. an element of
UpslopeVector) to the child class, this is needed for the Python
interface If the cell is not of type Derived, the function returns a
null- pointer (None in Python)

C++ includes: UpslopeCell.h ";

/*  Interface to the soil water storages  */

%feature("docstring")  cmf::upslope::UpslopeCell::AverageSaturation "virtual double AverageSaturation(double integrationDepth=-1)=0

Pure virtual function, returns the average Saturation [0..1] of the
soil.

average Saturation [0..1] in m3 H2O m-3 pores

Parameters:
-----------

integrationDepth:  Depth of the zone to include into the calculation,
negative Values will use the overall depth of the soil ";

%feature("docstring")  cmf::upslope::UpslopeCell::SaturatedDepth "virtual double SaturatedDepth()=0

Pure virtual function, returns the current saturated depth [m]. ";

%feature("docstring")  cmf::upslope::UpslopeCell::SetSaturation "virtual void SetSaturation(double newSat)=0

Pure virtual function, sets the average saturation. ";

%feature("docstring")  cmf::upslope::UpslopeCell::SetSaturatedDepth "virtual void SetSaturatedDepth(double depth)

Sets the saturated depth. ";

%feature("docstring")  cmf::upslope::UpslopeCell::ETact "virtual
cmf::water::WaterFlux ETact(const cmf::math::Time &time)=0

Pure virtual function, returns the actual evapotranspiration [m3/d].
";

%feature("docstring")  cmf::upslope::UpslopeCell::InFlow "virtual
cmf::water::WaterFlux InFlow(const cmf::math::Time &time)

Returns the incoming water (e.g. throughfall, snow melting rate).

Parameters:
-----------

time:  Time step of the model ";

%feature("docstring")  cmf::upslope::UpslopeCell::GetPondedFlow "virtual cmf::water::WaterFlux GetPondedFlow(cmf::math::Time time)=0

Returns the flow of ponded water [m3/s].

Parameters:
-----------

time:  ( cmf::math::Time) ";

%feature("docstring")  cmf::upslope::UpslopeCell::ETpot "double
ETpot(const cmf::math::Time &time)

Returns the potential evapotranspiration (from the vegetation) in
m3/day.

Parameters:
-----------

time:  Time step of the model ";

/*  Metadata  */

/*  References to Map-based properties (like Vegetation and Soil)  */

%feature("docstring")  cmf::upslope::UpslopeCell::Vegetation "const
cmf::upslope::vegetation::IVegetation& Vegetation() const

Vegetation of the UpslopeCell ";

%feature("docstring")  cmf::upslope::UpslopeCell::Vegetation "void
Vegetation(const cmf::upslope::vegetation::IVegetation &vegetation)

Sets the vegetation of the cell. The vegetation is copied to the cell,
therefore each cell owns an extra copy of vegetation.

Parameters:
-----------

vegetation:  Vegetation that should be referenced by UpslopeCell

Vegetation does not mean the Vegetation type, like forest, arable land
etc., but the special vegetation patch at the location of the
UpslopeCell. The IVegetation object can (and should) know about its
vegetation type, but for the UpslopeCell the Vegetation-object acts as
the upper boundary of the model. For coupling with biogeochemical plot
models derivations of the IVegetation-Interface can be used. ";

%feature("docstring")  cmf::upslope::UpslopeCell::Snowpack "const
cmf::upslope::snow::Snowpack& Snowpack() const ";

%feature("docstring")  cmf::upslope::UpslopeCell::Snowpack "cmf::upslope::snow::Snowpack& Snowpack() ";

%feature("docstring")  cmf::upslope::UpslopeCell::Snowpack "void
Snowpack(const cmf::upslope::snow::Snowpack &snowpack) ";

/*  Spatial Properties.  */

/* Properties of UpslopeCell that are describing the spatial
distribution of the Cells

*/

%feature("docstring")  cmf::upslope::UpslopeCell::Area "double Area()
const

Area of UpslopeCell in m2. ";

%feature("docstring")  cmf::upslope::UpslopeCell::Center "cmf::geometry::point& Center()

Center of the Cell. ";

%feature("docstring")  cmf::upslope::UpslopeCell::Center "cmf::geometry::point Center() const ";

%feature("docstring")  cmf::upslope::UpslopeCell::Height "double
Height() const

Mean height of Cell a.s.l. ";

%feature("docstring")  cmf::upslope::UpslopeCell::GetSlopeTo "double
GetSlopeTo(cmf::upslope::UpslopeCell &other) const

Calculates the topographic slope to another cell in m/m. ";

/*  Neighborhood.  */

/* Methods to handle and describe the topological relation to other
Cells

*/

%feature("docstring")  cmf::upslope::UpslopeCell::NeighborCount "int
NeighborCount() const ";

%feature("docstring")  cmf::upslope::UpslopeCell::GetNeighbor "Neighbor& GetNeighbor(int index)

The Neighborhood of a cell, this acces is quite slow, in C++ use the
NeighborIterator for cycling.

Parameters:
-----------

index:  Index of the neighbor ";

%feature("docstring")  cmf::upslope::UpslopeCell::AddNeighbor "bool
AddNeighbor(UpslopeCell &cell, double flowwidth)

Adds a Neighbor cell to the neighborhood.

True if cell was added, false if cell was already defiened as neighbor

Parameters:
-----------

cell:  Neighboring cell

flowwidth:  Lenght of intersection [m] ";

%feature("docstring")  cmf::upslope::UpslopeCell::IsNeighbor "bool
IsNeighbor(const UpslopeCell &cell)

Returns true if the given cell is a neighbor of this. ";

%feature("docstring")  cmf::upslope::UpslopeCell::RemoveNeighbor "void RemoveNeighbor(int index)

Removes a neighbor at an specified index. ";

%feature("docstring")  cmf::upslope::UpslopeCell::RemoveNeighbor "bool RemoveNeighbor(const UpslopeCell &cell)

Removes a specific cell. ";

%feature("docstring")  cmf::upslope::UpslopeCell::JoinCell "void
JoinCell(UpslopeCell &cell)

Creates a union from the given cell and this. Changes area and
neighborhood relations, any other properties stay the same. Don't
forget to remove the joined cell from any collection and delete it! ";

%feature("docstring")  cmf::upslope::UpslopeCell::GetNeighbor "NeighborIterator GetNeighbor()

Returns an NeighborIterator for fast cycling (only C++ API). ";

%feature("docstring")  cmf::upslope::UpslopeCell::GetNeighbor "NeighborIterator GetNeighbor(const UpslopeCell &cell) ";

%feature("docstring")  cmf::upslope::UpslopeCell::MainOutlet "Neighbor MainOutlet(bool ForceCalculation)

Gets the downslope cell with steepest slope (terrain), calculated at
first call of the function. ";

%feature("docstring")  cmf::upslope::UpslopeCell::MainOutlet "Neighbor MainOutlet() const ";

%feature("docstring")  cmf::upslope::UpslopeCell::GetNeighborhoodType
"cmf::upslope::UpslopeCell::NeighborhoodType GetNeighborhoodType()

Returns the type of neighborhood. ";

%feature("docstring")
cmf::upslope::UpslopeCell::SortNeighborhoodClockwise "void
SortNeighborhoodClockwise()

Sorts the neighbors in clockwise direction. ";

/*  Flow Accumulation  */

%feature("docstring")  cmf::upslope::UpslopeCell::CatchmentSize "double CatchmentSize() const

Public Get-Method of the catchment size. ";

%feature("docstring")  cmf::upslope::UpslopeCell::AddToCatchmentSize "void AddToCatchmentSize(const cmf::upslope::UpslopeCell &upc)

Adds a cell to the catchment, not for external use. ";

/*  Constructors.  */

%feature("docstring")  cmf::upslope::UpslopeCell::UpslopeCell "UpslopeCell(double x, double y, double z, double Area, const
cmf::upslope::vegetation::IVegetation *vegetation)

Constructor of an upslope cell.

Parameters:
-----------

x:  X-Coordinate of cell [m]

y:  Y-Coordinate of cell [m]

z:  Mean height of cell a.s.l. [m]

Area:  Area of the cell [m2]

vegetation:  Pointer to the vegetation of the cell (
cmf::upslope::vegetation::IVegetation), the instance is copied. ";

%feature("docstring")  cmf::upslope::UpslopeCell::UpslopeCell "UpslopeCell()

Initializes the location with (0 0 0) and the Area with 1. ";

%feature("docstring")  cmf::upslope::UpslopeCell::~UpslopeCell "virtual ~UpslopeCell() ";

%feature("docstring")  cmf::upslope::UpslopeCell::ToString "std::string ToString() const

Converts a cell to a string. ";

%feature("docstring")  cmf::upslope::UpslopeCell::AddStateVariables "virtual void AddStateVariables(cmf::math::StateVariableVector
&vector)=0

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";


// File: a00078.xml
%feature("docstring") cmf::upslope::UpslopeCell::NeighborIterator "

Fast iterator for the neighborhood of a cell (only for the C++ API,
use GetNeighbor instead).

C++ includes: UpslopeCell.h ";

%feature("docstring")
cmf::upslope::UpslopeCell::NeighborIterator::valid "bool valid()

Returns false, if the all neighbors are cycled. ";

%feature("docstring")
cmf::upslope::UpslopeCell::NeighborIterator::NeighborIterator "NeighborIterator(std::vector< Neighbor >::iterator Begin, std::vector<
Neighbor >::iterator End)

Creates an iterator for a range. ";

%feature("docstring")
cmf::upslope::UpslopeCell::NeighborIterator::NeighborIterator "NeighborIterator(const NeighborIterator &copy)

Copies an iterator. ";


// File: a00079.xml
%feature("docstring") cmf::upslope::UpslopeResultRaster "

A raster with fast access to results of UpslopeCells.

C++ includes: UpslopeResultRaster.h ";

/*  Metadata  */

%feature("docstring")  cmf::upslope::UpslopeResultRaster::Xllcorner "double Xllcorner() const

x-Coordinate for the Lower Left corner (in cellsize units) ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::Yllcorner "double Yllcorner() const

y-Coordinate for the Lower Left corner (in cellsize units) ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::XCellsize "double XCellsize() const

Cellsize of the raster. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::YCellsize "double YCellsize() const

Cellsize of the raster. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::ColumnCount
"int ColumnCount() const

Number of columns in the raster. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::RowCount "int RowCount() const

Number of rows in the raster. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::Width "double Width() const

Extent W-E in cellsize units. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::Height "double Height() const

Extent N-S in cellsize units. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::NoData "float  NoData() const

Returns rasterType (NoData). ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::GetBounds "BoundingBox GetBounds() const

Returns the bounding box of the raster. ";

/*  Data access  */

%feature("docstring")  cmf::upslope::UpslopeResultRaster::IdentifyXY "float  IdentifyXY(double x, double y) const

Returns the value of the raster at the given position. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::IdentifyRowCol "float
IdentifyRowCol(int row, int col) const

Returns the value of the raster at the given cell. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::IdentifyColRow "float
IdentifyColRow(int col, int row) const

Returns the value of the raster at the given cell. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::HasData "bool HasData(double x, double y) const

Returns true if there is data at the given position. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::HasData "bool HasData(int col, int row) const

Returns true if there is data at the given position. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::SetData "void SetData(double x, double y, floatval)

Sets a value at the given position.

Parameters:
-----------

x:  X-coordinate

y:  Y-coordinate

val:  Value to set at (x,y) ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::SetData "void SetData(int col, int row, floatval)

Sets a value at the given position.

Parameters:
-----------

col:  Column of the raster

row:  Row of the raster

val:  Value to set at (col,row) ";

/*  Analysis  */

%feature("docstring")  cmf::upslope::UpslopeResultRaster::statistics "RasterStatistics statistics()

Creates statistics for the raster. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::histogram "Histogram histogram(size_t bins=100) ";

/*  Operators  */

/*  Constructors & IO-Methods  */

%feature("docstring")
cmf::upslope::UpslopeResultRaster::WriteToASCFile "void
WriteToASCFile(std::ostream &ASCFile)

Writes the raster to a stream in ESRI-ASC format. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::WriteToASCFile "void
WriteToASCFile(std::string filename)

Writes the raster to a filename. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::WriteToBinary "void
WriteToBinary(std::string filename) const

Writes the data to the file with the given file name and the header to
a filename with the extension .hdr.

If the filename has the extension .flt and the raster is a float
raster the saved file can be read by ArcGIS ";

/*  Conversion functions  */

%feature("docstring")  cmf::upslope::UpslopeResultRaster::ToInt "Raster<int> ToInt() const

Converts the raster to a raster of int. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::ToFloat "Raster<float> ToFloat()

Converts the raster to a raster of float (32bit). ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::ToDouble "Raster<double> ToDouble()

Converts the raster to a raster of float (64bit). ";

/*  Focal functions  */

%feature("docstring")  cmf::upslope::UpslopeResultRaster::focal_min "Raster<float > focal_min(int n=3)

Creates a raster, which contains for each cell the minimum of the
surrounding n x n window. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::focal_max "Raster<float > focal_max(int n=3)

Creates a raster, which contains for each cell the maximum of the
surrounding n x n window. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::focal_mean "Raster<float > focal_mean(int n=3)

Creates a raster, which contains for each cell the mean of the
surrounding n x n window. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::focal_stdev
"Raster<float > focal_stdev(int n=3)

Creates a raster, which contains for each cell the standard deviation
of the surrounding n x n window. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::focal_majority "Raster<float >
focal_majority(int n=3)

Creates a raster, which contains for each cell the majority value of
the surrounding n x n window (usually only used for integer raster).
";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::focal_mean_difference "Raster<float > focal_mean_difference(int n=3)

Creates a raster, which contains for each cell the difference between
the actual value and the mean of the surrounding n x n window (usually
only used for integer raster) This function can be used to identify
very important points (VIP) for triangulation. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::UpslopeResultRaster "UpslopeResultRaster(const cmf::geometry::Raster< float >
&TemplateRaster)

Creates a UpslopeResultRaster from a template raster. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::SetSaturation "void
SetSaturation(const UpslopeVector &upslopes, double
integrationdepth=-1)

Populates the raster with the average saturation of each cell in
upslopes. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::SetSaturationDepth "void
SetSaturationDepth(const UpslopeVector &upslopes)

Populates the raster with the saturated depth of each cell in
upslopes. ";

%feature("docstring")
cmf::upslope::UpslopeResultRaster::SetPondedFlow "void
SetPondedFlow(const UpslopeVector &upslopes, cmf::math::Time timestep)

Populates the raster with the ponded flow of each cell in upslopes at
the given time step. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::GetXPosition
"double GetXPosition(int col)

Returns the real world x position of a column. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::GetYPosition
"double GetYPosition(int row)

Returns the real world y position of a row. ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::__len__ "int __len__() ";

%feature("docstring")  cmf::upslope::UpslopeResultRaster::__getitem__
"float  __getitem__(int index) ";


// File: a00080.xml
%feature("docstring") cmf::upslope::UpslopeVector "

Vector of cmf::upslope::UpslopeCell. This class inherits from the STL
vector container.

C++ includes: UpslopeVector.h ";

/*  Constructors  */

%feature("docstring")  cmf::upslope::UpslopeVector::UpslopeVector "UpslopeVector(int count)

Creates a new UpslopeVector with count Capacity.

Parameters:
-----------

count:  Initial capacity ";

%feature("docstring")  cmf::upslope::UpslopeVector::UpslopeVector "UpslopeVector() ";

%feature("docstring")  cmf::upslope::UpslopeVector::UpslopeVector "UpslopeVector(const UpslopeVector &vector) ";

/*  Catchment-Utilities  */

%feature("docstring")
cmf::upslope::UpslopeVector::CalcFlowAccumulation "void
CalcFlowAccumulation()

Sorts the upslope cells in ascending height order, sets the MainOutlet
cell and calculates the contributing area for surface flow. ";

%feature("docstring")  cmf::upslope::UpslopeVector::sort "void sort()

Sorts the upslope cell after ascending heights. ";

%feature("docstring")  cmf::upslope::UpslopeVector::FlowAccCalculated
"bool FlowAccCalculated() const

Returns bool A flag indicating if the UpslopeVector is sorted. ";

%feature("docstring")  cmf::upslope::UpslopeVector::Area "double
Area() const

Returns the sum of the area of all upslope cell. ";

%feature("docstring")  cmf::upslope::UpslopeVector::Boundary "UpslopeVector Boundary() const

Returns a new UplsopeVector containing all outer cells. ";

%feature("docstring")
cmf::upslope::UpslopeVector::DeactivateExternalNeighborRelations "void DeactivateExternalNeighborRelations()

Deactivates all neighborhood relations outside of this vector. ";

%feature("docstring")
cmf::upslope::UpslopeVector::UpdateNeighborhoodRelations "void
UpdateNeighborhoodRelations()

Deactivates all neighborhood relations outside of this vector and
reactivates all neighborhood relations inside of this vector (this is
called by cmf::SubsurfaceSolver::Add()). ";

%feature("docstring")  cmf::upslope::UpslopeVector::SetVegetation "void SetVegetation(cmf::upslope::maps::IMap<
cmf::upslope::vegetation::IVegetation * > &vegetationmap)

Replaces the current vegetation objects of the cells by a new one,
taken from the given map. ";

/*  Overrides of std::vector  */

%feature("docstring")  cmf::upslope::UpslopeVector::push_back "void
push_back(UpslopeCell *const &_Val)

calls vector::push_back and sets m_sorted = false ";

%feature("docstring")  cmf::upslope::UpslopeVector::erase "iterator
erase(iterator _Where)

calls vector::erase(iterator _Where) and sets m_sorted = false ";

%feature("docstring")  cmf::upslope::UpslopeVector::erase "iterator
erase(iterator _First, iterator _Last)

calls vector::erase(iterator _First,iterator _Last) and sets m_sorted
= false ";

%feature("docstring")  cmf::upslope::UpslopeVector::insert "void
insert(iterator _Where, iterator _First, iterator _Last)

calls vector::insert(iterator _Where, _Iter _First, _Iter _Last) and
sets m_sorted = false ";

%feature("docstring")  cmf::upslope::UpslopeVector::find "UpslopeCell* find(cmf::geometry::point p, double maxdist=1e200)

Finds the nearest UpslopeCell to the point p. ";

%feature("docstring")  cmf::upslope::UpslopeVector::find "const
UpslopeCell* find(cmf::geometry::point p, double maxdist=1e200) const
";

%feature("docstring")  cmf::upslope::UpslopeVector::find "UpslopeCell* find(double x, double y, double maxdist=1e200)

Finds the nearest UpslopeCell to the point (x,y). ";

%feature("docstring")  cmf::upslope::UpslopeVector::find "const
UpslopeCell* find(double x, double y, double maxdist=1e200) const ";

%feature("docstring")  cmf::upslope::UpslopeVector::find "int
find(const cmf::upslope::UpslopeCell *) const

Finds the cell, returns this->size() if the cell is not in this. ";

/*  Implements StateVariableOwner  */

%feature("docstring")  cmf::upslope::UpslopeVector::AddStateVariables
"void AddStateVariables(cmf::math::StateVariableVector &states)

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

/*  total flows  */

%feature("docstring")  cmf::upslope::UpslopeVector::Fluxes "TotalFlux
Fluxes(const cmf::math::Time &t)

Returns the total input into the collection of UpslopeCells. ";

%feature("docstring")  cmf::upslope::UpslopeVector::FillSinks "int
FillSinks(double minCellDifference=0.001) ";


// File: a00662.xml
%feature("docstring") std::valarray "

STL class. ";


// File: a00663.xml
%feature("docstring") std::vector "

STL class. ";


// File: a00664.xml
%feature("docstring") std::vector::const_iterator "

STL iterator class. ";


// File: a00665.xml
%feature("docstring") std::vector::const_reverse_iterator "

STL iterator class. ";


// File: a00666.xml
%feature("docstring") std::vector::iterator "

STL iterator class. ";


// File: a00667.xml
%feature("docstring") std::vector::reverse_iterator "

STL iterator class. ";


// File: a00668.xml
%feature("docstring") cmf::upslope::vegetation::Vegetation "";

%feature("docstring")
cmf::upslope::vegetation::Vegetation::RootFraction "virtual double
RootFraction(double upperBoundary, double lowerBoundary) const ";

%feature("docstring")
cmf::upslope::vegetation::Vegetation::Vegetation "Vegetation(double
_LAI=12, double _Height=0.12, double _RootDepth=0.25, double
_StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
double _CanopyCapacityPerLAI=0.01) ";


// File: a00594.xml
%feature("docstring")
cmf::upslope::verticalHomogeneous::VerticalHomogeneousCellBuilder "";

%feature("docstring")
cmf::upslope::verticalHomogeneous::VerticalHomogeneousCellBuilder::VerticalHomogeneousCellBuilder
"VerticalHomogeneousCellBuilder(cmf::upslope::maps::IMap<
cmf::upslope::vegetation::IVegetation * > *vegetationMap,
cmf::upslope::maps::IMap< cmf::upslope::SoilType > *soilMap,
cmf::upslope::maps::IMap< float > *soilDepthMap=0) ";

%feature("docstring")
cmf::upslope::verticalHomogeneous::VerticalHomogeneousCellBuilder::CreateCell
"cmf::upslope::UpslopeCell* CreateCell(cmf::geometry::point p, double
Area) const ";

%feature("docstring")
cmf::upslope::verticalHomogeneous::VerticalHomogeneousCellBuilder::CreateCell
"cmf::upslope::UpslopeCell* CreateCell(double x, double y, double z,
double Area) const ";


// File: a00595.xml
%feature("docstring")
cmf::upslope::verticalHomogeneous::VerticalHomogeneousCellSurfaceWaterBuilder
"";

%feature("docstring")
cmf::upslope::verticalHomogeneous::VerticalHomogeneousCellSurfaceWaterBuilder::VerticalHomogeneousCellSurfaceWaterBuilder
"VerticalHomogeneousCellSurfaceWaterBuilder(cmf::upslope::maps::IMap<
cmf::upslope::vegetation::IVegetation * > *vegetationMap,
cmf::upslope::maps::IMap< cmf::upslope::SoilType > *soilMap,
cmf::upslope::maps::IMap< float > *soilDepthMap=0) ";

%feature("docstring")
cmf::upslope::verticalHomogeneous::VerticalHomogeneousCellSurfaceWaterBuilder::CreateCell
"cmf::upslope::UpslopeCell* CreateCell(cmf::geometry::point p, double
Area) const ";

%feature("docstring")
cmf::upslope::verticalHomogeneous::VerticalHomogeneousCellSurfaceWaterBuilder::CreateCell
"cmf::upslope::UpslopeCell* CreateCell(double x, double y, double z,
double Area) const ";


// File: a00081.xml
%feature("docstring") cmf::water::WaterFlux "

Water fluxes consist of the flux in $\\\\frac{m^3}{day}$ and a map of
concentrations (ConcentrationMap).

C++ includes: WaterFlux.h ";

%feature("docstring")  cmf::water::WaterFlux::Update "WaterFlux&
Update(real waterflux, const cmf::water::WaterStorage &origin, bool
uptake=false) ";

%feature("docstring")  cmf::water::WaterFlux::WaterFlux "WaterFlux()

Standard constructor. ";

%feature("docstring")  cmf::water::WaterFlux::WaterFlux "WaterFlux(const WaterFlux &forcopy)

Copy constructor. ";

%feature("docstring")  cmf::water::WaterFlux::WaterFlux "WaterFlux(real flux)

Creates a clear water flux. ";

%feature("docstring")  cmf::water::WaterFlux::WaterFlux "WaterFlux(real flux, const cmf::water::WaterStorage &origin, bool
uptake=false) ";

%feature("docstring")  cmf::water::WaterFlux::Add "WaterFlux&
Add(real flux, const cmf::water::WaterStorage &origin)

Adds water from the origin to the flux (mixing) Both fluxes may be
negative, but mixed signs will throw an error \\\\begin{eqnarray*}
q&=& \\\\mbox{Flux in }\\\\frac{m^3}{day} \\\\\\\\ c&=&
\\\\mbox{Vector of concentrations in } \\\\frac{mol}{m^3} \\\\\\\\
c_{this}&=&\\\\frac{c_{this}q_{this}+c_{other}q_{other}}{q_{this}+q_{other}}
\\\\\\\\ q_{this}&=&q_{this}+q_{other} \\\\\\\\ \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::water::WaterFlux::Add "WaterFlux&
Add(real flux, const cmf::water::WaterQuality &concentrations)

Adds water of a certain water quality to the flux (mixing) Both fluxes
may be negative, but mixed signs will throw an error
\\\\begin{eqnarray*} q&=& \\\\mbox{Flux in }\\\\frac{m^3}{day}
\\\\\\\\ c&=& \\\\mbox{Vector of concentrations in }
\\\\frac{mol}{m^3} \\\\\\\\
c_{this}&=&\\\\frac{c_{this}q_{this}+c_{other}q_{other}}{q_{this}+q_{other}}
\\\\\\\\ q_{this}&=&q_{this}+q_{other} \\\\\\\\ \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::water::WaterFlux::Abs "WaterFlux& Abs()

Changes the sign of the flux to positive. ";

%feature("docstring")  cmf::water::WaterFlux::matterflux "real
matterflux(const cmf::water::Solute &solute)

Returns the water flux of the given solute in $\\\\frac{mol}{day}$,
depending on the unit of the concentration (see cmf::water )
\\\\begin{eqnarray*} Q_{Solute} &=&
q_{H_2O}\\\\left[\\\\frac{m^3}{day}\\\\right] c_{Solute}
\\\\left[\\\\frac{mol}{m^3}\\\\right] \\\\end{eqnarray*}. ";

%feature("docstring")  cmf::water::WaterFlux::clear "void clear()

Sets all concentrations and the flux to 0. ";


// File: a00082.xml
%feature("docstring") cmf::water::WaterQuality "

Map of concentrations for different solutes.

C++ includes: Solute.h ";

%feature("docstring")  cmf::water::WaterQuality::begin "iterator
begin() ";

%feature("docstring")  cmf::water::WaterQuality::end "iterator end()
";

%feature("docstring")  cmf::water::WaterQuality::begin "const_iterator begin() const ";

%feature("docstring")  cmf::water::WaterQuality::end "const_iterator
end() const ";

%feature("docstring")  cmf::water::WaterQuality::size "size_t size()
const

Returns the number of solutes. ";

%feature("docstring")  cmf::water::WaterQuality::tostring "std::string tostring() const ";

%feature("docstring")  cmf::water::WaterQuality::clear "void clear()

Clears the water. ";

%feature("docstring")  cmf::water::WaterQuality::WaterQuality "WaterQuality()

Standard constructor. ";

%feature("docstring")  cmf::water::WaterQuality::WaterQuality "WaterQuality(const cmf::water::WaterQuality &wq) ";


// File: a00083.xml
%feature("docstring") cmf::water::WaterStorage "

A state variable for the storage of water A class for the storage of
any tracer. The state is the amount (mol, kg etc. see cmf::water) of
the tracer in the storage \\\\begin{eqnarray*}
\\\\frac{dV}{dt}&=&\\\\sum_{f=1}^{F} q_f \\\\\\\\ F&=& \\\\mbox{Number
of fluxes in water storage} \\\\\\\\ q_f&=& \\\\mbox{Water flux in }
\\\\frac{m^3}{day} \\\\\\\\ \\\\end{eqnarray*} The vector fluxes is
used used by concentration to get the amount of water mixing.

C++ includes: WaterStorage.h ";

/*  Overrides of FluxNode  */

%feature("docstring")  cmf::water::WaterStorage::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure FluxNodes do not influence fluxes, therefore no recalculation of
fluxes is required by fluxnode. WaterStorage overrides this, since
state changes require an update of the fluxes. ";

%feature("docstring")  cmf::water::WaterStorage::Empty "virtual bool
Empty() ";

%feature("docstring")  cmf::water::WaterStorage::copy "virtual
WaterStorage* copy() const ";

%feature("docstring")  cmf::water::WaterStorage::AddStateVariables "void AddStateVariables(cmf::math::StateVariableVector &vector)

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::water::WaterStorage::WaterStorage "WaterStorage(double InitialState=0)

creates a water storage (abstract class)

Parameters:
-----------

InitialState:  Initial water content in m3 ";

%feature("docstring")  cmf::water::WaterStorage::WaterStorage "WaterStorage(const WaterStorage &forcopy) ";

%feature("docstring")  cmf::water::WaterStorage::Solute "SoluteStorage& Solute(const cmf::water::Solute &solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::water::WaterStorage::Solute "const
SoluteStorage& Solute(const cmf::water::Solute &solute) const ";

%feature("docstring")  cmf::water::WaterStorage::conc "real
conc(const cmf::water::Solute &solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::water::WaterStorage::conc "WaterQuality
conc(cmf::math::Time t)

Returns the current WaterQuality (concentration of all solutes). ";

%feature("docstring")  cmf::water::WaterStorage::conc "void
conc(const cmf::water::Solute &solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::water::WaterStorage::water "real water()
const

Returns the volume of water in this storage in m3. ";

%feature("docstring")  cmf::water::WaterStorage::water "void
water(real newwatercontent)

Sets the volume of water in this storage in m3. ";

%feature("docstring")  cmf::water::WaterStorage::ToString "virtual
std::string ToString() const ";

%feature("docstring")  cmf::water::WaterStorage::Derivate "virtual
real Derivate(const cmf::math::Time &time)

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::water::WaterStorage::State "const real&
State() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::water::WaterStorage::State "void
State(const real &newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::water::WaterStorage::StateIsChanged "bool
StateIsChanged()

Returns if the state was currently updated. ";

%feature("docstring")  cmf::water::WaterStorage::ConnectionTo "cmf::water::FluxConnection& ConnectionTo(const FluxNode &target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::water::WaterStorage::FluxTo "real
FluxTo(const FluxNode &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from target into this\"). ";

%feature("docstring")  cmf::water::WaterStorage::Waterbalance "real
Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

Returns the sum of all fluxes (positive and negative) at time t.
Single fluxes can be excluded from the calculation.

Parameters:
-----------

t:  Time of the query

except:  A FluxConnection that is excluded from the Waterbalance (e.g.
to prevent closed circuits) ";

%feature("docstring")  cmf::water::WaterStorage::sum_inflow "cmf::water::WaterFlux sum_inflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and the mix of their
concentrations. ";

%feature("docstring")  cmf::water::WaterStorage::sum_outflow "cmf::water::WaterFlux sum_outflow(cmf::math::Time t, const
FluxConnection *except=0)

Returns the sum of the incoming (positive) fluxes and their
concentrations. ";

%feature("docstring")  cmf::water::WaterStorage::Potential "virtual
real Potential()

Returns the water potential of the node in m waterhead The base class
water storage always returns the height of the location. ";


// File: a00084.xml
%feature("docstring") cmf::atmosphere::Weather "

A structure to return all parts of the incoming radiation, all values
in $\\\\frac{MJ}{m^2 day}$.

C++ includes: Meteorology.h ";

%feature("docstring")  cmf::atmosphere::Weather::Rn "double Rn(double
albedo, bool daily=false)

Calculates the net radiation flux $R_n \\\\left[\\\\frac{MJ}{m^2
day}\\\\right]$.

\\\\begin{eqnarray*} R_{n} &=& R_{ns} - R_{nl} \\\\\\\\ \\\\mbox{ Net
short wave radiation: }R_{ns} &=& (1-\\\\alpha) R_s \\\\\\\\ \\\\mbox{
Net long wave radiation: }R_{nl} &=& R_{black}\\\\ \\\\beta_{v}\\\\
\\\\beta_{c} \\\\\\\\ \\\\mbox{Black body radiation: } R_{black} &=&
\\\\left\\\\{\\\\begin{array}{cl} \\\\sigma T^4 & \\\\mbox{for less
than daily time steps} \\\\\\\\ \\\\sigma \\\\frac {T_{max}^4 +
T_{min}^4} 2 & \\\\mbox{for daily time steps} \\\\end{array}
\\\\right. \\\\\\\\ T &=& \\\\mbox{Temperature }[K] \\\\\\\\ \\\\sigma
&=& 4.903\\\\ 10^{-9} \\\\frac{MJ}{K^4 m^2 day} \\\\mbox{ Stefan-
Boltzmann constant } \\\\\\\\ \\\\mbox{Long wave reflectance: }
\\\\\\\\ \\\\mbox{by water vapor: }\\\\beta_{v} &=& 0.34 - 0.14
\\\\sqrt{e_a} \\\\\\\\ \\\\mbox{ by clouds: }\\\\beta_{c} &=& 0.1 +
0.9 \\\\frac n N \\\\end{eqnarray*}

Parameters:
-----------

albedo:  the albedo $\\\\alpha$ of the surface

daily:  If true, the net radiation for daily averages will be
calculated ";


// File: a00557.xml
%feature("docstring") std::wfstream "

STL class. ";


// File: a00560.xml
%feature("docstring") std::wifstream "

STL class. ";


// File: a00565.xml
%feature("docstring") std::wios "

STL class. ";


// File: a00570.xml
%feature("docstring") std::wistream "

STL class. ";


// File: a00572.xml
%feature("docstring") std::wistringstream "

STL class. ";


// File: a00575.xml
%feature("docstring") std::wofstream "

STL class. ";


// File: a00578.xml
%feature("docstring") std::wostream "

STL class. ";


// File: a00580.xml
%feature("docstring") std::wostringstream "

STL class. ";


// File: a00583.xml
%feature("docstring") std::wstring "

STL class. ";


// File: a00669.xml
%feature("docstring") std::wstring::const_iterator "

STL iterator class. ";


// File: a00670.xml
%feature("docstring") std::wstring::const_reverse_iterator "

STL iterator class. ";


// File: a00671.xml
%feature("docstring") std::wstring::iterator "

STL iterator class. ";


// File: a00672.xml
%feature("docstring") std::wstring::reverse_iterator "

STL iterator class. ";


// File: a00589.xml
%feature("docstring") std::wstringstream "

STL class. ";


// File: a00136.xml


// File: a00137.xml


// File: a00138.xml


// File: a00139.xml


// File: a00140.xml


// File: a00141.xml
%feature("docstring")  cmf::upslope::connections::CreateIrregularCells
"cmf::upslope::UpslopeVector*
cmf::upslope::CreateIrregularCells(const cmf::geometry::Polygons
&polygons, const cmf::geometry::Points &centers, const
cmf::upslope::CellBuilder &cellbuilder, double slither_tolerance=0.1)
";

%feature("docstring")  cmf::upslope::connections::CreateSquaredCells "cmf::upslope::UpslopeVector* cmf::upslope::CreateSquaredCells(const
cmf::geometry::Raster< double > &DEM, const cmf::upslope::CellBuilder
&cellbuilder)

Creates a squared cell network from a raster dataset.

Before you can create meshes from rastered dem's you have to know: How
to create vegetation objects

How to distribute objects and values in space with the objects of the
maps namespace

Meshed networks of cells are generally hard to set up. But if you can
limit your needs to use regular squared cells, the process of building
the network might become quite simple using factories. Until now there
are two factories to build UpslopeCells from a raster dataset, one for
layered cells and one for vertical homogeneous cells. Most of the work
is the same for both kinds of factories. First the
VerticalHomogeneousCellFactory is explained, and then only the
differing features of the layered one are shown.

The following objects are needed to create the mesh: A Raster
representing a DEM. The simplest way to create such an raster is to
load an ESRI ASCII raster file

A map (namespace maps) of vegetation (IVegetation) objects.

A map of SoilTypes or SoilProfiles

A map of soil depth (float)[m] (optional for layered cells)

If you like to create verticalHomogeneous cells, you will need a
VerticalHomogeneousCellFactory , for layered cells you will need a
LayeredCellFactory . The created cell mesh

Parameters:
-----------

DEM:  a DoubleRaster (Raster<double>) containing the digital elevation
model

cellbuilder:  A CellBuilder, creates cells at given locations ";

%feature("docstring")
cmf::upslope::connections::pressure_to_waterhead "double
cmf::upslope::pressure_to_waterhead(double Pressure)

Converts a pressure in Pa to a lenght of a water column in m. ";

%feature("docstring")
cmf::upslope::connections::waterhead_to_pressure "double
cmf::upslope::waterhead_to_pressure(double waterhead)

Converts a height of a water column in m to a pressure in Pa. ";

%feature("docstring")  cmf::upslope::connections::pF_to_waterhead "double cmf::upslope::pF_to_waterhead(double pF)

Converts a pF value to a height of a water column in m. ";

%feature("docstring")  cmf::upslope::connections::waterhead_to_pF "double cmf::upslope::waterhead_to_pF(double waterhead)

Converts a height of a water column to a pF value. ";

%feature("docstring")  cmf::upslope::connections::UpslopeCellIsLower "bool cmf::upslope::UpslopeCellIsLower(UpslopeCell *upc1, UpslopeCell
*upc2) ";

%feature("docstring")  cmf::upslope::connections::deleteUpslope "void
cmf::upslope::deleteUpslope(UpslopeCell *upc) ";


// File: a00142.xml


// File: a00143.xml
%feature("docstring")  cmf::upslope::ET::PenmanMonteith "real
cmf::upslope::ET::PenmanMonteith(real Rn, real ra, real rs, real T,
real vap_press_deficit)

Returns the potential Evaporation after Penman-Monteith using some
simplifications for a given Radiation balance, aerodynamic and surface
resistances, and a vapor pressure deficit.

\\\\[ ET &=& \\\\frac{\\\\Delta R_n}{\\\\lambda \\\\Delta + \\\\gamma
+ \\\\gamma \\\\frac{r_s}{r_a}} + \\\\frac{c_p\\\\rho_a}{\\\\Delta +
\\\\gamma + \\\\gamma \\\\frac{r_s}{r_a}} \\\\frac{e_s - e_a}{r_a}
\\\\] where  $ ET $ is the evapotranspiration in $\\\\frac{kg}{m^2
day}\\\\approx \\\\frac{mm}{day}$

$ \\\\Delta \\\\left[\\\\frac{kPa}{k}\\\\right]= 4098\\\\ 0.618
\\\\exp\\\\left(\\\\frac{17.27 T}{T+237.3}\\\\right (T+237.3)^{-2} $
is the slope of vapor pressure

$ R_n \\\\left[\\\\frac{MJ}{m^2 day}\\\\right]$ is the radiation
balance

$ r_s \\\\left[\\\\frac s m\\\\right] $ is the surface resistance

$ r_a \\\\left[\\\\frac s m\\\\right] $ is the aerodynamic resistance

$ \\\\gamma = 0.067 \\\\left[\\\\frac{kPa}{k}\\\\right] $ is the
psychrometer constant

$ e_s - e_a \\\\left[kPa\\\\right]$ is the vapor pressure deficit

Parameters:
-----------

Rn:  Radiation balance in $ \\\\frac{MJ}{m^2 day} $

ra:  Aerodynamic resistance in $ \\\\frac s m $

rs:  Surface resistance in $ \\\\frac s m $, is 0 for free water

T:  Actual Temperature in $ ^\\\\circ C $

vap_press_deficit:  Deficit of vapor pressure $ kPa $ ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteith "real
cmf::upslope::ET::PenmanMonteith(cmf::atmosphere::Weather A, const
cmf::upslope::vegetation::Vegetation &veg, double h) ";


// File: a00144.xml


// File: a00145.xml


// File: a00146.xml


// File: a00147.xml


// File: a00148.xml


// File: a00149.xml


// File: a00150.xml


// File: a00151.xml


// File: a00085.xml


// File: a00086.xml


// File: a00087.xml


// File: a00088.xml


// File: a00089.xml
%feature("docstring")  printResult "void printResult(std::ostream
&stream, cmf::river::Reach &reach, cmf::math::Time time, char
delimiter='\\\\t')

Prints states and fluxes of a reach and its subreaches and their
subbasins to a stream. ";


// File: a00090.xml


// File: a00091.xml


// File: a00092.xml


// File: a00093.xml


// File: a00094.xml


// File: a00095.xml


// File: a00096.xml


// File: a00097.xml


// File: a00098.xml


// File: a00099.xml


// File: a00100.xml


// File: a00101.xml


// File: a00102.xml


// File: a00103.xml


// File: a00104.xml


// File: a00105.xml


// File: a00106.xml


// File: a00107.xml


// File: a00108.xml


// File: a00109.xml


// File: a00110.xml


// File: a00111.xml


// File: a00112.xml


// File: a00113.xml


// File: a00114.xml
%feature("docstring")  minimum "real minimum(real a, real b)

Returns the minimum of two values. ";

%feature("docstring")  maximum "real maximum(real a, real b) ";

%feature("docstring")  minmax "real minmax(real x, real min, real
max) ";

%feature("docstring")  piecewise_linear "real piecewise_linear(real
x, real xmin, real xmax, real ymin=0, real ymax=1) ";


// File: a00115.xml


// File: a00116.xml


// File: a00117.xml


// File: a00118.xml


// File: a00119.xml


// File: a00120.xml


// File: a00121.xml


// File: a00122.xml


// File: a00123.xml


// File: a00124.xml


// File: a00125.xml


// File: a00126.xml


// File: a00127.xml


// File: a00128.xml


// File: a00129.xml


// File: a00130.xml


// File: a00131.xml


// File: a00132.xml


// File: a00133.xml


// File: a00134.xml


// File: a00135.xml


// File: todo.xml


// File: dir_c1ea5421cc65d94b94e40c62a9b5a1dd.xml


// File: dir_6894f7e083c2acd5418ccb3ff9f63a93.xml


// File: dir_ae9974ebd7051295e79d2ed4449e54bc.xml


// File: dir_038de44c667e837ac7bd0b408387318b.xml


// File: dir_604b8536ae4240420803795590a868a7.xml


// File: dir_81549b682468b23bdbc7df6c0b32b8f5.xml


// File: dir_c0896370e153f001321c91693a4cbc22.xml


// File: dir_0b605bb2de6e1c694a2540ec3ac67506.xml


// File: dir_b83afa0b74726f74995a386148265b1e.xml


// File: dir_8d7ec48f781d1fac3a54fee02c978e9f.xml


// File: dir_50af7c761aef9dc579d8e1abd9fe623f.xml


// File: dir_0da5447fd7d47a67fe2452d4bdbe2da9.xml


// File: dir_11bc2ed6aa39a494ef0bce8cb36cb582.xml


// File: dir_9eff83046f00f9e6cc4048faf2ac1c38.xml


// File: dir_45ea423ffc5cafa91296868978211296.xml


// File: dir_e95cedbddb14e57b939e6a50e26231be.xml


// File: dir_ba45a2dbe8dd3f378776f2648a94f5f5.xml


// File: dir_1265e4f635bae04c16c8d7056d02c669.xml


// File: dir_3dad22b3fe88b15a4f51db2444a052f5.xml


// File: dir_340f115698215a189081ce0e243457b9.xml


// File: dir_e7d645e420bf6d0d95a90959c6d04a44.xml


// File: main.xml


]
%feature("autodoc","1") ;

// Usage for autoamted downcast
// %include factory.i

// Include typemaps for STL
%includefile "C:\\Programme\\swig\\Lib\\python\\stl.i" [
/* initial STL definition. extended as needed in each language */
%includefile "C:\\Programme\\swig\\Lib\\python\\std_common.i" [
%includefile "C:\\Programme\\swig\\Lib\\std\\std_except.i" [




%{
#include <stdexcept>
%}






























































]
%includefile "C:\\Programme\\swig\\Lib\\python\\pystdcommon.swg" [
%fragment("StdTraits","header",fragment="StdTraitsCommon")
{
namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static PyObject *from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static PyObject *from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static PyObject *from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static PyObject *from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline PyObject *from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline PyObject *from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(PyObject *obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(PyObject *obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(PyObject *obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(PyObject *obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(PyObject *obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	static Type *v_def = (Type*) malloc(sizeof(Type));
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	return 0;
      }
    }
  };
    
  template <class Type>
  inline Type as(PyObject *obj, bool te = false) {
    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(PyObject *obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}
}

//
// Backward compatibility
//

































































]


/*
  Generate the traits for a 'primitive' type, such as 'double',
  for which the SWIG_AsVal and SWIG_From methods are already defined.
*/




























%includefile "C:\\Programme\\swig\\Lib\\std\\std_common.i" [


//
// Use the following macro with modern STL implementations
//
//#define SWIG_STD_MODERN_STL
//
// Use this to deactive the previous definition, when using gcc-2.95
// or similar old compilers.
//
//#define SWIG_STD_NOMODERN_STL

// Here, we identify compilers we know have problems with STL.
%{
#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif
%}

//
// Common code for supporting the STD C++ namespace
//

%{
#include <string>
#include <stdexcept>
%}


%fragment("StdIteratorTraits","header") %{
#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif
%}

%fragment("StdTraitsCommon","header") %{
namespace swig {  
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category> 
  struct traits_as { };
 
  template <class Type, class Category> 
  struct traits_check { };

}
%}
 
/*
  Generate the traits for a swigtype
*/














/*
  Generate the typemaps for a class that has 'value' traits
*/










/*
  Generate the typemaps for a class that behaves more like a 'pointer' or
  plain wrapped Swigtype.
*/











/*
  Equality methods
*/













/*
  Order methods
*/





















/*
  Comparison methods
*/







]

//
// Generates the traits for all the known primitive
// C++ types (int, double, ...)
//
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,281,%apply_cpptypes@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,256,%apply_ctypes@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {bool},"header",
	    fragment="SWIG_" "AsVal" "_" {bool},
	    fragment="SWIG_" "From" "_" {bool},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<bool > {
    typedef value_category category;
    static const char* type_name() { return"bool"; }
  };  
  template <>  struct traits_asval<bool > {   
    typedef bool value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_bool (obj, val);
    }
  };
  template <>  struct traits_from<bool > {
    typedef bool value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_bool  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {signed char},"header",
	    fragment="SWIG_" "AsVal" "_" {signed char},
	    fragment="SWIG_" "From" "_" {signed char},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<signed char > {
    typedef value_category category;
    static const char* type_name() { return"signed char"; }
  };  
  template <>  struct traits_asval<signed char > {   
    typedef signed char value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_signed_SS_char (obj, val);
    }
  };
  template <>  struct traits_from<signed char > {
    typedef signed char value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_signed_SS_char  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {unsigned char},"header",
	    fragment="SWIG_" "AsVal" "_" {unsigned char},
	    fragment="SWIG_" "From" "_" {unsigned char},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<unsigned char > {
    typedef value_category category;
    static const char* type_name() { return"unsigned char"; }
  };  
  template <>  struct traits_asval<unsigned char > {   
    typedef unsigned char value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_unsigned_SS_char (obj, val);
    }
  };
  template <>  struct traits_from<unsigned char > {
    typedef unsigned char value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_unsigned_SS_char  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {short},"header",
	    fragment="SWIG_" "AsVal" "_" {short},
	    fragment="SWIG_" "From" "_" {short},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<short > {
    typedef value_category category;
    static const char* type_name() { return"short"; }
  };  
  template <>  struct traits_asval<short > {   
    typedef short value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_short (obj, val);
    }
  };
  template <>  struct traits_from<short > {
    typedef short value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_short  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {unsigned short},"header",
	    fragment="SWIG_" "AsVal" "_" {unsigned short},
	    fragment="SWIG_" "From" "_" {unsigned short},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<unsigned short > {
    typedef value_category category;
    static const char* type_name() { return"unsigned short"; }
  };  
  template <>  struct traits_asval<unsigned short > {   
    typedef unsigned short value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_unsigned_SS_short (obj, val);
    }
  };
  template <>  struct traits_from<unsigned short > {
    typedef unsigned short value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_unsigned_SS_short  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {int},"header",
	    fragment="SWIG_" "AsVal" "_" {int},
	    fragment="SWIG_" "From" "_" {int},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<int > {
    typedef value_category category;
    static const char* type_name() { return"int"; }
  };  
  template <>  struct traits_asval<int > {   
    typedef int value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_int (obj, val);
    }
  };
  template <>  struct traits_from<int > {
    typedef int value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_int  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {unsigned int},"header",
	    fragment="SWIG_" "AsVal" "_" {unsigned int},
	    fragment="SWIG_" "From" "_" {unsigned int},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<unsigned int > {
    typedef value_category category;
    static const char* type_name() { return"unsigned int"; }
  };  
  template <>  struct traits_asval<unsigned int > {   
    typedef unsigned int value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_unsigned_SS_int (obj, val);
    }
  };
  template <>  struct traits_from<unsigned int > {
    typedef unsigned int value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_unsigned_SS_int  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {long},"header",
	    fragment="SWIG_" "AsVal" "_" {long},
	    fragment="SWIG_" "From" "_" {long},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<long > {
    typedef value_category category;
    static const char* type_name() { return"long"; }
  };  
  template <>  struct traits_asval<long > {   
    typedef long value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_long (obj, val);
    }
  };
  template <>  struct traits_from<long > {
    typedef long value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_long  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {unsigned long},"header",
	    fragment="SWIG_" "AsVal" "_" {unsigned long},
	    fragment="SWIG_" "From" "_" {unsigned long},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<unsigned long > {
    typedef value_category category;
    static const char* type_name() { return"unsigned long"; }
  };  
  template <>  struct traits_asval<unsigned long > {   
    typedef unsigned long value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_unsigned_SS_long (obj, val);
    }
  };
  template <>  struct traits_from<unsigned long > {
    typedef unsigned long value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_unsigned_SS_long  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {long long},"header",
	    fragment="SWIG_" "AsVal" "_" {long long},
	    fragment="SWIG_" "From" "_" {long long},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<long long > {
    typedef value_category category;
    static const char* type_name() { return"long long"; }
  };  
  template <>  struct traits_asval<long long > {   
    typedef long long value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_long_SS_long (obj, val);
    }
  };
  template <>  struct traits_from<long long > {
    typedef long long value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_long_SS_long  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {unsigned long long},"header",
	    fragment="SWIG_" "AsVal" "_" {unsigned long long},
	    fragment="SWIG_" "From" "_" {unsigned long long},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<unsigned long long > {
    typedef value_category category;
    static const char* type_name() { return"unsigned long long"; }
  };  
  template <>  struct traits_asval<unsigned long long > {   
    typedef unsigned long long value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_unsigned_SS_long_SS_long (obj, val);
    }
  };
  template <>  struct traits_from<unsigned long long > {
    typedef unsigned long long value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_unsigned_SS_long_SS_long  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {float},"header",
	    fragment="SWIG_" "AsVal" "_" {float},
	    fragment="SWIG_" "From" "_" {float},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<float > {
    typedef value_category category;
    static const char* type_name() { return"float"; }
  };  
  template <>  struct traits_asval<float > {   
    typedef float value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_float (obj, val);
    }
  };
  template <>  struct traits_from<float > {
    typedef float value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_float  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {double},"header",
	    fragment="SWIG_" "AsVal" "_" {double},
	    fragment="SWIG_" "From" "_" {double},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<double > {
    typedef value_category category;
    static const char* type_name() { return"double"; }
  };  
  template <>  struct traits_asval<double > {   
    typedef double value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_double (obj, val);
    }
  };
  template <>  struct traits_from<double > {
    typedef double value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_double  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {char},"header",
	    fragment="SWIG_" "AsVal" "_" {char},
	    fragment="SWIG_" "From" "_" {char},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<char > {
    typedef value_category category;
    static const char* type_name() { return"char"; }
  };  
  template <>  struct traits_asval<char > {   
    typedef char value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_char (obj, val);
    }
  };
  template <>  struct traits_from<char > {
    typedef char value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_char  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {wchar_t},"header",
	    fragment="SWIG_" "AsVal" "_" {wchar_t},
	    fragment="SWIG_" "From" "_" {wchar_t},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<wchar_t > {
    typedef value_category category;
    static const char* type_name() { return"wchar_t"; }
  };  
  template <>  struct traits_asval<wchar_t > {   
    typedef wchar_t value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_wchar_t (obj, val);
    }
  };
  template <>  struct traits_from<wchar_t > {
    typedef wchar_t value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_wchar_t  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {size_t},"header",
	    fragment="SWIG_" "AsVal" "_" {size_t},
	    fragment="SWIG_" "From" "_" {size_t},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<size_t > {
    typedef value_category category;
    static const char* type_name() { return"size_t"; }
  };  
  template <>  struct traits_asval<size_t > {   
    typedef size_t value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_size_t (obj, val);
    }
  };
  template <>  struct traits_from<size_t > {
    typedef size_t value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_size_t  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {ptrdiff_t},"header",
	    fragment="SWIG_" "AsVal" "_" {ptrdiff_t},
	    fragment="SWIG_" "From" "_" {ptrdiff_t},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<ptrdiff_t > {
    typedef value_category category;
    static const char* type_name() { return"ptrdiff_t"; }
  };  
  template <>  struct traits_asval<ptrdiff_t > {   
    typedef ptrdiff_t value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_ptrdiff_t (obj, val);
    }
  };
  template <>  struct traits_from<ptrdiff_t > {
    typedef ptrdiff_t value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_ptrdiff_t  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {std::size_t},"header",
	    fragment="SWIG_" "AsVal" "_" {std::size_t},
	    fragment="SWIG_" "From" "_" {std::size_t},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<std::size_t > {
    typedef value_category category;
    static const char* type_name() { return"std::size_t"; }
  };  
  template <>  struct traits_asval<std::size_t > {   
    typedef std::size_t value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_std_size_t (obj, val);
    }
  };
  template <>  struct traits_from<std::size_t > {
    typedef std::size_t value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_std_size_t  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {std::ptrdiff_t},"header",
	    fragment="SWIG_" "AsVal" "_" {std::ptrdiff_t},
	    fragment="SWIG_" "From" "_" {std::ptrdiff_t},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<std::ptrdiff_t > {
    typedef value_category category;
    static const char* type_name() { return"std::ptrdiff_t"; }
  };  
  template <>  struct traits_asval<std::ptrdiff_t > {   
    typedef std::ptrdiff_t value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_std_ptrdiff_t (obj, val);
    }
  };
  template <>  struct traits_from<std::ptrdiff_t > {
    typedef std::ptrdiff_t value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_std_ptrdiff_t  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {std::string},"header",
	    fragment="SWIG_" "AsVal" "_" {std::string},
	    fragment="SWIG_" "From" "_" {std::string},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<std::string > {
    typedef value_category category;
    static const char* type_name() { return"std::string"; }
  };  
  template <>  struct traits_asval<std::string > {   
    typedef std::string value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_std_string (obj, val);
    }
  };
  template <>  struct traits_from<std::string > {
    typedef std::string value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_std_string  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {std::wstring},"header",
	    fragment="SWIG_" "AsVal" "_" {std::wstring},
	    fragment="SWIG_" "From" "_" {std::wstring},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<std::wstring > {
    typedef value_category category;
    static const char* type_name() { return"std::wstring"; }
  };  
  template <>  struct traits_asval<std::wstring > {   
    typedef std::wstring value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_std_wstring (obj, val);
    }
  };
  template <>  struct traits_from<std::wstring > {
    typedef std::wstring value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_std_wstring  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {std::complex<float>},"header",
	    fragment="SWIG_" "AsVal" "_" {std::complex<float>},
	    fragment="SWIG_" "From" "_" {std::complex<float>},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<std::complex<float> > {
    typedef value_category category;
    static const char* type_name() { return"std::complex<float>"; }
  };  
  template <>  struct traits_asval<std::complex<float> > {   
    typedef std::complex<float> value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_std_complex_Sl_float_Sg_ (obj, val);
    }
  };
  template <>  struct traits_from<std::complex<float> > {
    typedef std::complex<float> value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_std_complex_Sl_float_Sg_  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\primtypes.swg,247,_apply_macro@*/



























/*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_common.i,10,%traits_ptypen@*/
  %fragment("SWIG_" "Traits" "_" {std::complex<double>},"header",
	    fragment="SWIG_" "AsVal" "_" {std::complex<double>},
	    fragment="SWIG_" "From" "_" {std::complex<double>},
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits<std::complex<double> > {
    typedef value_category category;
    static const char* type_name() { return"std::complex<double>"; }
  };  
  template <>  struct traits_asval<std::complex<double> > {   
    typedef std::complex<double> value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_std_complex_Sl_double_Sg_ (obj, val);
    }
  };
  template <>  struct traits_from<std::complex<double> > {
    typedef std::complex<double> value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_std_complex_Sl_double_Sg_  (val);
    }
  };
}
}
/*@SWIG@*/;

/*@SWIG@*/;
/*@SWIG@*/;


]
%includefile "C:\\Programme\\swig\\Lib\\python\\std_string.i" [
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\std_string.swg" [
//
// String
//





%includefile "C:\\Programme\\swig\\Lib\\typemaps\\std_strings.swg" [

/* defining the String asptr/from methods */

















































































]

%{
#include <string>
%}
  
namespace std
{
  %feature("naturalvar") string;
  class string;
}

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_strings.swg,74,%typemaps_std_string@*/

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_strings.swg,4,%std_string_asptr@*/
%fragment("SWIG_" "AsPtr" "_" {std::string},"header",fragment="SWIG_AsCharPtrAndSize") {
SWIGINTERN int
SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}
}
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_strings.swg,52,%std_string_asval@*/
%fragment("SWIG_" "AsVal" "_" {std::string},"header", fragment="SWIG_" "AsPtr" "_" {std::string}) {
SWIGINTERN int
SWIG_AsVal_std_string (PyObject * obj, std::string *val)
{
  std::string* v = (std::string *) 0;
  int res = SWIG_AsPtr_std_string (obj, &v);
  if (!SWIG_IsOK(res)) return res;
  if (v) {
    if (val) *val = *v;
    if (SWIG_IsNewObj(res)) {
      delete v;
      res = SWIG_DelNewMask(res);
    }
    return res;
  }
  return SWIG_ERROR;
}
}
/*@SWIG@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_strings.swg,38,%std_string_from@*/
%fragment("SWIG_" "From" "_" {std::string},"header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE PyObject *
SWIG_From_std_string  (const std::string& s)
{
  if (s.size()) {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  } else {
    return SWIG_FromCharPtrAndSize(s.c_str(), 0);
  }
}
}
/*@SWIG@*/

/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,204,%typemaps_asptrfromn@*/
/*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,193,%typemaps_asptrfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,163,%typemaps_asptr@*/
  %fragment("SWIG_" "AsVal" "_" {std::string},"header",fragment="SWIG_" "AsPtr" "_" {std::string}) {
    SWIGINTERNINLINE int
    SWIG_AsVal_std_string (PyObject * obj, std::string *val)
    {
      std::string *v = (std::string *)0;
      int res = SWIG_AsPtr_std_string (obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  delete v;
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,31,%ptr_in_typemap@*/
  %typemap(in,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  %typemap(freearg) std::string "";
  %typemap(in,fragment="SWIG_" "AsPtr" "_" {std::string}) const std::string & (int res = SWIG_OLDOBJ) {
    std::string *ptr = (std::string *)0;
    res = SWIG_AsPtr_std_string($input, &ptr);
    if (!SWIG_IsOK(res)) { SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    if (!ptr) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const std::string &  {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,56,%ptr_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in variable '""$name""' of type '""$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,71,%ptr_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string *DIRECTOROUT ($*ltype temp) {
    std::string *swig_optr = 0;
    int swig_ores = $input ? SWIG_AsPtr_std_string($input, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    temp = *swig_optr;
    $result = &temp;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string {
    std::string *swig_optr = 0;
    int swig_ores = SWIG_AsPtr_std_string($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "AsPtr" "_" {std::string},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::string* {
    std::string *swig_optr = 0;
    int swig_ores = SWIG_AsPtr_std_string($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::string*
  {
    if (director)  {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "AsPtr" "_" {std::string},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::string& {
    std::string *swig_optr = 0;
    int swig_ores = SWIG_AsPtr_std_string($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    } else {
      if (!swig_optr) { 
	Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::string&
  {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }


  %typemap(directorout,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string &DIRECTOROUT = std::string

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,146,%ptr_typecheck_typemap@*/
%typemap(typecheck,noblock=1,precedence=135,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string * {
  int res = SWIG_AsPtr_std_string($input, (std::string**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=135,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string, const std::string& {  
  int res = SWIG_AsPtr_std_string($input, (std::string**)(0));
  $1 = SWIG_CheckState(res);
}
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,254,%ptr_input_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,117,%_ptr_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string *INPUT(int res = 0) {  
    res = SWIG_AsPtr_std_string($input, &$1);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string &INPUT(int res = 0) {  
    res = SWIG_AsPtr_std_string($input, &$1);
    if (!SWIG_IsOK(res)) { 
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }     
    if (!$1) { 
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") std::string *INPUT, std::string &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=135,fragment="SWIG_" "AsPtr" "_" {std::string}) std::string *INPUT, std::string &INPUT {
    int res = SWIG_AsPtr_std_string($input, (std::string**)0);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {std::string}) std::string, const std::string {
    $result = SWIG_From_std_string(static_cast< std::string >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {std::string}) const std::string& {
    $result = SWIG_From_std_string(static_cast< std::string >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {std::string}) std::string, const std::string&  {
    $result = SWIG_From_std_string(static_cast< std::string >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {std::string}) std::string {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_std_string(static_cast< std::string >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {std::string}) std::string *DIRECTORIN {
    $input = SWIG_From_std_string(static_cast< std::string >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {std::string}) std::string, const std::string& {
    $input = SWIG_From_std_string(static_cast< std::string >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {std::string}) std::string {
    SWIG_Python_Raise(SWIG_From_std_string(static_cast< std::string >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::string *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::string &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {std::string}) std::string *OUTPUT, std::string &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_std_string((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::string *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::string &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {std::string}) std::string *OUTPUT, std::string &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_std_string((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,240,%_ptr_inout_typemap@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::string *INOUT = std::string *INPUT;
 %typemap(in) std::string &INOUT = std::string &INPUT;
 %typemap(typecheck) std::string *INOUT = std::string *INPUT;
 %typemap(typecheck) std::string &INOUT = std::string &INPUT;
 %typemap(argout) std::string *INOUT = std::string *OUTPUT;
 %typemap(argout) std::string &INOUT = std::string &OUTPUT;
/*@SWIG@*/
 %typemap(typecheck) std::string *INOUT = std::string *INPUT;
 %typemap(typecheck) std::string &INOUT = std::string &INPUT;
 %typemap(freearg) std::string *INOUT = std::string *INPUT;
 %typemap(freearg) std::string &INOUT = std::string &INPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;

/*@SWIG@*/;







]

]
%includefile "C:\\Programme\\swig\\Lib\\python\\std_vector.i" [
/*
  Vectors
*/

%fragment("StdVectorTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class T>
    struct traits_asptr<std::vector<T> >  {
      static int asptr(PyObject *obj, std::vector<T> **vec) {
	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
      }
    };
    
    template <class T>
    struct traits_from<std::vector<T> > {
      static PyObject *from(const std::vector<T>& vec) {
	return traits_from_stdseq<std::vector<T> >::from(vec);
      }
    };
  }
%}




%includefile "C:\\Programme\\swig\\Lib\\std\\std_vector.i" [
//
// std::vector
//

%includefile "C:\\Programme\\swig\\Lib\\python\\std_container.i" [
%includefile "C:\\Programme\\swig\\Lib\\python\\pycontainer.swg" [
/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * pycontainer.swg
 *
 * Python sequence <-> C++ container wrapper
 *
 * This wrapper, and its iterator, allows a general use (and reuse) of
 * the the mapping between C++ and Python, thanks to the C++
 * templates.
 *
 * Of course, it needs the C++ compiler to support templates, but
 * since we will use this wrapper with the STL containers, that should
 * be the case.
 * ----------------------------------------------------------------------------- */

%{
#include <iostream>
%}








%includefile "C:\\Programme\\swig\\Lib\\python\\pyiterators.swg" [
/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * pyiterators.swg
 *
 * Implement a python 'output' iterator for Python 2.2 or higher.
 *
 * Users can derive form the SwigPyIterator to implement their
 * own iterators. As an example (real one since we use it for STL/STD
 * containers), the template SwigPyIterator_T does the
 * implementation for genereic C++ iterators.
 * ----------------------------------------------------------------------------- */



%fragment("SwigPyIterator","header") {  
namespace swig {
  struct stop_iteration {
  };

  struct SwigPyIterator {
  private:
    SwigPtr_PyObject _seq;

  protected:
    SwigPyIterator(PyObject *seq) : _seq(seq)
    {
    }
      
  public:
    virtual ~SwigPyIterator() {}

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual SwigPyIterator *decr(size_t /*n*/ = 1)
    {
      throw stop_iteration();
    }

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }

    virtual bool equal (const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }
    
    // C++ common/needed methods
    virtual SwigPyIterator *copy() const = 0;

    PyObject *next()     
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      PyObject *obj = value();
      incr();       
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
      return obj;     
    }

    /* Make an alias for Python 3.x */
    PyObject *__next__()
    {
      return next();
    }

    PyObject *previous()
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      decr();
      PyObject *obj = value();
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
      return obj;
    }

    SwigPyIterator *advance(ptrdiff_t n)
    {
      return  (n > 0) ?  incr(n) : decr(-n);
    }
      
    bool operator == (const SwigPyIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const SwigPyIterator& x) const
    {
      return ! operator==(x);
    }
      
    SwigPyIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    SwigPyIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    SwigPyIterator* operator + (ptrdiff_t n) const
    {
      return copy()->advance(n);
    }

    SwigPyIterator* operator - (ptrdiff_t n) const
    {
      return copy()->advance(-n);
    }
      
    ptrdiff_t operator - (const SwigPyIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
	init = 1;
      }	
      return desc;
    }    
  };
}
}

%fragment("SwigPyIterator_T","header",fragment="SwigPyIterator",fragment="StdTraits",fragment="StdIteratorTraits") {
namespace swig {
  template<typename OutIterator>
  class SwigPyIterator_T :  public SwigPyIterator
  {
  public:
    typedef OutIterator out_iterator;
    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
    typedef SwigPyIterator_T<out_iterator> self_type;

    SwigPyIterator_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator(seq), current(curr)
    {
    }

    const out_iterator& get_current() const
    {
      return current;
    }

    
    bool equal (const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    ptrdiff_t distance(const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }    
    
  protected:
    out_iterator current;
  };
  
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef PyObject *result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorOpen_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;
    typedef SwigPyIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorOpen_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq)
    {
    }
    
    PyObject *value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	++base::current;
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	--base::current;
      }
      return this;
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorClosed_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;    
    typedef SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    PyObject *value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	if (base::current == end) {
	  throw stop_iteration();
	} else {
	  ++base::current;
	}
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	if (base::current == begin) {
	  throw stop_iteration();
	} else {
	  --base::current;
	}
      }
      return this;
    }

  private:
    out_iterator begin;
    out_iterator end;
  };

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
  {
    return new SwigPyIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, PyObject *seq = 0)
  {
    return new SwigPyIteratorOpen_T<OutIter>(current, seq);
  }
}
}


%fragment("SwigPyIterator");
namespace swig 
{
  /*
    Throw a StopIteration exception
  */
  %rename($ignore) stop_iteration;
  struct stop_iteration {};
  
  %typemap(throws) stop_iteration {
    (void)$1;
    SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
    SWIG_fail;
  }

  /* 
     Mark methods that return new objects
  */
  %feature("new") SwigPyIterator::copy;
  %feature("new") SwigPyIterator::operator + (ptrdiff_t n) const;
  %feature("new") SwigPyIterator::operator - (ptrdiff_t n) const;

  %feature("director","0") SwigPyIterator;
  %extend SwigPyIterator {
  %insert("python") {def __iter__(self): return self}
  }

  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::value() const;
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::incr(size_t n = 1);
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::decr(size_t n = 1);
  %feature("catches","(""std::invalid_argument"")") SwigPyIterator::distance(const SwigPyIterator &x) const;
  %feature("catches","(""std::invalid_argument"")") SwigPyIterator::equal (const SwigPyIterator &x) const;
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::__next__();
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::next();
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::previous();
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::advance(ptrdiff_t n);
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::operator += (ptrdiff_t n);
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::operator -= (ptrdiff_t n);
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::operator + (ptrdiff_t n) const;
  %feature("catches","(""swig::stop_iteration"")") SwigPyIterator::operator - (ptrdiff_t n) const;


  struct SwigPyIterator
  {
  protected:
    SwigPyIterator(PyObject *seq);

  public:
    virtual ~SwigPyIterator();

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual SwigPyIterator *decr(size_t n = 1);

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const SwigPyIterator &x) const;

    virtual bool equal (const SwigPyIterator &x) const;
    
    // C++ common/needed methods
    virtual SwigPyIterator *copy() const = 0;

    PyObject *next();
    PyObject *__next__();
    PyObject *previous();
    SwigPyIterator *advance(ptrdiff_t n);

    bool operator == (const SwigPyIterator& x)  const;
    bool operator != (const SwigPyIterator& x) const;
    SwigPyIterator& operator += (ptrdiff_t n);
    SwigPyIterator& operator -= (ptrdiff_t n);
    SwigPyIterator* operator + (ptrdiff_t n) const;
    SwigPyIterator* operator - (ptrdiff_t n) const;
    ptrdiff_t operator - (const SwigPyIterator& x) const;
  };
}


]

/**** The PySequence C++ Wrap ***/

%insert(header) %{
#include <stdexcept>
%}

%includefile "C:\\Programme\\swig\\Lib\\python\\std_except.i" [
%includefile "C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg" [



/* 
   Mark all of std exception classes as "exception classes" via
   the "exceptionclass" feature.
   
   If needed, you can disable it by using %noexceptionclass.
*/













namespace std {
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  bad_exception; 

  %typemap(throws,noblock=1) bad_exception {
    SWIG_exception_fail(SWIG_SystemError, $1.what());
  }
  %rename($ignore) bad_exception;
  struct bad_exception {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  domain_error; 

  %typemap(throws,noblock=1) domain_error {
    SWIG_exception_fail(SWIG_ValueError, $1.what());
  }
  %rename($ignore) domain_error;
  struct domain_error {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  exception; 

  %typemap(throws,noblock=1) exception {
    SWIG_exception_fail(SWIG_SystemError, $1.what());
  }
  %rename($ignore) exception;
  struct exception {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  invalid_argument; 

  %typemap(throws,noblock=1) invalid_argument {
    SWIG_exception_fail(SWIG_ValueError, $1.what());
  }
  %rename($ignore) invalid_argument;
  struct invalid_argument {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  length_error; 

  %typemap(throws,noblock=1) length_error {
    SWIG_exception_fail(SWIG_IndexError, $1.what());
  }
  %rename($ignore) length_error;
  struct length_error {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  logic_error; 

  %typemap(throws,noblock=1) logic_error {
    SWIG_exception_fail(SWIG_RuntimeError, $1.what());
  }
  %rename($ignore) logic_error;
  struct logic_error {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  out_of_range; 

  %typemap(throws,noblock=1) out_of_range {
    SWIG_exception_fail(SWIG_IndexError, $1.what());
  }
  %rename($ignore) out_of_range;
  struct out_of_range {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  overflow_error; 

  %typemap(throws,noblock=1) overflow_error {
    SWIG_exception_fail(SWIG_OverflowError, $1.what());
  }
  %rename($ignore) overflow_error;
  struct overflow_error {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  range_error; 

  %typemap(throws,noblock=1) range_error {
    SWIG_exception_fail(SWIG_OverflowError, $1.what());
  }
  %rename($ignore) range_error;
  struct range_error {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  runtime_error; 

  %typemap(throws,noblock=1) runtime_error {
    SWIG_exception_fail(SWIG_RuntimeError, $1.what());
  }
  %rename($ignore) runtime_error;
  struct runtime_error {
  };

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\std_except.swg,11,%std_exception_map@*/
  %feature("exceptionclass")  underflow_error; 

  %typemap(throws,noblock=1) underflow_error {
    SWIG_exception_fail(SWIG_OverflowError, $1.what());
  }
  %rename($ignore) underflow_error;
  struct underflow_error {
  };

/*@SWIG@*/;
}






























































]

]

%fragment("SWIG_" "Traits" "_" {swig::SwigPtr_PyObject},"header",fragment="StdTraits") {
namespace swig {
  template <>  struct traits<SwigPtr_PyObject > {
    typedef value_category category;
    static const char* type_name() { return  "SwigPtr_PyObject"; }
  };
  
  template <>  struct traits_from<SwigPtr_PyObject> {
    typedef SwigPtr_PyObject value_type;
    static PyObject *from(const value_type& val) {
      PyObject *obj = static_cast<PyObject *>(val);
      Py_XINCREF(obj);
      return obj;
    }
  };
  
  template <> 
  struct traits_check<SwigPtr_PyObject, value_category> {
    static bool check(SwigPtr_PyObject) {
      return true;
    }
  };
  
  template <>  struct traits_asval<SwigPtr_PyObject > {   
    typedef SwigPtr_PyObject value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };
}
}

%fragment("SWIG_" "Traits" "_" {swig::SwigVar_PyObject},"header",fragment="StdTraits") {
namespace swig {
  template <>  struct traits<SwigVar_PyObject > {
    typedef value_category category;
    static const char* type_name() { return  "SwigVar_PyObject"; }
  };
  
  template <>  struct traits_from<SwigVar_PyObject> {
    typedef SwigVar_PyObject value_type;
    static PyObject *from(const value_type& val) {
      PyObject *obj = static_cast<PyObject *>(val);
      Py_XINCREF(obj);
      return obj;
    }
  };
  
  template <> 
  struct traits_check<SwigVar_PyObject, value_category> {
    static bool check(SwigVar_PyObject) {
      return true;
    }
  };
  
  template <>  struct traits_asval<SwigVar_PyObject > {   
    typedef SwigVar_PyObject value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };
} 
}

%fragment("SwigPySequence_Base","header")
{
#include <functional>

namespace std {
  template <>
  struct less <PyObject *>: public binary_function<PyObject *, PyObject *, bool>
  {
    bool
    operator()(PyObject * v, PyObject *w) const
    { 
      bool res;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      res = PyObject_Compare(v, w) < 0;
      /* This may fall into a case of inconsistent
               eg. ObjA > ObjX > ObjB
               but ObjA < ObjB
      */
      if( PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError) )
      {
        /* Objects can't be compared, this mostly occured in Python 3.0 */
        /* Compare their ptr directly for a workaround */
        res = (v < w);
        PyErr_Clear();
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return res;
    }
  };

  template <>
  struct less <swig::SwigPtr_PyObject>: public binary_function<swig::SwigPtr_PyObject, swig::SwigPtr_PyObject, bool>
  {
    bool
    operator()(const swig::SwigPtr_PyObject& v, const swig::SwigPtr_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

  template <>
  struct less <swig::SwigVar_PyObject>: public binary_function<swig::SwigVar_PyObject, swig::SwigVar_PyObject, bool>
  {
    bool
    operator()(const swig::SwigVar_PyObject& v, const swig::SwigVar_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

}

namespace swig {
  template <> struct traits<PyObject *> {
    typedef value_category category;
    static const char* type_name() { return "PyObject *"; }
  };  

  template <>  struct traits_asval<PyObject * > {   
    typedef PyObject * value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };

  template <> 
  struct traits_check<PyObject *, value_category> {
    static bool check(PyObject *) {
      return true;
    }
  };

  template <>  struct traits_from<PyObject *> {
    typedef PyObject * value_type;
    static PyObject *from(const value_type& val) {
      Py_XINCREF(val);
      return val;
    }
  };
  
}

namespace swig {
  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}
}

%fragment("SwigPySequence_Cont","header",
	  fragment="StdTraits",
	  fragment="SwigPySequence_Base",
	  fragment="SwigPyIterator_T")
{
namespace swig
{
  template <class T>
  struct SwigPySequence_Ref
  {
    SwigPySequence_Ref(PyObject* seq, int index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      swig::SwigVar_PyObject item = PySequence_GetItem(_seq, _index);
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", _index);
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	SWIG_Python_AddErrorMsg(msg);
	SWIG_Python_AddErrorMsg(e.what());
	throw;
      }
    }

    SwigPySequence_Ref& operator=(const T& v)
    {
      PySequence_SetItem(_seq, _index, swig::from<T>(v));
      return *this;
    }

  private:
    PyObject* _seq;
    int _index;
  };

  template <class T>
  struct SwigPySequence_ArrowProxy
  {
    SwigPySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };

  template <class T, class Reference >
  struct SwigPySequence_InputIterator
  {
    typedef SwigPySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;

    SwigPySequence_InputIterator()
    {
    }

    SwigPySequence_InputIterator(PyObject* seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    SwigPySequence_ArrowProxy<T>
    operator->() const {
      return SwigPySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    PyObject* _seq;
    difference_type _index;
  };

  template <class T>
  struct SwigPySequence_Cont
  {
    typedef SwigPySequence_Ref<T> reference;
    typedef const SwigPySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef SwigPySequence_InputIterator<T, reference> iterator;
    typedef SwigPySequence_InputIterator<T, const_reference> const_iterator;

    SwigPySequence_Cont(PyObject* seq) : _seq(0)
    {
      if (!PySequence_Check(seq)) {
	throw std::invalid_argument("a sequence is expected");
      }
      _seq = seq;
      Py_INCREF(_seq);
    }

    ~SwigPySequence_Cont()
    {
      Py_XDECREF(_seq);
    }

    size_type size() const
    {
      return static_cast<size_type>(PySequence_Size(_seq));
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = true) const
    {
      int s = size();
      for (int i = 0; i < s; ++i) {
	swig::SwigVar_PyObject item = PySequence_GetItem(_seq, i);
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    PyObject* _seq;
  };

}
}







































































/**** The python container methods  ****/









































































































































//
// Common fragments
//

%fragment("StdSequenceTraits","header",
	  fragment="StdTraits",
	  fragment="SwigPySequence_Cont")
{
namespace swig {
  template <class SwigPySeq, class Seq>
  inline void
  assign(const SwigPySeq& swigpyseq, Seq* seq) {
    // seq->assign(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
    typedef typename SwigPySeq::value_type value_type;
    typename SwigPySeq::const_iterator it = swigpyseq.begin();
    for (;it != swigpyseq.end(); ++it) {
      seq->insert(seq->end(),(value_type)(*it));
    }
  }

  template <class Seq, class T = typename Seq::value_type >
  struct traits_asptr_stdseq {
    typedef Seq sequence;
    typedef T value_type;

    static int asptr(PyObject *obj, sequence **seq) {
      if (obj == Py_None || SWIG_Python_GetSwigThis(obj)) {
	sequence *p;
	if (::SWIG_ConvertPtr(obj,(void**)&p,
			      swig::type_info<sequence>(),0) == SWIG_OK) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      } else if (PySequence_Check(obj)) {
	try {
	  SwigPySequence_Cont<value_type> swigpyseq(obj);
	  if (seq) {
	    sequence *pseq = new sequence();
	    assign(swigpyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return swigpyseq.check() ? SWIG_OK : SWIG_ERROR;
	  }
	} catch (std::exception& e) {
	  if (seq) {
	    if (!PyErr_Occurred()) {
	      PyErr_SetString(PyExc_TypeError, e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      }
      return SWIG_ERROR;
    }
  };

  template <class Seq, class T = typename Seq::value_type >
  struct traits_from_stdseq {
    typedef Seq sequence;
    typedef T value_type;
    typedef typename Seq::size_type size_type;
    typedef typename sequence::const_iterator const_iterator;

    static PyObject *from(const sequence& seq) {
#ifdef SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
      swig_type_info *desc = swig::type_info<sequence>();
      if (desc && desc->clientdata) {
	return SWIG_NewPointerObj(new sequence(seq), desc, SWIG_POINTER_OWN);
      }
#endif
      size_type size = seq.size();
      if (size <= (size_type)INT_MAX) {
	PyObject *obj = PyTuple_New((int)size);
	int i = 0;
	for (const_iterator it = seq.begin();
	     it != seq.end(); ++it, ++i) {
	  PyTuple_SetItem(obj,i,swig::from<value_type>(*it));
	}
	return obj;
      } else {
	PyErr_SetString(PyExc_OverflowError,"sequence size not valid in python");
	return NULL;
      }
    }
  };
}
}

]
%includefile "C:\\Programme\\swig\\Lib\\std\\std_container.i" [

%includefile "C:\\Programme\\swig\\Lib\\python\\exception.i" [



%insert("runtime") {
  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 
}

]
%includefile "C:\\Programme\\swig\\Lib\\python\\std_alloc.i" [
%includefile "C:\\Programme\\swig\\Lib\\std\\std_alloc.i" [
namespace std
{
  /**
   *  @brief  The "standard" allocator, as per [20.4].
   *
   *  The private _Alloc is "SGI" style.  (See comments at the top
   *  of stl_alloc.h.)
   *
   *  The underlying allocator behaves as follows.
   *    - __default_alloc_template is used via two typedefs
   *    - "__single_client_alloc" typedef does no locking for threads
   *    - "__alloc" typedef is threadsafe via the locks
   *    - __new_alloc is used for memory requests
   *
   *  (See @link Allocators allocators info @endlink for more.)
   */
  template<typename _Tp>
    class allocator
    {
    public:
      typedef size_t     size_type;
      typedef ptrdiff_t  difference_type;
      typedef _Tp*       pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp&       reference;
      typedef const _Tp& const_reference;
      typedef _Tp        value_type;

      template<typename _Tp1>
        struct rebind;

      allocator() throw();
      
      allocator(const allocator&) throw();
      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw();
      ~allocator() throw();
      

      pointer
      address(reference __x) const;
      

      const_pointer
      address(const_reference __x) const;
      

      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      _Tp*
      allocate(size_type __n, const void* = 0);

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type __n);

      size_type
      max_size() const throw();

      void construct(pointer __p, const _Tp& __val);
      void destroy(pointer __p);
    };

  template<>
    class allocator<void>
    {
    public:
      typedef size_t      size_type;
      typedef ptrdiff_t   difference_type;
      typedef void*       pointer;
      typedef const void* const_pointer;
      typedef void        value_type;

      template<typename _Tp1>
        struct rebind;
    };
} // namespace std

]

]

%{
#include <algorithm>
%}

// Common container methods



























// Common sequence





























































//
// Ignore member methods for Type with no default constructor
//









]

]

// Vector

















// ------------------------------------------------------------------------
// std::vector
// 
// The aim of all that follows would be to integrate std::vector with 
// as much as possible, namely, to allow the user to pass and 
// be returned tuples or lists.
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::vector<T>), f(const std::vector<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::vector<T> can be passed.
//   -- f(std::vector<T>&), f(std::vector<T>*):
//      the parameter may be modified; therefore, only a wrapped std::vector
//      can be passed.
//   -- std::vector<T> f(), const std::vector<T>& f():
//      the vector is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::vector<T>& f(), std::vector<T>* f():
//      the vector is returned by reference; therefore, a wrapped std::vector
//      is returned
//   -- const std::vector<T>* f(), f(const std::vector<T>*):
//      for consistency, they expect and return a plain vector pointer.
// ------------------------------------------------------------------------

%{
#include <vector>
%}    

// exported classes


namespace std {

  template<class _Tp, class _Alloc = allocator< _Tp > >
  class vector {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Alloc allocator_type;

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {_Tp},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<_Tp > {
      typedef pointer_category category;
      static const char* type_name() { return"_Tp"; }
    };
  }
}
/*@SWIG@*/;

    %fragment("SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}, "header",
	      fragment="SWIG_" "Traits" "_" {_Tp},
	      fragment="StdVectorTraits") {
      namespace swig {
	template <>  struct traits<std::vector<_Tp, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" #_Tp "," #_Alloc " >";
	  }
	};
      }
    }

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,180,%typemap_traits_ptr@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,193,%typemaps_asptrfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,163,%typemaps_asptr@*/
  %fragment("SWIG_" "AsVal" "_" {std::vector<_Tp,_Alloc >},"header",fragment="SWIG_" "AsPtr" "_" {std::vector<_Tp,_Alloc >}) {
    SWIGINTERNINLINE int
    SWIG_AsVal_std_vector_Sl__Tp_Sc__Alloc_Sg_ (PyObject * obj, std::vector<_Tp,_Alloc > *val)
    {
      std::vector<_Tp,_Alloc > *v = (std::vector<_Tp,_Alloc > *)0;
      int res = SWIG_AsPtr_std_vector_Sl__Tp_Sc__Alloc_Sg_ (obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  delete v;
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,31,%ptr_in_typemap@*/
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > {
    std::vector<_Tp,_Alloc > *ptr = (std::vector<_Tp,_Alloc > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  %typemap(freearg) std::vector<_Tp,_Alloc > "";
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) const std::vector<_Tp,_Alloc > & (int res = SWIG_OLDOBJ) {
    std::vector<_Tp,_Alloc > *ptr = (std::vector<_Tp,_Alloc > *)0;
    res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res)) { SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    if (!ptr) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const std::vector<_Tp,_Alloc > &  {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,56,%ptr_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > {
    std::vector<_Tp,_Alloc > *ptr = (std::vector<_Tp,_Alloc > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in variable '""$name""' of type '""$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,71,%ptr_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > *DIRECTOROUT ($*ltype temp) {
    std::vector<_Tp,_Alloc > *swig_optr = 0;
    int swig_ores = $input ? swig::asptr($input, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    temp = *swig_optr;
    $result = &temp;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > {
    std::vector<_Tp,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::vector<_Tp,_Alloc >* {
    std::vector<_Tp,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::vector<_Tp,_Alloc >*
  {
    if (director)  {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::vector<_Tp,_Alloc >& {
    std::vector<_Tp,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    } else {
      if (!swig_optr) { 
	Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::vector<_Tp,_Alloc >&
  {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }


  %typemap(directorout,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > &DIRECTOROUT = std::vector<_Tp,_Alloc >

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,146,%ptr_typecheck_typemap@*/
%typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > * {
  int res = swig::asptr($input, (std::vector<_Tp,_Alloc >**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc >, const std::vector<_Tp,_Alloc >& {  
  int res = swig::asptr($input, (std::vector<_Tp,_Alloc >**)(0));
  $1 = SWIG_CheckState(res);
}
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,254,%ptr_input_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,117,%_ptr_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > *INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > &INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) { 
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }     
    if (!$1) { 
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") std::vector<_Tp,_Alloc > *INPUT, std::vector<_Tp,_Alloc > &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > *INPUT, std::vector<_Tp,_Alloc > &INPUT {
    int res = swig::asptr($input, (std::vector<_Tp,_Alloc >**)0);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc >, const std::vector<_Tp,_Alloc > {
    $result = swig::from(static_cast< std::vector<_Tp,_Alloc > >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) const std::vector<_Tp,_Alloc >& {
    $result = swig::from(static_cast< std::vector<_Tp,_Alloc > >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc >, const std::vector<_Tp,_Alloc >&  {
    $result = swig::from(static_cast< std::vector<_Tp,_Alloc > >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > {
    SWIG_Python_SetConstant(d, "$symname",swig::from(static_cast< std::vector<_Tp,_Alloc > >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > *DIRECTORIN {
    $input = swig::from(static_cast< std::vector<_Tp,_Alloc > >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc >, const std::vector<_Tp,_Alloc >& {
    $input = swig::from(static_cast< std::vector<_Tp,_Alloc > >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > {
    SWIG_Python_Raise(swig::from(static_cast< std::vector<_Tp,_Alloc > >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::vector<_Tp,_Alloc > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::vector<_Tp,_Alloc > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > *OUTPUT, std::vector<_Tp,_Alloc > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::vector<_Tp,_Alloc > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::vector<_Tp,_Alloc > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp,_Alloc >}) std::vector<_Tp,_Alloc > *OUTPUT, std::vector<_Tp,_Alloc > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,240,%_ptr_inout_typemap@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::vector<_Tp,_Alloc > *INOUT = std::vector<_Tp,_Alloc > *INPUT;
 %typemap(in) std::vector<_Tp,_Alloc > &INOUT = std::vector<_Tp,_Alloc > &INPUT;
 %typemap(typecheck) std::vector<_Tp,_Alloc > *INOUT = std::vector<_Tp,_Alloc > *INPUT;
 %typemap(typecheck) std::vector<_Tp,_Alloc > &INOUT = std::vector<_Tp,_Alloc > &INPUT;
 %typemap(argout) std::vector<_Tp,_Alloc > *INOUT = std::vector<_Tp,_Alloc > *OUTPUT;
 %typemap(argout) std::vector<_Tp,_Alloc > &INOUT = std::vector<_Tp,_Alloc > &OUTPUT;
/*@SWIG@*/
 %typemap(typecheck) std::vector<_Tp,_Alloc > *INOUT = std::vector<_Tp,_Alloc > *INPUT;
 %typemap(typecheck) std::vector<_Tp,_Alloc > &INOUT = std::vector<_Tp,_Alloc > &INPUT;
 %typemap(freearg) std::vector<_Tp,_Alloc > *INOUT = std::vector<_Tp,_Alloc > *INPUT;
 %typemap(freearg) std::vector<_Tp,_Alloc > &INOUT = std::vector<_Tp,_Alloc > &INPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;


    // Add swig/language extra methods
    /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,701,%swig_sequence_methods@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,622,%swig_sequence_methods_common@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,529,%swig_sequence_iterator@*/

  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    $result = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1)),
				 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
  }
  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    std::pair<iterator, iterator>, std::pair<const_iterator, const_iterator> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).first),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));
    PyTuple_SetItem($result,1,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).second),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
  }

  %fragment("SwigPyPairBoolOutputIterator","header",fragment="SWIG_" "From" "_" {bool},fragment="SwigPySequence_Cont") {}

  %typemap(out,noblock=1,fragment="SwigPyPairBoolOutputIterator")
    std::pair<iterator, bool>, std::pair<const_iterator, bool> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).first),
					       swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
    PyTuple_SetItem($result,1,SWIG_From_bool  (static_cast< const $type & >($1).second));
  }

  %typemap(in,noblock=1,fragment="SwigPySequence_Cont")
    iterator(swig::SwigPyIterator *iter = 0, int res),
    reverse_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_reverse_iterator(swig::SwigPyIterator *iter = 0, int res) {
    res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    if (!SWIG_IsOK(res) || !iter) {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    } else {
      swig::SwigPyIterator_T<$type > *iter_t = dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter);
      if (iter_t) {
	$1 = iter_t->get_current();
      } else {
	SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
      }
    }
  }

   %typemap(typecheck, precedence=     5     ,noblock=1,fragment="SwigPySequence_Cont") 
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    swig::SwigPyIterator *iter = 0;
    int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    $1 = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter) != 0));
  }

  %fragment("SwigPySequence_Cont");

  %feature("new") iterator(PyObject **PYTHON_SELF);
  %extend  {
    swig::SwigPyIterator* iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %insert("python") {def __iter__(self): return self.iterator()}
  }


/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,602,%swig_container_methods@*/

  %feature("new") __getslice__;

  %extend {
    bool __nonzero__() const {
      return !(self->empty());
    }

    /* Alias for Python 3 compatibility */
    bool __bool__() const {
      return !(self->empty());
    }

    size_type __len__() const {
      return self->size();
    }
  }
/*@SWIG@*/
  
  %fragment("SwigPySequence_Base");

  %extend {
    value_type pop() throw (std::out_of_range) {
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector<_Tp,_Alloc >::value_type x = self->back();
      self->pop_back();
      return x;
    }

    /* typemap for slice object support */
    %typemap(in) PySliceObject* {
      $1 = (PySliceObject *) $input;
    }
    %typemap(typecheck,precedence=      0     ) PySliceObject* {
      $1 = PySlice_Check($input);
    }

    std::vector<_Tp,_Alloc >* __getslice__(difference_type i, difference_type j) throw (std::out_of_range) {
      return swig::getslice(self, i, j);
    }

    void __setslice__(difference_type i, difference_type j, const std::vector<_Tp,_Alloc >& v) 
      throw (std::out_of_range, std::invalid_argument) {
      swig::setslice(self, i, j, v);
    }

    void __delslice__(difference_type i, difference_type j) throw (std::out_of_range) {
      swig::delslice(self, i, j);
    }

    void __delitem__(difference_type i) throw (std::out_of_range) {
      self->erase(swig::getpos(self,i));
    }


    /* Overloaded methods for Python 3 compatibility 
     * (Also useful in Python 2.x)
     */
    std::vector<_Tp,_Alloc >* __getitem__(PySliceObject *slice) throw (std::out_of_range) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return NULL;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      return swig::getslice(self, i, j);
    }

    void __setitem__(PySliceObject *slice, const std::vector<_Tp,_Alloc >& v)
      throw (std::out_of_range, std::invalid_argument) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::setslice(self, i, j, v);
    }

    void __delitem__(PySliceObject *slice)
      throw (std::out_of_range) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::delslice(self, i,j);
    }
     
  }
/*@SWIG@*/
  %extend {
    const value_type& __getitem__(difference_type i) const throw (std::out_of_range) {
      return *(swig::cgetpos(self, i));
    }

    void __setitem__(difference_type i, const value_type& x) throw (std::out_of_range) {
      *(swig::getpos(self,i)) = x;
    }

    void append(const value_type& x) {
      self->push_back(x);
    }
 }
/*@SWIG@*/;

  
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_vector.i,9,%std_vector_methods@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,56,%std_sequence_methods@*/
  
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,39,%std_sequence_methods_common@*/
  
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,11,%std_container_methods@*/
  vector();
  vector(const vector&);

  bool empty() const;
  size_type size() const;
  void clear();

  void swap(vector& v);

  allocator_type get_allocator() const;


  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  const_iterator begin() const;
  const_iterator end() const;
  const_reverse_iterator rbegin() const;
  const_reverse_iterator rend() const;


/*@SWIG@*/;
  
  vector(size_type size);
  void pop_back();
  
  void resize(size_type new_size);
  

  iterator erase(iterator pos);
  iterator erase(iterator first, iterator last);

  
/*@SWIG@*/;
  
  vector(size_type size, const value_type& value);
  void push_back(const value_type& x);  

  const value_type& front() const;
  const value_type& back() const;
 
  void assign(size_type n, const value_type& x);

  void resize(size_type new_size, const value_type& x);
  

  iterator insert(iterator pos, const value_type& x);
  void insert(iterator pos, size_type n, const value_type& x);

  
/*@SWIG@*/
  
  void reserve(size_type n);
  size_type capacity() const;
/*@SWIG@*/;
  };

  // ***
  // This specialization should dissapear or get simplified when
  // a 'const SWIGTYPE*&' can be defined
  // ***
  template<class _Tp, class _Alloc >
  class vector<_Tp*, _Alloc > {
  public:
    typedef size_t size_type;    
    typedef ptrdiff_t difference_type;
    typedef _Tp* value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Alloc allocator_type;

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {_Tp},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<_Tp > {
      typedef pointer_category category;
      static const char* type_name() { return"_Tp"; }
    };
  }
}
/*@SWIG@*/;

    %fragment("SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}, "header",
	      fragment="SWIG_" "Traits" "_" {_Tp},
	      fragment="StdVectorTraits") {
      namespace swig {
	template <>  struct traits<std::vector<_Tp*, _Alloc > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<" #_Tp " *," #_Alloc " >";
	  }
	};
      }
    }

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,180,%typemap_traits_ptr@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,193,%typemaps_asptrfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,163,%typemaps_asptr@*/
  %fragment("SWIG_" "AsVal" "_" {std::vector<_Tp*,_Alloc >},"header",fragment="SWIG_" "AsPtr" "_" {std::vector<_Tp*,_Alloc >}) {
    SWIGINTERNINLINE int
    SWIG_AsVal_std_vector_Sl__Tp_Sm__Sc__Alloc_Sg_ (PyObject * obj, std::vector<_Tp*,_Alloc > *val)
    {
      std::vector<_Tp*,_Alloc > *v = (std::vector<_Tp*,_Alloc > *)0;
      int res = SWIG_AsPtr_std_vector_Sl__Tp_Sm__Sc__Alloc_Sg_ (obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  delete v;
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,31,%ptr_in_typemap@*/
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > {
    std::vector<_Tp*,_Alloc > *ptr = (std::vector<_Tp*,_Alloc > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  %typemap(freearg) std::vector<_Tp*,_Alloc > "";
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) const std::vector<_Tp*,_Alloc > & (int res = SWIG_OLDOBJ) {
    std::vector<_Tp*,_Alloc > *ptr = (std::vector<_Tp*,_Alloc > *)0;
    res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res)) { SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    if (!ptr) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const std::vector<_Tp*,_Alloc > &  {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,56,%ptr_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > {
    std::vector<_Tp*,_Alloc > *ptr = (std::vector<_Tp*,_Alloc > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in variable '""$name""' of type '""$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,71,%ptr_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > *DIRECTOROUT ($*ltype temp) {
    std::vector<_Tp*,_Alloc > *swig_optr = 0;
    int swig_ores = $input ? swig::asptr($input, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    temp = *swig_optr;
    $result = &temp;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > {
    std::vector<_Tp*,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::vector<_Tp*,_Alloc >* {
    std::vector<_Tp*,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::vector<_Tp*,_Alloc >*
  {
    if (director)  {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::vector<_Tp*,_Alloc >& {
    std::vector<_Tp*,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    } else {
      if (!swig_optr) { 
	Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::vector<_Tp*,_Alloc >&
  {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }


  %typemap(directorout,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > &DIRECTOROUT = std::vector<_Tp*,_Alloc >

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,146,%ptr_typecheck_typemap@*/
%typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > * {
  int res = swig::asptr($input, (std::vector<_Tp*,_Alloc >**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc >, const std::vector<_Tp*,_Alloc >& {  
  int res = swig::asptr($input, (std::vector<_Tp*,_Alloc >**)(0));
  $1 = SWIG_CheckState(res);
}
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,254,%ptr_input_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,117,%_ptr_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > *INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > &INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) { 
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }     
    if (!$1) { 
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") std::vector<_Tp*,_Alloc > *INPUT, std::vector<_Tp*,_Alloc > &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > *INPUT, std::vector<_Tp*,_Alloc > &INPUT {
    int res = swig::asptr($input, (std::vector<_Tp*,_Alloc >**)0);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc >, const std::vector<_Tp*,_Alloc > {
    $result = swig::from(static_cast< std::vector<_Tp*,_Alloc > >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) const std::vector<_Tp*,_Alloc >& {
    $result = swig::from(static_cast< std::vector<_Tp*,_Alloc > >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc >, const std::vector<_Tp*,_Alloc >&  {
    $result = swig::from(static_cast< std::vector<_Tp*,_Alloc > >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > {
    SWIG_Python_SetConstant(d, "$symname",swig::from(static_cast< std::vector<_Tp*,_Alloc > >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > *DIRECTORIN {
    $input = swig::from(static_cast< std::vector<_Tp*,_Alloc > >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc >, const std::vector<_Tp*,_Alloc >& {
    $input = swig::from(static_cast< std::vector<_Tp*,_Alloc > >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > {
    SWIG_Python_Raise(swig::from(static_cast< std::vector<_Tp*,_Alloc > >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::vector<_Tp*,_Alloc > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::vector<_Tp*,_Alloc > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > *OUTPUT, std::vector<_Tp*,_Alloc > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::vector<_Tp*,_Alloc > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::vector<_Tp*,_Alloc > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<_Tp*,_Alloc >}) std::vector<_Tp*,_Alloc > *OUTPUT, std::vector<_Tp*,_Alloc > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,240,%_ptr_inout_typemap@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::vector<_Tp*,_Alloc > *INOUT = std::vector<_Tp*,_Alloc > *INPUT;
 %typemap(in) std::vector<_Tp*,_Alloc > &INOUT = std::vector<_Tp*,_Alloc > &INPUT;
 %typemap(typecheck) std::vector<_Tp*,_Alloc > *INOUT = std::vector<_Tp*,_Alloc > *INPUT;
 %typemap(typecheck) std::vector<_Tp*,_Alloc > &INOUT = std::vector<_Tp*,_Alloc > &INPUT;
 %typemap(argout) std::vector<_Tp*,_Alloc > *INOUT = std::vector<_Tp*,_Alloc > *OUTPUT;
 %typemap(argout) std::vector<_Tp*,_Alloc > &INOUT = std::vector<_Tp*,_Alloc > &OUTPUT;
/*@SWIG@*/
 %typemap(typecheck) std::vector<_Tp*,_Alloc > *INOUT = std::vector<_Tp*,_Alloc > *INPUT;
 %typemap(typecheck) std::vector<_Tp*,_Alloc > &INOUT = std::vector<_Tp*,_Alloc > &INPUT;
 %typemap(freearg) std::vector<_Tp*,_Alloc > *INOUT = std::vector<_Tp*,_Alloc > *INPUT;
 %typemap(freearg) std::vector<_Tp*,_Alloc > &INOUT = std::vector<_Tp*,_Alloc > &INPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;


    // Add swig/language extra methods
    /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,718,%swig_sequence_methods_val@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,622,%swig_sequence_methods_common@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,529,%swig_sequence_iterator@*/

  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    $result = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1)),
				 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
  }
  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    std::pair<iterator, iterator>, std::pair<const_iterator, const_iterator> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).first),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));
    PyTuple_SetItem($result,1,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).second),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
  }

  %fragment("SwigPyPairBoolOutputIterator","header",fragment="SWIG_" "From" "_" {bool},fragment="SwigPySequence_Cont") {}

  %typemap(out,noblock=1,fragment="SwigPyPairBoolOutputIterator")
    std::pair<iterator, bool>, std::pair<const_iterator, bool> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).first),
					       swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
    PyTuple_SetItem($result,1,SWIG_From_bool  (static_cast< const $type & >($1).second));
  }

  %typemap(in,noblock=1,fragment="SwigPySequence_Cont")
    iterator(swig::SwigPyIterator *iter = 0, int res),
    reverse_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_reverse_iterator(swig::SwigPyIterator *iter = 0, int res) {
    res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    if (!SWIG_IsOK(res) || !iter) {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    } else {
      swig::SwigPyIterator_T<$type > *iter_t = dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter);
      if (iter_t) {
	$1 = iter_t->get_current();
      } else {
	SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
      }
    }
  }

   %typemap(typecheck, precedence=     5     ,noblock=1,fragment="SwigPySequence_Cont") 
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    swig::SwigPyIterator *iter = 0;
    int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    $1 = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter) != 0));
  }

  %fragment("SwigPySequence_Cont");

  %feature("new") iterator(PyObject **PYTHON_SELF);
  %extend  {
    swig::SwigPyIterator* iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %insert("python") {def __iter__(self): return self.iterator()}
  }


/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,602,%swig_container_methods@*/

  %feature("new") __getslice__;

  %extend {
    bool __nonzero__() const {
      return !(self->empty());
    }

    /* Alias for Python 3 compatibility */
    bool __bool__() const {
      return !(self->empty());
    }

    size_type __len__() const {
      return self->size();
    }
  }
/*@SWIG@*/
  
  %fragment("SwigPySequence_Base");

  %extend {
    value_type pop() throw (std::out_of_range) {
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector<_Tp*,_Alloc >::value_type x = self->back();
      self->pop_back();
      return x;
    }

    /* typemap for slice object support */
    %typemap(in) PySliceObject* {
      $1 = (PySliceObject *) $input;
    }
    %typemap(typecheck,precedence=      0     ) PySliceObject* {
      $1 = PySlice_Check($input);
    }

    std::vector<_Tp*,_Alloc >* __getslice__(difference_type i, difference_type j) throw (std::out_of_range) {
      return swig::getslice(self, i, j);
    }

    void __setslice__(difference_type i, difference_type j, const std::vector<_Tp*,_Alloc >& v) 
      throw (std::out_of_range, std::invalid_argument) {
      swig::setslice(self, i, j, v);
    }

    void __delslice__(difference_type i, difference_type j) throw (std::out_of_range) {
      swig::delslice(self, i, j);
    }

    void __delitem__(difference_type i) throw (std::out_of_range) {
      self->erase(swig::getpos(self,i));
    }


    /* Overloaded methods for Python 3 compatibility 
     * (Also useful in Python 2.x)
     */
    std::vector<_Tp*,_Alloc >* __getitem__(PySliceObject *slice) throw (std::out_of_range) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return NULL;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      return swig::getslice(self, i, j);
    }

    void __setitem__(PySliceObject *slice, const std::vector<_Tp*,_Alloc >& v)
      throw (std::out_of_range, std::invalid_argument) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::setslice(self, i, j, v);
    }

    void __delitem__(PySliceObject *slice)
      throw (std::out_of_range) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::delslice(self, i,j);
    }
     
  }
/*@SWIG@*/
  %extend {
    value_type __getitem__(difference_type i) throw (std::out_of_range) {
      return *(swig::cgetpos(self, i));
    }

    void __setitem__(difference_type i, value_type x) throw (std::out_of_range) {
      *(swig::getpos(self,i)) = x;
    }

    void append(value_type x) {
      self->push_back(x);
    }
 }
/*@SWIG@*/;;


    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_vector.i,17,%std_vector_methods_val@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,77,%std_sequence_methods_val@*/
  
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,39,%std_sequence_methods_common@*/
  
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,11,%std_container_methods@*/
  vector();
  vector(const vector&);

  bool empty() const;
  size_type size() const;
  void clear();

  void swap(vector& v);

  allocator_type get_allocator() const;


  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  const_iterator begin() const;
  const_iterator end() const;
  const_reverse_iterator rbegin() const;
  const_reverse_iterator rend() const;


/*@SWIG@*/;
  
  vector(size_type size);
  void pop_back();
  
  void resize(size_type new_size);
  

  iterator erase(iterator pos);
  iterator erase(iterator first, iterator last);

  
/*@SWIG@*/;
  
  vector(size_type size, value_type value);
  void push_back(value_type x);  

  value_type front() const;
  value_type back() const;
 
  void assign(size_type n, value_type x);

  void resize(size_type new_size, value_type x);
  

  iterator insert(iterator pos, value_type x);
  void insert(iterator pos, size_type n, value_type x);

  
/*@SWIG@*/
  
  void reserve(size_type n);
  size_type capacity() const;
/*@SWIG@*/;
  };

  // ***
  // ***
  // bool specialization

  template<class _Alloc > 
  class vector<bool,_Alloc > {
  public:
    typedef size_t size_type;    
    typedef ptrdiff_t difference_type;
    typedef bool value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Alloc allocator_type;

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {bool},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<bool > {
      typedef pointer_category category;
      static const char* type_name() { return"bool"; }
    };
  }
}
/*@SWIG@*/;

    %fragment("SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}, "header",
	      fragment="SWIG_" "Traits" "_" {bool},
	      fragment="StdVectorTraits") {
      namespace swig {
	template <>  struct traits<std::vector<bool, _Alloc > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<bool, _Alloc >";
	  }
	};
      }
    }

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,180,%typemap_traits_ptr@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,193,%typemaps_asptrfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,163,%typemaps_asptr@*/
  %fragment("SWIG_" "AsVal" "_" {std::vector<bool,_Alloc >},"header",fragment="SWIG_" "AsPtr" "_" {std::vector<bool,_Alloc >}) {
    SWIGINTERNINLINE int
    SWIG_AsVal_std_vector_Sl_bool_Sc__Alloc_Sg_ (PyObject * obj, std::vector<bool,_Alloc > *val)
    {
      std::vector<bool,_Alloc > *v = (std::vector<bool,_Alloc > *)0;
      int res = SWIG_AsPtr_std_vector_Sl_bool_Sc__Alloc_Sg_ (obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  delete v;
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,31,%ptr_in_typemap@*/
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > {
    std::vector<bool,_Alloc > *ptr = (std::vector<bool,_Alloc > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  %typemap(freearg) std::vector<bool,_Alloc > "";
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) const std::vector<bool,_Alloc > & (int res = SWIG_OLDOBJ) {
    std::vector<bool,_Alloc > *ptr = (std::vector<bool,_Alloc > *)0;
    res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res)) { SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    if (!ptr) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const std::vector<bool,_Alloc > &  {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,56,%ptr_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > {
    std::vector<bool,_Alloc > *ptr = (std::vector<bool,_Alloc > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in variable '""$name""' of type '""$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,71,%ptr_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > *DIRECTOROUT ($*ltype temp) {
    std::vector<bool,_Alloc > *swig_optr = 0;
    int swig_ores = $input ? swig::asptr($input, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    temp = *swig_optr;
    $result = &temp;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > {
    std::vector<bool,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::vector<bool,_Alloc >* {
    std::vector<bool,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::vector<bool,_Alloc >*
  {
    if (director)  {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::vector<bool,_Alloc >& {
    std::vector<bool,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    } else {
      if (!swig_optr) { 
	Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::vector<bool,_Alloc >&
  {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }


  %typemap(directorout,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > &DIRECTOROUT = std::vector<bool,_Alloc >

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,146,%ptr_typecheck_typemap@*/
%typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > * {
  int res = swig::asptr($input, (std::vector<bool,_Alloc >**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc >, const std::vector<bool,_Alloc >& {  
  int res = swig::asptr($input, (std::vector<bool,_Alloc >**)(0));
  $1 = SWIG_CheckState(res);
}
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,254,%ptr_input_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,117,%_ptr_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > *INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > &INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) { 
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }     
    if (!$1) { 
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") std::vector<bool,_Alloc > *INPUT, std::vector<bool,_Alloc > &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=160,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > *INPUT, std::vector<bool,_Alloc > &INPUT {
    int res = swig::asptr($input, (std::vector<bool,_Alloc >**)0);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc >, const std::vector<bool,_Alloc > {
    $result = swig::from(static_cast< std::vector<bool,_Alloc > >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) const std::vector<bool,_Alloc >& {
    $result = swig::from(static_cast< std::vector<bool,_Alloc > >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc >, const std::vector<bool,_Alloc >&  {
    $result = swig::from(static_cast< std::vector<bool,_Alloc > >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > {
    SWIG_Python_SetConstant(d, "$symname",swig::from(static_cast< std::vector<bool,_Alloc > >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > *DIRECTORIN {
    $input = swig::from(static_cast< std::vector<bool,_Alloc > >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc >, const std::vector<bool,_Alloc >& {
    $input = swig::from(static_cast< std::vector<bool,_Alloc > >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > {
    SWIG_Python_Raise(swig::from(static_cast< std::vector<bool,_Alloc > >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::vector<bool,_Alloc > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::vector<bool,_Alloc > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > *OUTPUT, std::vector<bool,_Alloc > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::vector<bool,_Alloc > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::vector<bool,_Alloc > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::vector<bool,_Alloc >}) std::vector<bool,_Alloc > *OUTPUT, std::vector<bool,_Alloc > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,240,%_ptr_inout_typemap@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::vector<bool,_Alloc > *INOUT = std::vector<bool,_Alloc > *INPUT;
 %typemap(in) std::vector<bool,_Alloc > &INOUT = std::vector<bool,_Alloc > &INPUT;
 %typemap(typecheck) std::vector<bool,_Alloc > *INOUT = std::vector<bool,_Alloc > *INPUT;
 %typemap(typecheck) std::vector<bool,_Alloc > &INOUT = std::vector<bool,_Alloc > &INPUT;
 %typemap(argout) std::vector<bool,_Alloc > *INOUT = std::vector<bool,_Alloc > *OUTPUT;
 %typemap(argout) std::vector<bool,_Alloc > &INOUT = std::vector<bool,_Alloc > &OUTPUT;
/*@SWIG@*/
 %typemap(typecheck) std::vector<bool,_Alloc > *INOUT = std::vector<bool,_Alloc > *INPUT;
 %typemap(typecheck) std::vector<bool,_Alloc > &INOUT = std::vector<bool,_Alloc > &INPUT;
 %typemap(freearg) std::vector<bool,_Alloc > *INOUT = std::vector<bool,_Alloc > *INPUT;
 %typemap(freearg) std::vector<bool,_Alloc > &INOUT = std::vector<bool,_Alloc > &INPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;



    // Add swig/language extra methods
    /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,718,%swig_sequence_methods_val@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,622,%swig_sequence_methods_common@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,529,%swig_sequence_iterator@*/

  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    $result = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1)),
				 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
  }
  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    std::pair<iterator, iterator>, std::pair<const_iterator, const_iterator> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).first),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));
    PyTuple_SetItem($result,1,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).second),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
  }

  %fragment("SwigPyPairBoolOutputIterator","header",fragment="SWIG_" "From" "_" {bool},fragment="SwigPySequence_Cont") {}

  %typemap(out,noblock=1,fragment="SwigPyPairBoolOutputIterator")
    std::pair<iterator, bool>, std::pair<const_iterator, bool> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).first),
					       swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
    PyTuple_SetItem($result,1,SWIG_From_bool  (static_cast< const $type & >($1).second));
  }

  %typemap(in,noblock=1,fragment="SwigPySequence_Cont")
    iterator(swig::SwigPyIterator *iter = 0, int res),
    reverse_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_reverse_iterator(swig::SwigPyIterator *iter = 0, int res) {
    res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    if (!SWIG_IsOK(res) || !iter) {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    } else {
      swig::SwigPyIterator_T<$type > *iter_t = dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter);
      if (iter_t) {
	$1 = iter_t->get_current();
      } else {
	SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
      }
    }
  }

   %typemap(typecheck, precedence=     5     ,noblock=1,fragment="SwigPySequence_Cont") 
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    swig::SwigPyIterator *iter = 0;
    int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    $1 = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter) != 0));
  }

  %fragment("SwigPySequence_Cont");

  %feature("new") iterator(PyObject **PYTHON_SELF);
  %extend  {
    swig::SwigPyIterator* iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %insert("python") {def __iter__(self): return self.iterator()}
  }


/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,602,%swig_container_methods@*/

  %feature("new") __getslice__;

  %extend {
    bool __nonzero__() const {
      return !(self->empty());
    }

    /* Alias for Python 3 compatibility */
    bool __bool__() const {
      return !(self->empty());
    }

    size_type __len__() const {
      return self->size();
    }
  }
/*@SWIG@*/
  
  %fragment("SwigPySequence_Base");

  %extend {
    value_type pop() throw (std::out_of_range) {
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector<bool,_Alloc >::value_type x = self->back();
      self->pop_back();
      return x;
    }

    /* typemap for slice object support */
    %typemap(in) PySliceObject* {
      $1 = (PySliceObject *) $input;
    }
    %typemap(typecheck,precedence=      0     ) PySliceObject* {
      $1 = PySlice_Check($input);
    }

    std::vector<bool,_Alloc >* __getslice__(difference_type i, difference_type j) throw (std::out_of_range) {
      return swig::getslice(self, i, j);
    }

    void __setslice__(difference_type i, difference_type j, const std::vector<bool,_Alloc >& v) 
      throw (std::out_of_range, std::invalid_argument) {
      swig::setslice(self, i, j, v);
    }

    void __delslice__(difference_type i, difference_type j) throw (std::out_of_range) {
      swig::delslice(self, i, j);
    }

    void __delitem__(difference_type i) throw (std::out_of_range) {
      self->erase(swig::getpos(self,i));
    }


    /* Overloaded methods for Python 3 compatibility 
     * (Also useful in Python 2.x)
     */
    std::vector<bool,_Alloc >* __getitem__(PySliceObject *slice) throw (std::out_of_range) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return NULL;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      return swig::getslice(self, i, j);
    }

    void __setitem__(PySliceObject *slice, const std::vector<bool,_Alloc >& v)
      throw (std::out_of_range, std::invalid_argument) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::setslice(self, i, j, v);
    }

    void __delitem__(PySliceObject *slice)
      throw (std::out_of_range) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::delslice(self, i,j);
    }
     
  }
/*@SWIG@*/
  %extend {
    value_type __getitem__(difference_type i) throw (std::out_of_range) {
      return *(swig::cgetpos(self, i));
    }

    void __setitem__(difference_type i, value_type x) throw (std::out_of_range) {
      *(swig::getpos(self,i)) = x;
    }

    void append(value_type x) {
      self->push_back(x);
    }
 }
/*@SWIG@*/;;


    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_vector.i,17,%std_vector_methods_val@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,77,%std_sequence_methods_val@*/
  
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,39,%std_sequence_methods_common@*/
  
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,11,%std_container_methods@*/
  vector();
  vector(const vector&);

  bool empty() const;
  size_type size() const;
  void clear();

  void swap(vector& v);

  allocator_type get_allocator() const;


  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  const_iterator begin() const;
  const_iterator end() const;
  const_reverse_iterator rbegin() const;
  const_reverse_iterator rend() const;


/*@SWIG@*/;
  
  vector(size_type size);
  void pop_back();
  
  void resize(size_type new_size);
  

  iterator erase(iterator pos);
  iterator erase(iterator first, iterator last);

  
/*@SWIG@*/;
  
  vector(size_type size, value_type value);
  void push_back(value_type x);  

  value_type front() const;
  value_type back() const;
 
  void assign(size_type n, value_type x);

  void resize(size_type new_size, value_type x);
  

  iterator insert(iterator pos, value_type x);
  void insert(iterator pos, size_type n, value_type x);

  
/*@SWIG@*/
  
  void reserve(size_type n);
  size_type capacity() const;
/*@SWIG@*/;





  };

}

]

]
%includefile "C:\\Programme\\swig\\Lib\\python\\std_map.i" [
/*
  Maps
*/

%fragment("StdMapTraits","header",fragment="StdSequenceTraits")
{
  namespace swig {
    template <class SwigPySeq, class K, class T >
    inline void
    assign(const SwigPySeq& swigpyseq, std::map<K,T > *map) {
      typedef typename std::map<K,T>::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	map->insert(value_type(it->first, it->second));
      }
    }

    template <class K, class T>
    struct traits_asptr<std::map<K,T> >  {
      typedef std::map<K,T> map_type;
      static int asptr(PyObject *obj, map_type **val) {
	int res = SWIG_ERROR;
	if (PyDict_Check(obj)) {
	  SwigVar_PyObject items = PyObject_CallMethod(obj,(char *)"items",NULL);
#if PY_VERSION_HEX >= 0x03000000
          /* In Python 3.x the ".items()" method return a dict_items object */
          items = PySequence_Fast(items, ".items() havn't returned a sequence!");
#endif
	  res = traits_asptr_stdseq<std::map<K,T>, std::pair<K, T> >::asptr(items, val);
	} else {
	  map_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<map_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }      
    };
      
    template <class K, class T >
    struct traits_from<std::map<K,T> >  {
      typedef std::map<K,T> map_type;
      typedef typename map_type::const_iterator const_iterator;
      typedef typename map_type::size_type size_type;
            
      static PyObject *from(const map_type& map) {
	swig_type_info *desc = swig::type_info<map_type>();
	if (desc && desc->clientdata) {
	  return SWIG_NewPointerObj(new map_type(map), desc, SWIG_POINTER_OWN);
	} else {
	  size_type size = map.size();
	  int pysize = (size <= (size_type) INT_MAX) ? (int) size : -1;
	  if (pysize < 0) {
	    SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	    PyErr_SetString(PyExc_OverflowError,
			    "map size not valid in python");
	    SWIG_PYTHON_THREAD_END_BLOCK;
	    return NULL;
	  }
	  PyObject *obj = PyDict_New();
	  for (const_iterator i= map.begin(); i!= map.end(); ++i) {
	    swig::SwigVar_PyObject key = swig::from(i->first);
	    swig::SwigVar_PyObject val = swig::from(i->second);
	    PyDict_SetItem(obj, key, val);
	  }
	  return obj;
	}
      }
    };

    template <class ValueType>
    struct from_key_oper 
    {
      typedef const ValueType& argument_type;
      typedef  PyObject *result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.first);
      }
    };

    template <class ValueType>
    struct from_value_oper 
    {
      typedef const ValueType& argument_type;
      typedef  PyObject *result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.second);
      }
    };

    template<class OutIterator, class FromOper, class ValueType = typename OutIterator::value_type>
    struct SwigPyMapIterator_T : SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper>
    {
      SwigPyMapIterator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyIteratorClosed_T<OutIterator,ValueType,FromOper>(curr, first, last, seq)
      {
      }
    };


    template<class OutIterator,
	     class FromOper = from_key_oper<typename OutIterator::value_type> >
    struct SwigPyMapKeyIterator_T : SwigPyMapIterator_T<OutIterator, FromOper>
    {
      SwigPyMapKeyIterator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyMapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };

    template<typename OutIter>
    inline SwigPyIterator*
    make_output_key_iterator(const OutIter& current, const OutIter& begin, const OutIter& end, PyObject *seq = 0)
    {
      return new SwigPyMapKeyIterator_T<OutIter>(current, begin, end, seq);
    }

    template<class OutIterator,
	     class FromOper = from_value_oper<typename OutIterator::value_type> >
    struct SwigPyMapValueITerator_T : SwigPyMapIterator_T<OutIterator, FromOper>
    {
      SwigPyMapValueITerator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyMapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };
    

    template<typename OutIter>
    inline SwigPyIterator*
    make_output_value_iterator(const OutIter& current, const OutIter& begin, const OutIter& end, PyObject *seq = 0)
    {
      return new SwigPyMapValueITerator_T<OutIter>(current, begin, end, seq);
    }
  }
}

















































































































%includefile "C:\\Programme\\swig\\Lib\\std\\std_map.i" [
//
// std::map
//

%includefile "C:\\Programme\\swig\\Lib\\python\\std_pair.i" [
/*
  Pairs
*/


//#define SWIG_STD_PAIR_ASVAL

%fragment("StdPairTraits","header",fragment="StdTraits") {
  namespace swig {

















































    template <class T, class U >
    struct traits_asptr<std::pair<T,U> >  {
      typedef std::pair<T,U> value_type;

      static int get_pair(PyObject* first, PyObject* second,
			  std::pair<T,U> **val) 
      {
	if (val) {
	  value_type *vp = (new std::pair<T,U>);
	  T *pfirst = &(vp->first);
	  int res1 = swig::asval((PyObject*)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = &(vp->second);
	  int res2 = swig::asval((PyObject*)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  *val = vp;
	  return SWIG_AddNewMask(res1 > res2 ? res1 : res2);
	} else {
	  T *pfirst = 0;
	  int res1 = swig::asval((PyObject*)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = 0;
	  int res2 = swig::asval((PyObject*)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  return res1 > res2 ? res1 : res2;
	}	
      }

      static int asptr(PyObject *obj, std::pair<T,U> **val) {
	int res = SWIG_ERROR;
	if (PyTuple_Check(obj)) {
	  if (PyTuple_GET_SIZE(obj) == 2) {
	    res = get_pair(PyTuple_GET_ITEM(obj,0),PyTuple_GET_ITEM(obj,1), val);
	  }
	} else if (PySequence_Check(obj)) {
	  if (PySequence_Size(obj) == 2) {
	    swig::SwigVar_PyObject first = PySequence_GetItem(obj,0);
	    swig::SwigVar_PyObject second = PySequence_GetItem(obj,1);
	    res = get_pair(first, second, val);
	  }
	} else {
	  value_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<value_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }
    };


    template <class T, class U >
    struct traits_from<std::pair<T,U> >   {
      static PyObject *from(const std::pair<T,U>& val) {
	PyObject* obj = PyTuple_New(2);
	PyTuple_SetItem(obj,0,swig::from(val.first));
	PyTuple_SetItem(obj,1,swig::from(val.second));
	return obj;
      }
    };
  }
}


















%includefile "C:\\Programme\\swig\\Lib\\std\\std_pair.i" [


%{
#include <utility>
%}


namespace std {
  template <class T, class U > struct pair {      
    typedef T first_type;
    typedef U second_type;
    
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {T},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<T > {
      typedef pointer_category category;
      static const char* type_name() { return"T"; }
    };
  }
}
/*@SWIG@*/;
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {U},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<U > {
      typedef pointer_category category;
      static const char* type_name() { return"U"; }
    };
  }
}
/*@SWIG@*/;

    %fragment("SWIG_" "Traits" "_" {std::pair<T,U >}, "header",
	      fragment="SWIG_" "Traits" "_" {T},
	      fragment="SWIG_" "Traits" "_" {U},
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair<T,U > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #T "," #U " >";
	  }
	};
      }
    }


    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,180,%typemap_traits_ptr@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,193,%typemaps_asptrfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,163,%typemaps_asptr@*/
  %fragment("SWIG_" "AsVal" "_" {std::pair<T,U >},"header",fragment="SWIG_" "AsPtr" "_" {std::pair<T,U >}) {
    SWIGINTERNINLINE int
    SWIG_AsVal_std_pair_Sl_T_Sc_U_Sg_ (PyObject * obj, std::pair<T,U > *val)
    {
      std::pair<T,U > *v = (std::pair<T,U > *)0;
      int res = SWIG_AsPtr_std_pair_Sl_T_Sc_U_Sg_ (obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  delete v;
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,31,%ptr_in_typemap@*/
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > {
    std::pair<T,U > *ptr = (std::pair<T,U > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  %typemap(freearg) std::pair<T,U > "";
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) const std::pair<T,U > & (int res = SWIG_OLDOBJ) {
    std::pair<T,U > *ptr = (std::pair<T,U > *)0;
    res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res)) { SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    if (!ptr) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const std::pair<T,U > &  {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,56,%ptr_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > {
    std::pair<T,U > *ptr = (std::pair<T,U > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in variable '""$name""' of type '""$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,71,%ptr_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > *DIRECTOROUT ($*ltype temp) {
    std::pair<T,U > *swig_optr = 0;
    int swig_ores = $input ? swig::asptr($input, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    temp = *swig_optr;
    $result = &temp;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > {
    std::pair<T,U > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::pair<T,U >* {
    std::pair<T,U > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::pair<T,U >*
  {
    if (director)  {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::pair<T,U >& {
    std::pair<T,U > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    } else {
      if (!swig_optr) { 
	Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::pair<T,U >&
  {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }


  %typemap(directorout,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > &DIRECTOROUT = std::pair<T,U >

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,146,%ptr_typecheck_typemap@*/
%typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > * {
  int res = swig::asptr($input, (std::pair<T,U >**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U >, const std::pair<T,U >& {  
  int res = swig::asptr($input, (std::pair<T,U >**)(0));
  $1 = SWIG_CheckState(res);
}
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,254,%ptr_input_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,117,%_ptr_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > *INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > &INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) { 
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }     
    if (!$1) { 
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") std::pair<T,U > *INPUT, std::pair<T,U > &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > *INPUT, std::pair<T,U > &INPUT {
    int res = swig::asptr($input, (std::pair<T,U >**)0);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U >, const std::pair<T,U > {
    $result = swig::from(static_cast< std::pair<T,U > >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) const std::pair<T,U >& {
    $result = swig::from(static_cast< std::pair<T,U > >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U >, const std::pair<T,U >&  {
    $result = swig::from(static_cast< std::pair<T,U > >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > {
    SWIG_Python_SetConstant(d, "$symname",swig::from(static_cast< std::pair<T,U > >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > *DIRECTORIN {
    $input = swig::from(static_cast< std::pair<T,U > >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U >, const std::pair<T,U >& {
    $input = swig::from(static_cast< std::pair<T,U > >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > {
    SWIG_Python_Raise(swig::from(static_cast< std::pair<T,U > >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::pair<T,U > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::pair<T,U > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > *OUTPUT, std::pair<T,U > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::pair<T,U > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::pair<T,U > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U >}) std::pair<T,U > *OUTPUT, std::pair<T,U > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,240,%_ptr_inout_typemap@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::pair<T,U > *INOUT = std::pair<T,U > *INPUT;
 %typemap(in) std::pair<T,U > &INOUT = std::pair<T,U > &INPUT;
 %typemap(typecheck) std::pair<T,U > *INOUT = std::pair<T,U > *INPUT;
 %typemap(typecheck) std::pair<T,U > &INOUT = std::pair<T,U > &INPUT;
 %typemap(argout) std::pair<T,U > *INOUT = std::pair<T,U > *OUTPUT;
 %typemap(argout) std::pair<T,U > &INOUT = std::pair<T,U > &OUTPUT;
/*@SWIG@*/
 %typemap(typecheck) std::pair<T,U > *INOUT = std::pair<T,U > *INPUT;
 %typemap(typecheck) std::pair<T,U > &INOUT = std::pair<T,U > &INPUT;
 %typemap(freearg) std::pair<T,U > *INOUT = std::pair<T,U > *INPUT;
 %typemap(freearg) std::pair<T,U > &INOUT = std::pair<T,U > &INPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;




    pair();
    pair(T first, U second);
    pair(const pair& p);

    template <class U1, class U2> pair(const pair<U1, U2> &p);

    T first;
    U second;


    // Add swig/language extra methods
    /*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_pair.i,121,%swig_pair_methods@*/
%extend {      
%insert("python") {def __len__(self): return 2
def __repr__(self): return str((self.first, self.second))
def __getitem__(self, index): 
  if not (index % 2): 
    return self.first
  else:
    return self.second
def __setitem__(self, index, val):
  if not (index % 2): 
    self.first = val
  else:
    self.second = val}
}
/*@SWIG@*/

  };

  // ***
  // The following specializations should dissapear or get 
  // simplified when a 'const SWIGTYPE*&' can be defined
  // ***
  template <class T, class U > struct pair<T, U*> {      
    typedef T first_type;
    typedef U* second_type;
    
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {T},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<T > {
      typedef pointer_category category;
      static const char* type_name() { return"T"; }
    };
  }
}
/*@SWIG@*/;
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {U},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<U > {
      typedef pointer_category category;
      static const char* type_name() { return"U"; }
    };
  }
}
/*@SWIG@*/;
      
    %fragment("SWIG_" "Traits" "_" {std::pair<T,U* >}, "header",
	      fragment="SWIG_" "Traits" "_" {T},
	      fragment="SWIG_" "Traits" "_" {U},
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair<T,U* > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #T "," #U " * >";
	  }
	};
      }
    }

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,180,%typemap_traits_ptr@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,193,%typemaps_asptrfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,163,%typemaps_asptr@*/
  %fragment("SWIG_" "AsVal" "_" {std::pair<T,U* >},"header",fragment="SWIG_" "AsPtr" "_" {std::pair<T,U* >}) {
    SWIGINTERNINLINE int
    SWIG_AsVal_std_pair_Sl_T_Sc_U_Sm__Sg_ (PyObject * obj, std::pair<T,U* > *val)
    {
      std::pair<T,U* > *v = (std::pair<T,U* > *)0;
      int res = SWIG_AsPtr_std_pair_Sl_T_Sc_U_Sm__Sg_ (obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  delete v;
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,31,%ptr_in_typemap@*/
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > {
    std::pair<T,U* > *ptr = (std::pair<T,U* > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  %typemap(freearg) std::pair<T,U* > "";
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) const std::pair<T,U* > & (int res = SWIG_OLDOBJ) {
    std::pair<T,U* > *ptr = (std::pair<T,U* > *)0;
    res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res)) { SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    if (!ptr) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const std::pair<T,U* > &  {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,56,%ptr_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > {
    std::pair<T,U* > *ptr = (std::pair<T,U* > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in variable '""$name""' of type '""$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,71,%ptr_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > *DIRECTOROUT ($*ltype temp) {
    std::pair<T,U* > *swig_optr = 0;
    int swig_ores = $input ? swig::asptr($input, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    temp = *swig_optr;
    $result = &temp;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > {
    std::pair<T,U* > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::pair<T,U* >* {
    std::pair<T,U* > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::pair<T,U* >*
  {
    if (director)  {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::pair<T,U* >& {
    std::pair<T,U* > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    } else {
      if (!swig_optr) { 
	Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::pair<T,U* >&
  {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }


  %typemap(directorout,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > &DIRECTOROUT = std::pair<T,U* >

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,146,%ptr_typecheck_typemap@*/
%typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > * {
  int res = swig::asptr($input, (std::pair<T,U* >**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* >, const std::pair<T,U* >& {  
  int res = swig::asptr($input, (std::pair<T,U* >**)(0));
  $1 = SWIG_CheckState(res);
}
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,254,%ptr_input_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,117,%_ptr_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > *INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > &INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) { 
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }     
    if (!$1) { 
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") std::pair<T,U* > *INPUT, std::pair<T,U* > &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > *INPUT, std::pair<T,U* > &INPUT {
    int res = swig::asptr($input, (std::pair<T,U* >**)0);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* >, const std::pair<T,U* > {
    $result = swig::from(static_cast< std::pair<T,U* > >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) const std::pair<T,U* >& {
    $result = swig::from(static_cast< std::pair<T,U* > >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* >, const std::pair<T,U* >&  {
    $result = swig::from(static_cast< std::pair<T,U* > >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > {
    SWIG_Python_SetConstant(d, "$symname",swig::from(static_cast< std::pair<T,U* > >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > *DIRECTORIN {
    $input = swig::from(static_cast< std::pair<T,U* > >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* >, const std::pair<T,U* >& {
    $input = swig::from(static_cast< std::pair<T,U* > >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > {
    SWIG_Python_Raise(swig::from(static_cast< std::pair<T,U* > >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::pair<T,U* > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::pair<T,U* > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > *OUTPUT, std::pair<T,U* > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::pair<T,U* > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::pair<T,U* > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T,U* >}) std::pair<T,U* > *OUTPUT, std::pair<T,U* > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,240,%_ptr_inout_typemap@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::pair<T,U* > *INOUT = std::pair<T,U* > *INPUT;
 %typemap(in) std::pair<T,U* > &INOUT = std::pair<T,U* > &INPUT;
 %typemap(typecheck) std::pair<T,U* > *INOUT = std::pair<T,U* > *INPUT;
 %typemap(typecheck) std::pair<T,U* > &INOUT = std::pair<T,U* > &INPUT;
 %typemap(argout) std::pair<T,U* > *INOUT = std::pair<T,U* > *OUTPUT;
 %typemap(argout) std::pair<T,U* > &INOUT = std::pair<T,U* > &OUTPUT;
/*@SWIG@*/
 %typemap(typecheck) std::pair<T,U* > *INOUT = std::pair<T,U* > *INPUT;
 %typemap(typecheck) std::pair<T,U* > &INOUT = std::pair<T,U* > &INPUT;
 %typemap(freearg) std::pair<T,U* > *INOUT = std::pair<T,U* > *INPUT;
 %typemap(freearg) std::pair<T,U* > &INOUT = std::pair<T,U* > &INPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;

    pair();
    pair(T __a, U* __b);
    pair(const pair& __p);

    T first;
    U* second;


    // Add swig/language extra methods
    /*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_pair.i,121,%swig_pair_methods@*/
%extend {      
%insert("python") {def __len__(self): return 2
def __repr__(self): return str((self.first, self.second))
def __getitem__(self, index): 
  if not (index % 2): 
    return self.first
  else:
    return self.second
def __setitem__(self, index, val):
  if not (index % 2): 
    self.first = val
  else:
    self.second = val}
}
/*@SWIG@*/

  };

  template <class T, class U > struct pair<T*, U> {      
    typedef T* first_type;
    typedef U second_type;
    
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {T},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<T > {
      typedef pointer_category category;
      static const char* type_name() { return"T"; }
    };
  }
}
/*@SWIG@*/;
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {U},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<U > {
      typedef pointer_category category;
      static const char* type_name() { return"U"; }
    };
  }
}
/*@SWIG@*/;
      
    %fragment("SWIG_" "Traits" "_" {std::pair<T*,U >}, "header",
	      fragment="SWIG_" "Traits" "_" {T},
	      fragment="SWIG_" "Traits" "_" {U},
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair<T*,U > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #T " *," #U " >";
	  }
	};
      }
    }

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,180,%typemap_traits_ptr@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,193,%typemaps_asptrfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,163,%typemaps_asptr@*/
  %fragment("SWIG_" "AsVal" "_" {std::pair<T*,U >},"header",fragment="SWIG_" "AsPtr" "_" {std::pair<T*,U >}) {
    SWIGINTERNINLINE int
    SWIG_AsVal_std_pair_Sl_T_Sm__Sc_U_Sg_ (PyObject * obj, std::pair<T*,U > *val)
    {
      std::pair<T*,U > *v = (std::pair<T*,U > *)0;
      int res = SWIG_AsPtr_std_pair_Sl_T_Sm__Sc_U_Sg_ (obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  delete v;
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,31,%ptr_in_typemap@*/
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > {
    std::pair<T*,U > *ptr = (std::pair<T*,U > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  %typemap(freearg) std::pair<T*,U > "";
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) const std::pair<T*,U > & (int res = SWIG_OLDOBJ) {
    std::pair<T*,U > *ptr = (std::pair<T*,U > *)0;
    res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res)) { SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    if (!ptr) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const std::pair<T*,U > &  {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,56,%ptr_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > {
    std::pair<T*,U > *ptr = (std::pair<T*,U > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in variable '""$name""' of type '""$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,71,%ptr_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > *DIRECTOROUT ($*ltype temp) {
    std::pair<T*,U > *swig_optr = 0;
    int swig_ores = $input ? swig::asptr($input, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    temp = *swig_optr;
    $result = &temp;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > {
    std::pair<T*,U > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::pair<T*,U >* {
    std::pair<T*,U > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::pair<T*,U >*
  {
    if (director)  {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::pair<T*,U >& {
    std::pair<T*,U > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    } else {
      if (!swig_optr) { 
	Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::pair<T*,U >&
  {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }


  %typemap(directorout,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > &DIRECTOROUT = std::pair<T*,U >

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,146,%ptr_typecheck_typemap@*/
%typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > * {
  int res = swig::asptr($input, (std::pair<T*,U >**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U >, const std::pair<T*,U >& {  
  int res = swig::asptr($input, (std::pair<T*,U >**)(0));
  $1 = SWIG_CheckState(res);
}
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,254,%ptr_input_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,117,%_ptr_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > *INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > &INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) { 
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }     
    if (!$1) { 
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") std::pair<T*,U > *INPUT, std::pair<T*,U > &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > *INPUT, std::pair<T*,U > &INPUT {
    int res = swig::asptr($input, (std::pair<T*,U >**)0);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U >, const std::pair<T*,U > {
    $result = swig::from(static_cast< std::pair<T*,U > >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) const std::pair<T*,U >& {
    $result = swig::from(static_cast< std::pair<T*,U > >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U >, const std::pair<T*,U >&  {
    $result = swig::from(static_cast< std::pair<T*,U > >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > {
    SWIG_Python_SetConstant(d, "$symname",swig::from(static_cast< std::pair<T*,U > >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > *DIRECTORIN {
    $input = swig::from(static_cast< std::pair<T*,U > >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U >, const std::pair<T*,U >& {
    $input = swig::from(static_cast< std::pair<T*,U > >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > {
    SWIG_Python_Raise(swig::from(static_cast< std::pair<T*,U > >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::pair<T*,U > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::pair<T*,U > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > *OUTPUT, std::pair<T*,U > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::pair<T*,U > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::pair<T*,U > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U >}) std::pair<T*,U > *OUTPUT, std::pair<T*,U > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,240,%_ptr_inout_typemap@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::pair<T*,U > *INOUT = std::pair<T*,U > *INPUT;
 %typemap(in) std::pair<T*,U > &INOUT = std::pair<T*,U > &INPUT;
 %typemap(typecheck) std::pair<T*,U > *INOUT = std::pair<T*,U > *INPUT;
 %typemap(typecheck) std::pair<T*,U > &INOUT = std::pair<T*,U > &INPUT;
 %typemap(argout) std::pair<T*,U > *INOUT = std::pair<T*,U > *OUTPUT;
 %typemap(argout) std::pair<T*,U > &INOUT = std::pair<T*,U > &OUTPUT;
/*@SWIG@*/
 %typemap(typecheck) std::pair<T*,U > *INOUT = std::pair<T*,U > *INPUT;
 %typemap(typecheck) std::pair<T*,U > &INOUT = std::pair<T*,U > &INPUT;
 %typemap(freearg) std::pair<T*,U > *INOUT = std::pair<T*,U > *INPUT;
 %typemap(freearg) std::pair<T*,U > &INOUT = std::pair<T*,U > &INPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;

    pair();
    pair(T* __a, U __b);
    pair(const pair& __p);

    T* first;
    U second;


    // Add swig/language extra methods
    /*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_pair.i,121,%swig_pair_methods@*/
%extend {      
%insert("python") {def __len__(self): return 2
def __repr__(self): return str((self.first, self.second))
def __getitem__(self, index): 
  if not (index % 2): 
    return self.first
  else:
    return self.second
def __setitem__(self, index, val):
  if not (index % 2): 
    self.first = val
  else:
    self.second = val}
}
/*@SWIG@*/

  };

  template <class T, class U > struct pair<T*, U*> {
    typedef T* first_type;
    typedef U* second_type;

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {T},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<T > {
      typedef pointer_category category;
      static const char* type_name() { return"T"; }
    };
  }
}
/*@SWIG@*/;
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {U},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<U > {
      typedef pointer_category category;
      static const char* type_name() { return"U"; }
    };
  }
}
/*@SWIG@*/;
      
    %fragment("SWIG_" "Traits" "_" {std::pair<T*,U* >}, "header",
	      fragment="SWIG_" "Traits" "_" {T},
	      fragment="SWIG_" "Traits" "_" {U},
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair<T*,U* > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #T " *," #U " * >";
	  }
	};
      }
    }

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,166,%typemap_traits@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,198,%typemaps_asvalfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,172,%typemaps_asval@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > (std::pair<T*,U* > val, int ecode = 0) {
    ecode = swig::asval<std::pair<T*,U* > >($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) std::pair<T*,U* > "";
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) const std::pair<T*,U* > & ($*ltype temp, std::pair<T*,U* > val, int ecode = 0) {  
    ecode = swig::asval<std::pair<T*,U* > >($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const std::pair<T*,U* >& "";
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > {
    std::pair<T*,U* > val;
    int res = swig::asval<std::pair<T*,U* > >($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > *DIRECTOROUT {
    std::pair<T*,U* > swig_val;
    int swig_res = swig::asval<std::pair<T*,U* > >($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > {
    std::pair<T*,U* > swig_val;
    int swig_res = swig::asval<std::pair<T*,U* > >($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const std::pair<T*,U* >& {  
    std::pair<T*,U* > swig_val;
    int swig_res = swig::asval<std::pair<T*,U* > >($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const std::pair<T*,U* > & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > &DIRECTOROUT = std::pair<T*,U* >
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,162,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* >, const std::pair<T*,U* >& {
    int res = swig::asval<std::pair<T*,U* > >($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      std::pair<T*,U* > val; 
      int ecode = swig::asval<std::pair<T*,U* > >($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      std::pair<T*,U* > val;
      int ecode = swig::asval<std::pair<T*,U* > >($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") std::pair<T*,U* > *INPUT, std::pair<T*,U* > &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=150,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > *INPUT, std::pair<T*,U* > &INPUT {
    void *ptr = 0;
    int res = swig::asval<std::pair<T*,U* > >($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* >, const std::pair<T*,U* > {
    $result = swig::from(static_cast< std::pair<T*,U* > >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) const std::pair<T*,U* >& {
    $result = swig::from(static_cast< std::pair<T*,U* > >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* >, const std::pair<T*,U* >&  {
    $result = swig::from(static_cast< std::pair<T*,U* > >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > {
    SWIG_Python_SetConstant(d, "$symname",swig::from(static_cast< std::pair<T*,U* > >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > *DIRECTORIN {
    $input = swig::from(static_cast< std::pair<T*,U* > >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* >, const std::pair<T*,U* >& {
    $input = swig::from(static_cast< std::pair<T*,U* > >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > {
    SWIG_Python_Raise(swig::from(static_cast< std::pair<T*,U* > >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::pair<T*,U* > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::pair<T*,U* > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::pair<T*,U* >}) std::pair<T*,U* > *OUTPUT, std::pair<T*,U* > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::pair<T*,U* > *INOUT = std::pair<T*,U* > *INPUT;
 %typemap(in) std::pair<T*,U* > &INOUT = std::pair<T*,U* > &INPUT;
 %typemap(typecheck) std::pair<T*,U* > *INOUT = std::pair<T*,U* > *INPUT;
 %typemap(typecheck) std::pair<T*,U* > &INOUT = std::pair<T*,U* > &INPUT;
 %typemap(argout) std::pair<T*,U* > *INOUT = std::pair<T*,U* > *OUTPUT;
 %typemap(argout) std::pair<T*,U* > &INOUT = std::pair<T*,U* > &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;

    pair();
    pair(T* __a, U* __b);
    pair(const pair& __p);

    T* first;
    U* second;
 

    // Add swig/language extra methods
    /*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_pair.i,121,%swig_pair_methods@*/
%extend {      
%insert("python") {def __len__(self): return 2
def __repr__(self): return str((self.first, self.second))
def __getitem__(self, index): 
  if not (index % 2): 
    return self.first
  else:
    return self.second
def __setitem__(self, index, val):
  if not (index % 2): 
    self.first = val
  else:
    self.second = val}
}
/*@SWIG@*/

  };

}

]


]




























// ------------------------------------------------------------------------
// std::map
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::map<T>), f(const std::map<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::map<T> can be passed.
//   -- f(std::map<T>&), f(std::map<T>*):
//      the parameter may be modified; therefore, only a wrapped std::map
//      can be passed.
//   -- std::map<T> f(), const std::map<T>& f():
//      the map is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::map<T>& f(), std::map<T>* f():
//      the map is returned by reference; therefore, a wrapped std::map
//      is returned
//   -- const std::map<T>* f(), f(const std::map<T>*):
//      for consistency, they expect and return a plain map pointer.
// ------------------------------------------------------------------------

%{
#include <map>
#include <algorithm>
#include <stdexcept>
%}

// exported class

namespace std {

  template<class _Key, class _Tp, class _Compare = std::less<_Key >,
	   class _Alloc = allocator<std::pair<const _Key, _Tp > > >
  class map {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef std::pair<const _Key, _Tp> value_type;

    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {_Key},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<_Key > {
      typedef pointer_category category;
      static const char* type_name() { return"_Key"; }
    };
  }
}
/*@SWIG@*/;
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,149,%traits_swigtype@*/
%fragment("SWIG_" "Traits" "_" {_Tp},"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits<_Tp > {
      typedef pointer_category category;
      static const char* type_name() { return"_Tp"; }
    };
  }
}
/*@SWIG@*/;	    

    %fragment("SWIG_" "Traits" "_" {std::pair< _Key,_Tp >}, "header",
	      fragment="SWIG_" "Traits" "_" {_Key},
	      fragment="SWIG_" "Traits" "_" {_Tp},
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair< _Key, _Tp > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #_Key "," #_Tp " >";
	  }
	};
      }
    }

    %fragment("SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}, "header",
	      fragment="SWIG_" "Traits" "_" {std::pair<_Key,_Tp >},
	      fragment="StdMapTraits") {
      namespace swig {
	template <>  struct traits<std::map<_Key, _Tp, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" #_Key "," #_Tp "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_common.i,180,%typemap_traits_ptr@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,193,%typemaps_asptrfrom@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,163,%typemaps_asptr@*/
  %fragment("SWIG_" "AsVal" "_" {std::map<_Key,_Tp,_Compare,_Alloc >},"header",fragment="SWIG_" "AsPtr" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) {
    SWIGINTERNINLINE int
    SWIG_AsVal_std_map_Sl__Key_Sc__Tp_Sc__Compare_Sc__Alloc_Sg_ (PyObject * obj, std::map<_Key,_Tp,_Compare,_Alloc > *val)
    {
      std::map<_Key,_Tp,_Compare,_Alloc > *v = (std::map<_Key,_Tp,_Compare,_Alloc > *)0;
      int res = SWIG_AsPtr_std_map_Sl__Key_Sc__Tp_Sc__Compare_Sc__Alloc_Sg_ (obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  delete v;
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,31,%ptr_in_typemap@*/
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > {
    std::map<_Key,_Tp,_Compare,_Alloc > *ptr = (std::map<_Key,_Tp,_Compare,_Alloc > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  %typemap(freearg) std::map<_Key,_Tp,_Compare,_Alloc > "";
  %typemap(in,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) const std::map<_Key,_Tp,_Compare,_Alloc > & (int res = SWIG_OLDOBJ) {
    std::map<_Key,_Tp,_Compare,_Alloc > *ptr = (std::map<_Key,_Tp,_Compare,_Alloc > *)0;
    res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res)) { SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    if (!ptr) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const std::map<_Key,_Tp,_Compare,_Alloc > &  {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,56,%ptr_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > {
    std::map<_Key,_Tp,_Compare,_Alloc > *ptr = (std::map<_Key,_Tp,_Compare,_Alloc > *)0;
    int res = swig::asptr($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in variable '""$name""' of type '""$type""'"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,71,%ptr_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > *DIRECTOROUT ($*ltype temp) {
    std::map<_Key,_Tp,_Compare,_Alloc > *swig_optr = 0;
    int swig_ores = $input ? swig::asptr($input, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    temp = *swig_optr;
    $result = &temp;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > {
    std::map<_Key,_Tp,_Compare,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError((swig_optr ? swig_ores : SWIG_TypeError))), "in output value of type '""$type""'");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) delete swig_optr;
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::map<_Key,_Tp,_Compare,_Alloc >* {
    std::map<_Key,_Tp,_Compare,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::map<_Key,_Tp,_Compare,_Alloc >*
  {
    if (director)  {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >},warning= "473:Returning a pointer or reference in a director method is not recommended." ) std::map<_Key,_Tp,_Compare,_Alloc >& {
    std::map<_Key,_Tp,_Compare,_Alloc > *swig_optr = 0;
    int swig_ores = swig::asptr($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_ores)), "in output value of type '""$type""'");
    } else {
      if (!swig_optr) { 
	Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) std::map<_Key,_Tp,_Compare,_Alloc >&
  {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }


  %typemap(directorout,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > &DIRECTOROUT = std::map<_Key,_Tp,_Compare,_Alloc >

/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\ptrtypes.swg,146,%ptr_typecheck_typemap@*/
%typemap(typecheck,noblock=1,precedence=210,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > * {
  int res = swig::asptr($input, (std::map<_Key,_Tp,_Compare,_Alloc >**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=210,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc >, const std::map<_Key,_Tp,_Compare,_Alloc >& {  
  int res = swig::asptr($input, (std::map<_Key,_Tp,_Compare,_Alloc >**)(0));
  $1 = SWIG_CheckState(res);
}
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,254,%ptr_input_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,117,%_ptr_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > *INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > &INPUT(int res = 0) {  
    res = swig::asptr($input, &$1);
    if (!SWIG_IsOK(res)) { 
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }     
    if (!$1) { 
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") std::map<_Key,_Tp,_Compare,_Alloc > *INPUT, std::map<_Key,_Tp,_Compare,_Alloc > &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=210,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > *INPUT, std::map<_Key,_Tp,_Compare,_Alloc > &INPUT {
    int res = swig::asptr($input, (std::map<_Key,_Tp,_Compare,_Alloc >**)0);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,184,%typemaps_from@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc >, const std::map<_Key,_Tp,_Compare,_Alloc > {
    $result = swig::from(static_cast< std::map<_Key,_Tp,_Compare,_Alloc > >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) const std::map<_Key,_Tp,_Compare,_Alloc >& {
    $result = swig::from(static_cast< std::map<_Key,_Tp,_Compare,_Alloc > >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc >, const std::map<_Key,_Tp,_Compare,_Alloc >&  {
    $result = swig::from(static_cast< std::map<_Key,_Tp,_Compare,_Alloc > >($1));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > {
    SWIG_Python_SetConstant(d, "$symname",swig::from(static_cast< std::map<_Key,_Tp,_Compare,_Alloc > >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > *DIRECTORIN {
    $input = swig::from(static_cast< std::map<_Key,_Tp,_Compare,_Alloc > >(*$1_name)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc >, const std::map<_Key,_Tp,_Compare,_Alloc >& {
    $input = swig::from(static_cast< std::map<_Key,_Tp,_Compare,_Alloc > >($1_name)); 
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\valtypes.swg,154,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > {
    SWIG_Python_Raise(swig::from(static_cast< std::map<_Key,_Tp,_Compare,_Alloc > >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::map<_Key,_Tp,_Compare,_Alloc > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::map<_Key,_Tp,_Compare,_Alloc > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > *OUTPUT, std::map<_Key,_Tp,_Compare,_Alloc > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::map<_Key,_Tp,_Compare,_Alloc > *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::map<_Key,_Tp,_Compare,_Alloc > &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "Traits" "_" {std::map<_Key,_Tp,_Compare,_Alloc >}) std::map<_Key,_Tp,_Compare,_Alloc > *OUTPUT, std::map<_Key,_Tp,_Compare,_Alloc > &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, swig::from((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,240,%_ptr_inout_typemap@*/
 /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::map<_Key,_Tp,_Compare,_Alloc > *INOUT = std::map<_Key,_Tp,_Compare,_Alloc > *INPUT;
 %typemap(in) std::map<_Key,_Tp,_Compare,_Alloc > &INOUT = std::map<_Key,_Tp,_Compare,_Alloc > &INPUT;
 %typemap(typecheck) std::map<_Key,_Tp,_Compare,_Alloc > *INOUT = std::map<_Key,_Tp,_Compare,_Alloc > *INPUT;
 %typemap(typecheck) std::map<_Key,_Tp,_Compare,_Alloc > &INOUT = std::map<_Key,_Tp,_Compare,_Alloc > &INPUT;
 %typemap(argout) std::map<_Key,_Tp,_Compare,_Alloc > *INOUT = std::map<_Key,_Tp,_Compare,_Alloc > *OUTPUT;
 %typemap(argout) std::map<_Key,_Tp,_Compare,_Alloc > &INOUT = std::map<_Key,_Tp,_Compare,_Alloc > &OUTPUT;
/*@SWIG@*/
 %typemap(typecheck) std::map<_Key,_Tp,_Compare,_Alloc > *INOUT = std::map<_Key,_Tp,_Compare,_Alloc > *INPUT;
 %typemap(typecheck) std::map<_Key,_Tp,_Compare,_Alloc > &INOUT = std::map<_Key,_Tp,_Compare,_Alloc > &INPUT;
 %typemap(freearg) std::map<_Key,_Tp,_Compare,_Alloc > *INOUT = std::map<_Key,_Tp,_Compare,_Alloc > *INPUT;
 %typemap(freearg) std::map<_Key,_Tp,_Compare,_Alloc > &INOUT = std::map<_Key,_Tp,_Compare,_Alloc > &INPUT;
/*@SWIG@*/;
/*@SWIG@*/;
/*@SWIG@*/;

    map( const _Compare& );


    // Add swig/language extra methods
    /*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_map.i,241,%swig_map_methods@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\std_map.i,139,%swig_map_common@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,529,%swig_sequence_iterator@*/

  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    $result = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1)),
				 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
  }
  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    std::pair<iterator, iterator>, std::pair<const_iterator, const_iterator> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).first),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));
    PyTuple_SetItem($result,1,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).second),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
  }

  %fragment("SwigPyPairBoolOutputIterator","header",fragment="SWIG_" "From" "_" {bool},fragment="SwigPySequence_Cont") {}

  %typemap(out,noblock=1,fragment="SwigPyPairBoolOutputIterator")
    std::pair<iterator, bool>, std::pair<const_iterator, bool> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const $type & >($1).first),
					       swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
    PyTuple_SetItem($result,1,SWIG_From_bool  (static_cast< const $type & >($1).second));
  }

  %typemap(in,noblock=1,fragment="SwigPySequence_Cont")
    iterator(swig::SwigPyIterator *iter = 0, int res),
    reverse_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_reverse_iterator(swig::SwigPyIterator *iter = 0, int res) {
    res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    if (!SWIG_IsOK(res) || !iter) {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
    } else {
      swig::SwigPyIterator_T<$type > *iter_t = dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter);
      if (iter_t) {
	$1 = iter_t->get_current();
      } else {
	SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
      }
    }
  }

   %typemap(typecheck, precedence=     5     ,noblock=1,fragment="SwigPySequence_Cont") 
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    swig::SwigPyIterator *iter = 0;
    int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    $1 = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter) != 0));
  }

  %fragment("SwigPySequence_Cont");

  %feature("new") iterator(PyObject **PYTHON_SELF);
  %extend  {
    swig::SwigPyIterator* iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %insert("python") {def __iter__(self): return self.iterator()}
  }


/*@SWIG@*/;
  /*@SWIG:C:\\Programme\\swig\\Lib\\python\\pycontainer.swg,602,%swig_container_methods@*/

  %feature("new") __getslice__;

  %extend {
    bool __nonzero__() const {
      return !(self->empty());
    }

    /* Alias for Python 3 compatibility */
    bool __bool__() const {
      return !(self->empty());
    }

    size_type __len__() const {
      return self->size();
    }
  }
/*@SWIG@*/

  %extend {
    mapped_type __getitem__(const key_type& key) const throw (std::out_of_range) {
      std::map<_Key,_Tp,_Compare,_Alloc >::const_iterator i = self->find(key);
      if (i != self->end())
	return i->second;
      else
	throw std::out_of_range("key not found");
    }
    
    void __delitem__(const key_type& key) throw (std::out_of_range) {
      std::map<_Key,_Tp,_Compare,_Alloc >::iterator i = self->find(key);
      if (i != self->end())
	self->erase(i);
      else
	throw std::out_of_range("key not found");
    }
    
    bool has_key(const key_type& key) const {
      std::map<_Key,_Tp,_Compare,_Alloc >::const_iterator i = self->find(key);
      return i != self->end();
    }
    
    PyObject* keys() {
      std::map<_Key,_Tp,_Compare,_Alloc >::size_type size = self->size();
      int pysize = (size <= (std::map<_Key,_Tp,_Compare,_Alloc >::size_type) INT_MAX) ? (int) size : -1;
      if (pysize < 0) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	PyErr_SetString(PyExc_OverflowError,
			"map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }
      PyObject* keyList = PyList_New(pysize);
      std::map<_Key,_Tp,_Compare,_Alloc >::const_iterator i = self->begin();
      for (int j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(keyList, j, swig::from(i->first));
      }
      return keyList;
    }
    
    PyObject* values() {
      std::map<_Key,_Tp,_Compare,_Alloc >::size_type size = self->size();
      int pysize = (size <= (std::map<_Key,_Tp,_Compare,_Alloc >::size_type) INT_MAX) ? (int) size : -1;
      if (pysize < 0) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	PyErr_SetString(PyExc_OverflowError,
			"map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }
      PyObject* valList = PyList_New(pysize);
      std::map<_Key,_Tp,_Compare,_Alloc >::const_iterator i = self->begin();
      for (int j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(valList, j, swig::from(i->second));
      }
      return valList;
    }
    
    PyObject* items() {
      std::map<_Key,_Tp,_Compare,_Alloc >::size_type size = self->size();
      int pysize = (size <= (std::map<_Key,_Tp,_Compare,_Alloc >::size_type) INT_MAX) ? (int) size : -1;
      if (pysize < 0) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	PyErr_SetString(PyExc_OverflowError,
			"map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }    
      PyObject* itemList = PyList_New(pysize);
      std::map<_Key,_Tp,_Compare,_Alloc >::const_iterator i = self->begin();
      for (int j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(itemList, j, swig::from(*i));
      }
      return itemList;
    }
    
    // Python 2.2 methods
    bool __contains__(const key_type& key) {
      return self->find(key) != self->end();
    }

    %feature("new") key_iterator(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* key_iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_key_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %feature("new") value_iterator(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* value_iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_value_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %insert("python") {def __iter__(self): return self.key_iterator()}    
    %insert("python") {def iterkeys(self): return self.key_iterator()}
    %insert("python") {def itervalues(self): return self.value_iterator()}
    %insert("python") {def iteritems(self): return self.iterator()}
  }
/*@SWIG@*/
  %extend {
    void __setitem__(const key_type& key, const mapped_type& x) throw (std::out_of_range) {
      (*self)[key] = x;
    }
  }
/*@SWIG@*/;

  
    /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_map.i,25,%std_map_methods@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_map.i,8,%std_map_methods_common@*/
  /*@SWIG:C:\\Programme\\swig\\Lib\\std\\std_container.i,11,%std_container_methods@*/
  map();
  map(const map&);

  bool empty() const;
  size_type size() const;
  void clear();

  void swap(map& v);

  allocator_type get_allocator() const;


  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  const_iterator begin() const;
  const_iterator end() const;
  const_reverse_iterator rbegin() const;
  const_reverse_iterator rend() const;


/*@SWIG@*/;

  size_type erase(const key_type& x);
  size_type count(const key_type& x) const;


//  iterator insert(iterator position, const value_type& x);
  void erase(iterator position);
  void erase(iterator first, iterator last);

  iterator find(const key_type& x);
  iterator lower_bound(const key_type& x);
  iterator upper_bound(const key_type& x);

/*@SWIG@*/;


//  iterator insert(const value_type& x);

/*@SWIG@*/;
  };

}

]

]



]

// enable exception support

%feature("except") {
    try {
        $action
    } 
    /*@SWIG:C:\\Programme\\swig\\Lib\\typemaps\\exception.swg,61,SWIG_CATCH_STDEXCEPT@*/  /* catching std::exception  */
  catch (std::invalid_argument& e) {
    SWIG_exception_fail(SWIG_ValueError, e.what() );
  } catch (std::domain_error& e) {
    SWIG_exception_fail(SWIG_ValueError, e.what() );
  } catch (std::overflow_error& e) {
    SWIG_exception_fail(SWIG_OverflowError, e.what() );
  } catch (std::out_of_range& e) {
    SWIG_exception_fail(SWIG_IndexError, e.what() );
  } catch (std::length_error& e) {
    SWIG_exception_fail(SWIG_IndexError, e.what() );
  } catch (std::runtime_error& e) {
    SWIG_exception_fail(SWIG_RuntimeError, e.what() );
  } catch (std::exception& e) {
    SWIG_exception_fail(SWIG_SystemError, e.what() );
  }
/*@SWIG@*/
}


// Start my Module
%module cmf
%includefile "Geometry\\geometry.i" [
%{
// Include geometry
#include "geometry/geometry.h"
#include "geometry/Raster.h"
%}

// Geometry.h
%includefile "geometry\\geometry.h" [










namespace cmf {
	/// Contains geometric features like point (=location) and raster datasets
	namespace geometry	{

		const double PI=3.141592654;
		class point;
		typedef std::vector<cmf::geometry::point> Points;
		
		class shape
		{
		public:
			virtual Points Vertices() const=0;
			virtual point Center() const=0;
			/// Returns the OGC well known text representation of the shape as defined in
			/// OpenGIS Implementation Specification for Geographic information - Simple feature access - Part 1: Common architecture
			/// http://www.opengeospatial.org/standards/is
			virtual std::string AsWKT() const=0;
		};

		/// 2D-Point Class.
		///
		/// Used as location property anywhere in the text 
		/// - Calculation of distances
		/// - +,-,-=,*= Operators overloaded
		class point : public shape
		{
		private:
			static const double& max(const double& a,const double& b) {return (a>b)?a:b;}
			public:
				double x; ///< East-value of the location in m.
				double y; ///< North-value of the location in m.
				double z; ///< Height of the location in m.a.s.l.
				point Center() const { return *this;}
				///Empty Constructor. Creates an (0 0) location
				point(); 
				///Copy Constructor
				point(const point& p);
				///Creates a point from two doubles
				point(double x_,double y_,double z_=0.0);
				///Returns the euclidian distance to another point.
				/// \f$\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}\f$
				double distanceTo(point p) const { 
					return sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));
				}
				double distance3DTo(point p) const {
					return sqrt(((x-p.x)*(x-p.x))+((y-p.y)*(y-p.y))+((z-p.z)*(z-p.z)));
				}
				static double distance(point p1,point p2) {
					return sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y));
				}
				///Returns the distance by the maximum orthogonal offset
				double distance_max(point p) const {
					return max(fabs(x-p.x),fabs(y-p.y));
				}
				///Returns the azimuth angle of the line \f$ \overline{this,p} \f$ to the Azimuth in degrees
				double azimuth(point p) const {
					double _azimuth=atan2(p.x-x,p.y-y)*180/PI;	
					return _azimuth<0 ? 360+_azimuth : _azimuth;						
				}
				///Returns the angle between the line \f$ \overline{this,p} \f$ to the x-Axis in degrees
				double angleToXAxis(point p) const {
					return atan2(p.y-y,p.x-x)*180/PI;						
				}
				std::string AsWKT() const;
				Points Vertices() const	{ 
					Points p;
					p.push_back(*this);
					return p;}
				size_t Vertex() const { return 1;}



				point operator+(const point &p) const; 
				point operator-(const point &p) const;
				point operator*(double left) const { return point(x*left,y*left);}
				point operator/(double left) const { return point(x/left,y/left);}
				point operator+=(const point &p);
				point operator-=(const point &p);
				bool operator ==(const point &p) const;
				bool operator !=(const point &p) const {return !(*this == p);}
		};

		/// Holds the corner coordinates of a bounding box
		class BoundingBox : public shape
		{
		public:
			double
				xmin, ///< x coordinate of lower left corner
				ymin,	///< y coordinate of lower left corner
				xmax, ///< x coordinate of upper right corner
				ymax; ///< y coordinate of upper right corner
			/// returns the center of the bounding box (z=0)
			point Center() const { return point((xmin+xmax)/2,(ymin+ymax)/2); }
			/// Returns true if the point p is inside the bounding box
			bool Includes(point p) const {return (p.x>=xmin && p.y>=ymin && p.x < xmax && p.y < ymax); }
			/// Returns true, if the bounding box is empty
			bool isempty() const {return xmin==0 && ymin==0 && xmax==0 && ymax==0 ;}
			/// Makes the bounding box empty
			void makeempty() {xmin=0;xmax=0;ymin=0;ymax=0;}
			/// Extends the BoundingBox to include the given point
			void extend(point p)
			{
				if (this->isempty())
				{
					xmin=p.x;
					xmax=p.x;
					ymin=p.y;
					ymax=p.y;
				}
				else
				{
					xmin=p.x<xmin?p.x:xmin;
					xmax=p.x>xmax?p.x:xmax;
					ymin=p.y<ymin?p.y:ymin;
					ymax=p.y>ymax?p.y:ymax;
				}
			}
			/// Extends the bounding box to contain the given Boundingbox although
			void extend(const BoundingBox& bbox)
			{
				 if (isempty())
				 {
					 xmin=bbox.xmin;xmax=bbox.xmax;ymin=bbox.ymin;ymax=bbox.ymax;
				 }
				 else
				 {
					 xmin=bbox.xmin<xmin?bbox.xmin:xmin;
					 xmax=bbox.xmax>xmax?bbox.xmax:xmax;
					 ymin=bbox.ymin<ymin?bbox.ymin:ymin;
					 ymax=bbox.ymax>ymax?bbox.ymax:ymax;
				 }
			}
			std::string AsWKT() const {return "";}
			/// Creates an empty bounding box
			BoundingBox() : xmin(0),xmax(0),ymin(0),ymax(0) {}
			/// Creates a bounding box between to coordinates
			BoundingBox(double X1,double Y1,double X2, double Y2) : xmin(X1<X2?X1:X2),ymin(Y1<Y2?Y1:Y2),xmax(X1>X2?X1:X2),ymax(Y1>Y2?Y1:Y2) {}
			/// Creates a bounding box between to coordinates
			BoundingBox(point p1,point p2) : xmin(p1.x<p2.x?p1.x:p2.x),ymin(p1.y<p2.y?p1.y:p2.y),xmax(p1.x>p2.x?p1.x:p2.x),ymax(p1.y>p2.y?p1.y:p2.y) {}
			/// Copies the bounding box
			BoundingBox(const BoundingBox & copy) : xmin(copy.xmin),ymin(copy.ymin),xmax(copy.xmax),ymax(copy.ymax) {}
			BoundingBox(double* bbox) : xmin(bbox[0]),ymin(bbox[1]),xmax(bbox[2]),ymax(bbox[3]) {}
			Points Vertices() const {
				Points p;
				p.push_back(point(xmin,ymin));
				p.push_back(point(xmax,ymax));
				return p;
			}

		};
		class Line;
		class MultiPoint : public shape
		{
		private:
		protected:
			Points m_points;
			BoundingBox bbox;
		public:
			/// Adds a point to the shape
			void AddPoint(point p)
			{
				m_points.push_back(p);
				bbox.makeempty();
			}
			void AddPoint(double x,double y,double z=0)
			{
				AddPoint(point(x,y,z));
			}
			void RemovePoint(int pos)
			{
				m_points.erase(m_points.begin()+pos);
				bbox.makeempty();
			}
			int size() const {return int(m_points.size());}
			point Vertex(int i) const
			{
				int ndx=i<0 ? ndx=int(size())+i : i;
				return m_points.at(ndx);
			}
			Points Vertices() const {return m_points;}
			point Center() const
			{
				point res;
				for(std::vector<point>::const_iterator it = m_points.begin(); it != m_points.end(); ++it)
				    res+=*it / size();
				return res;
			}
			/// Returns the longest straight line between two vertices of the shape
			Line MaxStraight() const;
			std::string AsWKT() const;
			BoundingBox boundingbox()
			{
				if (bbox.isempty() && size())
				{
					bbox=BoundingBox(m_points[0],m_points[0]);
					for(std::vector<point>::const_iterator it = m_points.begin(); it != m_points.end(); ++it)
						bbox.extend(*it);
				}
				return bbox;
			}












			MultiPoint() {}
			MultiPoint(const MultiPoint & copy) : m_points(copy.m_points) {}
			MultiPoint(const Points & copy) : m_points(copy) {}
 		};
		class Line : public MultiPoint
		{
		public:
			/// returns the point in the middle of the line
			point Center() const; 
			/// returns the point in the distance d from the start point on the line
			point PointOnLine(double d) const;
			double Length() const;
			/// returns the Well-Known-Text of aline with the vertices of this vector
			std::string AsWKT() const;

		};
		class Ring : public MultiPoint
		{
			friend class Polygon;
			double SignedArea() const;
		public:
			/// returns the Well-Known-Text of a polygon with the vertices of this ring
			std::string AsWKT() const;
			/// returns the Area of a polygon defined by the points
			double Area() const;
			/// returns the centroid of a polygon defined by the points
			point Center() const; 
			/// returns true if p lies in the polygon defined by the points
			///
			/// Algorithm by W. Randolph Franklin, http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
			bool Includes(point p) const;

			/// returns true if p lies in the polygon defined by the points, and creates the bounding box if needed
			///
			/// Algorithm by W. Randolph Franklin, http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
			bool Includes(point p);
			/// Returns true if all vertices of mp are lying in the ring
			bool Ring::Includes(const shape& shp ) const;
			bool Ring::Includes(const shape& shp );
			/// Returns the shared boundary of two rings
			Line SharedBoundary(const Ring & with,double tolerance=0.1) const;

			Ring() {}
			Ring(const cmf::geometry::Ring & copy) : MultiPoint(copy) {}
			Ring(const cmf::geometry::BoundingBox & bbox) : MultiPoint(bbox.Vertices()) {}
			Ring(const cmf::geometry::Line & copy) : MultiPoint(copy) {}
		};
		typedef std::vector<cmf::geometry::Ring> Rings;
		typedef std::vector<cmf::geometry::Line> Lines;
		typedef std::vector<cmf::geometry::MultiPoint> MultiPoints;

		class PolyLine : public shape
		{
		private:
			Lines m_parts;
		public:
			double Length() const
			{
				double l=0;
				for(Lines::const_iterator it = m_parts.begin(); it != m_parts.end(); ++it)
					l+=it->Length();				    
				return l;
			}
			point Center() const
			{
				double l=0,lastl=0,c_l=Length()/2;
				for(Lines::const_iterator it = m_parts.begin(); it != m_parts.end(); ++it)
				{
					lastl=l;
					l+=it->Length();
					if (l>c_l)
						return it->PointOnLine(c_l-lastl);
				}
				return m_parts[m_parts.size()][-1];
			}
			size_t size() const
			{
				return m_parts.size();
			}
			cmf::geometry::Line& AddPart(const cmf::geometry::Line & part)
			{
				m_parts.push_back(part);
				return m_parts.back();
			}
			cmf::geometry::Line& AddPart()
			{
				m_parts.push_back(Line());
				return m_parts.back();
			}
			cmf::geometry::BoundingBox boundingbox()
			{
				BoundingBox res;
				for(Lines::iterator it = m_parts.begin(); it != m_parts.end(); ++it)
					res.extend(it->boundingbox());
				return res;
			}
			cmf::geometry::PolyLine straight_parts()	const
			{
				PolyLine res;
				for(Lines::const_iterator it = m_parts.begin(); it != m_parts.end(); ++it)
				    res.AddPart(it->MaxStraight());
				return res;
			}
			PolyLine()	{}
			PolyLine(const PolyLine & copy)
			{
				for (size_t i = 0; i < copy.size() ; ++i)
				{
					m_parts.push_back(copy[int(i)]);
				}
			}
			PolyLine(const Line & copy)
			{
				m_parts.push_back(copy);
			}
			cmf::geometry::Points Vertices()	const
			{
				Points p;
				for(Lines::const_iterator it = m_parts.begin(); it != m_parts.end(); ++it)
				{
				  Points v=it->Vertices();
					p.insert(p.end(),v.begin(),v.end());  
				}
				return p;
			}
			std::string AsWKT() const;












		};
		class Polygon : public shape
		{
		private:
			Rings m_parts;
		public:
			double Area() const
			{
				double a=0;
				for(Rings::const_iterator it = m_parts.begin(); it != m_parts.end(); ++it)
				{
						a+=it->SignedArea();
				}
				return abs(a);
			}
			cmf::geometry::point Center() const
			{
				point res;double a=0;double p_a;
				for(Rings::const_iterator it = m_parts.begin(); it != m_parts.end(); ++it)
				{
					p_a=it->Area();
					a+=p_a;
					res+=it->Center()*p_a;
				}
				return res/a;
			}
			size_t size() const
			{
				return m_parts.size();
			}
			cmf::geometry::Ring& AddPart(const cmf::geometry::Ring & part)
			{
				m_parts.push_back(part);
				return m_parts.back();
			}
			cmf::geometry::Ring& AddPart()
			{
				m_parts.push_back(Ring());
				return m_parts.back();
			}
			cmf::geometry::BoundingBox boundingbox()
			{
				BoundingBox res;
				for(Rings::iterator it = m_parts.begin(); it != m_parts.end(); ++it)
					res.extend(it->boundingbox());
				return res;
			}
			Polygon()	{}
			Polygon(const Polygon & copy)
			{
				for (size_t i = 0; i < copy.size() ; ++i)
				{
					m_parts.push_back(copy[int(i)]);
				}
			}
			Polygon(const cmf::geometry::Ring & copy)
			{
				m_parts.push_back(copy);
			}
			Polygon(const cmf::geometry::BoundingBox & copy)
			{
				m_parts.push_back(copy);
			}
			std::string AsWKT() const;












			bool Includes(cmf::geometry::point p) const;

			/// returns true if p lies in the polygon defined by the points, and creates the bounding box if needed
			///
			/// Algorithm by W. Randolph Franklin, http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
			bool Includes(cmf::geometry::point p);
			/// Returns true if all vertices of mp are lying in the ring
			bool Includes(const cmf::geometry::shape& shp) const;
			bool Includes(const cmf::geometry::shape& shp);
			Points Vertices()	const
			{
				Points p;
				for(Rings::const_iterator it = m_parts.begin(); it != m_parts.end(); ++it)
				{
					Points v=it->Vertices();
					p.insert(p.end(),v.begin(),v.end());  
				}
				return p;
			}

		};


		typedef std::vector<cmf::geometry::PolyLine> PolyLines;
		typedef std::vector<cmf::geometry::Polygon> Polygons;
	}
}






]
%extend cmf::geometry::point {
    inline int __len__() const { return 3; }

    %insert("python") 
    {
    def __getitem__(self,index) :
        if index==0 :
            return self.x
        elif index==1 :
            return self.y
        elif index==2 :
            return self.z
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __setitem__(self,index,value) :
        if index==0 :
            self.x=value
        elif index==1 :
            self.y=value
        elif index==2 :
            self.z=value
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
	}
}
%extend cmf::geometry::MultiPoint {
	inline size_t __len__() const { return $self->size();}
	inline cmf::geometry::point& __getitem__(int index)
	{
		return (*$self)[index];
	}
}
%extend cmf::geometry::Line {
	inline size_t __len__() const { return $self->size();}
	inline cmf::geometry::point& __getitem__(int index) 
	{
		return (*$self)[index];
	}
}
%extend cmf::geometry::Ring {
	inline size_t __len__() const { return $self->size();}
	inline cmf::geometry::point& __getitem__(int index)
	{
		return (*$self)[index];
	}
	%insert("python")
	{
    def __contains___(self,p):
        return self.Includes(p)
	}	
}
%extend cmf::geometry::PolyLine {
	inline size_t __len__() const { return $self->size();}
	inline cmf::geometry::Line& __getitem__(int index)
	{
		return (*$self)[index];
	}
}
%extend cmf::geometry::Polygon {
	inline size_t __len__() const { return $self->size();}
	inline cmf::geometry::Ring& __getitem__(int index)
	{
		return (*$self)[index];
	}
	%insert("python")
	{
    def __contains___(self,p):
        return self.Includes(p)
	}	
}
%template(Rings) std::vector<cmf::geometry::Ring>;
%template(Lines) std::vector<cmf::geometry::Line>;
%template(Points) std::vector<cmf::geometry::point>;
%template(MultiPoints) std::vector<cmf::geometry::MultiPoint>;
%template(PolyLines) std::vector<cmf::geometry::PolyLine>;
%template(Polygons) std::vector<cmf::geometry::Polygon>;


// Raster.h
 
%feature("nodefaultctor","1") cmf::geometry::Raster;
%feature("new") cmf::geometry::Raster::ToInt();
%feature("new") cmf::geometry::Raster::ToDouble();
%feature("new") cmf::geometry::Raster::ToFloat();

%includefile "geometry\\Raster.h" [














namespace cmf { 
	namespace geometry
	{
		/// Holds the statistics for a raster
		struct RasterStatistics
		{			
			double 
				min, ///< Minimum value in raster
				max, ///< Maximum value in raster
				mean,///< Mean value in raster
				stdev; /// Standard deviation of raster
			int count; /// Count of cells with data
			RasterStatistics() : min(0),max(0),mean(0),stdev(0),count(0) {}
// 			RasterStatistics(const RasterStatistics& rs) : min(rs.min),max(rs.max),mean(rs.mean),stdev(rs.stdev),count(rs.count) {}
// 			RasterStatistics& operator=(const RasterStatistics& rs)
// 			{
// 				min=rs.min;max=rs.max;mean=rs.mean;stdev=rs.stdev;count=rs.count;
// 			}
		};
		/// Holds the histogram for a raster
		class Histogram
		{
		private:
			double m_width,m_min;
			int count;
			std::vector<int> m_frequency;
		public:
			/// Returns the left side of the first histogram bar
			double min() const  { return m_min;}
			/// Returns the right side of the last histogram bar
			double max()  const { return m_min+m_width*m_frequency.size();}
			/// Returns the width of the histogram bars
			double barwidth() const { return m_width;} 
			/// Returns the number of the historam bars
			int size() const   { return int(m_frequency.size());}
			/// Returns the number of entries with a value <= until, default is the total number of entries
			int sum(double until=1e308)	const
			{
				if (until>max()) return count;
				int s=0,p=pos(until);
				for (int i = 0; i < size() && i<p ; ++i)
					s+=frequency(i);
				return s;
			}
			/// Returns the frequency of values near val
			int frequency(double val) const
			{
				int p=pos(val);
				if (p>=0 && p<size())
					return m_frequency[p];
				else
					return 0.0;
			}
			/// Returns the relative frequency of values near val
			double relfrequency(double val) const
			{
				return double(frequency(val))/double(sum());
			}
			/// Returns the frequency of bar number pos
			int frequency(int pos) const
			{
				return m_frequency.at(pos);
			}
			/// Returns the relative frequency of bar number pos
			double relfrequency(int pos) const
			{
				return double(frequency(pos))/double(sum());
			}
			/// Returns the bar number, that contains value val
			int pos(double val) const { 
				if (val>max()) return size();
				else if (val<min()) return -1;
				else return int((val-m_min)/m_width);
			}
			/// Returns the center of the bar at position pos
			double barcenter(double pos) const {
				return (pos+0.5)*m_width+m_min;
			}
			
			/// Returns the inexact quantile. The result gets better with higher numbers of bars
			/// Assumes the values of each bar uniformly distributed
			double quantile(double Quantile=0.5) const
			{
				int
					// Number of items in quantile
					max_count = int(count*Quantile+0.5),
					// Item counter
					cnt=0,
					// bar counter
					i=0,
					// item counter for (i-1)
					lastcnt=0;
				// If Quantile > 1 return max()
				if (max_count>=count) return max();
				// If Quantile < 0 return min()
				else if (max_count<=0) return min();
				else
				{
					while (cnt<max_count)
					{
						lastcnt=cnt;
						cnt+=m_frequency[i++];
					}
					if (frequency(i))
						return (i-1)*m_width+m_min + double(max_count-lastcnt)/double(frequency(i))*m_width;
					else
						while (!frequency(i))
							--i;
						return i*m_width+m_min;

				}
			}
			/// Counts a value in the histogram
			void CountValue(double val)
			{
				int p=pos(val);
				p=p<0 ? 0 : p>=size() ? size()-1 : p;
				++m_frequency[p];
				++count;
			}
			/// Creates a histogram with bars ranging from _min to _max with a width of width
			Histogram(double _min,double _max, double _width) : m_min(_min),m_width(_width),m_frequency(size_t((_max-_min)/_width),0),count(0) {}
			/// Creates a histogram with count bars ranging from _min to _max
			Histogram(double _min,double _max, size_t _count) : m_min(_min),m_width((_max-_min)/_count),m_frequency(_count,0),count(0) {}


		};

		///Represents a raster dataset.
		template<class rasterType> 
		class Raster
		{
			RasterStatistics m_statistic;
			bool m_statistic_actual;





















































































		public:
			/// @name Metadata
			//@{
			///x-Coordinate for the Lower Left corner (in cellsize units)
			double Xllcorner() const {return m_Header.xllcorner;}
			///y-Coordinate for the Lower Left corner (in cellsize units)
			double Yllcorner() const {return m_Header.yllcorner;}
			///Cellsize of the raster
			double XCellsize() const {return m_Header.Xcellsize;}
			///Cellsize of the raster
			double YCellsize() const {return m_Header.Ycellsize;}
			///Number of columns in the raster
			int    ColumnCount() const {return m_Header.ncols;}
			///Number of rows in the raster
			int    RowCount() const {return m_Header.nrows;}
			///Extent W-E in cellsize units
			double Width() const {return m_Header.ncols*m_Header.Xcellsize;}
			///Extent N-S in cellsize units
			double Height() const {return m_Header.nrows*m_Header.Ycellsize;}
			///Returns rasterType (NoData)
			rasterType NoData() const { return m_Header.NoData; }
			/// Returns the bounding box of the raster
			BoundingBox GetBounds() const
			{
				return BoundingBox(Xllcorner(),Yllcorner(),Xllcorner()+Width(),Yllcorner()+Height());
			}
			//@}
			/// @name Data access
			//@{
			///Returns the value of the raster at the given position.
			rasterType IdentifyXY(double x, double y) const {
				return this->IdentifyColRow(
					(int)((x-m_Header.xllcorner)/m_Header.Xcellsize),
					m_Header.nrows-(int)((y-m_Header.yllcorner)/m_Header.Ycellsize)-1
					);}

			///Returns the value of the raster at the given cell.
			rasterType IdentifyRowCol(int row, int col) const
			{
				return IdentifyColRow(col,row);
			}
			///Returns the value of the raster at the given cell.
			rasterType IdentifyColRow(int col, int row) const
			{
				if (HasData(col,row))
					return m_data[col+m_Header.ncols*row];
				else 
					return m_Header.NoData;
			}
			///Returns true if there is data at the given position			
			bool HasData(double x,double y) const {
				return HasData(
					(int)((x-m_Header.xllcorner)/m_Header.Xcellsize),
					m_Header.nrows-(int)((y-m_Header.yllcorner)/m_Header.Ycellsize)-1);
			}

			///Returns true if there is data at the given position
			bool HasData(int col, int row) const {
				return	(
					col>=0 && col<m_Header.ncols && 
					row>=0 && row<m_Header.nrows && 
					m_data[col+m_Header.ncols*row]!=m_Header.NoData
					);
			}
			///Sets a value at the given position
			/// @param x X-coordinate
			/// @param y Y-coordinate
			/// @param val Value to set at (x,y)
			void SetData(double x,double y,rasterType val)
			{
				SetData((int)((x-m_Header.xllcorner)/m_Header.Xcellsize),
					m_Header.nrows-(int)((y-m_Header.yllcorner)/m_Header.Ycellsize)-1,
					val);
			}
			///Sets a value at the given position
			/// @param col Column of the raster
			/// @param row Row of the raster
			/// @param val Value to set at (col,row)
			void SetData(int col,int row, rasterType val)
			{
				if (col>=0 && col<m_Header.ncols && row>=0 && row<m_Header.nrows)
				{
					m_data[col+m_Header.ncols*row]=val;
					m_statistic_actual=false;
				}
			}
			//@}

			/// Returns the real world x position of a column
			double GetXPosition(int col)			{
				return (col+0.5)*m_Header.Xcellsize+m_Header.xllcorner;			}
			/// Returns the real world y position of a row
			double GetYPosition(int row)			{
				return (m_Header.nrows-row-0.5)*m_Header.Ycellsize+m_Header.yllcorner;			}
			/// @name Analysis
			//@{
			/// Creates statistics for the raster
			RasterStatistics statistics()
			{
				if (m_statistic_actual) return m_statistic;
				m_statistic=RasterStatistics();
				m_statistic.min=double(NoData());
				m_statistic.max=double(NoData());
				for (int r = 0; r < m_Header.nrows ; r++)
					for (int c = 0; c < m_Header.ncols ; c++)
					{
						if (this->HasData(c,r))
						{
							rasterType val=IdentifyColRow(c,r);
							m_statistic.min=m_statistic.min==double(NoData()) || val<m_statistic.min ?  double(val) : m_statistic.min;
							m_statistic.max=m_statistic.max==double(NoData()) || val>m_statistic.max ?  double(val) : m_statistic.max;
							m_statistic.mean+=val;
							m_statistic.stdev+=val*val;				
							++m_statistic.count;
						}	
					}
				m_statistic.mean/=m_statistic.count;
				m_statistic.stdev=sqrt(m_statistic.stdev/m_statistic.count - m_statistic.mean*m_statistic.mean);
				return m_statistic;
			}
			Histogram histogram(size_t bins=100) 
			{
				RasterStatistics stat=statistics();
				Histogram hist(stat.min,stat.max,bins);
				for (int r = 0; r < m_Header.nrows ; r++)
					for (int c = 0; c < m_Header.ncols ; c++)
						if (this->HasData(c,r))
							hist.CountValue(this->IdentifyColRow(c,r));
				return hist;
			}
			//@}
			/// @name Operators
			//@{
			/// Mulitplies all the values with a scalar
			Raster<rasterType>& operator*=(rasterType scalar)
			{
				
				for (int r = 0; r < m_Header.nrows ; r++)
					for (int c = 0; c < m_Header.ncols ; c++)
					{
						if (HasData(c,r))
							m_data[r*m_Header.ncols+c]*=scalar;
					}
					return *this;
			}
			/// Multiplies all the values with the value at the same location in the given raster
			Raster<rasterType>& operator*=(const Raster<rasterType>& raster)
			{

				for (int r = 0; r < m_Header.nrows ; r++)
					for (int c = 0; c < m_Header.ncols ; c++)
					{
						double 
							x=GetXPosition(c),
							y=GetYPosition(r);
						if (HasData(c,r) && raster.HasData(x,y))
							m_data[r*m_Header.ncols+c]*=raster.IdentifyXY(x,y);
						else
							m_data[r*m_Header.ncols+c]=this->NoData();
					}
				return *this;
			}
			/// Add to all the values a scalar
			Raster<rasterType>& operator+=(rasterType scalar)
			{

				for (int r = 0; r < m_Header.nrows ; r++)
					for (int c = 0; c < m_Header.ncols ; c++)
					{

						if (HasData(c,r))
							m_data[r*m_Header.ncols+c]+=scalar;
					}
					return *this;
			}
			/// Add to all the values the value at the same location in the given raster
			Raster<rasterType>& operator+=(const Raster<rasterType>& raster)
			{

				for (int r = 0; r < m_Header.nrows ; r++)
					for (int c = 0; c < m_Header.ncols ; c++)
					{
						double 
							x=GetXPosition(c),
							y=GetYPosition(r);
						if (HasData(c,r) && raster.HasData(x,y))
							m_data[r*m_Header.ncols+c]+=raster.IdentifyXY(x,y);
						else
							m_data[r*m_Header.ncols+c]=NoData();
					}
					return *this;
			}
			/// Subtract from all the values a scalar
			Raster<rasterType>& operator-=(rasterType scalar)
			{

				for (int r = 0; r < m_Header.nrows ; r++)
					for (int c = 0; c < m_Header.ncols ; c++)
					{

						if (HasData(c,r))
							m_data[r*m_Header.ncols+c]-=scalar;
					}
					return *this;
			}
			/// Subtract from all the values the value at the same location in the given raster
			Raster<rasterType>& operator-=(const Raster<rasterType>& raster)
			{

				for (int r = 0; r < m_Header.nrows ; r++)
					for (int c = 0; c < m_Header.ncols ; c++)
					{
						double 
							x=GetXPosition(c),
							y=GetYPosition(r);
						if (HasData(c,r) && raster.HasData(x,y))
							m_data[r*m_Header.ncols+c]-=raster.IdentifyXY(x,y);
						else
							m_data[r*m_Header.ncols+c]=NoData();

					}
					return *this;
			}

			//@}

			/// @name Constructors & IO-Methods
			//@{
			///Creates an empty Raster dataset	
			Raster(int ncols,int nrows, double xllcorner, double yllcorner, double xcellsize,double ycellsize, rasterType nodata,rasterType initialValue=0)
				: m_Header(ncols,nrows,xllcorner,yllcorner,xcellsize,ycellsize,nodata),
				m_data(ncols*nrows,nodata),
				m_statistic_actual(false),m_statistic()
			{	}
			/// Copy constructor
			Raster(const Raster<rasterType>& R) 
				: 
			m_Header(R.ColumnCount(),R.RowCount(),R.Xllcorner(),R.Yllcorner(),R.XCellsize(),R.YCellsize(),R.NoData()),
				m_data(R.m_data),m_statistic_actual(false),m_statistic()
			{ }
			/// Copy constructor, creates an empty raster dataset with the same spatial properties like the input raster
			Raster(const Raster<rasterType>& R,rasterType FixedValue) 
				: 
			m_Header(R.ColumnCount(),R.RowCount(),R.Xllcorner(),R.Yllcorner(),R.XCellsize(),R.YCellsize(),R.NoData()),
				m_data(R.ColumnCount()*R.RowCount(),FixedValue),m_statistic_actual(false)
			{			}
			///Builds a new Rasterdataset and passes the ownership of the dataset to the Raster. No external reference to the dataset should be used.
			/// Loads an ESRI ASCII-raster data set
			Raster(const std::string& FileName) : m_statistic_actual(false),m_statistic()
			{
				std::ifstream ASCFile;
				try
				{
					ASCFile.open(FileName.c_str());
					if (!ASCFile) throw std::runtime_error("Raster file: " + FileName + " not found");
				}
				catch (...)
				{
					ASCFile.close();
					throw std::runtime_error("Could not read Raster file: " + FileName);
				}
				m_Header=header<rasterType>(ASCFile);
				LoadFromASC(ASCFile);
				ASCFile.close();
			}

			/// Loads an ESRI ASCII-raster data set
			Raster(std::istream& ASCFile) : m_statistic_actual(false),m_statistic()
			{
				m_Header=header<rasterType>(ASCFile);
				LoadFromASC(ASCFile);
			}
			/// Writes the raster to a stream in ESRI-ASC format
			void WriteToASCFile(std::ostream& ASCFile)
			{
				m_Header.WriteToStream(ASCFile);
				data::iterator reader=m_data.begin();
				for (int row=0;row<this->m_Header.nrows;row++)
				{
					for (int col=0;col<this->m_Header.ncols;col++)
						ASCFile << *reader++ << " ";
					ASCFile << std::endl;
				}
			}
			/// Writes the raster to a filename
			void WriteToASCFile(std::string filename)
			{
				std::ofstream file;
				try
				{
					file.open(filename.c_str());
					if (!file) throw std::ofstream::failure("Raster file: " + filename + " could not be created");
				}
				catch (...)
				{
					file.close();
					throw std::ofstream::failure("Raster file: " + filename + " could not be created");
				}
				WriteToASCFile(file);
				file.close();
			}
			/// Writes the data to the file with the given file name and the header to a filename with the extension .hdr
			/// @note If the filename has the extension .flt and the raster is a float raster the saved file can be read by ArcGIS
			void WriteToBinary(std::string filename) const
			{
				size_t dotpos=filename.find_last_of('.');
				std::string hdrfilename=filename.substr(0,dotpos) + ".hdr";
				std::ofstream hdrfile;
				try
				{
					hdrfile.open(hdrfilename.c_str());
					if (!hdrfile) throw std::ofstream::failure("Raster file: " + hdrfilename + " could not be created");
				}
				catch (...)
				{
					hdrfile.close();
					throw std::ofstream::failure("Raster file: " + hdrfilename + " could not be created");
				}
				m_Header.WriteToStream(hdrfile);
				hdrfile << "BYTEORDER MSBFIRST" << std::endl;
				hdrfile.close();
				std::ofstream binfile;
				binfile.open(filename.c_str(),std::ios_base::binary || std::ios_base::out);
				for(data::const_iterator it = m_data.begin(); it != m_data.end(); ++it)
				{
				    binfile.write((const char*)&(*it),sizeof(rasterType));
				}
				binfile.close();
			}


















			//@}

			///@name Conversion functions
			//@{
			/// Converts the raster to a raster of int
			Raster<int> ToInt() const
			{
				Raster<int> result(ColumnCount(),RowCount(),Xllcorner(),Yllcorner(),XCellsize(),YCellsize(),int(NoData()),0);

				for (int r = 0; r < (int)RowCount() ; ++r)
					for (int c = 0; c < ColumnCount() ; ++c)
						result.SetData(c,r,int(IdentifyColRow(c,r)));
				return result;
			}		

			/// Converts the raster to a raster of float (32bit)
			Raster<float> ToFloat()
			{
				Raster<float> result(ColumnCount(),RowCount(),Xllcorner(),Yllcorner(),XCellsize(),YCellsize(),float(NoData()),0);

				for (int r = 0; r < (int)RowCount() ; ++r)
					for (int c = 0; c < ColumnCount() ; ++c)
						result.SetData(c,r,float(IdentifyColRow(c,r)));
				return result;
			}
			/// Converts the raster to a raster of float (64bit)
			Raster<double> ToDouble()
			{
				Raster<double> result(ColumnCount(),RowCount(),Xllcorner(),Yllcorner(),XCellsize(),YCellsize(),double(NoData()),0);

				for (int r = 0; r < (int)RowCount() ; ++r)
					for (int c = 0; c < ColumnCount() ; ++c)
							result.SetData(c,r,double(IdentifyColRow(c,r)));
				return result;
			}
	
			//@}

			/// @name Focal functions
			//@{
		private:














































































































































		public:
			/// Creates a raster, which contains for each cell the minimum of the surrounding n x n window
			Raster<rasterType> focal_min(int n=3)
			{
				Raster<rasterType> result(*this,rasterType(0));
				focal(result,2,n);
				return result;
			}
			/// Creates a raster, which contains for each cell the maximum of the surrounding n x n window
			Raster<rasterType> focal_max(int n=3)
			{
				Raster<rasterType> result(*this,rasterType(0));
				focal(result,3,n);
				return result;
			}
			/// Creates a raster, which contains for each cell the mean of the surrounding n x n window
			Raster<rasterType> focal_mean(int n=3)
			{
				Raster<rasterType> result(*this,rasterType(0));
				focal(result,1,n);
				return result;
			}
			/// Creates a raster, which contains for each cell the standard deviation of the surrounding n x n window
			Raster<rasterType> focal_stdev(int n=3)
			{
				Raster<rasterType> result(*this,rasterType(0));
				focal(result,5,n);
				return result;
			}
			/// Creates a raster, which contains for each cell the majority value of the surrounding n x n window (usually only used for integer raster)
			Raster<rasterType> focal_majority(int n=3)
			{
				Raster<rasterType> result(*this,rasterType(0));
				focal(result,4,n);
				return result;
			}
			/// Creates a raster, which contains for each cell the difference between the actual value and the mean of the surrounding n x n window (usually only used for integer raster)
			/// This function can be used to identify very important points (VIP)	for triangulation
			Raster<rasterType> focal_mean_difference(int n=3)
			{
				Raster<rasterType> result(*this,rasterType(0));
				focal(result,6,n);
				return result;
			}
			//@}


			int __len__()
			{
				return this->ColumnCount()*this->RowCount();
			}
			rasterType __getitem__(int index)
			{
				int ndx=index < 0 ? this->ColumnCount()*this->RowCount() + index : index;
				if (ndx<0 || ndx>=this->ColumnCount() * this->RowCount())
				{
					throw std::out_of_range("Index must be between 0 and row*col");
				}
				int col=ndx % this->ColumnCount();
				int row=ndx / this->ColumnCount();
				return this->IdentifyColRow(col,row);
			}
		};
	}
}








]


%template(DoubleRaster) cmf::geometry::Raster<double>;
%template(IntRaster) cmf::geometry::Raster<int>;
%template(SingleRaster) cmf::geometry::Raster<float>;
%extend cmf::geometry::Histogram
{
	%insert("python")
	{
    def __getitem__(self,index):
        if index<0 : index=self.size()+index
        if index<0 or index>=self.size() : raise IndexError("Bar of histogram not available")
        return (self.barcenter(index),self.frequency(index))
    def __len__(self):
        return self.size()
	}
}




]
%includefile "math\\math.i" [
%{
#include "math/Time.h"
#include "math/timeseries.h"
#include "math/numVector.h"
#include "math/StateVariable.h"
#include "math/Integrator.h"
#include "math/Integrators/BDF2.h"
#include "math/Integrators/ExplicitEuler_fixed.h"
#include "math/Integrators/ExplicitEuler_variable.h"
#include "math/Integrators/FixpointImplicitEuler.h"
#include "math/Integrators/RKFIntegrator.h"
#include "math/Integrators/Gears_Fixpoint.h"
#include "math/Integrators/cvodeIntegrator.h"
%}
// Get Math
%insert("python")
{
import datetime
}

%includefile "math\\Time.h" [







%constant JULIANDAY_0_1_1900 = 2415019;
namespace cmf {
	namespace math {
		struct Date;
		/// A time class, used to pass around current modelling times
		///
		///	<p>
		///		Timespans and dates in cmf are used with a special object, called Time. The advantage
		///		of an extra class has the advantage, that the user does not has to rememember, which
		///		unit of time he or she uses or what time unit is accepted by a specific function
		///		of the model. Arithmetic and boolean operators are supported by Time. Internally
		///		the time classes stores the time as integer milliseconds, therefore rounding issues
		///		will only appear at very small time ranges. Absolute time (like dates) are represented
		///		as milliseconds gone by from Dec, 31st 1899. Microsoft Excel dates are represented
		///		as days from that time, using floating point numbers, therefore it is very simple
		///		to convert Excel time representations to cmf time.
		///	</p>
		///	<p>
		///		Another object is Date, which is doesn't provide the operators, but has a nice printed
		///		version and some special date functions, like day of year (DOY) and provides access
		///		to the current hour of day and so on, which only applyto dates and not to time spans.
		///		You can convert Time to Date an vice versa. The printing is not culture aware and
		///		uses the European representation. If you use the Python standard library datetime,
		///		conversion between Python time and cmf time is possible</p>
		///	<h2>
		///		Creating absolute time values (dates)</h2>
		///	<div class="fragment">
		///		<pre class="fragment">import CMFlib as cmf
		///# Create the time: Jan, 5th 2001, 2:30 pm, 20s, 412 ms
		///t=cmf.Time(5,1,2001,14,30,20,412)
		///print t # Prints: '36896d:14:30:20.412h'
		///print t.AsDate() # Prints: '05.01.2001 14:30:20.412'
		///</pre>
		///	</div>
		///	<h2>
		///		Creating time spans</h2>
		///	<p>
		///		In principle, there are three ways to create time spans. One is to use one of the
		///		static functions, another is to multiply an existing time span (like one of the
		///		build in constants) or to substrate two absolute times.
		///	</p>
		///	<h3>
		///		Available static functions, the default value is always 1</h3>
		///	<ul>
		///		<li>Milliseconds(): <code>t=cmf.Time.Milliseconds(4100)</code>, create a timespan
		///			of 4.1 seconds</li>
		///		<li>Seconds(): <code>t=cmf.Time.Seconds(4.1)</code>, create a timespan of 4.1 seconds</li>
		///		<li>Minutes(): <code>t=cmf.Time.Minutes(138)</code>, create a timespan of 2.3 hours
		///			(138 min)</li>
		///		<li>Hours():<code>t=cmf.Time.Hours(2.3)</code>, create a timespan of 2.3 hours (138
		///			min)</li>
		///		<li>Days():<code>t=cmf.Time.Days(2.5)</code>, create a timespan of 60 hours</li>
		///		<li>Years():<code>t=cmf.Time.Years()</code>, create a timespan of 365 days</li>
		///	</ul>
		///	<h3>
		///		Available constants</h3>
		///	<ul>
		///		<li><code>cmf.sec * 4.1</code>: 4.1 seconds</li>
		///		<li><code>cmf.min * 138</code>: 2.3 hours (138 min)</li>
		///		<li><code>cmf.h * 2.3</code>: 2.3 hours (138 min)</li>
		///		<li><code>cmf.day * 2.5</code>: 60 hours (2.5 days)</li>
		///		<li><code>cmf.week </code>: 7 days</li>
		///		<li><code>cmf.month</code>: 365/12 days (30.4167 days)</li>
		///		<li><code>cmf.year</code>: 365 days</li>
		///	</ul>
		///	<h3>
		///		Available operators:</h3>
		///	<ul>
		///		<li>time + time = time, time - time = time</li>
		///		<li>time * float = time ,time / float = time</li>
		///		<li>time/time=float</li>
		///		<li>&gt, &lt, ==, !=</li>
		///	</ul>
		///	<h2>
		///		Conversions</h2>
		///	<h3>
		///		Converting to python datetime</h3>
		///	<div class="fragment">
		///		<pre class="fragment">
		///import CMFlib as cmf
		///pythontime = cmf.year.AsPython()
		///cmftime=cmf.AsCMFTime(pythontime)
		///print type(pythontime) # '&lt;type 'datetime.datetime'&gt;'
		///print type(cmftime)    # '&lt;class 'CMFLib.Time'&gt;'
		///</pre>
		///	</div>
		///	<h3>
		///		Converting to numbers</h3>
		///	<ul>
		///		<li>t.AsMilliseconds()</li>
		///		<li>t.AsSeconds()</li>
		///		<li>t.AsMinutes()</li>
		///		<li>t.AsHours()</li>
		///		<li>t.AsDays()</li>
		///		<li>t.AsYears()</li>
		///	</ul>
		///	<h2>
		///		Creating time ranges</h2>
		///	<div class="fragment">
		///		<pre class="fragment">
		///import CMFLib as cmf
		///start=cmf.Time(5,1,2001)
		///end=cmf.Time(6,1,2001)
		///step=cmf.h * 6
		///for t in cmf.timerange(start,end,step):
		///    print t.AsDate()
		///# Prints:
		///# 05.01.2001
		///# 05.01.2001 06:00
		///# 05.01.2001 12:00
		///# 05.01.2001 18:00
		///</pre>
		///	</div>
		class Time
		{
		private:
			long long m_time_in_ms;
			Time(long long ms):m_time_in_ms(ms) {}
		public:
			static const long long ms_per_day=86400000;
			/// @name Constructors
			//@{
			/// Conversion constructor
			Time(double days):m_time_in_ms((long long)(days*ms_per_day)) {}
			/// Construction from date and stores the time as Excel-Time (0 = 31.12.1899 0:00:00)
			Time(int day,int month,int year=2001,int hour=0,int minute=0,int second=0,int ms=0);
			/// Conversion constructor
			Time(Date date);
			/// Copy constructor
			Time(const Time& t):m_time_in_ms(t.AsMilliseconds()) {}
			/// Standard constructor
			Time():m_time_in_ms(0) {}
			//@}
			/// @name Time unit conversion
			//@{
			/// Time in days
			double AsDays() const {return m_time_in_ms/((double)ms_per_day);} 
			/// Time in hours
			double AsHours() const {return m_time_in_ms/3600000.0;}
			/// Time in minutes
			double AsMinutes() const {return m_time_in_ms/60000.0;}
			/// Time in seconds
			double AsSeconds() const {return m_time_in_ms/1000.0;}
			/// Time in milliseconds
			long long AsMilliseconds() const {return m_time_in_ms;}
			Date AsDate() const;
			std::string ToString(char seperator=':');
			//@}


			/// @name Arithmetic operators
			//@{
			/// Time = Time + Time
			Time operator+(const Time& t1) const	{return Time(m_time_in_ms+t1.AsMilliseconds());} 
			/// Time = Time - Time
			Time operator-(const Time& t1) const	{return Time(m_time_in_ms-t1.AsMilliseconds());}
			/// Time += Time
			Time operator+=(const Time& t1)				{m_time_in_ms+=t1.AsMilliseconds(); return *this;}
			/// Time -= Time
			Time operator-=(const Time& t1)				{m_time_in_ms-=t1.AsMilliseconds(); return *this;}
			/// Time = Time * double
			Time operator*(double x) const				{return Time((long long)(m_time_in_ms*x));}
			/// Time = Time / double
			Time operator/(double x) const				{return Time((long long)(m_time_in_ms/x));}
			/// Time *= double
			Time operator*=(double x)							{m_time_in_ms= long long(m_time_in_ms * x); return *this;}
			/// Time /= double
			Time operator/=(double x)							{m_time_in_ms= long long(m_time_in_ms / x); return *this;}
			/// Time = Time * int
			Time operator*(int x) const           {return Time((long long)(m_time_in_ms*x));}
			/// Time = Time / int
			Time operator/(int x) const           {return Time((long long)(m_time_in_ms/x));}
			/// Time *= int
			Time operator*=(int x)						  	{m_time_in_ms*= x; return *this;}
			/// Time /= int
			Time operator/=(int x)						  	{m_time_in_ms/= x; return *this;}
			/// double = Time / Time
			double operator/(const Time& t1) const  {return ((double)m_time_in_ms)/((double)t1.AsMilliseconds());}
			//@}
			/// @name Boolean Operators
			//@{
			/// bool = Time < Time
			bool operator<(const Time& t1) const	{return m_time_in_ms < t1.AsMilliseconds();}
			/// bool = Time > Time
			bool operator>(const Time& t1) const	{return m_time_in_ms > t1.AsMilliseconds();}
			/// bool = Time <= Time
			bool operator<=(const Time& t1) const	{return m_time_in_ms <= t1.AsMilliseconds();}
			/// bool = Time >= Time
			bool operator>=(const Time& t1)	const	{return m_time_in_ms >= t1.AsMilliseconds();}
			/// bool = Time == Time
			bool operator==(const Time& t1)	const	{return m_time_in_ms==t1.AsMilliseconds();}
			/// bool = Time != Time
			bool operator!=(const Time& t1)	const	{return m_time_in_ms!=t1.AsMilliseconds();}
			//@}

			/// Returns the beginning of the next day
			Time NextDay() const {return Time(floor(this->AsDays())+1);}
			/// Returns the next full hour
			Time NextFullHour() const {return Time((floor(this->AsHours())+1)/24.0);}
			
			/// Creates a time representing y years
			static Time Years(double y=1) {return Time((long long)(y*365*24*60*60*1000));}
			/// Creates a time representing y days
			static Time Days(double d=1) {return Time((long long)(d*24*60*60*1000));}
			/// Creates a time representing h hours
			static Time Hours(double h=1) {return Time((long long)(h*60*60*1000));}
			/// Creates a time representing min minutes
			static Time Minutes(double min=1) {return Time((long long)(min*60*1000));}
			/// Creates a time representing secs seconds
			static Time Seconds(double secs=1) {return Time((long long)(secs*1000));}
			/// Creates a time representing ms milliseconds
			static Time Milliseconds(long long ms=1) {return Time(ms);}
		};
		Time operator*(double f,Time t);
		Time operator*(int f,Time t);


		/// An absolute time, not for calculation. Date and Time are interchangable 
		struct Date
		{
			int year;  ///<Year
			int month; ///<Month
			int day;   ///<Day of Month
			int hour;  ///<Hour of day
			int minute;///<Minute of hour
			int second;///<Second of minute
			int ms;    ///< millisecond of second

			/// Creates a new date
			Date(int _day,int _month,int _year=2001,int _hour=0,int _minute=0,int _second=0,int _ms=0):
			day(_day),month(_month),year(_year),hour(_hour),minute(_minute),second(_second),ms(_ms)
			{	}

			/// Creates a new date from time (based on the 31.12.1899, like in Excel(TM))
			Date(const Time& time)
			{
				Date tdate=time.AsDate();
				day=tdate.day;
				month=tdate.month;
				year=tdate.year;
				hour=tdate.hour;
				minute=tdate.minute;
				second=tdate.second;
				ms=tdate.ms;
			}

			/// Converts a date to Time (based on the 31.12.1899, like in Excel(TM)
			Time ToTime()
			{
				return Time(*this);
			}
			/// Returns the day of year
			int DOY()
			{
				Time Jan1(1,1,year);
				return int((ToTime() - Jan1).AsMilliseconds() / Time::ms_per_day);
			}

			/// Returns a string representing the date
			std::string ToString();
		};
		const Time ms=Time::Milliseconds();   ///< 1 milli second
		const Time sec=Time::Seconds();       ///< 1 second
		const Time min=Time::Minutes();	      ///< 1 minute
		const Time h=Time::Hours();           ///< 1 hour
		const Time day=Time::Days();		      ///< 1 day
		const Time week=Time::Days(7);	      ///< 1 week
		const Time month=Time::Days(365/12.0);///< 1 month = 30*day+10*h
		const Time year=Time::Years();				///< 1 year  = 365*day
	}
}





%extend cmf::math::Time {
	std::string __str__() {
		return $self->ToString();
	}
	%insert("python") 
	{
    def AsPython(self):
        d=self.AsDate()
        return datetime.datetime(d.year,d.month,d.day,d.hour,d.minute,d.second,d.ms*1000)
	}
}
%extend cmf::math::Date {
	std::string __str__() {return $self->ToString();}
	%insert("python") 
	{
    def AsPython(self):
        return datetime.datetime(self.year,self.month,self.day,self.hour,self.minute,self.second,self.ms*1000)
	}
}





]
%includefile "math\\timeseries.h" [





namespace cmf {
	namespace math {
		///	A timeseries is a list of values, equally distributed over time. To create one,
		///	one have to provide as start date and a step size. The end time is calculated from
		///	the number of values. Values queried for times before the start time are returned
		///	as the first item, values after the end time equal the last item. A timeseries with
		///	only one item reacts like a scalar value.
		///	<h3>
		///		Creating a time series</h3>
		///	<div class="fragment">
		///		<pre class="fragment">
		///import CMFLib as cmf
		///# Start date is the January 5th 2001 at 2:30 pm
		///start=cmf.Time(5,1,2001,14,30)                      
		///# time step of the timeseries is 20 minutes
		///step=cmf.min*20
		///# Type of interpolation between values
		///# 0 - Nearest neighbor,
		///# 1 - Linear,
		///# 2 - Squared,
		///# 3 - Cubic, etc.
		///interpolation=1                                     
		///# Create timeseries
		///timeseries=cmf.timeseries(start,step,interpolation) 
		///# Add data
		///timeseries.Add(0.1) # Value at 2001/5/1 2:30pm is 0.1
		///timeseries.Add(0.2) # Value at 2001/5/1 2:50pm is 0.2
		///timeseries.Add(0.1) # Value at 2001/5/1 3:10pm is 0.1	</pre>
		///	</div>
		///	<p>
		///		With this technic it is simple to read files or databases to fill timeseries.</p>
		///	<h3>
		///		Using a timeseries</h3>
		///	<div class="fragment">
		///		<pre class="fragment">
		///# Query every minute between 2:15 and 3:14 pm
		///for t in cmf.timerange(start,start+cmf.h,cmf.min):
		///    print "Time:",t.AsDate(),"Value:",timeseries[t]
		///# Query a specific position of the timeseries
		///print timeseries[2]</pre>
		///	</div>
		class timeseries
		{
		private:
			std::vector<double> m_Values;
			double position(cmf::math::Time t) const;
			double interpolate(cmf::math::Time t,double n) const;
			/// Order of the interpolation
		protected:
		public:
			/// First date of measurement
			cmf::math::Time begin;
			/// Time between the measurements
			cmf::math::Time step;
			/// Last date of measurements
			cmf::math::Time end()	const		{return begin+step*int(m_Values.size());}
			/// Method for the interpolation (0 - Nearest neighbor, 1- linear, 2 - cubic spline (not implemented yet)
			double interpolationpower;
			/// Appends a measurement
			void Add(double Value)
			{
				m_Values.push_back(Value);
			}
			/// returns true if no values are added to the timeseries
			bool isempty() const {return m_Values.size()==0;}
			void clear()
			{
				m_Values.clear();
			}

			int size() const {return int(m_Values.size());}
			/// Constructor of a time series
			/// @param _begin First date of measurement
			/// @param _step Time between measurements
			/// @param _interpolationmethod Method for the interpolation (0 - Nearest neighbor, 1- linear, 2 - cubic spline (not implemented yet)
			timeseries(cmf::math::Time _begin,cmf::math::Time _step,int _interpolationmethod=0) 
				: begin(_begin),step(_step),interpolationpower(_interpolationmethod) {}
			timeseries(cmf::math::Time _begin,cmf::math::Time _step,int size,int _interpolationmethod) 
				: begin(_begin),step(_step),interpolationpower(_interpolationmethod),m_Values(size,0) {}
			timeseries() : begin(),step(),interpolationpower(0) {}
			timeseries( const cmf::math::timeseries& ts ) : begin(ts.begin),step(ts.step),interpolationpower(ts.interpolationpower),m_Values(ts.m_Values)
			{	}















			/// @name Operators
			/// Binary operators defined as free operators:
			///
			/// x = {+,-,*,/}
			///
			/// Defined for (x is one of the operators above):
			/// - timeseries = timeseries x timeseries 
			/// - timeseries = double x timeseries
			/// - timeseries = timeseries x double
			//@{
			timeseries& operator+=(const timeseries&);      ///< Add timeseries to this
			timeseries& operator+=(double);                ///< Add scalar to this
			timeseries& operator-=(const timeseries&);      ///< Subtract timeseries from this
			timeseries& operator-=(double);                ///< Subtract scalar from this
			timeseries& operator*=(const timeseries&);      ///< Multiply each element of timeseries with each element of this
			timeseries& operator*=(double);                ///< Multiply each element of timeseries with scalar
			timeseries& operator/=(const timeseries&);      ///< Divide each element of this by each element of timeseries
			timeseries& operator/=(double);                ///< Divide each element of this by scalar
			timeseries& power(double);											 ///< raises the timeseries to a power

			timeseries reduce_min(cmf::math::Time begin,cmf::math::Time step) const; /// Creates a timeseries with a bigger timestep, containing the minimum
			timeseries reduce_max(cmf::math::Time begin,cmf::math::Time step) const; /// Creates a timeseries with a bigger timestep, containing the maximum
			timeseries reduce_sum(cmf::math::Time begin,cmf::math::Time step) const; /// Creates a timeseries with a bigger timestep, containing the sum
			timeseries reduce_avg(cmf::math::Time begin,cmf::math::Time step) const; /// Creates a timeseries with a bigger timestep, containing the average

			//@}
			/// @name I/O
			//@{
			/// Save the Meteorology data to an ASCII File with fixed format
			void Save(std::ostream& file);
			/// Creates a Meterology from a File in fixed format
			/// @code
			/// begin <year> <month> <day> <hour> <minute> <second> <millisecond>
			/// step <year> <month> <day> <hour> <minute> <second> <millisecond>
			/// size <size>	 interpolationpower <interpolationpower>
			/// values <val1> <val2> ...
			/// @endcode
			explicit timeseries(std::istream& file);
			//@}
		};


	}
}

	%extend cmf::math::timeseries
	{
		double __size__()
		{
			return $self->size();
		}
		double __getitem__(cmf::math::Time t)
		{
			return (*$self)[t];
		}
		double __getitem__(int i)
		{
			return (*$self)[i];
		}
		void __setitem__(int i,double value)
		{
			 (*$self)[i]=value;
		}
		%insert("python")
    {
        def AddList(list) :
            """ Adds the values of a list to the timeseries"""
            for item in list :
                self.Add(float(item))
    }
	}




]
%includefile "math\\numVector.h" [




 namespace cmf {
 	namespace math {
		/// A valarray kind of vector implementation with OpenMP capabilities
		class numVector
		{
		private:
			real* m_data;
			int m_size;
		public:
			/// @name Constructors & Destructors
			// @{
			/// Creates a new vector with size count
			/// @param count size of new vector
			/// @param Value Value of each element (default=0)
			numVector(int count,real Value=0);
			numVector(size_t count,real Value=0);
			/// Creates a vector of size 1 with value {0}
			numVector();
			/// Copy constructor
			numVector(const numVector& Vector);




			/// Destructor
			~numVector();
			//@}






			/// Size of the vector
			int size() const { return m_size;}
			/// Changes the size of the vector
			void resize(int count);
			void resize(size_t count) {resize(int(count));}






			/// @name Operators
			/// Binary operators defined as free operators:
			///
			/// x = {+,-,*,/}
			///
			/// Defined for (x is one of the operators above):
			/// - vector = vector x vector 
			/// - vector = real x vector
			/// - vector = vector x real
			//@{
			numVector operator-() const;                  ///< Return sign toggled vector
			numVector power(const numVector&) const;      ///< Return each element to the power of each element of vector
			numVector power(real exponent) const;       ///< Return each element to the power "exponent"
			numVector& operator+=(const numVector&);      ///< Add vector to this
			numVector& operator+=(real);                ///< Add scalar to this
			numVector& operator-=(const numVector&);      ///< Subtract vector from this
			numVector& operator-=(real);                ///< Subtract scalar from this
			numVector& operator*=(const numVector&);      ///< Multiply each element of vector with each element of this
			numVector& operator*=(real);                ///< Multiply each element of vector with scalar
			numVector& operator/=(const numVector&);      ///< Divide each element of this by each element of vector
			numVector& operator/=(real);                ///< Divide each element of this by scalar
			

			/// Return funct(this)
			/// @param funct a function of signature real funct(real)
			///
			/// Example: Return the sinus of each element of vector x
			/// @code
			/// numVector sin_x = x.apply(sin);
			/// @endcode
			numVector apply(real funct(real)) const; 
			//@}

			/// @name Summarizing functions
			//@{
			real dot(const numVector&) const;           ///< Return dot product of this and vector
			real sum() const;                           ///< Return sum of vector
			real max() const;														///< Return max of vector
			real min() const;                           ///< Return min of vector
			
			/// Returns a norm of the vector, implemented norms:  1 - sum of abs, 2 - Euclidean distance, 0 Maximum of abs
			/// @param normtype An integer indicating the type of norm
			real norm(int normtype=0) const;              
			//@}

	
		};

		numVector operator+(const numVector& _Left,const numVector& _Right);
		numVector operator-(const numVector& _Left,const numVector& _Right);
		numVector operator*(const numVector& _Left,const numVector& _Right);
		numVector operator/(const numVector& _Left,const numVector& _Right);

		numVector operator+(const numVector& _Left,real _Right);
		numVector operator-(const numVector& _Left,real _Right);
		numVector operator*(const numVector& _Left,real _Right);
		numVector operator/(const numVector& _Left,real _Right);

		numVector operator+(real _Left,const numVector& _Right);
		numVector operator-(real _Left,const numVector& _Right);
		numVector operator*(real _Left,const numVector& _Right);
		numVector operator/(real _Left,const numVector& _Right);

		%extend numVector {
			double __getitem__(int index) 
			{
				int ndx = index < 0 ? $self->size() - index : index;
				if (ndx < 0 || ndx>=$self->size())
				{
					throw std::out_of_range("Index out of range");
				}
				return (*$self)[ndx];
			}
			void __setitem__(int index,double value) 
			{
				int ndx = index < 0 ? $self->size() - index : index;
				if (ndx < 0 || ndx>=$self->size())
				{
					throw std::out_of_range("Index out of range");
				}
				(*$self)[ndx]=value;
			}
			int __len__() {return $self->size();}
		}


	}
}




]

%rename($ignore) svVector;

class cmf::math::StateVariable;
namespace std {
	%template(svVector) vector<cmf::math::StateVariable*>; 
}
%includefile "math\\StateVariable.h" [








namespace cmf {
	/// Contains classes for numerical solving of ODE's
  namespace math {
		/*! Abstract class state variable
				
				Simple exponential system class header implementing a state variable:
				@code
				class RateGrowth
				{
				public:
					real rate;
					virtual real Derivate(const cmf::math::Time& time) {return rate*State();}
				};
				@endcode
		*/
		class StateVariable
		{
		private:
			bool m_StateIsNew;
			/// Holds the value of the Statevariable
			real m_State;
		protected:
			virtual void StateChangeAction() {}
			/// Sets the updated flag (m_StateIsNew) to false
			void MarkStateChangeHandled() {m_StateIsNew=false;}
		public:
			/// Returns the derivate of the state variable at time @c time
			virtual real Derivate(const cmf::math::Time& time)=0;
			/// Returns the current state of the variable
			const real& State() const {return m_State;}
			/// Gives access to the state variable
			void State(const real& newState) {
				//m_StateIsNew=m_State!=newState;
				m_State=newState;
				m_StateIsNew=true;
				if (m_StateIsNew) StateChangeAction();
			}
			/// Returns if the state was currently updated
			bool StateIsChanged() {return m_StateIsNew;}
			/// ctor
			StateVariable(real InitialState=0) : m_State(InitialState),m_StateIsNew(true) {}
		};

		/// A vector of state variables, can be solved by RKFIntegrator
		class StateVariableVector : public std::vector<StateVariable*>
		{
			void AddValuesToStates(const numVector& operands);
		public:
			/// Copies the states to a numeric vector using OpenMP
			void CopyStates(numVector & destination) const;
			void CopyStates(real * destination) const;
			/// Copies the new states to the actual states
			void SetStates(const numVector & newStates) ;
			void SetStates(real * newStates);
			/// Operator to add something to the states
			StateVariableVector& operator+=(const numVector& aVector)
			{
				this->AddValuesToStates(aVector);
				return *this;
			}
			/// Copies the derivatives at time step "time" to a numeric vector using OpenMP
			/// @param time Time at which the derivatives should be calculated
			/// @param destination Vector to be overwritten by the results
			/// @param factor A factor that is multiplied to the derivate (e.g. unit conversion or integration length)
			void CopyDerivs(Time time,numVector & destination, real factor=1) const;
			/// Copies the derivatives at time step "time" to an preallocated c array
			/// @param time Time at which the derivatives should be calculated
			/// @param destination Allocated c array
			/// @param factor A factor that is multiplied to the derivate (e.g. unit conversion or integration length)
			void CopyDerivs(Time time,real * destination,real factor=1) const;
			/// Returns the states in a numeric vector using :CopyStates, but is slower because of additional memory allocation
			numVector GetStates() const 
			{
				numVector result(this->size());
				CopyStates(result);
				return result;
			}
			/// Returns the derivatives at time step "time" in a numeric vector using :CopyDerivs, but is slower because of additional memory allocation
			numVector GetDerivs(Time time) const 
			{
				numVector result(this->size());
				CopyDerivs(time,result);
				return result;
			}
		};
		
		///An abstract class, that owns one or more state variables, that can add them to a vector of state variables in a certain order
		class StateVariableOwner
		{
		public:
			/// Add the state variables, owned by an object derived from StateVariableOwner, to the given vector
			virtual void AddStateVariables(cmf::math::StateVariableVector& vector)=0;
			explicit StateVariableOwner() {}
		};
	}
}




]
%includefile "math\\Integrators\\Integrator.h" [







namespace cmf {
	namespace math {
		/// Base class for any kind of integrator
		///
		/// Pure virtual functions:
		/// - Integrate
		/// - Copy
		/// Please provide a custom copy constructor
		/// @todo Put the methods of StateVariableVector here, and delete StateVariableVector
		class Integrator
		{
		protected:
			///@name The state variables to integrate
			//@{
			StateVariableVector m_States;

			real error_exceedance( const numVector& compare )
			{
				real res=0;

				for (int i = 0; i < count() ; i++)
				{
					real error=abs(compare[i]-state(i));
					// Calculate absolute error tolerance as: epsilon + |(x_p+x_(n+1))/2|*epsilon
					real errortol=Epsilon + abs(state(i))*Epsilon;
					if (error/errortol>res)

					{
						if (error/errortol>res)
							res=error/errortol;
					}
				}
				return res;
			}
			
			//@}
		public:
			/// A public variable to identify the solver
			char Tag;
			/// returns the number of state variables
			int count() const
			{
				return (int)m_States.size();
			}
			/// Simplifies the assessment of state variables
			const real& state(int position) const
			{
				return m_States[position]->State();
			}
			/// Simplifies the assessment of state variables
			void state(int position,real newState)
			{
				m_States[position]->State(newState);
			}
			
			/// @name Assessment of state variables for integration
			//@{ 
			/// Adds the state variables of a StateVariableOwner to the state variables of the solver
			virtual void AddStatesFromOwner(cmf::math::StateVariableOwner& stateOwner)
			{
				stateOwner.AddStateVariables(m_States);
			}
			virtual void AddState(cmf::math::StateVariable& statevar)
			{
				m_States.push_back(&statevar);
			}
			//@}

		protected:
			/// Returns the vector of StateVariable pointers 
			cmf::math::StateVariableVector& States() {return m_States;}
			const cmf::math::StateVariableVector& States() const {return m_States;}
			///@name Accuracy parameters
			//@{
			///Tolerable error
			const real Epsilon;
			///Minimal timestep
			const cmf::math::Time m_MinTimestep;
			//@}
			/// @name model time
			//@{
			/// Actual time of the solver
			cmf::math::Time m_Time;
			/// last time step of the solver
			cmf::math::Time m_TimeStep;
			/// Proposed step width for the next time step
			cmf::math::Time m_NextTimeStep;
			/// Protected function to adjust the step width for stability reasons
			void AdjustTimestep(cmf::math::Time& TimeStep,cmf::math::Time MaxTime)
			{
				//We should not step over the maximum time
				if ( MaxTime - m_Time <= TimeStep) 
					TimeStep = MaxTime-m_Time;
				//If the max time is reached at the next time step, we should lower the timestep, to avoid a too short timestep on the next call
				else if	((MaxTime - m_Time) < TimeStep*2.0) 
					TimeStep = (MaxTime - m_Time) * 0.5;
			}
			//number of iterations
			int m_Iterations;
		public:
			///Returns the current model time
			cmf::math::Time ModelTime() const { return m_Time; }
			///Sets the current model time
			void ModelTime(cmf::math::Time val) { m_Time = val;Reset(); }
			///Returns the last time step
			cmf::math::Time TimeStep() const { return m_TimeStep; }
			///Returns the next time step width
			cmf::math::Time NextTimeStep() const { return m_NextTimeStep; }
			///Sets the next time step width
			void NextTimeStep(cmf::math::Time val) { m_NextTimeStep = val; }
			///Returns The minimal allowed time step length
			const cmf::math::Time MinTimestep() const { return m_MinTimestep; }
			int Iterations() const { return m_Iterations;}
			void ResetIterations() {m_Iterations=0;}
			virtual void Reset() {}
			//@}
			/// @name Constructors and Destructors
			//@{
			/// Constructs a new FixPointImplicitEuler from a pointer to a vector of state variables
			/// @note The RKF Integrator becomes the owner of states
			/// @param states Statevariables of the system
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			Integrator(const StateVariableVector& states, real epsilon=1e-9,cmf::math::Time tStepMin=10.0/(3600.0*24.0)) 
				: m_States(states), Epsilon(epsilon),m_MinTimestep(tStepMin),m_TimeStep(1.0),m_Time(0.0),m_NextTimeStep(1.0)			{			}
			
			/// Constructs a new Integrator with a new own state vector
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			Integrator(real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10)) 
				: m_States(), Epsilon(epsilon),m_MinTimestep(tStepMin),m_TimeStep(1.0),m_Time(0.0),m_NextTimeStep(1.0)
			{
			}
			/// Copy constructor, does not copy the state variables
			Integrator(const Integrator& forCopy)
				: Epsilon(forCopy.Epsilon), m_MinTimestep(forCopy.m_MinTimestep),m_NextTimeStep(forCopy.m_NextTimeStep),m_Time(forCopy.m_Time),m_TimeStep(forCopy.m_TimeStep),
				Tag(forCopy.Tag),m_States()
			{
			}
			
			/// Returns a new Integrator, based on this (without the state variables), e.g. same type, epsilon, model time etc.
			virtual cmf::math::Integrator * Copy() const=0;
			//@}

			///@name Integrate
			//@{

			///Integrates the vector of state variables
			/// @param MaxTime To stop the model (if running in a model framework) at time steps of value exchange e.g. full hours, the next value exchange time can be given
			/// @param TimeStep Takes the proposed timestep, and changes it into the effictivly used timestep according to the local stiffness of the problem and MaxTime
			virtual int Integrate(cmf::math::Time MaxTime,cmf::math::Time TimeStep)=0;
			int Integrate( cmf::math::Time MaxTime)
			{		return Integrate(MaxTime,m_NextTimeStep);	}
			///
			void IntegrateUntil(cmf::math::Time MaxTime)
			{ IntegrateUntil(MaxTime,m_NextTimeStep);	}
			///Integrates the vector of state variables until MaxTime
			void IntegrateUntil(cmf::math::Time MaxTime,cmf::math::Time TimeStep)
			{
				m_Iterations=0;
				m_NextTimeStep=TimeStep;
				while (m_Time < MaxTime)
					Integrate(MaxTime);
			}
			/// Calls IntegrateUntil
			void __call__(cmf::math::Time until)
			{
				IntegrateUntil(until);
			}

			//@}


		};
	}
}






]
%includefile "math\\Integrators\\BDF2.h" [





namespace cmf {
	namespace math {

		/// An order 2 BDF-Method with fixed-point iteration and variable step size
		///
		/// Recommended integrator for CMF (so far)
		///
		/// Derived from 
		///  - Roussel C. and Roussel M. (2003) "Generic Object-Oriented Differential Equation Integrators", 
		/// C/C++ User Journal, Nov. 2003, http://www.ddj.com/cpp/184401724?pgno=8 and
		///  - Eckert S., Baaser H., Gross D. and Scherf O. (2004) "A BDF2 integration method with step size control for elasto-plasticity",
		/// Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1
		///
		/// Most important function: Integrate

		class BDF2 : public Integrator
		{
		private:
			///@name Internal data storages
			//@{
			/// Array to store the states for test of convergence
			numVector compareStates;
			/// Array to store the derivatives
			numVector dxdt;

			///History of the last states
			numVector pastStatesArray[2];
			///Number of steps taken
			int stepNo;
			/// Current order of Gear formula
			int order;
			/// Gets one of the last states
			/// @returns   the n<sup>th</sup> state in history
			/// @param toBack Number of steps back (ranging from 1..4, no runtime check)
			numVector& pastStates(int toBack=1)
			{
				int pos = (stepNo-toBack) % 2;
				return pastStatesArray[pos];
			}



			//@}


			/// @name Gear functions: The following functions evaluate the Gear formulas of specified order, loading the results into compareStates.
			//@{
			/// Gear formulas through an array of pointers.
			typedef void (BDF2::*newState_functions)(real);
			newState_functions calc_newState[2];

			void Gear1newState(real h);
			void Gear2newState(real h);

			//@}


		public:

			void AddStatesFromOwner(cmf::math::StateVariableOwner& stateOwner);

			/// Constructs a new Gears_var_Step from a pointer to a vector of state variables
			/// @note The Integrator becomes the owner of states
			/// @param states Statevariables of the system
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			BDF2(const StateVariableVector& states, real epsilon=1e-9,cmf::math::Time tStepMin=Time::Milliseconds(10));
			/// Constructs a new Gears_var_Step
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			BDF2(real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10));
			BDF2(const Integrator & templ);
			virtual Integrator * Copy() const
			{
				return new BDF2(*this);
			}



			/// Integrates the vector of state variables
			///
			///  - if \f$ t_{max}-t_{now}\leq 2h_n \f$ then \f$ h_{n+1}= t_{max}-t_{now} \f$ else \f$ h_{n+1}= 2h_n \f$
			///  - Uses pastStatesArray to store \f$ y_n,y_{n-1} \f$
			///  - if more than one step is taken start iterating:
			///    - \f$ y_{n+1}^i=\frac{1}{1+2\rho }\left( (\rho +1)^{2}y_{n}-\rho ^{2}y_{n-1}+(\rho +1)h\frac{dy}{dt}(y_{n+1}^{i-1},t_{n+1} \right), y_{n+1}^0=y_n \f$ 
			///   with \f$ \rho = \frac{h_{n+1}}{h_n} \f$
			///  - until \f$ y_{n+1}^{i} - y_{n+1}^{i-1} \leq \ \|\epsilon + \epsilon y_{n+1}\|_{\infty} \f$
			///  - If too many iterations are needed, or the error is rising, repeat iteration with \f$ h_{n+1} = \frac{h_{n+1}}{2} \f$
			/// @param MaxTime To stop the model (if running in a model framework) at time steps of value exchange e.g. full hours, the next value exchange time can be given
			/// @param TimeStep Takes the proposed timestep, ignored by this solver
			int Integrate(cmf::math::Time MaxTime,cmf::math::Time TimeStep);
		};
	}
}



]
%includefile "math\\Integrators\\ExplicitEuler_fixed.h" [




namespace cmf {
	namespace math {
		/// An explicit Euler integrator, with a fixed time step
		class ExplicitEuler_fixed : public Integrator
		{
		private:
			numVector 
				dxdt;
		public:
			void AddStatesFromOwner(cmf::math::StateVariableOwner& stateOwner)
			{
				Integrator::AddStatesFromOwner(stateOwner);
				dxdt.resize(count());
			}

			/// Constructs a new ExplicitEuler_fixed from a pointer to a vector of state variables
			/// @note The Integrator becomes the owner of states
			/// @param states Statevariables of the system
			/// @param epsilon (ignored) relative error tolerance per time step (default=1e-9)
			/// @param tStepMin (ignored) minimum time step (default=10s)
			ExplicitEuler_fixed(const StateVariableVector& states, real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10))
				: Integrator(states,epsilon,tStepMin),
				dxdt(states.size())
			{}

			/// Constructs a new ExplicitEuler_fixed
			/// @param epsilon (ignored) relative error tolerance per time step (default=1e-9)
			/// @param tStepMin (ignored) minimum time step (default=10s)
			ExplicitEuler_fixed(real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10))
				: Integrator(epsilon,tStepMin)
			{	}

			/// Copy constructor
			ExplicitEuler_fixed(const Integrator& copy) : Integrator(copy) {}
			virtual ~ExplicitEuler_fixed() {}
			virtual Integrator * Copy() const
			{
				return new ExplicitEuler_fixed(*this);
			}

			///Integrates the vector of state variables
			/// @param MaxTime (ignored) To stop the model (if running in a model framework) at time steps of value exchange e.g. full hours, the next value exchange time can be given
			/// @param TimeStep Takes the proposed time step
			int Integrate(cmf::math::Time MaxTime,cmf::math::Time TimeStep)
			{
				m_TimeStep=TimeStep;
				if (m_TimeStep>MaxTime-ModelTime())
					m_TimeStep=MaxTime-ModelTime();
				// Copy derivates multipied with time step to dxdt
				States().CopyDerivs(ModelTime(),dxdt,m_TimeStep.AsDays());
				// Update time step with delta x
				States() += dxdt;
				m_Time += m_TimeStep;
				
				return 1;
			}

		};

	}
}




]
%includefile "math\\Integrators\\ExplicitEuler_variable.h" [








namespace cmf {
	namespace math {
		/// An explicit Euler integrator with variable step size
		class ExplicitEuler_variable : public Integrator
		{
		private:
			numVector 
				dxdt,
				compare,
				oldStates;
		public:
			/// A public field triggering error based stepsize control
			bool WithStepsizeControl;
			void AddStatesFromOwner(cmf::math::StateVariableOwner& stateOwner)
			{
				Integrator::AddStatesFromOwner(stateOwner);
				dxdt.resize(count());
				compare.resize(count());
				oldStates.resize(count());
			}

			/// Constructs a new ExplicitEuler_variable from a pointer to a vector of state variables
			/// @note The Integrator becomes the owner of states
			/// @param states Statevariables of the system
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			ExplicitEuler_variable(const StateVariableVector& states, real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10))
				: Integrator(states,epsilon,tStepMin)
			{}

			/// Constructs a new ExplicitEuler_variable
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			ExplicitEuler_variable(real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10))
				: Integrator(epsilon,tStepMin)	{	}

			/// Copy constructor
			ExplicitEuler_variable(const Integrator& copy) : Integrator(copy) {}
			virtual ~ExplicitEuler_variable() {}

			virtual Integrator * Copy() const
			{
				return new ExplicitEuler_variable(*this);
			}

			///Integrates the vector of state variables
			/// @param MaxTime To stop the model (if running in a model framework) at time steps of value exchange e.g. full hours, the next value exchange time can be given
			/// @param TimeStep Takes the proposed time step, and changes it into the effectively used time step according to the local stiffness of the problem and MaxTime
			int Integrate(cmf::math::Time MaxTime,cmf::math::Time TimeStep)
			{
				Time h=TimeStep;
				// Copy current state to oldStates
				States().CopyStates(oldStates);
				real err_ex=0;
				do 
				{
					// Calculate states in two half time steps
					for (int i = 0; i < 2 ; i++)
					{
						States().CopyDerivs(ModelTime() + ((h*i)/2).AsDays(),dxdt,h.AsDays()/2);
						States()+=dxdt;			
					}
					// Store the result as comparison
					States().CopyStates(compare);
					// Reset the states
					States().SetStates(oldStates);
					// Make Euler step
					States().CopyDerivs(ModelTime(),dxdt,h.AsDays());
					// Get error exceedance
					err_ex=error_exceedance(compare)+1e-100;
					m_TimeStep=h;
					// Calculate new time step
					h/=((((err_ex)<(0.1) ? (err_ex) : (0.1)))>(10) ? (((err_ex)<(0.1) ? (err_ex) : (0.1))) : (10));

					if (err_ex>1 && h>m_MinTimestep)
						// Failed: Reset the states
						States().SetStates(oldStates);
					else
						// Mission accomplished
						break;

				} while(1);
				m_NextTimeStep=h;
				m_Time += m_TimeStep;
				return 1;
			}

		};
	}
}






]
%includefile "math\\Integrators\\FixpointImplicitEuler.h" [









namespace cmf {
	namespace math {
		/// An implicit (backward) Euler integrator using fixpoint iteration
		class ImplicitEuler : public Integrator
		{
			//@}
		private:
			///@name Internal data storages
			//@{
			/// Array to store the new states
			numVector compareStates;
			///Vector of the state variable in the beginning of the integration
			numVector oldStates;
			///Vector of derivatives
			numVector dxdt;
			//@}



		public:
			void AddStatesFromOwner(cmf::math::StateVariableOwner& stateOwner);
			/// Constructs a new FixPointImplicitEuler from a pointer to a vector of state variables
			/// @note The Integrator becomes the owner of states
			/// @param states Statevariables of the system
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			ImplicitEuler(const StateVariableVector& states, real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10));
			/// Constructs a new FixPointImplicitEuler
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			ImplicitEuler(real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10));

			/// Copy constructor
			ImplicitEuler(const Integrator&);

			virtual Integrator * Copy() const
			{
				return new ImplicitEuler(*this);
			}
			///Integrates the vector of state variables
			/// @param MaxTime To stop the model (if running in a model framework) at time steps of value exchange e.g. full hours, the next value exchange time can be given
			/// @param TimeStep Takes the proposed timestep, and changes it into the effictivly used timestep according to the local stiffness of the problem and MaxTime
			int Integrate(cmf::math::Time MaxTime,cmf::math::Time TimeStep);
		};
	}
}




]
%includefile "math\\Integrators\\RKFIntegrator.h" [








namespace cmf {
	namespace math {
		///Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-Fehlberg (RKF54) method
		class RKFIntegrator : public Integrator
		{
		private:
			static const real 
				//Constants for the RKF-Method
				c[6],A[6][5],b5[6],e[6];

			///The 6 Vectors of k-Values. 
			///Since they are only needed in the Integrate method, from theory they should defined as local variable. 
			///But Allocation needs time, and we will call this often
			numVector kValues[6];
			real& k(size_t order,int stateIndex) 
			{return (kValues[order])[stateIndex];}
			numVector& k(size_t order)
			{return kValues[order]; }
			///Vector of the state variable in the beginning of the integration
			numVector oldStates;
			//@}
		public:
			void cmf::math::RKFIntegrator::AddStatesFromOwner( cmf::math::StateVariableOwner& stateOwner );

			/// Constructs a new RKFIntegrator from a pointer to a vector of state variables
			/// @note The RKF Integrator becomes the owner of states
			/// @param states Statevariables of the system
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			RKFIntegrator(const StateVariableVector& states, real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10));
			/// Constructs a new RKFIntegrator
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			RKFIntegrator(real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10));
			/// Copy constructor, does not copy 
			RKFIntegrator(const Integrator& forCopy);
			

			virtual Integrator * Copy() const
			{
				return new RKFIntegrator(*this);
			}
			
			///Integrates the vector of state variables
			/// @param MaxTime To stop the model (if running in a model framework) at time steps of value exchange e.g. full hours, the next value exchange time can be given
			/// @param TimeStep Takes the proposed timestep, and changes it into the effictivly used timestep according to the local stiffness of the problem and MaxTime
			int Integrate(cmf::math::Time MaxTime,cmf::math::Time TimeStep);
	

		};
		
	}
}



]
%includefile "math\\Integrators\\Gears_Fixpoint.h" [




%constant GEAR_MAX_ITER = 200;
%constant GEAR_RECOVER_AFTER_STEPS = 500;



namespace cmf {
	namespace math {
		/// An up to 4 step Gears-Method with fixpoint iteration, needs bug fixing
		///
		/// Derived from 
		/// Roussel C. and Roussel M. (2003) "Generic Object-Oriented Differential Equation Integrators", 
		/// C/C++ User Journal, Nov. 2003, http://www.ddj.com/cpp/184401724?pgno=8
		class Gears_Fixpoint : public Integrator
		{
			//@}
		private:
			///@name Internal data storages
			//@{
			/// Array to store the states for test of convergence
			numVector compareStates;
			/// Array to store the derivatives
			numVector dxdt;

			///History of the last states
			numVector pastStatesArray[6];
			///Number of steps taken
			int stepNo;
			/// Current order of Gear formula
			int order;
			/// Maximum order of method
			int max_order;
			/// Gets one of the last states
			/// @returns   the n<sup>th</sup> state in history
			/// @param toBack Number of steps back (ranging from 1..4, no runtime check)
			numVector& pastStates(int toBack=1)
			{
				int pos = (stepNo-toBack) % max_order;
				return pastStatesArray[pos];
			}

			/// Returns true if the states are approximately equal to the given array (test for convergence)
			bool approx_equal_to_states(const numVector& compare);
			/// Returns the maximum of the error exceedance between states and a given array
			real max_rel_error_exceedance(const numVector& compare);
			//@}

			/// @name Time step management
			//@{
			int time_reduce_stage;
		public:
			///Returns int Stage oof time reduction
			int Time_reduce_stage() const { return time_reduce_stage; }			
			//@}
		private:



			/// @name Gear functions: The following functions evaluate the Gear formulas of specified order, loading the results into compareStates.
			//@{
			/// Gear formulas through an array of pointers.
			typedef void (Gears_Fixpoint::*newState_functions)(real);
			newState_functions calc_newState[4];

			void Gear1newState(real h);
			void Gear2newState(real h);
			void Gear3newState(real h);
			void Gear4newState(real h);
			void Gear5newState(real h);
			//@}


		public:

			void AddStatesFromOwner(cmf::math::StateVariableOwner& stateOwner);

			/// Constructs a new Gears_Fixpoint from a pointer to a vector of state variables
			/// @note The Integrator becomes the owner of states
			/// @param states Statevariables of the system
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			/// @param maxOrder Maximum order of method (default=4)
			Gears_Fixpoint(const StateVariableVector& states, real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10),int maxOrder=4);
			/// Constructs a new Gears_Fixpoint
			/// @param epsilon relative error tolerance per time step (default=1e-9)
			/// @param tStepMin minimum time step (default=10s)
			/// @param maxOrder Maximum order of method (default=4)
			Gears_Fixpoint(real epsilon=1e-9,cmf::math::Time tStepMin=Time::Seconds(10),int maxOrder=4);
			/// Copy constructor
			Gears_Fixpoint(const Integrator&);

			virtual Integrator * Copy() const
			{
				return new Gears_Fixpoint(*this);
			}

			virtual ~Gears_Fixpoint();


			///Integrates the vector of state variables
			/// @param MaxTime To stop the model (if running in a model framework) at time steps of value exchange e.g. full hours, the next value exchange time can be given
			/// @param TimeStep Takes the proposed timestep, and changes it into the effictivly used timestep according to the local stiffness of the problem and MaxTime
			int Integrate(cmf::math::Time MaxTime,cmf::math::Time TimeStep);
		};	
		
		
		
	
	}
}




]
%includefile "math\\Integrators\\cvodeIntegrator.h" [


// include CVODE



namespace cmf {
	namespace math {
		/// A wrapper class for the CVODE integrator from the SUNDIALS library
		///
		/// https://computation.llnl.gov/casc/sundials/main.html
		class CVodeIntegrator : public Integrator
		{
		private:
			N_Vector m_y;
			void * cvode_mem, * precond_mem;
			/// The right handside function f in eq. \f$\frac{dy}{dt}=f(t,y)\f$
			static int f(realtype t, N_Vector u, N_Vector udot, void *f_data);
			
		public:
			/// Type of Krylov preconditioning. Must have one of the following values:
			/// - 'N' No Krylov preconditioner
			/// - 'L' Left hand side banded preconditioning
			/// - 'R' Right hand side preconditioning
			char preconditioner;
			/// Thickness of jacobian band used for the solver
			int maxl;
			/// Type of linear solver:
			/// - 0 = Dense Jacobian
			/// - 1 = Banded Jacobian
			/// - 2 = Diagonal Jacobian
			/// - 3 = Iterative Krylov solver with scaled preconditioned GMRES
			/// - 4 = Iterative Krylov solver with scaled preconditioned Bi-CGStab
			/// - 5 = Iterative Krylov solver with scaled preconditioned TFQMR
			int LinearSolver;
			int MaxOrder;
			int GetOrder();
			/// Initializes the solver. Do not add or remove statevariables after initialization
			void Initialize();
			virtual int Integrate(cmf::math::Time MaxTime,cmf::math::Time TimeStep);
			virtual void Reset();
			
			/// Create a new CVODE integrator
			/// @param epsilon relative and absolute error tolerance
			/// @param tStepMin Minimal timestep
			CVodeIntegrator(real epsilon=1e-9,cmf::math::Time tStepMin=Time::Milliseconds(50)) : Integrator(epsilon,tStepMin), m_y(0),cvode_mem(0),precond_mem(0),preconditioner('N'),maxl(5),LinearSolver(3),MaxOrder(5)
			{
				
			}
			/// Copy constructor, creates a new CVODE integrator similiar to the given, but without statevariables
			CVodeIntegrator(const CVodeIntegrator & templ) : Integrator(templ),preconditioner(templ.preconditioner),maxl(templ.maxl),m_y(0),cvode_mem(0),precond_mem(0),LinearSolver(templ.LinearSolver),MaxOrder(templ.MaxOrder) {}
			
			CVodeIntegrator * Copy() const
			{
				return new CVodeIntegrator(*this);
			}
			virtual ~CVodeIntegrator();


		};
		
	}
	
}






]

%feature("implicitconv") cmf::math::Time;
%feature("implicitconv") cmf::math::Date;

%insert("python") {
def AsCMFtime(date):
    """Converts a python datetime to cmf.Time"""
    return Time(date.day,date.month,date.year,date.hour,date.minute,date.second,date.microsecond/1000)
def timerange(start,end,step=day):
    """Creates a list of cmf.Time, similar to the Python range function"""
    return [start+step*x for x in range(0,int((end-start)/step+0.999))]

]
%{
	// Include Water
	#include "water/Solute.h"
	#include "water/WaterFlux.h"
	#include "water/Reaction.h"
	#include "water/SoluteStorage.h"
	#include "water/WaterStorage.h"

	#include "Atmosphere/Meteorology.h"

	// Include Upslope
	#include "upslope/Soil/RetentionCurve.h"
	// Need a retention curve profile
	#include "upslope/SoilWaterStorage.h"
	#include "upslope/Vegetation/StructVegetation.h"
	#include "upslope/cell.h"
	#include "upslope/FluxConnections.h"
	// Include maps
	#include "upslope/maps/maps.h"
	// Include river model
	#include "Reach/ReachType.h"
	#include "Reach/ManningConnection.h"

	// Include the combined solver
	// Include Factories and helper IO
%}


// Include Water
%includefile "water\\Solute.h" [








namespace cmf
{
	/// Contains generic classes for %matter transport. You can use any unit for %matter amounts you like, like mol, g, kg, or none at all as long as you stay consistent. 
	/// But for the concentrations, the nominator of the unit must be \f$m^3\f$, e.g. \f$\frac{mol}{m^3},\frac{g}{m^3},\frac{1}{m^3}\f$. For simplicity, in the following the unit of concentrations
	/// are called \f$\frac{mol}{m^3}\f$.
	namespace water
	{
		class Solutes;
		/// A structure to identify a solute
		struct Solute
		{
		private:
			Solute(size_t id) :Id(id), Name(""),Uptake(1),Unit("") {}
			Solute(size_t id,const std::string& name="",const std::string& unit="" ,double uptake=1)
				: Name(name),Uptake(uptake),Unit(unit),m_Id(id),Id(m_Id)
			{
			}
			size_t m_Id;
		public:
			Solute(const Solute& copy) : Name(copy.Name),Uptake(copy.Uptake),Unit(copy.Unit),m_Id(copy.Id),Id(m_Id) {}



			friend class Solutes;
			/// Name of the solute
			std::string Name;
			/// Used unit for amount of solute e.g. 'mol','mmol','g','mg' etc.
			std::string Unit;
			/// Fraction of the available concentration, that is taken up by vegetation
			/// - 0 means no uptake
			/// - 0..1 mean uptake is partially inhibited
			/// - 1 solute is taken up without changes in concentration
			/// - >1 preferential uptake (not tested, may result in negative concentrations)
			double Uptake;
			/// An automatically set identifier of the solute
			const size_t & Id;
			static const Solute& create(const std::string& name,const std::string& unit="",double uptake=1);
		};
		/// Manages the solutes of the whole model. The static member All is the only instance. Before you  are creating any cmf object 
		/// (like UpslopeCell, Reach or IVegetation or Meteorology), make sure you have added all solutes you are interest in to Solutes::All
		/// Generally you are free to add any kind of Solute to the model, but each additional will slow down calculations remarkably, and if you 
		/// intend to use one or more ExternalFunctionReaction special requirements apply.
		class Solutes
		{
			std::vector<Solute>	m_Solutes;
			bool InUse;
			static Solutes m_All;
			Solutes() : InUse(false) {}

		public:
			/// Creates a solute in Solute::All
			/// @param name the name of the solute, e.g. 'Tracer', 'NO3'
			/// @param unit Used unit for amount of solute e.g. 'mol','mmol','g','mg' etc.
			/// @param uptake Fraction of the available concentration, that is taken up by vegetation
			const Solute& add(const std::string& name,const std::string& unit="",double uptake=1);
			size_t size() {return m_Solutes.size();}
			/// If the Solutes of the model are marked as "InUse", no more solutes may be added. They get marked as "InUse" as soon as an object depending on the
			/// number of solutes is created (e.g. an UpslopeCell, Reach, IVegetation or Meteorology)
			void SetInUse();























			static Solutes& all() {return Solutes::m_All;}
		};
	}
}

namespace cmf {
	namespace water {	
		/// Map of concentrations for different solutes
		class WaterQuality 
		{
		private:
			typedef std::vector<double> Concentrations;
			Concentrations	conc;
		public:


































			/// Returns the number of solutes
			size_t size() const
			{
				return conc.size();
			}
			std::string tostring() const
			{
				std::stringstream out;
				out.precision(4);
				for (int i = 0; i < int(size()) ; ++i)
				{				 
					out << Solutes::all()[i].Name << ": " << conc[i] << " " << Solutes::all()[i].Unit << " ";
				}
				return out.str();
			}

			/// Clears the water
			void clear();

		  /// Standard constructor
			WaterQuality() : conc(cmf::water::Solutes::all().size(),0) {/*cmf::water::Solutes::all().SetInUse();*/}
			WaterQuality(const cmf::water::WaterQuality& wq) : conc(wq.conc) {}
		};
		/// A map of concentration time series for solutes
		class SoluteTimeseries
		{
		private:
			typedef std::vector<cmf::math::timeseries> timeseriesVector;
			timeseriesVector conc_ts;
		public:




















			WaterQuality conc(cmf::math::Time t)
			{
				WaterQuality res;
				for(Solutes::const_iterator it = Solutes::all().begin(); it != Solutes::all().end(); ++it)
				{
				    res[*it]=(*this)[*it][t];
				}
				return res;
			}
			/// Returns the number of solutes in the solution
			size_t size() const
			{
				return conc_ts.size();
			}
			SoluteTimeseries() : conc_ts(cmf::water::Solutes::all().size()) {cmf::water::Solutes::all().SetInUse();}
			SoluteTimeseries(cmf::math::Time begin,cmf::math::Time step) : conc_ts(cmf::water::Solutes::all().size()) 
			{
				cmf::water::Solutes::all().SetInUse();
				for (iterator it=conc_ts.begin();it!=conc_ts.end();++it)
				{
					it->begin=begin;
					it->step=step;
				}

			}

			SoluteTimeseries(const cmf::water::SoluteTimeseries& sts) : conc_ts(sts.begin(),sts.end()) {}
		};
	}
}

%extend cmf::water::Solutes
{
	Solute& __getitem__(int i)
	{
		return (*$self)[i];
	}
}
%extend cmf::water::WaterQuality
{
	double __getitem__(const cmf::water::Solute& solute)
	{
		return (*$self)[solute];
	}
	void __setitem__(const cmf::water::Solute& solute,double concentration)
	{
		(*$self)[solute]=concentration;
	}
	size_t __len__() const
	{
		return $self->size();
	}
	std::string __str__() const
	{
		return $self->tostring();
	}
}
%extend cmf::water::SoluteTimeseries
{
	cmf::math::timeseries& __getitem__(const cmf::water::Solute& solute)
	{
		return (*$self)[solute];
	}
	void __setitem__(const cmf::water::Solute& solute,cmf::math::timeseries concentration)
	{
		(*$self)[solute]=concentration;
	}
	size_t __len__() const
	{
		return $self->size();
	}
}




]
%includefile "water\\WaterFlux.h" [







namespace cmf {
	namespace water {

		class WaterStorage;
		/// Water fluxes consist of the flux in \f$\frac{m^3}{day}\f$ and a map of concentrations (ConcentrationMap)
		class WaterFlux
		{
		public:
			WaterFlux& Update(real waterflux,const cmf::water::WaterStorage& origin,bool uptake=false);
			/// The water quality
			cmf::water::WaterQuality c;
			/// The amount of moving water in \f$\frac{m^3}{day}\f$
			real q;
			/// Standard constructor
			WaterFlux(): q(0),c() {}
			/// Copy constructor
			WaterFlux(const WaterFlux& forcopy)
				: q(forcopy.q),c(forcopy.c) {}
			/// Creates a clear water flux
			WaterFlux(real flux)
				: q(flux),c() {}
			WaterFlux(real flux,const cmf::water::WaterStorage& origin,bool uptake=false);
			WaterFlux(real flux,WaterQuality wq) : q(flux),c(wq) {}




















			/// Adds water from the origin to the flux (mixing)
			/// Both fluxes may be negative, but mixed signs will throw an error
			/// \f{eqnarray*} 
			/// q&=& \mbox{Flux in }\frac{m^3}{day} \\
			/// c&=& \mbox{Vector of concentrations in } \frac{mol}{m^3} \\
			/// c_{this}&=&\frac{c_{this}q_{this}+c_{other}q_{other}}{q_{this}+q_{other}}	\\
			/// q_{this}&=&q_{this}+q_{other}	\\
			/// \f}
			WaterFlux& Add(real flux,const cmf::water::WaterStorage& origin);
			/// Adds water of a certain water quality to the flux (mixing)
			/// Both fluxes may be negative, but mixed signs will throw an error
			/// \f{eqnarray*} 
			/// q&=& \mbox{Flux in }\frac{m^3}{day} \\
			/// c&=& \mbox{Vector of concentrations in } \frac{mol}{m^3} \\
			/// c_{this}&=&\frac{c_{this}q_{this}+c_{other}q_{other}}{q_{this}+q_{other}}	\\
			/// q_{this}&=&q_{this}+q_{other}	\\
			/// \f}
			WaterFlux& Add(real flux,const cmf::water::WaterQuality& concentrations);
			/// Changes the sign of the flux to positive
			WaterFlux& Abs()
			{
				q=abs(q);
				return *this;
			}
			/// Returns the %water flux of the given solute in \f$\frac{mol}{day}\f$, depending on the unit of the concentration (see cmf::water )
			/// \f{eqnarray*}
			/// Q_{Solute} &=& q_{H_2O}\left[\frac{m^3}{day}\right] c_{Solute} \left[\frac{mol}{m^3}\right]
			/// \f}
			real matterflux(const cmf::water::Solute& solute)
			{
				return q*c[solute];
			}
			/// Sets all concentrations and the flux to 0
			void clear()
			{
				c.clear();
				q=0.0;
			}
			/// Adds a flux to this, and mixes the concentrations.
			/// Both fluxes may be negative, but mixed signs will throw an error
			/// \f{eqnarray*} 
			/// q&=& \mbox{Flux in }\frac{m^3}{day} \\
			/// c&=& \mbox{Vector of concentrations in } \frac{mol}{m^3} \\
			/// c_{this}&=&\frac{c_{this}q_{this}+c_{other}q_{other}}{q_{this}+q_{other}}	\\
			/// q_{this}&=&q_{this}+q_{other}	\\
			/// \f}
			WaterFlux& operator+=(const WaterFlux& add);
			/// Multiplies the flux with a factor, but is not changing the concentration
			WaterFlux& operator*=(real factor)
			{
				this->q*=factor;
				return *this;
			}
			/// Divides the flux by a factor, but is not changing the concentration
			WaterFlux& operator/=(real factor)
			{
				this->q/=factor;
				return *this;
			}
			WaterFlux operator -()
			{
				WaterFlux res=*this;
				res.q*=-1;
				return res;
			}
		};
	}
}

%extend cmf::water::WaterFlux
{
	cmf::water::WaterFlux& __call__(double waterflux,const cmf::water::WaterStorage& origin)
	{
		return (*$self)(waterflux,origin);
	}
}





]
%includefile "water\\Reaction.h" [



namespace cmf {
	namespace water {
		namespace reaction {
			/// An abstract type to use chemical (or other) reactions of solutes.
			/// Override the ReactiveFlux function or use one of the child classes, if appropriate (Have a look at the ExternalFunctionReaction, before you start recompiling cmf)
			class Reaction
			{
			public:
				/// The solute this reaction is changing (X)
				const cmf::water::Solute& Solute;
				/// Returns the reactive flux as \f$\frac{d[X]}{dt}=f([A],[B]...) \left[\frac{mol}{m^3\ day}\right]\f$ 
				virtual double ReactiveFlux(const WaterQuality& Environment)=0;
				Reaction(const cmf::water::Solute& solute) : Solute(solute) {}
			};

			
			/// A simple reaction with a constant reaction rate
			class RateReaction : public Reaction
			{
				/// The reaction rate in \f$\frac 1{day}\f$, positive rates will lead to an exponential rise of the concentration
				double r;
				/// Reactive flux: \f$ \frac{d[X]}{dt}=r\ [X] \f$
				virtual double ReactiveFlux(const WaterQuality& Environment)
				{
					 return r*Environment[Solute];
				}
				/// Creates a rate based reaction rate
				/// @param solute The solute the reaction applies to
				/// @param ReactionRate The constant (but changeable) rate of the reaction
				RateReaction(const cmf::water::Solute& solute,double ReactionRate=0) : Reaction(solute),r(ReactionRate) {}

			};

			/// A simple reaction with a constant linear change of the concentration.
			/// If the constant range is \f$ 1\frac{mol}{m^3\ day}\f$ and the rainfall deposition is 0, the concentration
			/// in each state equals the time the water stayed in the system in days
			class LinearReaction: public Reaction
			{
				/// The linear rate in \f$\frac{mol}{m^3\ day}\f$. Can be used for mean residence time calculations 
				double r;
				/// Reactive flux: \f$ \frac{d[X]}{dt}=r V \f$, where V is the volume of water
				virtual double ReactiveFlux(const WaterQuality& Environment)
				{
					if (Environment[Solute]<=0 && r<0)
						return 0;
					else
						return r;
				}
				/// Creates a aging tracer reaction
				/// @param solute The solute the reaction applies to
				/// @param LinearRate The constant (but changeable) rate of the reaction in  \f$\frac{mol}{m^3\ day}\f$
				LinearReaction(const cmf::water::Solute& solute,double LinearRate=0) : Reaction(solute),r(LinearRate) {}
			};
			/// A Michaelis Menten reaction without inhibitors
			class MichaelisMentenReaction : public Reaction
			{
			public:
				/// Michaelis Menten constant \f$ \frac{d[X]}{dt}=0.5 \mbox{ if } [X]=K_m \f$
				double K_m;
				/// Maximum reaction rate
				double V_max;
				/// Reactive flux: \f$ \frac{d[X]}{dt}=\frac{v_{max}\ [X]}{K_m+[X]} \f$
				virtual double ReactiveFlux(const WaterQuality& Environment)
				{
					double X=Environment[Solute];
					return V_max*X/(K_m+X);
				}
			};
			/// Not yet implemented: Will take a pointer to an external function to calculate the reaction
			class ExternalFunctionReaction : public Reaction
			{
			public:


			};
			typedef std::vector<Reaction*> ReactionVector;
		}
	}
	
}

%template(ReactionVector) std::vector<cmf::water::Reaction*>;




]
%includefile "water\\SoluteStorage.h" [








namespace cmf {
	namespace water {
		class WaterStorage;
		class SoluteStorageMap;
		/// A class for the storage of any tracer. The state is the amount (mol, kg etc. see cmf::water) of the tracer in the storage
		/// \f{eqnarray*}
		/// \frac{dX}{dt}&=&\sum_{f=1}^{F}\left( q_f [X]_f\right) + \sum_{r=1}^R\left(f_r\left([A],...,[Z]\right)\ V\right) \left[\frac{mol}{day}\right]\\
		/// F&=& \mbox{Number of fluxes in water storage} \\
		/// q_f&=& \mbox{Water flux in } \frac{m^3}{day}	\\
		/// \left[X\right]_f &=& \mbox{Concentration of solute X in flux }q_f \mbox{ in } \frac{mol}{m^3} \\
		/// R&=& \mbox{Number of reactions defined for this solute storage} \\
		/// f_r\left([A],...,[Z]\right)&=& \mbox{Reactive flux of }[X] \mbox{ in environment } [A],...,[Z] \left[\frac{mol}{m^3\ day}\right] \\
		/// V &=& \mbox{Volume of water in water storage }\left[m^3\right]
		/// \f}
		class SoluteStorage : public cmf::math::StateVariable
		{
			SoluteStorage(WaterStorage& water,const cmf::water::Solute& solute, double InitialState=0) 
				: cmf::math::StateVariable(InitialState),Storage(water),Solute(solute),AdditionalFlux(0) {}
		public:
			friend class WaterStorage;
			/// Provides an interface to other models to update the rate. This variable can be set by the += operator
			/// Unit is in \f$\frac{mol}{day}\f$, where mol is only a proxy for the unit of the solute
			real AdditionalFlux;
			SoluteStorage& operator +=(real additionalRate)
			{
				AdditionalFlux=additionalRate;
				return *this;
			}
			/// The reactions applying to this Solute(vector of pointers to Reaction objects)
			reaction::ReactionVector Reactions;
			/// The water storage to which the concentration storage belongs
			WaterStorage& Storage;
			/// The solute, which is stored in this
			const cmf::water::Solute& Solute;
			/// Returns the concentration of the solute
			real conc() const;
			virtual real Derivate(const cmf::math::Time& time);
		};
	}
}




]

%includefile "water\\WaterStorage.h" [













namespace cmf {
	namespace water {

		/// A state variable for the storage of water
		/// A class for the storage of any tracer. The state is the amount (mol, kg etc. see cmf::water) of the tracer in the storage
		/// \f{eqnarray*}
		/// \frac{dV}{dt}&=&\sum_{f=1}^{F} q_f  \\
		/// F&=& \mbox{Number of fluxes in water storage} \\
		/// q_f&=& \mbox{Water flux in } \frac{m^3}{day}	\\
		/// \f}
		/// The vector fluxes is used used by concentration to get the amount of water mixing.
		class WaterStorage : public cmf::math::StateVariable,public cmf::math::StateVariableOwner,public cmf::water::FluxNode
		{
		private:
			typedef std::vector<cmf::water::SoluteStorage*> SoluteStorageMap;
			SoluteStorageMap m_Concentrations;
			void initializeSoluteStorages();
		public:
			void AddStateVariables(cmf::math::StateVariableVector& vector);
			/// creates a water storage (abstract class)
			/// @param InitialState Initial water content in m<sup>3</sup>
			WaterStorage(double InitialState=0);
			WaterStorage(const WaterStorage& forcopy);
			
			/// Returns the water quality of the water storage.
			SoluteStorage& Solute(const cmf::water::Solute& solute);
			const SoluteStorage& Solute(const cmf::water::Solute& solute) const {return *m_Concentrations[solute.Id];}
			/// Returns the concentration of the given solute
			real conc(const cmf::water::Solute& solute) const;
			/// Returns the current WaterQuality (concentration of all solutes)
			WaterQuality conc(cmf::math::Time t);
			/// Sets a new concentration
			void conc(const cmf::water::Solute& solute,real NewConcetration)
			{
				Solute(solute).State(NewConcetration*this->State());
			}
			/// Returns the volume of water in this storage in m<sup>3</sup>
			real water() const {
				return State();
			}
			/// Sets the volume of water in this storage in m<sup>3</sup>
			void water(real newwatercontent)	{
				State(newwatercontent);
			}
			virtual std::string ToString() const	{
				return "Water storage";
			}
			virtual real Derivate(const cmf::math::Time& time) {
				return Waterbalance(time);
			}
			///@name Overrides of FluxNode
			//@{
			virtual bool RecalcFluxes(cmf::math::Time t) {return StateIsChanged();}
			virtual bool Empty() {return State()<=0;}
			virtual WaterStorage* copy() const
			{
				return new WaterStorage(*this);
			}
			//@}
		};
	}
}

%extend cmf::water::WaterStorage
{
	std::string __str__()
	{
		return $self->ToString();
	}
}




]

%includefile "Atmosphere\\Meteorology.h" [









namespace cmf {
	/// Contains classes to describe interactions with the atmosphere
	namespace atmosphere {

		/// A structure to return all parts of the incoming radiation, all values in \f$\frac{MJ}{m^2 day}\f$
		struct Weather
		{
			double
				T,					///< actual Temperature \f$T \left[^\circ C\right]\f$
				Tmax,				///< Maximum daily Temperature \f$T_{max} \left[^\circ C\right]\f$
				Tmin,				///< daily minimum Temperature	\f$T_{min} \left[^\circ C\right]\f$
				Tground,    ///< actual Temperature of the ground
				Prec,				///< Precipitation \f$P \left[\frac{mm}{day}\right] \f$
				Windspeed,	///< Windspeed \f$u \left[\frac{m}{s}\right] \f$
				e_a,				///< Actual vapor pressure \f$e_a\ [kPa]\f$
				e_s,				///< Saturated vapor pressure in \f$e_s [kPa]\f$
				sunshine,		///< Fractional sunshine duration (per potential sunshine duration) \f$\frac n N\ [-]\f$
				Rs;					///< Global Radiation in \f$R_s \left[\frac{MJ}{m^2 day}\right]\f$
			
			/// Calculates the net radiation flux  \f$R_n \left[\frac{MJ}{m^2 day}\right]\f$
			///
			/// \f{eqnarray*}
			/// R_{n} &=& R_{ns} - R_{nl} \\
			/// \mbox{ Net short wave radiation: }R_{ns} &=& (1-\alpha)	R_s \\
			/// \mbox{ Net long wave radiation: }R_{nl} &=& R_{black}\ \beta_{v}\ \beta_{c}	\\
			/// \mbox{Black body radiation: } 
			/// R_{black} &=& \left\{\begin{array}{cl} 
			///                    \sigma T^4 & \mbox{for less than daily time steps} \\
			///                    \sigma \frac {T_{max}^4 + T_{min}^4} 2  & \mbox{for daily time steps}
			///                    \end{array} \right. \\
			/// T &=& \mbox{Temperature }[K] \\
			/// \sigma &=& 4.903\ 10^{-9} \frac{MJ}{K^4 m^2 day} \mbox{ Stefan-Boltzmann constant } \\
			/// \mbox{Long wave reflectance:     } \\
			/// \mbox{by water vapor: }\beta_{v} &=& 0.34 - 0.14 \sqrt{e_a} \\
			/// \mbox{ by clouds: }\beta_{c} &=& 0.1 + 0.9 \frac n N  
			/// \f}
			/// @param albedo the albedo \f$\alpha\f$ of the surface
			/// @param daily If true, the net radiation for daily averages will be calculated
			double Rn(double albedo,bool daily=false);

		};


		/// In order to calculate ETpot with cmf a big amount of meteorological data is needed,
		/// more data than usually available. The Meteorology class can estimate missing data
		/// from a minimal set. As more data, as one provides, the better the calculation of
		/// ETpot becomes. The minimal data needed is Tmin and Tmax (daily) and precipitation.
		/// To calculate the global radiation (although measured global radiation could be inserted),
		/// the position of meteorological station in geographic coordinates has to be set.
		/// 
		/// 
		/// There are two modes for the meteorology: daily=true and daily=false. If daily=true,
		/// Radiation is given as a daily mean value. If daily=false, Radiation is given as
		/// an hourly mean value, which shows the dial ETpot variation but results in erronous
		/// results if the timestep is daily.
		/// 
		/// 
		/// In the following, we will assume a meteorological station with given Tmin, Tmax,
		/// precipitation and daily mean relative humidity. To use other meteorological data,
		/// please consult the description of the Meteorology class in the API documentation
		/// <h3>
		/// Creating a meteorological station</h3>
		/// <div class="fragment">
		/// <pre class="fragment">
		/// import CMFlib as cmf
		/// latitude=51.2 # Latitude of station in decimal degrees
		/// longitude=8.1 # Longitude of station in decimal degrees (only needed for daily=false)
		/// timezone=1    # Timezone, pos. values mean east of GMT, negative west (Germany=1, Pacific time=-8, only needed for daily=false)
		/// start=cmf.Time(1,1,2001) # Creates all timeseries with this start time, one can change them later
		/// step=cmf.day             # s. start
		/// name="Giessen"           # A name for the station (optional)
		/// meteo=cmf.Meteorology(latitude,longitude,timezone,start,step,name)</pre>
		/// </div>
		/// 
		/// The daily flag is automatically set to true, since the step width is &ge cmf.day
		/// <h3>
		/// Loading data into the meteorological station</h3>
		/// <div class="fragment">
		/// <pre class="fragment">
		/// # MeteoData.txt is tab seperated file containing 
		/// # Tmin [deg C],Tmax [deg C],rHmean [%] and precipitation [mm/day] values for every day
		/// f=file('MeteoData.txt')
		/// for line in file:
		/// meteo.Tmin.Add(float(line.split('\\t')[0]))
		/// meteo.Tmax.Add(float(line.split('\\t')[1]))
		/// meteo.rHmean.Add(float(line.split('\\t')[2]))
		/// meteo.Prec.Add(float(line.split('\\t')[3]))</pre>
		/// </div>
		/// <h3>
		/// Using a meteorological station</h3>
		/// <div class="fragment">
		/// <pre class="fragment">
		/// weather=meteo.GetData(cmf.Time(3,2,2001,14)) # Weather at Feb. 3rd, 2001, 2pm
		/// print 'Global Radiation: ',weather.Rs	       # Daily mean Rs, since daily=true
		/// print 'Temperature:',weather.T               # Daily mean T, since nothing else in known
		/// </pre>
		/// </div>

		class Meteorology
		{
		private:
			double vapour_pressure(double T) const;
			
		public:
			///@name Location and behaviour properties
			//@{
			double 
				Latitude,			///< Latitude in dec. deg.
				Longitude,			///< Longitude in dec. deg.
				Timezone,	///< Time zone, 1 Germany, 0 UK, -8 Pacific U.S.
				Elevation;   ///< elevation of the station in m a.s.l.

			std::string 
				Name; ///< Name of the Station
			bool daily;
			//@}
			/// Constructor of the Atmosphere object
			/// @param latitude Latitude of the study area (for solar radiation)
			/// @param longitude Longitude of the study area (for solar time)
			/// @param timezone Time zone of the study area (e.g Germany +1,U.S. Pacific time -8
			/// @param elevation Height of the meterological station above sea level [m]
			/// @param startTime Date of the beginning of the climatic data (may be changed for each time series later)
			/// @param timestep Frequency of climatic data (may be changed for each time series later)
			/// @param name Name of the station
			Meteorology(double latitude=51,double longitude=8,double timezone=1,double elevation=0,
				cmf::math::Time startTime=cmf::math::Time(1,1,2001),cmf::math::Time timestep=cmf::math::day,std::string name="");
			///@name Data access methods
			//@{
			/// Calculates the mean pressure for a specific height
		  static double Pressure(double height);
			/// Returns the current Atmosphere state. Uses default values for missing timeseries
			Weather GetData(cmf::math::Time t,double height) const;
			
			/// Returns the global radiation at a given time step \f$ R_s \frac{MJ}{m^2day}\f$, see http://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
			/// \f{eqnarray*}
			/// \phi &=& \frac{(\mbox{geogr. Latitude})^\circ \pi}{180^\circ} \mbox{ Latitude in }rad \\
			/// \delta &=& 0.409 \sin\left(\frac{2\pi}{365}DOY - 1.39\right) \mbox{ Declination, DOY is day of year}\\
			/// \omega_s &=& \arccos(-\tan\phi\tan\delta) \mbox{ Sunset angle} \\
			/// G_{sc} &=& 0.0802 \frac{MJ}{m^2min} \mbox{Solar constant} \\
			/// d_r &=& 1+0.033 \cos\left(\frac{2\pi}{365}DOY\right) \mbox{Inverse relative distance Earth-Sun} \\
			/// b &=& \frac{2\pi(DOY-81)}{364}\\
			/// S_c &=& 0.1645\sin(2b)-0.1255\cos(b)-0.025\sin(b) \mbox{ Seasonal correction for solar time} \\
			/// \omega &=& \frac {\pi} {12}	\left(t_h+\frac{(\mbox{geogr. Longitude})^\circ}{15}-\mbox{Timezone}+S_c-12\right) \mbox{ solar time in }rad \\
			/// \mbox{If daily}  \\
			/// R_a &=& \frac{24\ 60}{\pi}G_{sc}\ d_r \left(\omega_s \sin\phi \sin\delta + \cos\phi \cos\delta \sin\omega_s\right) \mbox{Extraterrestrial radiation } \frac{MJ}{m^2 day} \\
			/// \mbox{If hourly} \\
			/// R_a &=& \frac{12\ 24\ 60}{\pi}G_{sc}\ d_r \left(\left(\omega^+ -\omega^-\right) \sin\phi \sin\delta + \cos\phi \cos\delta \left(\sin\omega^+ - \sin\omega^-\right)\right) \\
			/// && \omega^+,\omega^- = \omega \pm\frac{\pi}{24} \\
			/// \frac n N &=& \mbox{Fractional sunshine duration}		 \\
			/// R_s &=& \left(0.25+\left(0.5+2\ 10^{-5}z\right)\frac{n}{N}\right)R_a \mbox{Global radiation in }\frac{MJ}{m^2 day} \\ 
			/// && z=\mbox{Height a.s.l. in }m \\
			/// \f}
			double GetRs(cmf::math::Time t,double height,double sunshine_fraction) const;
			
			double GetRn(double albedo,double Rs,double Tmax, double Tmin, double T,double e_a,double sunshine_fraction) const;
			/// Returns the net radiation flux at a site, see http://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
			/// \f{eqnarray*}
			/// R_{ns} &=& (1-\alpha)R_s \mbox{ Net shortwave radiation in }	\frac{MJ}{m^2 day} \\
			/// && \alpha = \mbox{ Albedo}	\\
			/// \sigma &=& 4.903\ 10^{-9} \frac{MJ}{m^2 K^4 day} \mbox{ Stefan-Boltzmann constant}\\
			/// \sigma T^4 &=& \sigma\left((T_{max}+273.16)^4+(T_{min}+273.16)^4\right) \mbox{ if daily} \\
			/// \sigma T^4 &=& \sigma \left(T+273.16\right)^4 \mbox{ if hourly} \\
			/// R_{nl}&=&\sigma(T) \left(0.34-0.14\sqrt{e_a}\right) \left(0.1+0.9\frac{n}{N}\right) \\
			/// R_n&=& R_{ns}-R_{nl} \\
			/// \f}
			/// @param albedo Albedo of the surface\f$\alpha\f$
			/// @param w A Weather structure provided from GetData			
			double GetRn(double albedo,Weather w)
			{
				return GetRn(albedo,w.Rs,w.Tmax,w.Tmin,w.T,w.e_a,w.sunshine);
			}
			/// Calculates a timeseries of the sunshine fraction (to put into Sunshine) from a timeseries of absolute sunshine duration, using the potential sunshine duration in hours,
			/// see http://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
			/// \f{eqnarray*}
			/// \phi &=& \frac{(\mbox{geogr. Latitude})^\circ \pi}{180^\circ} \mbox{ Latitude in }rad \\
			/// \delta &=& 0.409 \sin\left(\frac{2\pi}{365}DOY - 1.39\right) \mbox{ Declination, DOY is day of year}\\
			/// \omega_s &=& \arccos(-\tan\phi\tan\delta) \mbox{ Sunset angle} \\
			/// N &=& \frac{24}{\pi}\omega_s \mbox{ potential duration of sunshine in }h \\
			/// \frac n N && n\mbox{Absolute sunshine duration}
			/// \f}
			void SetSunshineFraction(cmf::math::timeseries sunshine_duration); 

			//@}
			/// @name Additional properties
			//@{
			/// Slope of temperature/height regression. Typical values are \f$ -0.0004 .. -0.001 \frac{^\circ C}{m} \f$, default is \f$ 0\frac{^\circ C}{m} \f$ (no temperature adjusting)
			double temp_height_slope;
			//@}
			/// @name Timeseries of meteorological data
			//@{
			cmf::math::timeseries
				/// Timeseries of daily precipitation in \f$ P \left[\frac{mm}{day}\right] \f$	<b>Requiered</b>
				Prec,
				/// Timeseries of Temperature \f$ T\left[^\circ C\right] \f$ <b>Optional, can be calculated from </b> \f$ T=\frac{T_{max} + T_{min}} 2 \f$
				T,
				/// Timeseries of daily maximum Temperature \f$ T_{max} \left[^\circ C\right] \f$ 
				/// <b>Requiered, but you can generate it from Generate TminTmax if a high resolution timeseries T is available</b>
				Tmax,
				/// Timeseries of daily minimum Temperature \f$ T_{min}\left[^\circ C\right] \f$ 
				/// <b>Requiered, but you can generate it from Generate TminTmax if a high resolution timeseries T is available</b>
				Tmin,
				/// Timeseries of upper soil temperature \f$ T_{ground}\left[^\circ C\right] \f$
				/// <b> Optional</b>, if missing \f$ T_{ground} = T \f$
				Tground,
				/// Timeseries of incoming solar energy in \f$ R_s \left[\frac{MJ}{m^2 day}\right]\f$. <b>Requiered, but can be generated with GenerateRadiation</b>
				Windspeed,
				/// Timeseries of relative mean Humidity  \f$ rH_{mean} \left[\%\right] \f$ <b>Optional, not used if rHmax or Tdew is available</b>
				rHmean,
				/// Timeseries of daily minimum relative Humidity \f$ rH_{min} \left[\%\right] \f$ <b>Optional, only used if rHmax is used </b>
				rHmin,
				/// Timeseries of daily maximum relative Humidity \f$ rH_{max} \left[\%\right] \f$	 <b>Optional, not used if Tdew is available</b>
				rHmax,
				/// Timeseries of dew point temperature \f$ T_{dew}\left[^\circ C\right]\f$					<b>Optional, if neither Tdew, rHmax or rHmean is available then Tdew = Tmin</b>
				Tdew,
				/// Fractional sunshine \f$\frac{n}{N}\f$. Sunshine duration per potential sunshine duration<b>Optional, if not present 0.5</b>
				/// If you have the total duration of sunshine, use CalcSunshineFraction. If you have cloud coverage instead of total sunshine duration you may assume
				/// that the fractional sunshine duration equals 1-cloudfraction
				Sunshine,
				/// Global Radiation in \f$ \frac{MJ}{m^2 day} \f$ <b> Optional, if not available GetRs is used</b>
				Rs;


			/// Map of time series of rainfall concentrations. 
			///
			/// Usage: 
			/// @code
			/// meteo.Deposition[Solute].Add(3.0);
			/// double d=meteo.Deposition[Solute][Time];
			/// @endcode
			cmf::water::SoluteTimeseries Deposition;
			/// Returns the rainfall with its current concentration. The concentration is derived from Deposition
			cmf::water::WaterFlux GetDeposition(cmf::math::Time t);
			//@}
			/// @name I/O
			//@{
			/// Save the Meteorology data to an ASCII File with fixed format(	 uses cmf::math::timeseries::Save )
			void Save(const std::string& filename);
			/// Creates a Meterology from a File in fixed format (uses cmf::math::timeseries::timeseries(std::istream&) )
			explicit Meteorology(const std::string& filename);
			//@}

		};
	}	
}

%extend cmf::atmosphere::Meteorology {
	%insert("python")
{
    def TimeseriesDictionary(self):
        return {"Tmin":self.Tmin,
                "Tmax":self.Tmax,
                "Tdew":self.Tdew,
                "T":self.T,
                "Prec":self.Prec,
                "rHmean":self.rHmean,
                "rHmax":self.rHmax,
                "rHmin":self.rHmin,
                "Sunshine":self.Sunshine,
                "Windspeed":self.Windspeed,
								"Rs" : self.Rs}
}
}




]


// Get Upslope Classes
%includefile "upslope\\soil\\RetentionCurve.h" [



namespace cmf {
	namespace upslope {
		const double rho_wg=9810; // Pa/m
		/// Converts a pressure in Pa to a lenght of a water column in m
		double pressure_to_waterhead(double Pressure);
		/// Converts a height of a water column in m to a pressure in Pa
		double waterhead_to_pressure(double waterhead);
		/// Converts a pF value to a height of a water column in m
		double pF_to_waterhead(double pF);
		/// Converts a height of a water column to a pF value
		double waterhead_to_pF(double waterhead);

		/// Abstract base class for different types of retention curves
		///
		/// This class, and its children uses wetness instead of volumetric water content. The wetness of a soil is defined as water content per void volume
		class RetentionCurve {
		public:
			/// Returns the conductivity in m/day at a certain depth and water content
			virtual real K(real wetness,real depth) const = 0;
			/// Returns the porosity at a certain depth
			virtual real Porosity(real depth) const = 0;
			/// Returns the void volume of a soil column
			virtual real VoidVolume(real upperDepth,real lowerDepth,real Area) const = 0;
			/// Returns the thickness of a soil column with a certain pore volume
			virtual real FillHeight(real lowerDepth,real Area,real Volume) const =0;
			/// Returns the transmissivity of a part of a soil column
			virtual real Transmissivity(real upperDepth,real lowerDepth,real theta) const = 0;
			/// returns the wetness (volumetric water content per pore space) at a given suction pressure
			virtual real Wetness(real suction) const = 0;
			/// returns the volumetric water content at a given pF value
			real Wetness_pF(real pF) const {return Wetness(pF_to_waterhead(pF));}
			/// returns the wetness of the soil at given water content
			virtual real MatricPotential(real wetness) const = 0;
			virtual RetentionCurve* copy() const=0;

		};
		/// Provides the use of the Brooks-Corey retention curve
		/// \f{eqnarray*}
		/// W(\theta) &=& \frac{\theta - \theta_r}{\theta_s - \theta_r} \\
		/// K(W) &=& K_{sat} W^{2+3b} \\
		/// \Psi(W) &=& \Psi_X \left(\frac{W}{W_X}\right)^{-b} \\
		/// W(\Psi) &=& {\left( \frac{\Psi_X}{\Psi}\right) }^{\frac{1}{b}}\ W_X
		/// \f}	
		/// where:
		/// - \f$K\f$ is the conductivity in \f$\frac m {day}\f$
		/// - \f$W\f$ is the wetness (Volume of soil water per volume of pores)
		/// - \f$b\f$ is the shape of the retention curve (usually between 4 (sand) and 14 (clay))
		/// - \f$\Psi(W)\f$ is the matric potential in \f$m H_2O\f$ at wetness W
		/// - \f$\Psi_X\f$ is a matric potential at a known wetness	in \f$m H_2O\f$
		/// - \f$W_X\f$ is the wetness with a known matric potential
		///	for dynamic changes with depth, exponential decays of porosity and saturated conductivity are used
		/// The decay function is: \f$ v(d)=v(0) (1+a)^{-d} \f$, where v is the value (\f$ K_{sat},\Phi\f$), d is the depth in m
		/// and a is the fractional decay per m. E.g. 0.1 means the value has in 1 m depth 90% of the value at the surface
		class BrooksCoreyRetentionCurve : public RetentionCurve
		{
		private:
			real m_Ksat;
			real m_KsatDecay;
		public:
			virtual real K(real wetness,real depth) const;
			real SetKsat(real ksat,real ksat_decay)
			{
				m_Ksat=ksat;
				m_KsatDecay=ksat_decay;
			}
		private:
			real m_Porosity;
			real m_PorosityDecay;
			real m_m,m_Wi,m_Psi_i,m_n,m_b;
			void Set_Saturated_pF_curve_tail_parameters();
		public:
			/// real (Porosity)
			real Porosity(real depth) const;
			/// Sets the porosity (Volume of pores per volume of soil) and the exponential porosity decline with depth
			void SetPorosity(real porosity,real porosity_decay=0);
			/// Returns the pore volume in a region of a soil column
			/// 
			/// If there is a porosity decay, the void volume is the integral of porosity over depth times area
			real VoidVolume(real upperDepth,real lowerDepth,real Area) const;
			
			real FillHeight(real lowerDepth,real Area,real Volume) const;
			real Transmissivity(real upperDepth,real lowerDepth,real theta) const;
			/// Wetness at a known point of the retention curve
			real wetness_X;
			/// Matric potential at the wetness X in m
			real Psi_X;
			/// Retention curve shape parameter
			real b() const { return m_b;}
			void Set_b(real new_b) {
				m_b=new_b;
				Set_Saturated_pF_curve_tail_parameters();

			}
			/// Returns the suction pressure in m, use conversion functions waterhead_to_pressure and waterhead_to_pF fro conversions
			real MatricPotential(real wetness) const;
			real Wetness(real suction) const;
			/// Creates a brooks corey retention curve
			/// @param ksat Saturated conductivity \f$\frac{m}{day}\f$
			/// @param porosity \f$\frac {m^3 Pores}{m^3 Soil}\f$
			/// @param _b Shape of the retention curve (if you do not know how to parameterize this, take a look at the other constructor)
			/// @param theta_x \f$\theta_X\f$ Water content at a specific suction pressure
			/// @param psi_x Suction pressure for \f$\theta_X\f$ in m water column, use the conversion functions pF_to_waterhead, pressure_to_waterhead to convert pressure in to waterhead height (default pF=2.5)
			/// @param ksat_decay Relative decay of conductivity with depth, e.g. 0.1 means conductivity gets 10% smaller per meter
			/// @param porosity_decay Relative decay of porosity with depth, e.g. 0.1 means conductivity gets 10% smaller per meter
			BrooksCoreyRetentionCurve(real ksat=15,real porosity=0.5,real _b=5,real theta_x=0.2,real psi_x=pF_to_waterhead(2.5),real ksat_decay=0,real porosity_decay=0);

			/// Creates a soiltype from two known points of the retention curve (e.g. fieldcapacity and wilting point)
			/// @param ksat Saturated conductivity \f$\frac{m}{day}\f$
			/// @param porosity \f$\frac {m^3 Pores}{m^3 Soil}\f$
			/// @param theta1 \f$\theta_1\f$ First water content at a specific suction pressure (e.g. fieldcapacity)
			/// @param theta2 \f$\theta_2\f$ Second water content at a specific suction pressure (e.g. wiltingpoint)
			/// @param psi_1 \f$ \Psi_1\f$ Suction pressure for \f$\theta_1\f$ in m water column, use the conversion functions pF_to_waterhead, pressure_to_waterhead to convert pressure in to waterhead height (default pF=2.5)
			/// @param psi_2 \f$ \Psi_2\f$ Suction pressure for \f$\theta_2\f$ in m water column, use the conversion functions pF_to_waterhead, pressure_to_waterhead to convert pressure in to waterhead height (default pF=4.2)
			///
			/// The parameter b (shape of the retention curve) is calculated by:
			/// \f[ b = \frac{\log\left(\frac{\Psi_1}{\Psi_2}\right)}{\log\left(\frac{\theta_2}{\theta_1}\right)} \f]
			static BrooksCoreyRetentionCurve CreateFrom2Points(real ksat,real porosity,real theta1,real theta2,real psi_1=pF_to_waterhead(2.5),real psi_2=pF_to_waterhead(4.2));
			virtual BrooksCoreyRetentionCurve* copy() const
			{
				return new BrooksCoreyRetentionCurve(m_Ksat,m_Porosity,b(),wetness_X*m_Porosity,Psi_X,m_KsatDecay,m_PorosityDecay);
			}
		};
	}
}




]
// Need a ret curve profile
%includefile "upslope\\SoilWaterStorage.h" [










namespace cmf {
	namespace upslope {
		/// A representation of a Layer
		class SoilWaterStorage: public cmf::water::WaterStorage,public HasCellReference
		{
		protected:
			double m_upperboundary,m_lowerboundary;
			std::auto_ptr<cmf::upslope::RetentionCurve> m_retentioncurve;
		protected:

		public:
			/// Returns the upper boundary of the water storage below ground in m
			virtual double UpperBoundary() const {return m_upperboundary;}
			/// Returns the lower boundary of the water storage below ground in m
			virtual double LowerBoundary() const {return m_lowerboundary;}
			double Thickness() const {return LowerBoundary()-UpperBoundary();}
			/// Returns the soil properties of the water storage
			virtual const RetentionCurve& Soil() const {return *m_retentioncurve;}
			virtual RetentionCurve& Soil() {return *m_retentioncurve;}
			/// Returns the actual volumetric water content of the water storage
			virtual real theta() const;
			virtual void theta(real Value)
			{
				State(Value*cell.Area()*Thickness());
			}
			/// Returns the actual conductivity	\f$\frac{m}{day}\f$
			double K() const;
			double Ksat() const;
			/// Returns the wetness of the soil \f$ \frac{V_{H_2O}}{V_{pores}} \f$
			virtual double Wetness() const;
			/// Calls RetentionCurve::Matrixpotential
			virtual real MatrixPotential() const;
			/// Gravitational Potential in m, reference height is sea level. If the layer is saturated, it returns the saturated depth above sea level, otherwise it returns the upperboundary of the layer
			/// \f[ \Psi_G=h \f]
			real GravitationalPotential() const;
			/// Returns the capacity of the water storage in m3
			virtual real Capacity()
			{
				return Soil().VoidVolume(UpperBoundary(),LowerBoundary(),cell.Area());
			}
			/// Sets the potential of this soil water storage
			void SetPotential(real waterhead);
			/// Returns the total potential in m
			/// \f[ \Psi = \Psi_M + \Psi_G \f]
			virtual real Potential() const;
			
			/// Calculates the shared crosssectional area of this and another soil water storage.
			///
			/// If both layers belong to the same cell, the area of the cell is returned, if they belong to different cells the area of the vertical shared boundary is returned
			/// @returns   Area in m2
			/// @param target The other soil water storage
			/// @param HorizontalLayers If true, the layers are assumed to be parallel to the gravitational potential, otherwise they are assumed to be parallel to the ground topography
			real GetFlowCrosssection(const cmf::upslope::SoilWaterStorage& target,bool HorizontalLayers=false) const
			{
				if (&cell == &target.cell)
				{
					return cell.Area();
				}
				else if (HorizontalLayers)
				{
					double w=cell.flowwidth(target.cell);
					real upper=minimum(cell.Center().z - UpperBoundary(),target.cell.Center().z - target.UpperBoundary());
					real lower=maximum(cell.Center().z - LowerBoundary(),target.cell.Center().z - target.LowerBoundary());
					return upper<lower ? (lower-upper)*w : 0;
				}
				else
				{
					double w=cell.flowwidth(target.cell);
					real upper=maximum(UpperBoundary(),target.UpperBoundary());
					real lower=minimum(LowerBoundary(),target.LowerBoundary());
					return upper<lower ? (lower-upper)*w : 0;
				}
			}
			
			SoilWaterStorage* copy()
			{
				return new SoilWaterStorage(cell,m_upperboundary,m_lowerboundary,*m_retentioncurve);
			}

			SoilWaterStorage(cmf::upslope::Cell & _cell,real lowerboundary,const RetentionCurve& r_curve,real saturateddepth=-10) 
				: cmf::water::WaterStorage(0),cmf::upslope::HasCellReference(_cell),m_retentioncurve(r_curve.copy()),
				m_lowerboundary(lowerboundary)
			{
				Location=cmf::geometry::point(_cell.Center().x,_cell.Center().y,_cell.Center().z - lowerboundary);
				m_upperboundary = cell.LayerCount()>0 ? cell.Layer(-1).LowerBoundary() : 0;
				if (m_lowerboundary-m_upperboundary<=0)
					throw std::runtime_error("0 m thickness of layer");
				SetPotential(cell.Center().z - saturateddepth);
				cell.AddLayer(this);
				std::stringstream sstr;
				sstr << "Layer " << UpperBoundary() << "-" << LowerBoundary() << "m @(" << cell.Center().x << "," << cell.Center().y << "," << cell.Center().z << ")";
				Name=sstr.str();
			}

		protected:
			SoilWaterStorage(cmf::upslope::Cell & _cell,real upperBoundary,real lowerboundary,const RetentionCurve& r_curve) 
				: cmf::water::WaterStorage(0),cmf::upslope::HasCellReference(_cell),m_retentioncurve(r_curve.copy()),
				  m_lowerboundary(lowerboundary),m_upperboundary(upperBoundary)
			{	}
			/// Invalidates the saturated depth of the cell
			virtual void StateChangeAction()
			{
				cell.InvalidateSatDepth();
			}

		};

		class FlexibleSizeLayer;
		/// A soil water storage with a flexible (non constant) upper boundary, according to its fill state. 
		/// This soil water storage is always saturated
		class FlexibleSizeSaturatedZone : public SoilWaterStorage
		{
		private:
			cmf::upslope::FlexibleSizeLayer* upperLayer;
			/// Creates	two soilwaterstorages and registers them with the owning cell. The boundary between the two layers is flexible and
			/// changes with saturation. The lower layer is always saturated, the upper never. A UnsatSatconnection connects both layers
			FlexibleSizeSaturatedZone(Cell& cell,real lowerboundary,const RetentionCurve& r_curve);

		public:
			/// Returns the current upper boundary of this layer (function of state)
			virtual double UpperBoundary() const;
			static FlexibleSizeSaturatedZone* Create(Cell& cell,real lowerboundary,const RetentionCurve& r_curve);

		};
		/// A soil water storage above a FlexibleSizeSaturatedLayer, can only be created by FlexibleSaturatedLayer
		class FlexibleSizeLayer : public SoilWaterStorage
		{
		private:
			cmf::upslope::SoilWaterStorage* belowLayer;
			friend class FlexibleSizeSaturatedZone;
			FlexibleSizeLayer(cmf::upslope::Cell & cell,real upperboundary,real lowerboundary,const RetentionCurve & r_curve,cmf::upslope::FlexibleSizeSaturatedZone* LayerBelow);
		public:
			virtual real LowerBoundary() const { return belowLayer ? belowLayer->UpperBoundary() : UpperBoundary()+0.001;}

		};


	}
}



]
%includefile "upslope\\Vegetation\\StructVegetation.h" [


namespace cmf {
	namespace upslope{
		namespace vegetation {
			struct Vegetation{
				double 
					LAI,
					Height,
					albedo,
					CanopyCapacityPerLAI,
					RootDepth,
					StomatalResistance,
					CanopyClosure,
					LeafWidth;
				virtual double RootFraction(double upperBoundary,double lowerBoundary) const
				{
					if (RootDepth<=0. || upperBoundary>RootDepth || upperBoundary>lowerBoundary)
						return 0.;
					else if (lowerBoundary>RootDepth)
						return (RootDepth-upperBoundary)/RootDepth;
					else
						return (lowerBoundary-upperBoundary)/RootDepth;
				}
				Vegetation(double _LAI=12,double _Height=0.12,double _RootDepth=0.25,double _StomatalResistance=100,
					double _albedo=0.23,double _CanopyClosure=1,double _CanopyCapacityPerLAI=0.01)
					: LAI(_LAI),Height(_Height),albedo(_albedo),
					  CanopyCapacityPerLAI(_CanopyCapacityPerLAI),
						RootDepth(_RootDepth),StomatalResistance(_StomatalResistance),
						CanopyClosure(_CanopyClosure)
				{}
			};			

		}		
	}	
}




]
%includefile "upslope\\cell.h" [









namespace cmf {
	namespace upslope {
		class SoilWaterStorage;
		class Cell;
		class NeighborIterator_const
		{
		private:
			std::map<Cell*,double>::const_iterator current;
		public:











			const Cell& cell() {return *current->first;}
			double flowwidth() {return current->second;}
			NeighborIterator_const& next(){ ++current; return *this;}

			/// Points the iterator to the next neighbor
		};
		class NeighborIterator
		{
		private:
			std::map<Cell*,double>::iterator current;
		public:











			Cell& cell() {return *current->first;}
			double flowwidth() {return current->second;}
			NeighborIterator& next(){ ++current; return *this;}
			/// Points the iterator to the next neighbor
			NeighborIterator& operator++(){ ++current; return *this;}
			operator NeighborIterator_const() {return NeighborIterator_const(current);}
		};

		class Cell : public cmf::math::StateVariableOwner {
			/// @name Location
			//@{
			cmf::geometry::point m_Center;
		public:
			/// Returns the location of the cell
			cmf::geometry::point Center() const { return m_Center; }
		private:
			cmf::geometry::Polygon m_Geometry;
		public:
			/// Returns the shape of the cell
			cmf::geometry::Polygon Geometry() const { return m_Geometry; }
			/// Sets the shape of the cell
			void Geometry(cmf::geometry::Polygon val) { m_Geometry = val; }
		private:
			double m_Area;
			real m_SatDepth;
		public:
			/// Returns the area of the cell
			double Area() const { return m_Area; }
			/// Marks the saturated depth as unvalid
			void InvalidateSatDepth() {m_SatDepth=-1e20;}
			/// 
			real SaturatedDepth() ;
		private:
			//@}
			/// @name Flux nodes of the cell
			//@{
			typedef std::auto_ptr<cmf::water::FluxNode> NodePointer;
			NodePointer m_ET;
			NodePointer m_Canopy;
			NodePointer m_Snow;
			NodePointer m_SnowWater;
			NodePointer m_SurfaceWater;
		public:
			/// Returns the end point of all evapotranspiration of this cell
			cmf::water::FluxNode& ET()						{ return *m_ET;}
			/// Returns the canopy of this cell
			cmf::water::FluxNode& Canopy()				{ return *m_Canopy;}
			/// Returns the snow of this cell
			cmf::water::FluxNode& Snow()					{ return *m_Snow;}
			/// Returns the snow water of this cell
			cmf::water::FluxNode& SnowWater()     { return *m_SnowWater;}
			/// returns the surface water of this cell
			cmf::water::FluxNode& SurfaceWater()	{ return *m_SurfaceWater;}
			/// Exchanges the type of canopy storage
			void SetCanopy(const cmf::water::FluxNode& newObject);
			void SetSnow(const cmf::water::FluxNode& newObject);
			void SetSnowWater(const cmf::water::FluxNode& newObject);
			void SetSurfaceWater(const cmf::water::FluxNode& newObject);
		cmf::upslope::vegetation::Vegetation Vegetation;
		real albedo()
		{
			if (Snow().Empty())
				return Vegetation.albedo;
			else
				return 0.9;
		}
		private:
			//@}
			/// @name Topology
			//@{
			typedef std::map<Cell*,double> mapNeighbor;
			mapNeighbor m_Neighbors;
			double m_CatchmentSize;
			Cell* m_MainOutlet;
		public:
			double flowwidth(Cell & target)
			{
				mapNeighbor::const_iterator it_n = m_Neighbors.find(&target);
				if (it_n==m_Neighbors.end())
					return 0;
				else
					return it_n->second;
			}
			void AddNeighbor(Cell & target,double flowwidth)
			{
				m_Neighbors[&target]=flowwidth;
			}
			void RemoveNeighbor(Cell & target)
			{
				if (m_Neighbors.find(&target)!=m_Neighbors.end())
				{
					m_Neighbors.erase(&target);
					target.RemoveNeighbor(*this);
				}
			}
			NeighborIterator neighbor_begin() {return NeighborIterator(m_Neighbors.begin());}
			NeighborIterator neighbor_end() {return NeighborIterator(m_Neighbors.end());}
			NeighborIterator_const neighbor_begin() const {return NeighborIterator_const(m_Neighbors.begin());}
			NeighborIterator_const neighbor_end() const {return NeighborIterator_const(m_Neighbors.end());}
//			NeighborIterator_const Neighbors() const { return NeighborIterator(m_Neighbors.begin(),m_Neighbors.end());}
			size_t neighbor_count() const { return m_Neighbors.size();}
			Cell * MainOutlet(bool forceRecalc=false);
			double ContributingArea(bool forceRecalc=false);
			//@}
			///@name Layers
			//@{
			std::vector<SoilWaterStorage*> m_Layers;
		public:
			int LayerCount() const
			{
				return int(m_Layers.size());
			}
			cmf::upslope::SoilWaterStorage& Layer(int ndx)
			{
				if (ndx<0) ndx=LayerCount()+ndx;
				return *m_Layers.at(ndx);
			}
			const cmf::upslope::SoilWaterStorage& Layer(int ndx) const
			{
				if (ndx<0) ndx=LayerCount()+ndx;
				return *m_Layers.at(ndx);
			}




			virtual ~Cell();
			//@}


			Cell(double x,double y,double z,double area) 
				: m_Center(x,y,z),m_Area(area),
					m_ET(new cmf::water::FluxNode),
					m_Canopy(new cmf::water::FluxNode),
					m_Snow(new cmf::water::FluxNode),
					m_SnowWater(new cmf::water::FluxNode),
					m_SurfaceWater(new cmf::water::FluxNode)
			{
				m_ET->Name="ET";
				m_Canopy->Name="Canopy";
				m_Snow->Name="Snow";
				m_SnowWater->Name="SnowWater";
				m_SurfaceWater->Name="SurfaceWater";
				new cmf::water::RouteWaterBalanceConnection(Canopy(),Snow());
				new cmf::water::RouteWaterBalanceConnection(Snow(),SnowWater());
				new cmf::water::RouteWaterBalanceConnection(SnowWater(),SurfaceWater());
			}
			std::string ToString()
			{
				std::stringstream sstr;
				sstr << "(" << Center().x << "," << Center().y << "," << Center().z << ")";
				return sstr.str();
			}
			//@}
			void AddStateVariables(cmf::math::StateVariableVector& vector);
		};
		class HasCellReference
		{
		public:
			Cell& cell;
			HasCellReference(Cell& _cell) : cell(_cell) {}
		};
		
	}
	
}

%extend cmf::upslope::NeighborIterator
{
	bool __eq__(const NeighborIterator& cmp) {return (*$self)==cmp;}
	bool __neq__(const NeighborIterator& cmp) {return (*$self)!=cmp;}
}
%extend cmf::upslope::Cell
{
%pythonextend
    {
    def neighbors(self):
        c_iter=self.neighbor_begin()
        c_end=self.neighbor_end()
        while c_iter!=c_end:
            yield (c_iter.cell(),c_iter.flowwidth())
            c_iter.next()
    }
}




]
%extend cmf::upslope::Cell
{
	std::string __str__() {return $self->ToString();}
	cmf::upslope::SoilWaterStorage* __getitem__(int i) {return $self->Layer(i);}
}
%includefile "upslope\\connections\\FluxConnections.h" [






namespace cmf {
	namespace upslope {
		namespace connections {
			/// Connects the surfacewater and the most upper layer
			///
			/// If UpslopeCell::InfiltrationExcess and Cell is not saturated 
			/// \f[ K_I = \min\left(\frac{\rho_{wg} \Delta z-\Psi_M}{\Delta z \rho_{wg}} K\left(\theta\right),\sum q_{surface\ in}\right) \f]
			/// else
			/// \f[ K_I = \sum q_{surface\ in} \f]
			class MatrixInfiltration : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::SoilWaterStorage& m_soilwater;
				cmf::water::FluxNode& m_surfacewater;
				virtual real calc_q(cmf::math::Time t);
			public:
				MatrixInfiltration(cmf::upslope::SoilWaterStorage& soilwater,cmf::water::FluxNode& surfacewater) 
					: FluxConnection(surfacewater,soilwater),m_soilwater(soilwater),m_surfacewater(surfacewater) {}
			};
			class CompleteInfiltration : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::SoilWaterStorage& m_soilwater;
				cmf::water::FluxNode& m_surfacewater;
				virtual real calc_q(cmf::math::Time t);
			public:
				CompleteInfiltration(cmf::upslope::SoilWaterStorage& soilwater,cmf::water::FluxNode& surfacewater) 
					: FluxConnection(surfacewater,soilwater),m_soilwater(soilwater),m_surfacewater(surfacewater) {}

			};
			/// Calculates the flux from the unsaturated zone to the saturated zone
			/// by vertical outflow from the unsaturated zone and 
			/// water exchange by water table changes
			///
			/// \f{eqnarray*}
			/// K_u &=& K(\theta) A \\
			/// Ex_w &=& \frac{dz_{sat}}{dt\ \Delta Z_{layer}} V_{layer} \\
			/// \frac{dz_{sat}}{dt} &=& \frac{ \sum q_{Saturated}}{ A \Phi} \\
			/// \f}
			/// where:
			/// - \f$ A \f$ is the area of the cell
			/// - \f$ K(\theta) \f$ is the unsaturated conductivity (see SoilType::Kunsat )
			/// - \f$ \Delta Z \f$ is the thickness of a layer
			/// - \f$ V \f$ is the volume of water in a layer
			/// - \f$ layer \f$ is the unsaturated zone if \f$ \frac{dz_{sat}}{dt} \f$ is positive, otherwise layer is the saturated zone
			/// - \f$ \sum q \f$ is the water balance of the saturated zone
			/// - \f$ \Phi \f$ is the porosity
			class UnsatSatConnection : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::FlexibleSizeLayer& m_unsat;
				cmf::upslope::FlexibleSizeSaturatedZone& m_sat;
				virtual real calc_q(cmf::math::Time t);
			public:
				/// Creates a connection between unsaturated and saturated zone
				UnsatSatConnection(cmf::upslope::FlexibleSizeLayer& unsat,cmf::upslope::FlexibleSizeSaturatedZone& sat) 
					: FluxConnection(unsat,sat), m_unsat(unsat),m_sat(sat) {}
			};

			/// Calculates the lateral flow using the gravitational potential gradient only
			///
			/// \f[ q_{lat} = \frac{\Delta \Psi_G}{\|C_1-C_2\|} \frac 12 (T(C_1)+T(C_2)) w \f]
			/// where
			/// - \f$ \Delta \Psi_G \f$ is the gravitational potential difference
			/// - \f$ \|C_1-C_2\| \f$ is the distance from Cell 1 to Cell 2
			/// - \f$ T(C) \f$ is the transmissivity of cell C, calculated by SoilType::Transmissivity
			/// - \f$ w \f$ is the width of the connection of the cells
			class DarcyConnection : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::SoilWaterStorage *sw1,*sw2;
				real 
					flow_width, distance;
				virtual real calc_q(cmf::math::Time t) ;
			public:
				static void ConnectLayers(cmf::upslope::Cell & cell1,cmf::upslope::Cell & cell2,int start_at_layer=0);
				DarcyConnection(cmf::upslope::SoilWaterStorage& left,cmf::upslope::SoilWaterStorage & right,real FlowWidth,real Distance)
					: FluxConnection(left,right),flow_width(FlowWidth),distance(Distance),sw1(&left),sw2(&right) {}

			};
			///	Calculates the lateral flow using the topographic gradient
			///
			/// \f[ q_{lat} = \frac{z_1 - z_2}{\|C_1-C_2\|} \frac 12 (T(C_1)+T(C_2)) w \f]
			/// where
			/// - \f$ z_1 - z_2 \f$ is the topographic height difference
			/// - \f$ \|C_1-C_2\| \f$ is the distance from Cell 1 to Cell 2
			/// - \f$ T(C) \f$ is the transmissivity of cell C, calculated by SoilType::Transmissivity
			/// - \f$ w \f$ is the width of the connection of the cells
			class TopographicGradientDarcy : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::SoilWaterStorage *sw1,*sw2;
				real 
					flow_width, distance;
				virtual real calc_q(cmf::math::Time t) ;
			public:
				static void ConnectLayers(cmf::upslope::Cell & cell1,cmf::upslope::Cell & cell2,int start_at_layer=0);
				TopographicGradientDarcy(cmf::upslope::SoilWaterStorage& left,cmf::upslope::SoilWaterStorage & right,real FlowWidth,real Distance)
					: FluxConnection(left,right),flow_width(FlowWidth),distance(Distance),sw1(&left),sw2(&right) {}

			};
			/// A tipping bucket percolation approach similar to the approach in SWAT
			///
			/// \f{eqnarray*} q_{perc} &=& V_{H_2O,drain}\left(1-e^{-\frac 1{-TT_{perc}}}\right) \\
			/// TT_{perc} &=& \frac{V_{pores,drain} - V_{field cap.}}{K_{sat}} \\
			/// V_{x,drain} &=& V_{x,drain} - V_{field cap.} \f}
			/// 
			class SWATPercolation : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::SoilWaterStorage *sw1,*sw2;
				virtual real calc_q(cmf::math::Time t) ;
			public:
				SWATPercolation(cmf::upslope::SoilWaterStorage& upperLayer,cmf::upslope::SoilWaterStorage & lowerLayer)
					: FluxConnection(upperLayer,lowerLayer),sw1(&upperLayer),sw2(&lowerLayer) {}

			};
			/// Calculates flow according to the Richards equation
			///
			/// \f{eqnarray*}
			/// q_{Richards} &=& \frac{\Delta\Psi_{tot}}{d} K(\theta) A \\
			/// \Psi_{tot} &= &\Psi_{M}(\theta) + h
			/// \f}
			/// where
			/// - \f$ \Delta\Psi_{tot} [m]\f$ is the difference of the total water potentials of the two soil layers
			/// - \f$ d [m]\f$ is the distance between the two soil layers
			/// - \f$ K(\theta)\left[\frac m{day}\right]\f$ is the actual conductivity (see SoilType::Kunsat)
			/// - \f$ A [m^2]\f$ is the crosssectional area of the flux
			/// - \f$ \Psi_M(\theta) [m]\f$ is the matrix potential (see SoilType::MatrixPotential)
			/// - \f$ h [m]\f$ is the height of a soil layer above sea level
			class RichardsConnection : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::SoilWaterStorage *sw1,*sw2;
				real 
					flow_area, distance;
				virtual real calc_q(cmf::math::Time t) ;
			public:
				RichardsConnection(cmf::upslope::SoilWaterStorage& left,cmf::upslope::SoilWaterStorage & right,real FlowArea,real Distance)
					: FluxConnection(left,right),flow_area(FlowArea),distance(Distance),sw1(&left),sw2(&right) {}
				static void ConnectLayers(cmf::upslope::Cell & cell1,cmf::upslope::Cell & cell2,int start_at_layer=0);
				static void ConnectLayers(cmf::upslope::Cell & cell,bool no_override=true);

			};
			/// Calculates the flow between a soil layer and any FluxNode using Richards equation. It uses the same formula as RichardsConnection but the conductivity is
			/// determined by the soil side only
			class RichardsOutflow : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::SoilWaterStorage *soilwater;
				cmf::water::FluxNode *OtherWater;
				real 
					flow_width, distance;
				virtual real calc_q(cmf::math::Time t) ;
			public:
				bool UseKsat;
				/// Creates a connection between a soilwater storage and another flux node
				/// @param soil Soilwater storage
				/// @param target Flux node, connected to soil
				/// @param flowwidth Width of the flow path (height is calculated from the soil layer)
				/// @param dist Distance between soil layer and flux node
				/// @param use_Ksat If true, the saturated conductivity \f$K_sat\f$ is used instead of the actual conductivity \f$K(\theta)\f$
				RichardsOutflow(cmf::upslope::SoilWaterStorage& soil,cmf::water::FluxNode& target,real flowwidth,real dist,bool use_Ksat=0)
					: FluxConnection(soil,target),soilwater(&soil),OtherWater(&target),flow_width(flowwidth),distance(dist),UseKsat(use_Ksat) {}
			};
			/// Calculates the flow between a soil layer and any FluxNode using Darcy equation. 
			class DarcyOutflow : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::SoilWaterStorage *soilwater;
				cmf::water::FluxNode *OtherWater;
				real 
					flow_width, distance;
				virtual real calc_q(cmf::math::Time t) ;
			public:
				DarcyOutflow(cmf::upslope::SoilWaterStorage& soil,cmf::water::FluxNode& target,real flowwidth,real dist)
					: FluxConnection(soil,target),soilwater(&soil),OtherWater(&target),flow_width(flowwidth),distance(dist) {}
			};

			/// Calculates the overflow of a canopy storage
			class CanopyOverflow : public cmf::water::FluxConnection {
			protected:
				cmf::upslope::Cell & m_cell;
				cmf::water::WaterStorage & m_Canopy;
				virtual real calc_q(cmf::math::Time t) ;
			public:
				CanopyOverflow(cmf::water::WaterStorage & Canopy,cmf::water::FluxNode & target,cmf::upslope::Cell & cell)
					: cmf::water::FluxConnection(Canopy,target),m_cell(cell),m_Canopy(Canopy) {}
			};
		}
	}
}




]


// Get maps

%includefile "upslope\\maps\\maps.h" [






namespace cmf {
	namespace upslope {
		/// Distributing parameter classes in space
		///
		/// @image html "spatialdistribution.png"
		/// When a study area is set up, a lot of data is given as maps. To assign upslope cells
		/// at a given position with georeferenced input dataset the use of spatial distributors,
		/// called maps in cmf might be useful, in some cases (like the usage of upslope cell
		/// factories) needed.
		/// 
		/// On the C++ side, the implementation of the distributors is class independent (using
		/// templates), but on the Python side, the distributed class has to be predefined (in
		/// the C++ wrapper). For the following classes distributors are defined (so far):
		///  - Numbers (int,float,double)
		///  - SoilType
		///  - SoilProfile
		///  - Pointer to IVegetation (the generalisation of all vegetation types)
		///  - Pointer to Meteorology
		/// There is an abstract base class IMap<class> from which all classes derive.
		namespace maps {
			
			/// An interface, that provides a Get(x,y) function, that returns the value or
			/// object at the given location (x,y) in planar coordinates, and a Has(x,y) function
			/// the returns true, if an object exists at this location <b>The coordination system
			/// has to be the same as used for the UpslopeCells, since no conversion between coordinate
			/// systems is provided</b>
			/// In Python the name resolves to IMap_* where * is one of the following: Int, Float,
			/// Double, SoilType, SoilProfile, Vegetation, Meteorology. The same convention applies
			/// to the following derived classes.
			template<class _Ty>
			class IMap
			{
			protected:
				///Returns a Soiltype at a location (pure virtual)
				virtual _Ty get(double x,double y) =0;
				virtual bool has(double x,double y) {return true;}
			public:
				///Returns a soil type by calling the protected virtual function get
				_Ty Get(cmf::geometry::point p) {return get(p.x,p.y);}
				///Returns a soil type by calling the protected virtual function get
				_Ty Get(double x,double y) {return get(x,y);}
				bool Has(double x,double y) {return has(x,y);}
				bool Has(cmf::geometry::point p) {return has(p.x,p.y);}
				_Ty __call__(double x,double y) {return get(x,y);}



			};
			/// A SingleValueMap is the simplest possible implementation of the IMap interface.
			/// the Get(x,y) function returns always the same value/object no matter what location
			/// is given</p>
			/// @code
			/// import CMFLib as cmf
			/// number=1
			/// map=SingleValueMap_Int(number)
			/// print map.Get(0,0) # Returns 1
			/// @endcode
			template<class _Ty>
			class SingleValueMap:public IMap<_Ty>
			{
			private:
				_Ty m_Value;
				virtual _Ty get(double x,double y)	{		return m_Value;			}
			public:
				SingleValueMap(_Ty value):m_Value(value) {}
			};

			/// Distributes a scalar value (int, float or double) with a raster dataset. The simplest
			/// way to create a continuous raster map is to load a raster in the ESRI ASCII format.
			/// @code
			/// import CMFLib as cmf
			/// conversionfactor=0.01 # A factor applied to the raster for unit conversion, optional
			/// map=ContinuousRasterMap_float('dem10.dem',conversionfactor) # A floating point ASCII-Raster
			/// print map.Get(0,0) # Returns the value at loacation 0,0 (might be -9999 if Has(0,0)==false)
			/// @endcode
			template<class _Ty>
			class ContinuousRasterMap : public IMap<_Ty>
			{
			private:
				_Ty m_NoData;
			protected:
				virtual _Ty get(double x,double y)
				{
					if (Raster.HasData(x,y))
						return Raster.IdentifyXY(x,y);
					else
						return m_NoData;
				}
				virtual bool has(double x,double y)
				{
					return Raster.HasData(x,y);
				}
			public:

				/// Creates a new continuous map
				/// @param raster Pointer to an existing cmf::geometry::Raster
				ContinuousRasterMap(const cmf::geometry::Raster<_Ty>& raster) : Raster(raster) {
					m_NoData=Raster.NoData();
				}
				/// Creates a new continuous map
				/// @param ASCFileName A file name of an ESRI ASC raster dataset
				/// @param factor Scales the raster dataset (e.g. unit conversion)
				/// @param nodata Value returned, if the raster has no data (if Has(x,y)=false) default: -9999
				ContinuousRasterMap(std::string ASCFileName,_Ty factor=1,_Ty nodata=-9999) : Raster(ASCFileName),m_NoData(nodata) {
					if (factor!=1)
					{
						Raster*=factor;
					}
				}
				cmf::geometry::Raster<_Ty> Raster;

			};
			
			/// Distributes a discrete value or object as a given in an integer raster dataset according
			/// to a lookup table. To use this, one have to provide the dstribution raster and add
			/// id object pairs to the map prior to use.
			/// @code
			/// import CMFLib as cmf
			/// map=DiscreteRasterMap_SoilType('soilmap.asc') # soilmap.asc holds the ASCII raster of the soilmap
			/// map.Add(1,cmf.SoilType(15,0.4,0.3,0.2,0.1,4.2)) # A soil type is registered with raster value 1
			/// map.Add(2,cmf.SoilType(5,0.6,0.2,0.5,0.3,8.2))  # Another soil type is registered with raster value 2
			/// print map.Get(0,0).Phi # prints the porosity of the soil at position (0,0)
			/// @endcode
			template<class _Ty>
			class DiscreteRasterMap:public IMap<_Ty>
			{
			private:
				typedef std::map<int,_Ty> map;
				map m_Values;
				_Ty m_NoData;
				bool m_delete_raster;
			protected:
				virtual _Ty get(double x,double y) 
				{	
					if (Raster.HasData(x,y)) 
					{
						int index=Raster.IdentifyXY(x,y);
						map::iterator found=m_Values.find(index);
						if (found!=m_Values.end())
							return (found->second);			
						else
							return m_NoData;
					}
					else return m_NoData;
				}
				virtual bool has(double x,double y)
				{
					if (Raster.HasData(x,y)) 
					{
						int index=Raster.IdentifyXY(x,y);
						map::iterator found=m_Values.find(index);
						if (found!=m_Values.end())
							return true;			
						else
							return false;
					}
					else return false;
				}
			public:
				geometry::Raster<int> Raster;
				/// Adds a value to the lookup table
				void Add(int index,_Ty value)
				{
					m_Values[index]=value;
				}
				/// Creates a new map of discrete values, for example soil types
				/// @param raster Pointer to an existing cmf::geometry::Raster<int>
				/// @param NoDataValue Value returned, if the raster has no data (Has(x,y)=false)
				DiscreteRasterMap(geometry::Raster<int>* raster,_Ty NoDataValue=_Ty()) 
					: Raster(*raster),m_NoData(NoDataValue)
				{}
				/// Creates a new map of discrete values, for example soil types
				/// @param RasterFileName File name of an ESRI ASC-raster, containing the handles
				/// @param NoDataValue Value returned if the handle is raster.NoData() or the value is not found in the lookup table
				DiscreteRasterMap(std::string RasterFileName,_Ty NoDataValue=_Ty()) 
					: Raster(RasterFileName),m_NoData(NoDataValue)
				{				}

			};
			
			/// Registers objects with locations and returns the nearest neighbor to the queried
			/// location. Distance is measured as: \f$ d = \sqrt{(x1-x2)^2+(y1-y2)^2} + w_z|z1-z2| \f$
			/// with w<sub>z</sub> is the weight factor for height differences, zWeight. A high w<sub>z</sub> may be used for contured
			/// object distribution, where \f$ \sqrt{(x1-x2)^2+(y1-y2)^2} \f$ is small compared to \f$ w_z|z1-z2| \f$
			/// @code
			/// import CMFLib as cmf
			/// map=cmf.NearestNeighborMap_float()
			/// map.Add(0,1,0.1) # Adds 0.1 at position (0,1)
			/// map.Add(1,3,7.8) # Adds 7.8 at position (1,3)
			/// print map.Get(0,0) # prints 0.1 (0,1) is nearer to (0,0) then (1,3)
			/// @endcode
			template <class _Ty> class NearestNeighborMap: public IMap<_Ty>
			{
			private: 
				typedef std::pair<cmf::geometry::point,_Ty> npair;
				typedef std::vector<npair> nearestNeighborVector;
				nearestNeighborVector m_Values;
			protected:
				virtual _Ty get(double x,double y)
				{
					cmf::geometry::point p(x,y);
					double minDist=p.distanceTo(m_Values.begin()->first);
					_Ty bestValue=m_Values.begin()->second;
					for(nearestNeighborVector::iterator it = m_Values.begin(); it != m_Values.end(); ++it)
					{
					   double dist=p.distanceTo(it->first)+zWeight*abs(p.z-it->first.z);
						 if (dist<minDist)
						 {
							 minDist=dist;
							 bestValue=it->second;
						 }
					}
					return bestValue;
				}
			public:
				/// Adds a value at a location
				/// @param p location of value
				/// @param value Value
				void Add(cmf::geometry::point p,_Ty value)
				{
					m_Values.push_back(npair(p,value));
				}
				/// Adds a value at a location
				/// @param x X-Value of location
				/// @param y Y-Value of location
				/// @param value Value
				void Add(double x,double y,_Ty value)
				{
					Add(cmf::geometry::point(x,y),value);
				}
				/// Weight of the z difference
				double zWeight;
				/// Returns the number of point value pairs in this map
				int size() { return int(m_Values.size());}
				/// Returns the position of a value
				cmf::geometry::point& Position(int index) { return m_Values.at(index).first;}
				/// Returns one of the values
				_Ty Value(int index) { return m_Values.at(index).second;}
				NearestNeighborMap(double z_Weight=0) : zWeight(z_Weight) {}

			};
			
			/// Should return objects or values that are registered with a polygon, if the queried
			/// point is in the polygon. This is not tested yet, nor exists a really simple example.
			/// Happy Hacking!
			template <class _Ty> class PolygonMap: public IMap<_Ty>
			{
			private:
				typedef std::vector<cmf::geometry::Ring> polygons;
				typedef std::vector<_Ty> values;
				polygons m_polys;
				values m_values;
				_Ty m_NoData;
			protected:
				virtual _Ty get(double x,double y)
				{
					cmf::geometry::point p(x,y);
					for (size_t i = 0; i < m_polys.size() ; ++i)
					{
						if (m_polys[i].Includes(p)) return m_values[i];
					}
					return m_NoData;
				}
			public:
				/// Creates a new map based on polygon/value pairs
				/// @param nodata Value returned, if no polygon is found at the given location
				PolygonMap(_Ty nodata=_Ty()):	m_NoData(nodata) {}
				/// Adds a ring with a value
				/// Makes a copy of polygon and stores it in the list of values
				void Add(const cmf::geometry::Ring& polygon,_Ty value)
				{
					m_polys.push_back(polygon);
					m_values.push_back(value);
				}
				/// Returns the number of point value pairs in this map
				int size() { return int(m_values.size());}
				/// Returns the polygon of a value
				cmf::geometry::Ring& Position(int index) { return m_polys.at(index);}
				/// Returns one of the values
				_Ty Value(int index) { return m_values.at(index);}

			};		
		}
	}
}




]




















/*@SWIG:cmf.i,96,ScalarMAP@*/
	%template(IMap_Double) cmf::upslope::maps::IMap<double>;
	%feature("implicitconv") SingleValueMap_Double;
	%template(SingleValueMap_Double) cmf::upslope::maps::SingleValueMap<double>;
	%template(ContinuousRasterMap_Double) cmf::upslope::maps::ContinuousRasterMap<double>;
	%template(DiscreteRasterMap_Double) cmf::upslope::maps::DiscreteRasterMap<double>;
	%template(NearestNeighborMap_Double) cmf::upslope::maps::NearestNeighborMap<double>;
	%template(PolygonMap_Double) cmf::upslope::maps::PolygonMap<double>;
/*@SWIG@*/
/*@SWIG:cmf.i,96,ScalarMAP@*/
	%template(IMap_Float) cmf::upslope::maps::IMap<float>;
	%feature("implicitconv") SingleValueMap_Float;
	%template(SingleValueMap_Float) cmf::upslope::maps::SingleValueMap<float>;
	%template(ContinuousRasterMap_Float) cmf::upslope::maps::ContinuousRasterMap<float>;
	%template(DiscreteRasterMap_Float) cmf::upslope::maps::DiscreteRasterMap<float>;
	%template(NearestNeighborMap_Float) cmf::upslope::maps::NearestNeighborMap<float>;
	%template(PolygonMap_Float) cmf::upslope::maps::PolygonMap<float>;
/*@SWIG@*/
/*@SWIG:cmf.i,96,ScalarMAP@*/
	%template(IMap_Int) cmf::upslope::maps::IMap<int>;
	%feature("implicitconv") SingleValueMap_Int;
	%template(SingleValueMap_Int) cmf::upslope::maps::SingleValueMap<int>;
	%template(ContinuousRasterMap_Int) cmf::upslope::maps::ContinuousRasterMap<int>;
	%template(DiscreteRasterMap_Int) cmf::upslope::maps::DiscreteRasterMap<int>;
	%template(NearestNeighborMap_Int) cmf::upslope::maps::NearestNeighborMap<int>;
	%template(PolygonMap_Int) cmf::upslope::maps::PolygonMap<int>;
/*@SWIG@*/
// ComplexMAP(cmf::upslope::vegetation::IVegetation*,Vegetation)
// ComplexMAP(cmf::upslope::SoilType,Soil)
// ComplexMAP(cmf::upslope::SoilProfile,SoilProfile)
// ComplexMAP(cmf::atmosphere::Meteorology*,Meteorology)

// Get river model classes
%includefile "Reach\\ReachType.h" [




namespace cmf {
	namespace river {
		
		///@brief Structure for the description of structural parameters of a reach
		///Abstract base class for different channel geometries
		struct ReachType
		{
			double
				nManning; ///<Manning's n (roughness coefficient)

			/// @brief Calculates the flow width from a given actual depth [m] using the actual channel %geometry
			virtual double Width(double depth) const=0;
			/// @brief Calculates the wetted perimeter from a given actual depth [m] using the actual channel %geometry
			virtual double Perimeter(double depth) const=0;
			/// @brief Calculates the actual depth of the reach using the channel %geometry
			/// @returns  Depth of the reach [m]
			/// @param area Wetted area of a river cross section [m<sup>2</sup>], can be obtained by V/l, where V is the stored volume and l is the reach length
			virtual double Depth(double area) const=0;
			/// @brief Calculates the wetted area from a given depth using the channel %geometry. In most cases use Area=V/l, where V is the stored volume and l is the reach length
			/// @returns   Wetted area of a river cross section [m<sup>2</sup>]
			/// @param depth Depth of the reach [m]
			virtual double Area(double depth) const=0;

			/// Calculates the flow rate from a given water volume in the reach
			/// \f{eqnarray*}
			/// q_{Manning}&=& A R^{\frac 23} \sqrt{\frac {\Delta_z} n} \\
			/// A &=& \frac V l \mbox{ Area of the wetted crossection, Volume per length}\\
			/// R&=&\frac A P(d) \\
			/// P(d)&=& \mbox{ Perimeter of the wetted crossection, a function of reach depth} \\
			/// d(V)&=& \mbox{ Depth of the reach} \\
			/// \Delta_z&=& \frac{z_{max} - z_{min}}{l} \mbox{ Slope of the reach} \\
			/// \f}
			/// @returns  Flow rate [m<sup>3</sup>/s]
			/// @param A The area of the cross section [m<sup>2</sup>]
			/// @param slope The slope of the reach [m/m]
			double qManning(double A,double slope) const;


			ReachType() : nManning(0.035) {}
			virtual ReachType* copy() const=0;
		};


		///@brief Structure for the description of structural parameters of a reach
		///
		///Uses the SWAT channel geometry (see SWAT Theoretical Documentation, Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class referenced as SWATtheoDoc.
		///Differences to the SWAT geometry: The flood plain is not plain, but has a small slope=0.5%, but has an infinite width
		struct SWATReachType : public ReachType
		{
			double
				BottomWidth, ///<Width of the channel bottom \f$ w_{bottom} [m] \f$
				ChannelDepth, ///<Depth of the channel  \f$ d_{channel} [m] \f$
				BankSlope, ///<Inverse slope of the river bank \f$ \Delta_{bank} \left[\frac m m\right] \f$
				FloodPlainSlope; ///<Inverse slope of the flood plain \f$ \Delta_{flood\ plain} \left[\frac m m\right] \f$

			///@brief Calculates the flow width from a given actual depth [m] using the actual channel geometry
			/// \f{eqnarray*}
			/// \mbox{If }  d\le d_{channel} && \\
			/// w &=& w_{bottom} + 2  \Delta_{bank} d \\
			/// \mbox{else,         } && \mbox{if the river floods the flood plain} \\
			/// w &=& w_{bank} + 2 \Delta_{Floodplain} (d-d_{channel} \\
			/// \f}
			///@see SWATtheoDoc eq. 7:1.1.3
			virtual double Width(double depth) const;
			///@brief Calculates the wetted perimeter from a given actual depth [m] using the actual channel geometry
			/// \f{eqnarray*}
			/// \mbox{If } d\le d_{channel} && \\
			/// P &=& w_{bottom} + 2  \sqrt{1+ {\Delta_{bank}}^2} d \\
			/// \mbox{else,         } && \mbox{if the river floods the flood plain} \\
			/// P &=& P(d_{channel} + 2 \sqrt{1+ {\Delta_{flood\ plain}}^2} (d-d_{channel}) \\
			/// \f}
			///@see SWATtheoDoc eq. 7:1.1.5
			///@param depth Actual depth of the reach [m]
			virtual double Perimeter(double depth) const;
			///@brief Calculates the actual depth of the reach using the channel geometry
			/// \f{eqnarray*}
			/// d &=& \sqrt{\frac{A}{\Delta_{bank}} + \frac{{w_{bottom}}^2}{4 {\Delta_{bank}}^2}} - \frac{w_{bottom}}{2 \Delta_{bank}} \\
			/// \mbox{If } d>d_{channel} &&\\
			/// d&=&d_{channel}+\sqrt{\frac{A-A(d_{channel})}{\Delta_{flood\ plain}} + \frac{{w(d_{channel})}^2}{4 {\Delta_{flood\ plain}}^2}} - \frac{w(d_{channel})}{2 \Delta_{flood\ plain}} \\
			/// \f}
			///@see SWATtheoDoc eq. 7:1.2.4
			/// @returns  Depth of the reach [m]
			/// @param area Wetted area of a river cross section [m<sup>2</sup>], can be obtained by V/l, where V is the stored volume and l is the reach length
			virtual double Depth(double area) const;
			/// @brief Calculates the wetted area from a given depth using the channel geometry. In most cases use Area=V/l, where V is the stored volume and l is the reach length
			/// \f{eqnarray*}
			/// \mbox{If } d>d_{channel} &&\\
			/// A &=& \left(w_{bottom} + \Delta_{bank} d\right) d \\
			/// \mbox{else,         } && \mbox{if the river floods the flood plain} \\
			/// A &=& A(d_{channel}) + \left(w(d_{channel} + \Delta_{flood\ plain} \left(d-d_{channel}\right)\right) (d-d_{channel}) \\
			/// \f}
			/// @see SWATtheoDoc eq. 7:1.1.4
			/// @returns   Wetted area of a river cross section [m<sup>2</sup>]
			/// @param depth Depth of the reach [m]
			virtual double Area(double depth) const;

			///Creates a new reach structure with standard values (small natural river)
			///BottomWidth = 3m, ChannelDepth = 0.5m, BankSlope = 2, nManning = 0.0035, FloodPlainSlope = 200
			SWATReachType();
			///Creates a new reach structure from a give width and depth
			/// @param BankWidth Width of the reach from bank to bank [m]
			/// @param Depth Depth of the reach [m]
			SWATReachType(double BankWidth,double Depth);
			SWATReachType* copy() const { return new SWATReachType(BottomWidth+2*BankSlope*ChannelDepth,ChannelDepth);}
		};
		/// @brief Structure for the description of reaches with a triangular cross section
		///
		/// Although real triangular cross section reach are rarely met, a triangular reach does scale with its water load, and is therefore preferable in case where nothing about channel geometry is known
		struct TriangularReach : public ReachType
		{
			/// Inverse slope of the bank \f$ \Delta = 0.5 \frac w d \f$
			double BankSlope;
			/// Returns the width of the  stream at a given depth
			/// \f{eqnarray*}
			/// w &=& 2 \Delta\ d
			/// \f}
			virtual double Width(double depth) const;
			/// Returns the wetted perimeter at a given depth
			/// \f{eqnarray*}
			/// P &=& 2 d \sqrt{1+\Delta^2}
			/// \f}
			virtual double Perimeter(double depth) const;
			/// Returns the depth at a given crossection area
			/// \f{eqnarray*}
			/// d &=& \sqrt{\frac{A}{\Delta}}
			/// \f}
			virtual double Depth(double area) const;
			/// Returns the crossection area at a given depth
			/// \f{eqnarray*}
			/// A &=& d^2 \Delta
			/// \f}
			virtual double Area(double depth) const;
			/// Creates a new triangular reach type
			TriangularReach(double bankSlope=2);
			TriangularReach* copy() const { return new TriangularReach(BankSlope);}

		};
		struct RectangularReach : public ReachType
		{
		private:
			double m_width;
		public:
			/// Returns the width of the  stream at a given depth
			/// \f{eqnarray*}
			/// w &=& const
			/// \f}
			virtual double Width(double depth) const;
			/// Returns the wetted perimeter at a given depth
			/// \f{eqnarray*}
			/// P &=& 2 d + w
			/// \f}
			virtual double Perimeter(double depth) const;
			/// Returns the depth at a given crossection area
			/// \f{eqnarray*}
			/// d &=& \frac A w
			/// \f}
			virtual double Depth(double area) const;
			/// Returns the crossection area at a given depth
			/// \f{eqnarray*}
			/// A &=& d w
			/// \f}
			virtual double Area(double depth) const;
			/// Creates a new rectangular reach type
			RectangularReach(double width) : m_width(width) {}
			RectangularReach* copy() const;

		};
		struct PipeReach : public ReachType
		{
		private:
			double m_Radius;
		public:
			virtual double Width(double depth) const;
			virtual double Perimeter(double depth) const;
			virtual double Depth(double area) const;
			virtual double Area(double depth) const;
			PipeReach(double diameter) : m_Radius(diameter * 0.5) {}
			PipeReach* copy() const;
		};

	
	}
}



]
%includefile "Reach\\ManningConnection.h" [







namespace cmf {

	namespace river {
		class ManningConnection : public cmf::water::FluxConnection
		{
		protected:
			cmf::water::WaterStorage *w1,*w2;
			virtual real calc_q(cmf::math::Time t)
			{
				cmf::water::FluxNode & target = this->Target(*w1);
				real 
					// Distance between source and target
					d=w1->Location.distance3DTo(w2->Location),
					// Wetted crossectional area use mean volume of the water storages if both sides are water storages
					A=w2 ? mean(w1->State(),w2->State())/d : w1->State()/d,
					// Depth of the rech
					h=flux_geometry->Depth(A)-BarrierHeight;
				if (h<=0) return 0;
				real
					// Wetted perimeter of the reach
					P=maximum(flux_geometry->Perimeter(h),0.01),
					// Gradient of the reach
					slope=(w1->Potential()-target.Potential())/d,
					// Flux
					qManning=A*pow((A/P),0.6666667)*sqrt(abs(slope)/flux_geometry->nManning);
				return qManning * sign(slope);
			}
			std::auto_ptr<ReachType> flux_geometry;
		public:
			real BarrierHeight;
			ReachType& ChannelGeometry() {return *flux_geometry;}
			const ReachType& ChannelGeometry() const {return *flux_geometry;}
			ManningConnection(cmf::water::WaterStorage& left,cmf::water::FluxNode & right,const ReachType& ChannelShape,real barrierHeight=0)
				: FluxConnection(left,right),BarrierHeight(barrierHeight),
				w1(&left),
				w2(dynamic_cast<cmf::water::WaterStorage*> &right),flux_geometry(ChannelShape.copy()) {}
		};
		/// Produces a constant but changeable flux from a source to a target, if enough water is present in the source
		///
		/// \f$ q=\left\{0 \mbox{ if }V_{source}\le V_{min}\\ \frac{V_{source} - V_{min}}{t_{decr} q_{0} - V_{min}}\mbox{ if } V_{source} t_{decr} q_{0}\\ q_{0} \mbox{ else}\le \right. \f$
		class TechnicalFlux : public FluxConnection
		{
		protected:
			cmf::water::WaterStorage *source;
			virtual real calc_q(cmf::math::Time t)
			{
				return piecewise_linear(source->State(),MinState,MinState+FluxDecreaseTime.AsDays()*MaxFlux,0,MaxFlux);
			}
		public:
			/// The requested flux \f$\q_{0}\left[frac{m^3}{day}\right]\f$
			real MaxFlux;
			/// The minimal volume of the state  \f$V_{min}\left[m^3\right]\f$
			real MinState;
			/// The flux is linearly decreased, if it takes less than FluxDecreaseTime \f$t_{decr}\f$ to reach MinState with MaxFlux
			cmf::math::Time FluxDecreaseTime;

			/// Produces a constant but changeable flux from a source to a target, if enough water is present in the source
			/// @param source The source of the water
			/// @param target The target of the water
			/// @param maximum_flux The requested flux \f$q_{0}\f$
			/// @param minimal_state Minimal volume of stored water in source
			/// @param flux_decrease_time (cmf::math::Time)
			TechnicalFlux(cmf::water::WaterStorage & source,cmf::water::FluxNode & target,real maximum_flux,real minimal_state=0,cmf::math::Time flux_decrease_time=cmf::math::h)
				: FluxConnection(source,target),MaxFlux(maximum_flux),MinState(minimal_state),FluxDecreaseTime(flux_decrease_time) {}
		};
		
	}
	
}



]
// %include "Reach/reach.h"


// Get factory classes and IO
// %include "upslope/Factory/UpslopeFromRaster.h"
//%include "upslope/UpslopeVectorCorrector.h"
// %include "upslope/Factory/UpslopeResultRaster.h"

// Get combined solver
// %include "Solver/Basin.h"
// %include "Solver/StudyAreaSolver.h"
// Makro to extend base classes with downcasts to child classes










// Add some function for down casting




}



]
