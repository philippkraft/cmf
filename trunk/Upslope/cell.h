#ifndef cell_h__
#define cell_h__
#include "../Atmosphere/Meteorology.h"
#include "../Atmosphere/Precipitation.h"
#include "../Geometry/geometry.h"
#include "../water/FluxConnection.h"
#include "vegetation/StructVegetation.h"
#include "../water/WaterStorage.h"
#include "../math/StateVariable.h"
#include "Soil/RetentionCurve.h"
#include <memory>
#include <map>
#include <vector>
#include <set>
namespace cmf {
	class project;
	namespace river {
		class OpenWaterStorage;	
		class Reach;
	}
	namespace upslope {
		class SoilWaterStorage;
		class Topology;
		class Cell;
		typedef void (*connectorfunction)(cmf::upslope::Cell&,cmf::upslope::Cell&,int);
		typedef void (*internal_connector)(cmf::upslope::Cell&);
		/// A helper class to connect cells with FluxConnection objects. This is generated by FluxConnection classes, intended to connect cells 
		class CellConnector
		{
		private:
			connectorfunction m_connector;
			CellConnector():m_connector(0) {}
		public:
#ifndef SWIG
			CellConnector(connectorfunction connector) : m_connector(connector)			{	}
			void operator()(cmf::upslope::Cell& cell1,cmf::upslope::Cell& cell2,int start_at_layer=0) const	{
				connect(cell1,cell2,start_at_layer);
			}
#endif
			void connect(cmf::upslope::Cell& cell1,cmf::upslope::Cell& cell2,int start_at_layer=0) const {
				m_connector(cell1,cell2,start_at_layer);
			}
		};
		/// This class is the basic landscape object. It is the owner of water storages, and the upper and lower boundary conditions 
		/// of the system (rainfall, atmospheric vapor, deep groundwater)
		class Cell : public cmf::math::StateVariableOwner {
			friend class project;
			/// @name Location
			//@{
			std::auto_ptr<Topology> m_topo;
		public:
			cmf::upslope::Topology& get_topology();
#ifndef SWIG
			operator cmf::upslope::Topology&() {return get_topology();}
#endif
			double x,y,z;
			/// Returns the location of the cell
			cmf::geometry::point Center() const { return cmf::geometry::point(x,y,z); }
		private:
			double m_Area;
			real m_SatDepth;
		public:
			/// Returns the area of the cell
			double Area() const { return m_Area; }
			/// @name Saturation
			//@{
			/// Marks the saturated depth as unvalid
			void InvalidateSatDepth() {m_SatDepth=-1e20;}
			/// 
			real SaturatedDepth() ;
			void SetSaturatedDepth(real depth);
			//@}
		private:
			//@}
			/// @name Flux nodes of the cell
			//@{
			typedef std::tr1::shared_ptr<cmf::water::WaterStorage> storage_pointer;
			typedef std::tr1::shared_ptr<cmf::river::Reach> reach_pointer;
			typedef std::vector<reach_pointer> reach_vector;
			typedef std::vector<storage_pointer> storage_vector;
			typedef std::tr1::shared_ptr<cmf::water::FluxNode> node_pointer;
			storage_vector m_storages;
			reach_vector m_reaches;
			cmf::atmosphere::RainfallNode* m_rainfall;
			int m_Canopy_pos;
			int m_Snow_pos;
			int m_SurfaceWater_pos;
			node_pointer m_SurfaceWater;
			const cmf::project & m_project;
		public:
			/// Returns the end point of all evaporation of this cell
 			cmf::water::FluxNode& Evaporation();
 			/// Returns the end point of all transpiration of this cell
 			cmf::water::FluxNode& Transpiration();
			/// returns the surface water of this cell
			cmf::water::FluxNode& SurfaceWater()	{ 
				if (m_SurfaceWater.get())
					return *m_SurfaceWater;
				else
					return *m_storages.at(m_SurfaceWater_pos);
			}
			cmf::water::WaterStorage& AddStorage(std::string Name,char storage_role='N',  bool isopenwater=false);
			void RemoveStorage(cmf::water::WaterStorage& storage);
			cmf::river::Reach& AddReach(double length,char shape='T', double depth=0.25,double width=1., std::string Name="Reach");
			int StorageCount() const
			{
				return int(m_storages.size());
			}
			cmf::water::WaterStorage& GetStorage(int index);
			const cmf::water::WaterStorage& GetStorage(int index) const;
			cmf::river::Reach& GetReach(int index=0)
			{
				return *m_reaches.at(index<0 ? m_storages.size()+index : index);
			}
			size_t ReachCount() const {return m_reaches.size();}
			cmf::water::WaterStorage* GetCanopy() const;
			cmf::water::WaterStorage* GetSnow() const;
			bool HasSnowStorage() const {return m_Snow_pos>=0;}
			real SnowCover() const
			{
				if (m_Snow_pos>=0)
					return piecewise_linear(GetStorage(m_Snow_pos).State()/Area(),0,0.01);
				else
					return 0.0;
			}
			bool HasInterceptedWater() const
			{
				return (m_Canopy_pos>=0) && (GetStorage(m_Canopy_pos).State()>1e-6*Area());
			}
			bool HasSurfaceWater() const
			{
				return (m_SurfaceWater_pos>=0) && (GetStorage(m_SurfaceWater_pos).State()>1e-6*Area());
			}
			cmf::upslope::vegetation::Vegetation Vegetation;
			cmf::upslope::vegetation::Vegetation GetVegetation() const;
			int Id;
			const cmf::project& project() const;
			cmf::atmosphere::Weather Weather(cmf::math::Time t) const;
			real Rain(cmf::math::Time t) const;

		public:
			//@}
			///@name Layers
			//@{
		private:
			typedef std::vector<SoilWaterStorage*> layer_vector;
			layer_vector m_Layers;
		public:
			int LayerCount() const
			{
				return int(m_Layers.size());
			}
			cmf::upslope::SoilWaterStorage& Layer(int ndx)
			{
				if (ndx<0) ndx=LayerCount()+ndx;
				return *m_Layers.at(ndx);
			}
			const cmf::upslope::SoilWaterStorage& Layer(int ndx) const
			{
				if (ndx<0) ndx=LayerCount()+ndx;
				return *m_Layers.at(ndx);
			}
#ifndef SWIG
			/// Registers a layer at the cell. This function is used by the ctor's of the layers and should never be used in other code.
			void AddLayer(cmf::upslope::SoilWaterStorage* layer);
#endif
			void AddLayer(real lowerboundary,const cmf::upslope::RCurve& r_curve,real saturateddepth=-10);
			void AddVariableLayerPair(real lowerboundary,const cmf::upslope::RCurve& r_curve);
			void RemoveLastLayer();
			void RemoveLayers();
			virtual ~Cell();
			//@}


			Cell(double x,double y,double z,double area,cmf::project & _project);
			std::string ToString()
			{
				std::stringstream sstr;
				sstr << "(" << Center().x << "," << Center().y << "," << Center().z << ")";
				return sstr.str();
			}
			//@}
			void AddStateVariables(cmf::math::StateVariableVector& vector);
		};
		
		typedef std::vector<cmf::upslope::Cell*> cell_vector;
		typedef std::set<cmf::upslope::Cell*> cell_set;



	}
	
}
#endif // cell_h__
