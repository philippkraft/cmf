# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.38
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _cmf.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        try:
            fp, pathname, description = imp.find_module('_cmf', [dirname(__file__)])
            _mod = imp.load_module('_cmf', fp, pathname, description)
        finally:
            if fp is not None: fp.close()
        return _mod
    _cmf = swig_import_helper()
    del swig_import_helper
else:
    import _cmf
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf.delete_SwigPyIterator
    def value(self):
        """value(self) -> PyObject"""
        return _cmf.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _cmf.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _cmf.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _cmf.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _cmf.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _cmf.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _cmf.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _cmf.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _cmf.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _cmf.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _cmf.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _cmf.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_cmf.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_cmf.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_cmf.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_cmf.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_cmf.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_cmf.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_cmf.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_cmf.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_cmf.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_cmf.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_cmf.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_cmf.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_cmf.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_cmf.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_cmf.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_cmf.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _cmf.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class shape(object):
    """Proxy of C++ cmf::geometry::shape class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Vertices(self):
        """
        Vertices(self) -> Points

        virtual Points
        Vertices() const =0 
        """
        return _cmf.shape_Vertices(self)

    def Center(self):
        """
        Center(self) -> point

        virtual point
        Center() const =0 
        """
        return _cmf.shape_Center(self)

    def AsWKT(self):
        """
        AsWKT(self) -> string

        virtual
        std::string AsWKT() const =0

        Returns the OGC well known text representation of the shape as defined
        in OpenGIS Implementation Specification for Geographic information -
        Simple feature access - Part 1: Common
        architecturehttp://www.opengeospatial.org/standards/is. 
        """
        return _cmf.shape_AsWKT(self)

    __swig_destroy__ = _cmf.delete_shape
shape.Vertices = new_instancemethod(_cmf.shape_Vertices,None,shape)
shape.Center = new_instancemethod(_cmf.shape_Center,None,shape)
shape.AsWKT = new_instancemethod(_cmf.shape_AsWKT,None,shape)
shape_swigregister = _cmf.shape_swigregister
shape_swigregister(shape)
cvar = _cmf.cvar
PI = cvar.PI

class point(shape):
    """
    2D-Point Class.

    Used as location property anywhere in the text Calculation of
    distances

    +,-,-=,*= Operators overloaded

    C++ includes: geometry.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_cmf.point_x_get, _cmf.point_x_set)
    y = _swig_property(_cmf.point_y_get, _cmf.point_y_set)
    z = _swig_property(_cmf.point_z_get, _cmf.point_z_set)
    def __init__(self, *args): 
        """
        __init__(self) -> point
        __init__(self, point p) -> point
        __init__(self, double x_, double y_, double z_ = 0.0) -> point
        __init__(self, double x_, double y_) -> point

        point(double x_,
        double y_, double z_=0.0)

        Creates a point from two doubles. 
        """
        _cmf.point_swiginit(self,_cmf.new_point(*args))
    def distanceTo(self, *args):
        """
        distanceTo(self, point p) -> double

        double
        distanceTo(point p) const

        Returns the euclidian distance to another point.
        $\\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}$. 
        """
        return _cmf.point_distanceTo(self, *args)

    def distance3DTo(self, *args):
        """
        distance3DTo(self, point p) -> double

        double
        distance3DTo(point p) const 
        """
        return _cmf.point_distance3DTo(self, *args)

    def distance(*args):
        """distance(point p1, point p2) -> double"""
        return _cmf.point_distance(*args)

    distance = staticmethod(distance)
    def distance_max(self, *args):
        """
        distance_max(self, point p) -> double

        double
        distance_max(point p) const

        Returns the distance by the maximum orthogonal offset. 
        """
        return _cmf.point_distance_max(self, *args)

    def azimuth(self, *args):
        """
        azimuth(self, point p) -> double

        double
        azimuth(point p) const

        Returns the azimuth angle of the line $ \\overline{this,p} $ to the
        Azimuth in degrees. 
        """
        return _cmf.point_azimuth(self, *args)

    def angleToXAxis(self, *args):
        """
        angleToXAxis(self, point p) -> double

        double
        angleToXAxis(point p) const

        Returns the angle between the line $ \\overline{this,p} $ to the
        x-Axis in degrees. 
        """
        return _cmf.point_angleToXAxis(self, *args)

    def Vertex(self):
        """
        Vertex(self) -> size_t

        size_t Vertex()
        const 
        """
        return _cmf.point_Vertex(self)

    def __add__(self, *args):
        """__add__(self, point p) -> point"""
        return _cmf.point___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, point p) -> point"""
        return _cmf.point___sub__(self, *args)

    def __mul__(self, *args):
        """__mul__(self, double left) -> point"""
        return _cmf.point___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, double left) -> point"""
        return _cmf.point___div__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, point p) -> point"""
        return _cmf.point___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, point p) -> point"""
        return _cmf.point___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, point p) -> bool"""
        return _cmf.point___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, point p) -> bool"""
        return _cmf.point___ne__(self, *args)

    def __len__(self):
        """__len__(self) -> int"""
        return _cmf.point___len__(self)

    def __getitem__(self,index) :
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(p)))]
        if index==0 :
            return self.x
        elif index==1 :
            return self.y
        elif index==2 :
            return self.z
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __setitem__(self,index,value) :
        if index==0 :
            self.x=value
        elif index==1 :
            self.y=value
        elif index==2 :
            self.z=value
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z
    def __repr__(self):
        return 'cmf.point(%g,%g,%g)' % (self.x,self.y,self.z)

    __swig_destroy__ = _cmf.delete_point
point.distanceTo = new_instancemethod(_cmf.point_distanceTo,None,point)
point.distance3DTo = new_instancemethod(_cmf.point_distance3DTo,None,point)
point.distance_max = new_instancemethod(_cmf.point_distance_max,None,point)
point.azimuth = new_instancemethod(_cmf.point_azimuth,None,point)
point.angleToXAxis = new_instancemethod(_cmf.point_angleToXAxis,None,point)
point.Vertex = new_instancemethod(_cmf.point_Vertex,None,point)
point.__add__ = new_instancemethod(_cmf.point___add__,None,point)
point.__sub__ = new_instancemethod(_cmf.point___sub__,None,point)
point.__mul__ = new_instancemethod(_cmf.point___mul__,None,point)
point.__div__ = new_instancemethod(_cmf.point___div__,None,point)
point.__iadd__ = new_instancemethod(_cmf.point___iadd__,None,point)
point.__isub__ = new_instancemethod(_cmf.point___isub__,None,point)
point.__eq__ = new_instancemethod(_cmf.point___eq__,None,point)
point.__ne__ = new_instancemethod(_cmf.point___ne__,None,point)
point.__len__ = new_instancemethod(_cmf.point___len__,None,point)
point_swigregister = _cmf.point_swigregister
point_swigregister(point)

def point_distance(*args):
  """point_distance(point p1, point p2) -> double"""
  return _cmf.point_distance(*args)

class BoundingBox(shape):
    """
    Holds the corner coordinates of a bounding box.

    C++ includes: geometry.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    xmin = _swig_property(_cmf.BoundingBox_xmin_get, _cmf.BoundingBox_xmin_set)
    ymin = _swig_property(_cmf.BoundingBox_ymin_get, _cmf.BoundingBox_ymin_set)
    xmax = _swig_property(_cmf.BoundingBox_xmax_get, _cmf.BoundingBox_xmax_set)
    ymax = _swig_property(_cmf.BoundingBox_ymax_get, _cmf.BoundingBox_ymax_set)
    def Includes(self, *args):
        """
        Includes(self, point p) -> bool

        bool
        Includes(point p) const

        Returns true if the point p is inside the bounding box. 
        """
        return _cmf.BoundingBox_Includes(self, *args)

    def isempty(self):
        """
        isempty(self) -> bool

        bool
        isempty() const

        Returns true, if the bounding box is empty. 
        """
        return _cmf.BoundingBox_isempty(self)

    def makeempty(self):
        """
        makeempty(self)

        void
        makeempty()

        Makes the bounding box empty. 
        """
        return _cmf.BoundingBox_makeempty(self)

    def extend(self, *args):
        """
        extend(self, point p)
        extend(self, BoundingBox bbox)

        void
        extend(const BoundingBox &bbox)

        Extends the bounding box to contain the given Boundingbox although. 
        """
        return _cmf.BoundingBox_extend(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> BoundingBox
        __init__(self, double X1, double Y1, double X2, double Y2) -> BoundingBox
        __init__(self, point p1, point p2) -> BoundingBox
        __init__(self, BoundingBox copy) -> BoundingBox
        __init__(self, double bbox) -> BoundingBox

        BoundingBox(double *bbox) 
        """
        _cmf.BoundingBox_swiginit(self,_cmf.new_BoundingBox(*args))
    __swig_destroy__ = _cmf.delete_BoundingBox
BoundingBox.Includes = new_instancemethod(_cmf.BoundingBox_Includes,None,BoundingBox)
BoundingBox.isempty = new_instancemethod(_cmf.BoundingBox_isempty,None,BoundingBox)
BoundingBox.makeempty = new_instancemethod(_cmf.BoundingBox_makeempty,None,BoundingBox)
BoundingBox.extend = new_instancemethod(_cmf.BoundingBox_extend,None,BoundingBox)
BoundingBox_swigregister = _cmf.BoundingBox_swigregister
BoundingBox_swigregister(BoundingBox)

class MultiPoint(shape):
    """Proxy of C++ cmf::geometry::MultiPoint class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def AddPoint(self, *args):
        """
        AddPoint(self, point p)
        AddPoint(self, double x, double y, double z = 0)
        AddPoint(self, double x, double y)

        void
        AddPoint(double x, double y, double z=0) 
        """
        return _cmf.MultiPoint_AddPoint(self, *args)

    def RemovePoint(self, *args):
        """
        RemovePoint(self, int pos)

        void
        RemovePoint(int pos) 
        """
        return _cmf.MultiPoint_RemovePoint(self, *args)

    def size(self):
        """
        size(self) -> int

        int size()
        const 
        """
        return _cmf.MultiPoint_size(self)

    def Vertex(self, *args):
        """
        Vertex(self, int i) -> point

        point
        Vertex(int i) const 
        """
        return _cmf.MultiPoint_Vertex(self, *args)

    def MaxStraight(self):
        """
        MaxStraight(self) -> Line

        Line
        MaxStraight() const

        Returns the longest straight line between two vertices of the shape.

        """
        return _cmf.MultiPoint_MaxStraight(self)

    def boundingbox(self):
        """
        boundingbox(self) -> BoundingBox

        BoundingBox boundingbox() 
        """
        return _cmf.MultiPoint_boundingbox(self)

    def __init__(self, *args): 
        """
        __init__(self) -> MultiPoint
        __init__(self, MultiPoint copy) -> MultiPoint
        __init__(self, Points copy) -> MultiPoint

        MultiPoint(const Points &copy) 
        """
        _cmf.MultiPoint_swiginit(self,_cmf.new_MultiPoint(*args))
    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf.MultiPoint___len__(self)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> point"""
        return _cmf.MultiPoint___getitem__(self, *args)

    __swig_destroy__ = _cmf.delete_MultiPoint
MultiPoint.AddPoint = new_instancemethod(_cmf.MultiPoint_AddPoint,None,MultiPoint)
MultiPoint.RemovePoint = new_instancemethod(_cmf.MultiPoint_RemovePoint,None,MultiPoint)
MultiPoint.size = new_instancemethod(_cmf.MultiPoint_size,None,MultiPoint)
MultiPoint.Vertex = new_instancemethod(_cmf.MultiPoint_Vertex,None,MultiPoint)
MultiPoint.MaxStraight = new_instancemethod(_cmf.MultiPoint_MaxStraight,None,MultiPoint)
MultiPoint.boundingbox = new_instancemethod(_cmf.MultiPoint_boundingbox,None,MultiPoint)
MultiPoint.__len__ = new_instancemethod(_cmf.MultiPoint___len__,None,MultiPoint)
MultiPoint.__getitem__ = new_instancemethod(_cmf.MultiPoint___getitem__,None,MultiPoint)
MultiPoint_swigregister = _cmf.MultiPoint_swigregister
MultiPoint_swigregister(MultiPoint)

class Line(MultiPoint):
    """Proxy of C++ cmf::geometry::Line class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def PointOnLine(self, *args):
        """
        PointOnLine(self, double d) -> point

        point
        PointOnLine(double d) const

        returns the point in the distance d from the start point on the line

        """
        return _cmf.Line_PointOnLine(self, *args)

    def Length(self):
        """
        Length(self) -> double

        double Length()
        const 
        """
        return _cmf.Line_Length(self)

    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf.Line___len__(self)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> point"""
        return _cmf.Line___getitem__(self, *args)

    def __init__(self): 
        """__init__(self) -> Line"""
        _cmf.Line_swiginit(self,_cmf.new_Line())
    __swig_destroy__ = _cmf.delete_Line
Line.PointOnLine = new_instancemethod(_cmf.Line_PointOnLine,None,Line)
Line.Length = new_instancemethod(_cmf.Line_Length,None,Line)
Line.__len__ = new_instancemethod(_cmf.Line___len__,None,Line)
Line.__getitem__ = new_instancemethod(_cmf.Line___getitem__,None,Line)
Line_swigregister = _cmf.Line_swigregister
Line_swigregister(Line)

class Ring(MultiPoint):
    """Proxy of C++ cmf::geometry::Ring class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Area(self):
        """
        Area(self) -> double

        double Area() const

        returns the Area of a polygon defined by the points 
        """
        return _cmf.Ring_Area(self)

    def Includes(self, *args):
        """
        Includes(self, point p) -> bool
        Includes(self, point p) -> bool
        Includes(self, shape shp) -> bool
        Includes(self, shape shp) -> bool

        bool
        Includes(point p)

        returns true if p lies in the polygon defined by the points, and
        creates the bounding box if needed

        Algorithm by W. Randolph
        Franklin,http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

        """
        return _cmf.Ring_Includes(self, *args)

    def SharedBoundary(self, *args):
        """
        SharedBoundary(self, Ring with, double tolerance = 0.1) -> Line
        SharedBoundary(self, Ring with) -> Line

        Line
        SharedBoundary(const Ring &with, double tolerance=0.1) const

        Returns the shared boundary of two rings. 
        """
        return _cmf.Ring_SharedBoundary(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Ring
        __init__(self, Ring copy) -> Ring
        __init__(self, BoundingBox bbox) -> Ring
        __init__(self, Line copy) -> Ring

        Ring(const
        cmf::geometry::Line &copy) 
        """
        _cmf.Ring_swiginit(self,_cmf.new_Ring(*args))
    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf.Ring___len__(self)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> point"""
        return _cmf.Ring___getitem__(self, *args)

    def __contains___(self,p):
        return self.Includes(p)

    __swig_destroy__ = _cmf.delete_Ring
Ring.Area = new_instancemethod(_cmf.Ring_Area,None,Ring)
Ring.Includes = new_instancemethod(_cmf.Ring_Includes,None,Ring)
Ring.SharedBoundary = new_instancemethod(_cmf.Ring_SharedBoundary,None,Ring)
Ring.__len__ = new_instancemethod(_cmf.Ring___len__,None,Ring)
Ring.__getitem__ = new_instancemethod(_cmf.Ring___getitem__,None,Ring)
Ring_swigregister = _cmf.Ring_swigregister
Ring_swigregister(Ring)

class PolyLine(shape):
    """Proxy of C++ cmf::geometry::PolyLine class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Length(self):
        """
        Length(self) -> double

        double
        Length() const 
        """
        return _cmf.PolyLine_Length(self)

    def size(self):
        """
        size(self) -> size_t

        size_t size()
        const 
        """
        return _cmf.PolyLine_size(self)

    def AddPart(self, *args):
        """
        AddPart(self, Line part) -> Line
        AddPart(self) -> Line

        cmf::geometry::Line& AddPart() 
        """
        return _cmf.PolyLine_AddPart(self, *args)

    def boundingbox(self):
        """
        boundingbox(self) -> BoundingBox

        cmf::geometry::BoundingBox boundingbox() 
        """
        return _cmf.PolyLine_boundingbox(self)

    def straight_parts(self):
        """
        straight_parts(self) -> PolyLine

        cmf::geometry::PolyLine straight_parts() const 
        """
        return _cmf.PolyLine_straight_parts(self)

    def __init__(self, *args): 
        """
        __init__(self) -> PolyLine
        __init__(self, PolyLine copy) -> PolyLine
        __init__(self, Line copy) -> PolyLine

        PolyLine(const Line &copy) 
        """
        _cmf.PolyLine_swiginit(self,_cmf.new_PolyLine(*args))
    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf.PolyLine___len__(self)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> Line"""
        return _cmf.PolyLine___getitem__(self, *args)

    __swig_destroy__ = _cmf.delete_PolyLine
PolyLine.Length = new_instancemethod(_cmf.PolyLine_Length,None,PolyLine)
PolyLine.size = new_instancemethod(_cmf.PolyLine_size,None,PolyLine)
PolyLine.AddPart = new_instancemethod(_cmf.PolyLine_AddPart,None,PolyLine)
PolyLine.boundingbox = new_instancemethod(_cmf.PolyLine_boundingbox,None,PolyLine)
PolyLine.straight_parts = new_instancemethod(_cmf.PolyLine_straight_parts,None,PolyLine)
PolyLine.__len__ = new_instancemethod(_cmf.PolyLine___len__,None,PolyLine)
PolyLine.__getitem__ = new_instancemethod(_cmf.PolyLine___getitem__,None,PolyLine)
PolyLine_swigregister = _cmf.PolyLine_swigregister
PolyLine_swigregister(PolyLine)

class Polygon(shape):
    """Proxy of C++ cmf::geometry::Polygon class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Area(self):
        """
        Area(self) -> double

        double Area()
        const 
        """
        return _cmf.Polygon_Area(self)

    def size(self):
        """
        size(self) -> size_t

        size_t size()
        const 
        """
        return _cmf.Polygon_size(self)

    def AddPart(self, *args):
        """
        AddPart(self, Ring part) -> Ring
        AddPart(self) -> Ring

        cmf::geometry::Ring& AddPart() 
        """
        return _cmf.Polygon_AddPart(self, *args)

    def boundingbox(self):
        """
        boundingbox(self) -> BoundingBox

        cmf::geometry::BoundingBox boundingbox() 
        """
        return _cmf.Polygon_boundingbox(self)

    def __init__(self, *args): 
        """
        __init__(self) -> Polygon
        __init__(self, Polygon copy) -> Polygon
        __init__(self, Ring copy) -> Polygon
        __init__(self, BoundingBox copy) -> Polygon

        Polygon(const
        cmf::geometry::BoundingBox &copy) 
        """
        _cmf.Polygon_swiginit(self,_cmf.new_Polygon(*args))
    def Includes(self, *args):
        """
        Includes(self, point p) -> bool
        Includes(self, point p) -> bool
        Includes(self, shape shp) -> bool
        Includes(self, shape shp) -> bool

        bool
        Includes(const cmf::geometry::shape &shp) 
        """
        return _cmf.Polygon_Includes(self, *args)

    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf.Polygon___len__(self)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> Ring"""
        return _cmf.Polygon___getitem__(self, *args)

    def __contains___(self,p):
        return self.Includes(p)

    __swig_destroy__ = _cmf.delete_Polygon
Polygon.Area = new_instancemethod(_cmf.Polygon_Area,None,Polygon)
Polygon.size = new_instancemethod(_cmf.Polygon_size,None,Polygon)
Polygon.AddPart = new_instancemethod(_cmf.Polygon_AddPart,None,Polygon)
Polygon.boundingbox = new_instancemethod(_cmf.Polygon_boundingbox,None,Polygon)
Polygon.Includes = new_instancemethod(_cmf.Polygon_Includes,None,Polygon)
Polygon.__len__ = new_instancemethod(_cmf.Polygon___len__,None,Polygon)
Polygon.__getitem__ = new_instancemethod(_cmf.Polygon___getitem__,None,Polygon)
Polygon_swigregister = _cmf.Polygon_swigregister
Polygon_swigregister(Polygon)

class Rings(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.Rings_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.Rings___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.Rings___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.Rings___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.Rings_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> Rings"""
        return _cmf.Rings___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, Rings v)"""
        return _cmf.Rings___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.Rings___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.Rings___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> Rings
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.Rings___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, Rings v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.Rings___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.Rings_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.Rings_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.Rings_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.Rings_clear(self)

    def swap(self, *args):
        """swap(self, Rings v)"""
        return _cmf.Rings_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.Rings_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.Rings_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.Rings_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.Rings_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.Rings_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.Rings_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.Rings_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Rings
        __init__(self, Rings arg0) -> Rings
        __init__(self, size_type size) -> Rings
        __init__(self, size_type size, value_type value) -> Rings
        """
        _cmf.Rings_swiginit(self,_cmf.new_Rings(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.Rings_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.Rings_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.Rings_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.Rings_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.Rings_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.Rings_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.Rings_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.Rings_capacity(self)

    __swig_destroy__ = _cmf.delete_Rings
Rings.iterator = new_instancemethod(_cmf.Rings_iterator,None,Rings)
Rings.__nonzero__ = new_instancemethod(_cmf.Rings___nonzero__,None,Rings)
Rings.__bool__ = new_instancemethod(_cmf.Rings___bool__,None,Rings)
Rings.__len__ = new_instancemethod(_cmf.Rings___len__,None,Rings)
Rings.pop = new_instancemethod(_cmf.Rings_pop,None,Rings)
Rings.__getslice__ = new_instancemethod(_cmf.Rings___getslice__,None,Rings)
Rings.__setslice__ = new_instancemethod(_cmf.Rings___setslice__,None,Rings)
Rings.__delslice__ = new_instancemethod(_cmf.Rings___delslice__,None,Rings)
Rings.__delitem__ = new_instancemethod(_cmf.Rings___delitem__,None,Rings)
Rings.__getitem__ = new_instancemethod(_cmf.Rings___getitem__,None,Rings)
Rings.__setitem__ = new_instancemethod(_cmf.Rings___setitem__,None,Rings)
Rings.append = new_instancemethod(_cmf.Rings_append,None,Rings)
Rings.empty = new_instancemethod(_cmf.Rings_empty,None,Rings)
Rings.size = new_instancemethod(_cmf.Rings_size,None,Rings)
Rings.clear = new_instancemethod(_cmf.Rings_clear,None,Rings)
Rings.swap = new_instancemethod(_cmf.Rings_swap,None,Rings)
Rings.get_allocator = new_instancemethod(_cmf.Rings_get_allocator,None,Rings)
Rings.begin = new_instancemethod(_cmf.Rings_begin,None,Rings)
Rings.end = new_instancemethod(_cmf.Rings_end,None,Rings)
Rings.rbegin = new_instancemethod(_cmf.Rings_rbegin,None,Rings)
Rings.rend = new_instancemethod(_cmf.Rings_rend,None,Rings)
Rings.pop_back = new_instancemethod(_cmf.Rings_pop_back,None,Rings)
Rings.erase = new_instancemethod(_cmf.Rings_erase,None,Rings)
Rings.push_back = new_instancemethod(_cmf.Rings_push_back,None,Rings)
Rings.front = new_instancemethod(_cmf.Rings_front,None,Rings)
Rings.back = new_instancemethod(_cmf.Rings_back,None,Rings)
Rings.assign = new_instancemethod(_cmf.Rings_assign,None,Rings)
Rings.resize = new_instancemethod(_cmf.Rings_resize,None,Rings)
Rings.insert = new_instancemethod(_cmf.Rings_insert,None,Rings)
Rings.reserve = new_instancemethod(_cmf.Rings_reserve,None,Rings)
Rings.capacity = new_instancemethod(_cmf.Rings_capacity,None,Rings)
Rings_swigregister = _cmf.Rings_swigregister
Rings_swigregister(Rings)

class Lines(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.Lines_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.Lines___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.Lines___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.Lines___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.Lines_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> Lines"""
        return _cmf.Lines___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, Lines v)"""
        return _cmf.Lines___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.Lines___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.Lines___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> Lines
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.Lines___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, Lines v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.Lines___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.Lines_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.Lines_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.Lines_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.Lines_clear(self)

    def swap(self, *args):
        """swap(self, Lines v)"""
        return _cmf.Lines_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.Lines_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.Lines_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.Lines_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.Lines_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.Lines_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.Lines_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.Lines_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Lines
        __init__(self, Lines arg0) -> Lines
        __init__(self, size_type size) -> Lines
        __init__(self, size_type size, value_type value) -> Lines
        """
        _cmf.Lines_swiginit(self,_cmf.new_Lines(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.Lines_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.Lines_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.Lines_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.Lines_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.Lines_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.Lines_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.Lines_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.Lines_capacity(self)

    __swig_destroy__ = _cmf.delete_Lines
Lines.iterator = new_instancemethod(_cmf.Lines_iterator,None,Lines)
Lines.__nonzero__ = new_instancemethod(_cmf.Lines___nonzero__,None,Lines)
Lines.__bool__ = new_instancemethod(_cmf.Lines___bool__,None,Lines)
Lines.__len__ = new_instancemethod(_cmf.Lines___len__,None,Lines)
Lines.pop = new_instancemethod(_cmf.Lines_pop,None,Lines)
Lines.__getslice__ = new_instancemethod(_cmf.Lines___getslice__,None,Lines)
Lines.__setslice__ = new_instancemethod(_cmf.Lines___setslice__,None,Lines)
Lines.__delslice__ = new_instancemethod(_cmf.Lines___delslice__,None,Lines)
Lines.__delitem__ = new_instancemethod(_cmf.Lines___delitem__,None,Lines)
Lines.__getitem__ = new_instancemethod(_cmf.Lines___getitem__,None,Lines)
Lines.__setitem__ = new_instancemethod(_cmf.Lines___setitem__,None,Lines)
Lines.append = new_instancemethod(_cmf.Lines_append,None,Lines)
Lines.empty = new_instancemethod(_cmf.Lines_empty,None,Lines)
Lines.size = new_instancemethod(_cmf.Lines_size,None,Lines)
Lines.clear = new_instancemethod(_cmf.Lines_clear,None,Lines)
Lines.swap = new_instancemethod(_cmf.Lines_swap,None,Lines)
Lines.get_allocator = new_instancemethod(_cmf.Lines_get_allocator,None,Lines)
Lines.begin = new_instancemethod(_cmf.Lines_begin,None,Lines)
Lines.end = new_instancemethod(_cmf.Lines_end,None,Lines)
Lines.rbegin = new_instancemethod(_cmf.Lines_rbegin,None,Lines)
Lines.rend = new_instancemethod(_cmf.Lines_rend,None,Lines)
Lines.pop_back = new_instancemethod(_cmf.Lines_pop_back,None,Lines)
Lines.erase = new_instancemethod(_cmf.Lines_erase,None,Lines)
Lines.push_back = new_instancemethod(_cmf.Lines_push_back,None,Lines)
Lines.front = new_instancemethod(_cmf.Lines_front,None,Lines)
Lines.back = new_instancemethod(_cmf.Lines_back,None,Lines)
Lines.assign = new_instancemethod(_cmf.Lines_assign,None,Lines)
Lines.resize = new_instancemethod(_cmf.Lines_resize,None,Lines)
Lines.insert = new_instancemethod(_cmf.Lines_insert,None,Lines)
Lines.reserve = new_instancemethod(_cmf.Lines_reserve,None,Lines)
Lines.capacity = new_instancemethod(_cmf.Lines_capacity,None,Lines)
Lines_swigregister = _cmf.Lines_swigregister
Lines_swigregister(Lines)

class Points(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.Points_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.Points___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.Points___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.Points___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.Points_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> Points"""
        return _cmf.Points___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, Points v)"""
        return _cmf.Points___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.Points___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.Points___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> Points
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.Points___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, Points v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.Points___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.Points_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.Points_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.Points_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.Points_clear(self)

    def swap(self, *args):
        """swap(self, Points v)"""
        return _cmf.Points_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.Points_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.Points_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.Points_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.Points_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.Points_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.Points_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.Points_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Points
        __init__(self, Points arg0) -> Points
        __init__(self, size_type size) -> Points
        __init__(self, size_type size, value_type value) -> Points
        """
        _cmf.Points_swiginit(self,_cmf.new_Points(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.Points_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.Points_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.Points_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.Points_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.Points_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.Points_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.Points_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.Points_capacity(self)

    __swig_destroy__ = _cmf.delete_Points
Points.iterator = new_instancemethod(_cmf.Points_iterator,None,Points)
Points.__nonzero__ = new_instancemethod(_cmf.Points___nonzero__,None,Points)
Points.__bool__ = new_instancemethod(_cmf.Points___bool__,None,Points)
Points.__len__ = new_instancemethod(_cmf.Points___len__,None,Points)
Points.pop = new_instancemethod(_cmf.Points_pop,None,Points)
Points.__getslice__ = new_instancemethod(_cmf.Points___getslice__,None,Points)
Points.__setslice__ = new_instancemethod(_cmf.Points___setslice__,None,Points)
Points.__delslice__ = new_instancemethod(_cmf.Points___delslice__,None,Points)
Points.__delitem__ = new_instancemethod(_cmf.Points___delitem__,None,Points)
Points.__getitem__ = new_instancemethod(_cmf.Points___getitem__,None,Points)
Points.__setitem__ = new_instancemethod(_cmf.Points___setitem__,None,Points)
Points.append = new_instancemethod(_cmf.Points_append,None,Points)
Points.empty = new_instancemethod(_cmf.Points_empty,None,Points)
Points.size = new_instancemethod(_cmf.Points_size,None,Points)
Points.clear = new_instancemethod(_cmf.Points_clear,None,Points)
Points.swap = new_instancemethod(_cmf.Points_swap,None,Points)
Points.get_allocator = new_instancemethod(_cmf.Points_get_allocator,None,Points)
Points.begin = new_instancemethod(_cmf.Points_begin,None,Points)
Points.end = new_instancemethod(_cmf.Points_end,None,Points)
Points.rbegin = new_instancemethod(_cmf.Points_rbegin,None,Points)
Points.rend = new_instancemethod(_cmf.Points_rend,None,Points)
Points.pop_back = new_instancemethod(_cmf.Points_pop_back,None,Points)
Points.erase = new_instancemethod(_cmf.Points_erase,None,Points)
Points.push_back = new_instancemethod(_cmf.Points_push_back,None,Points)
Points.front = new_instancemethod(_cmf.Points_front,None,Points)
Points.back = new_instancemethod(_cmf.Points_back,None,Points)
Points.assign = new_instancemethod(_cmf.Points_assign,None,Points)
Points.resize = new_instancemethod(_cmf.Points_resize,None,Points)
Points.insert = new_instancemethod(_cmf.Points_insert,None,Points)
Points.reserve = new_instancemethod(_cmf.Points_reserve,None,Points)
Points.capacity = new_instancemethod(_cmf.Points_capacity,None,Points)
Points_swigregister = _cmf.Points_swigregister
Points_swigregister(Points)

class MultiPoints(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.MultiPoints_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.MultiPoints___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.MultiPoints___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.MultiPoints___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.MultiPoints_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> MultiPoints"""
        return _cmf.MultiPoints___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, MultiPoints v)"""
        return _cmf.MultiPoints___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.MultiPoints___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.MultiPoints___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> MultiPoints
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.MultiPoints___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, MultiPoints v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.MultiPoints___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.MultiPoints_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.MultiPoints_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.MultiPoints_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.MultiPoints_clear(self)

    def swap(self, *args):
        """swap(self, MultiPoints v)"""
        return _cmf.MultiPoints_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.MultiPoints_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.MultiPoints_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.MultiPoints_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.MultiPoints_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.MultiPoints_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.MultiPoints_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.MultiPoints_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> MultiPoints
        __init__(self, MultiPoints arg0) -> MultiPoints
        __init__(self, size_type size) -> MultiPoints
        __init__(self, size_type size, value_type value) -> MultiPoints
        """
        _cmf.MultiPoints_swiginit(self,_cmf.new_MultiPoints(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.MultiPoints_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.MultiPoints_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.MultiPoints_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.MultiPoints_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.MultiPoints_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.MultiPoints_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.MultiPoints_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.MultiPoints_capacity(self)

    __swig_destroy__ = _cmf.delete_MultiPoints
MultiPoints.iterator = new_instancemethod(_cmf.MultiPoints_iterator,None,MultiPoints)
MultiPoints.__nonzero__ = new_instancemethod(_cmf.MultiPoints___nonzero__,None,MultiPoints)
MultiPoints.__bool__ = new_instancemethod(_cmf.MultiPoints___bool__,None,MultiPoints)
MultiPoints.__len__ = new_instancemethod(_cmf.MultiPoints___len__,None,MultiPoints)
MultiPoints.pop = new_instancemethod(_cmf.MultiPoints_pop,None,MultiPoints)
MultiPoints.__getslice__ = new_instancemethod(_cmf.MultiPoints___getslice__,None,MultiPoints)
MultiPoints.__setslice__ = new_instancemethod(_cmf.MultiPoints___setslice__,None,MultiPoints)
MultiPoints.__delslice__ = new_instancemethod(_cmf.MultiPoints___delslice__,None,MultiPoints)
MultiPoints.__delitem__ = new_instancemethod(_cmf.MultiPoints___delitem__,None,MultiPoints)
MultiPoints.__getitem__ = new_instancemethod(_cmf.MultiPoints___getitem__,None,MultiPoints)
MultiPoints.__setitem__ = new_instancemethod(_cmf.MultiPoints___setitem__,None,MultiPoints)
MultiPoints.append = new_instancemethod(_cmf.MultiPoints_append,None,MultiPoints)
MultiPoints.empty = new_instancemethod(_cmf.MultiPoints_empty,None,MultiPoints)
MultiPoints.size = new_instancemethod(_cmf.MultiPoints_size,None,MultiPoints)
MultiPoints.clear = new_instancemethod(_cmf.MultiPoints_clear,None,MultiPoints)
MultiPoints.swap = new_instancemethod(_cmf.MultiPoints_swap,None,MultiPoints)
MultiPoints.get_allocator = new_instancemethod(_cmf.MultiPoints_get_allocator,None,MultiPoints)
MultiPoints.begin = new_instancemethod(_cmf.MultiPoints_begin,None,MultiPoints)
MultiPoints.end = new_instancemethod(_cmf.MultiPoints_end,None,MultiPoints)
MultiPoints.rbegin = new_instancemethod(_cmf.MultiPoints_rbegin,None,MultiPoints)
MultiPoints.rend = new_instancemethod(_cmf.MultiPoints_rend,None,MultiPoints)
MultiPoints.pop_back = new_instancemethod(_cmf.MultiPoints_pop_back,None,MultiPoints)
MultiPoints.erase = new_instancemethod(_cmf.MultiPoints_erase,None,MultiPoints)
MultiPoints.push_back = new_instancemethod(_cmf.MultiPoints_push_back,None,MultiPoints)
MultiPoints.front = new_instancemethod(_cmf.MultiPoints_front,None,MultiPoints)
MultiPoints.back = new_instancemethod(_cmf.MultiPoints_back,None,MultiPoints)
MultiPoints.assign = new_instancemethod(_cmf.MultiPoints_assign,None,MultiPoints)
MultiPoints.resize = new_instancemethod(_cmf.MultiPoints_resize,None,MultiPoints)
MultiPoints.insert = new_instancemethod(_cmf.MultiPoints_insert,None,MultiPoints)
MultiPoints.reserve = new_instancemethod(_cmf.MultiPoints_reserve,None,MultiPoints)
MultiPoints.capacity = new_instancemethod(_cmf.MultiPoints_capacity,None,MultiPoints)
MultiPoints_swigregister = _cmf.MultiPoints_swigregister
MultiPoints_swigregister(MultiPoints)

class PolyLines(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.PolyLines_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.PolyLines___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.PolyLines___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.PolyLines___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.PolyLines_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> PolyLines"""
        return _cmf.PolyLines___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, PolyLines v)"""
        return _cmf.PolyLines___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.PolyLines___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.PolyLines___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> PolyLines
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.PolyLines___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, PolyLines v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.PolyLines___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.PolyLines_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.PolyLines_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.PolyLines_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.PolyLines_clear(self)

    def swap(self, *args):
        """swap(self, PolyLines v)"""
        return _cmf.PolyLines_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.PolyLines_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.PolyLines_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.PolyLines_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.PolyLines_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.PolyLines_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.PolyLines_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.PolyLines_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> PolyLines
        __init__(self, PolyLines arg0) -> PolyLines
        __init__(self, size_type size) -> PolyLines
        __init__(self, size_type size, value_type value) -> PolyLines
        """
        _cmf.PolyLines_swiginit(self,_cmf.new_PolyLines(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.PolyLines_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.PolyLines_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.PolyLines_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.PolyLines_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.PolyLines_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.PolyLines_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.PolyLines_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.PolyLines_capacity(self)

    __swig_destroy__ = _cmf.delete_PolyLines
PolyLines.iterator = new_instancemethod(_cmf.PolyLines_iterator,None,PolyLines)
PolyLines.__nonzero__ = new_instancemethod(_cmf.PolyLines___nonzero__,None,PolyLines)
PolyLines.__bool__ = new_instancemethod(_cmf.PolyLines___bool__,None,PolyLines)
PolyLines.__len__ = new_instancemethod(_cmf.PolyLines___len__,None,PolyLines)
PolyLines.pop = new_instancemethod(_cmf.PolyLines_pop,None,PolyLines)
PolyLines.__getslice__ = new_instancemethod(_cmf.PolyLines___getslice__,None,PolyLines)
PolyLines.__setslice__ = new_instancemethod(_cmf.PolyLines___setslice__,None,PolyLines)
PolyLines.__delslice__ = new_instancemethod(_cmf.PolyLines___delslice__,None,PolyLines)
PolyLines.__delitem__ = new_instancemethod(_cmf.PolyLines___delitem__,None,PolyLines)
PolyLines.__getitem__ = new_instancemethod(_cmf.PolyLines___getitem__,None,PolyLines)
PolyLines.__setitem__ = new_instancemethod(_cmf.PolyLines___setitem__,None,PolyLines)
PolyLines.append = new_instancemethod(_cmf.PolyLines_append,None,PolyLines)
PolyLines.empty = new_instancemethod(_cmf.PolyLines_empty,None,PolyLines)
PolyLines.size = new_instancemethod(_cmf.PolyLines_size,None,PolyLines)
PolyLines.clear = new_instancemethod(_cmf.PolyLines_clear,None,PolyLines)
PolyLines.swap = new_instancemethod(_cmf.PolyLines_swap,None,PolyLines)
PolyLines.get_allocator = new_instancemethod(_cmf.PolyLines_get_allocator,None,PolyLines)
PolyLines.begin = new_instancemethod(_cmf.PolyLines_begin,None,PolyLines)
PolyLines.end = new_instancemethod(_cmf.PolyLines_end,None,PolyLines)
PolyLines.rbegin = new_instancemethod(_cmf.PolyLines_rbegin,None,PolyLines)
PolyLines.rend = new_instancemethod(_cmf.PolyLines_rend,None,PolyLines)
PolyLines.pop_back = new_instancemethod(_cmf.PolyLines_pop_back,None,PolyLines)
PolyLines.erase = new_instancemethod(_cmf.PolyLines_erase,None,PolyLines)
PolyLines.push_back = new_instancemethod(_cmf.PolyLines_push_back,None,PolyLines)
PolyLines.front = new_instancemethod(_cmf.PolyLines_front,None,PolyLines)
PolyLines.back = new_instancemethod(_cmf.PolyLines_back,None,PolyLines)
PolyLines.assign = new_instancemethod(_cmf.PolyLines_assign,None,PolyLines)
PolyLines.resize = new_instancemethod(_cmf.PolyLines_resize,None,PolyLines)
PolyLines.insert = new_instancemethod(_cmf.PolyLines_insert,None,PolyLines)
PolyLines.reserve = new_instancemethod(_cmf.PolyLines_reserve,None,PolyLines)
PolyLines.capacity = new_instancemethod(_cmf.PolyLines_capacity,None,PolyLines)
PolyLines_swigregister = _cmf.PolyLines_swigregister
PolyLines_swigregister(PolyLines)

class Polygons(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.Polygons_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.Polygons___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.Polygons___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.Polygons___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.Polygons_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> Polygons"""
        return _cmf.Polygons___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, Polygons v)"""
        return _cmf.Polygons___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.Polygons___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.Polygons___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> Polygons
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.Polygons___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, Polygons v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.Polygons___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.Polygons_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.Polygons_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.Polygons_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.Polygons_clear(self)

    def swap(self, *args):
        """swap(self, Polygons v)"""
        return _cmf.Polygons_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.Polygons_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.Polygons_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.Polygons_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.Polygons_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.Polygons_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.Polygons_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.Polygons_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Polygons
        __init__(self, Polygons arg0) -> Polygons
        __init__(self, size_type size) -> Polygons
        __init__(self, size_type size, value_type value) -> Polygons
        """
        _cmf.Polygons_swiginit(self,_cmf.new_Polygons(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.Polygons_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.Polygons_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.Polygons_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.Polygons_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.Polygons_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.Polygons_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.Polygons_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.Polygons_capacity(self)

    __swig_destroy__ = _cmf.delete_Polygons
Polygons.iterator = new_instancemethod(_cmf.Polygons_iterator,None,Polygons)
Polygons.__nonzero__ = new_instancemethod(_cmf.Polygons___nonzero__,None,Polygons)
Polygons.__bool__ = new_instancemethod(_cmf.Polygons___bool__,None,Polygons)
Polygons.__len__ = new_instancemethod(_cmf.Polygons___len__,None,Polygons)
Polygons.pop = new_instancemethod(_cmf.Polygons_pop,None,Polygons)
Polygons.__getslice__ = new_instancemethod(_cmf.Polygons___getslice__,None,Polygons)
Polygons.__setslice__ = new_instancemethod(_cmf.Polygons___setslice__,None,Polygons)
Polygons.__delslice__ = new_instancemethod(_cmf.Polygons___delslice__,None,Polygons)
Polygons.__delitem__ = new_instancemethod(_cmf.Polygons___delitem__,None,Polygons)
Polygons.__getitem__ = new_instancemethod(_cmf.Polygons___getitem__,None,Polygons)
Polygons.__setitem__ = new_instancemethod(_cmf.Polygons___setitem__,None,Polygons)
Polygons.append = new_instancemethod(_cmf.Polygons_append,None,Polygons)
Polygons.empty = new_instancemethod(_cmf.Polygons_empty,None,Polygons)
Polygons.size = new_instancemethod(_cmf.Polygons_size,None,Polygons)
Polygons.clear = new_instancemethod(_cmf.Polygons_clear,None,Polygons)
Polygons.swap = new_instancemethod(_cmf.Polygons_swap,None,Polygons)
Polygons.get_allocator = new_instancemethod(_cmf.Polygons_get_allocator,None,Polygons)
Polygons.begin = new_instancemethod(_cmf.Polygons_begin,None,Polygons)
Polygons.end = new_instancemethod(_cmf.Polygons_end,None,Polygons)
Polygons.rbegin = new_instancemethod(_cmf.Polygons_rbegin,None,Polygons)
Polygons.rend = new_instancemethod(_cmf.Polygons_rend,None,Polygons)
Polygons.pop_back = new_instancemethod(_cmf.Polygons_pop_back,None,Polygons)
Polygons.erase = new_instancemethod(_cmf.Polygons_erase,None,Polygons)
Polygons.push_back = new_instancemethod(_cmf.Polygons_push_back,None,Polygons)
Polygons.front = new_instancemethod(_cmf.Polygons_front,None,Polygons)
Polygons.back = new_instancemethod(_cmf.Polygons_back,None,Polygons)
Polygons.assign = new_instancemethod(_cmf.Polygons_assign,None,Polygons)
Polygons.resize = new_instancemethod(_cmf.Polygons_resize,None,Polygons)
Polygons.insert = new_instancemethod(_cmf.Polygons_insert,None,Polygons)
Polygons.reserve = new_instancemethod(_cmf.Polygons_reserve,None,Polygons)
Polygons.capacity = new_instancemethod(_cmf.Polygons_capacity,None,Polygons)
Polygons_swigregister = _cmf.Polygons_swigregister
Polygons_swigregister(Polygons)

class RasterStatistics(object):
    """
    Holds the statistics for a raster.

    C++ includes: Raster.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    min = _swig_property(_cmf.RasterStatistics_min_get, _cmf.RasterStatistics_min_set)
    max = _swig_property(_cmf.RasterStatistics_max_get, _cmf.RasterStatistics_max_set)
    mean = _swig_property(_cmf.RasterStatistics_mean_get, _cmf.RasterStatistics_mean_set)
    stdev = _swig_property(_cmf.RasterStatistics_stdev_get, _cmf.RasterStatistics_stdev_set)
    count = _swig_property(_cmf.RasterStatistics_count_get, _cmf.RasterStatistics_count_set)
    def __init__(self): 
        """
        __init__(self) -> RasterStatistics

        RasterStatistics()

        Count of cells with data. 
        """
        _cmf.RasterStatistics_swiginit(self,_cmf.new_RasterStatistics())
    __swig_destroy__ = _cmf.delete_RasterStatistics
RasterStatistics_swigregister = _cmf.RasterStatistics_swigregister
RasterStatistics_swigregister(RasterStatistics)

class Histogram(object):
    """
    Holds the histogram for a raster.

    C++ includes: Raster.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def min(self):
        """
        min(self) -> double

        double min()
        const

        Returns the left side of the first histogram bar. 
        """
        return _cmf.Histogram_min(self)

    def max(self):
        """
        max(self) -> double

        double max()
        const

        Returns the right side of the last histogram bar. 
        """
        return _cmf.Histogram_max(self)

    def barwidth(self):
        """
        barwidth(self) -> double

        double
        barwidth() const

        Returns the width of the histogram bars. 
        """
        return _cmf.Histogram_barwidth(self)

    def size(self):
        """
        size(self) -> int

        int size()
        const

        Returns the number of the historam bars. 
        """
        return _cmf.Histogram_size(self)

    def sum(self, until = 1e308):
        """
        sum(self, double until = 1e308) -> int
        sum(self) -> int

        int sum(double
        until=1e308) const

        Returns the number of entries with a value <= until, default is the
        total number of entries. 
        """
        return _cmf.Histogram_sum(self, until)

    def frequency(self, *args):
        """
        frequency(self, double val) -> int
        frequency(self, int pos) -> int

        int
        frequency(int pos) const

        Returns the frequency of bar number pos. 
        """
        return _cmf.Histogram_frequency(self, *args)

    def relfrequency(self, *args):
        """
        relfrequency(self, double val) -> double
        relfrequency(self, int pos) -> double

        double
        relfrequency(int pos) const

        Returns the relative frequency of bar number pos. 
        """
        return _cmf.Histogram_relfrequency(self, *args)

    def pos(self, *args):
        """
        pos(self, double val) -> int

        int pos(double
        val) const

        Returns the bar number, that contains value val. 
        """
        return _cmf.Histogram_pos(self, *args)

    def barcenter(self, *args):
        """
        barcenter(self, double pos) -> double

        double
        barcenter(double pos) const

        Returns the center of the bar at position pos. 
        """
        return _cmf.Histogram_barcenter(self, *args)

    def quantile(self, Quantile = 0.5):
        """
        quantile(self, double Quantile = 0.5) -> double
        quantile(self) -> double

        double
        quantile(double Quantile=0.5) const

        Returns the inexact quantile. The result gets better with higher
        numbers of bars Assumes the values of each bar uniformly distributed.

        """
        return _cmf.Histogram_quantile(self, Quantile)

    def CountValue(self, *args):
        """
        CountValue(self, double val)

        void
        CountValue(double val)

        Counts a value in the histogram. 
        """
        return _cmf.Histogram_CountValue(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double _min, double _max, double _width) -> Histogram
        __init__(self, double _min, double _max, size_t _count) -> Histogram

        Histogram(double _min, double _max, size_t _count)

        Creates a histogram with count bars ranging from _min to _max. 
        """
        _cmf.Histogram_swiginit(self,_cmf.new_Histogram(*args))
    def __getitem__(self,index):
        if index<0 : index=self.size()+index
        if index<0 or index>=self.size() : raise IndexError("Bar of histogram not available")
        return (self.barcenter(index),self.frequency(index))
    def __len__(self):
        return self.size()

    __swig_destroy__ = _cmf.delete_Histogram
Histogram.min = new_instancemethod(_cmf.Histogram_min,None,Histogram)
Histogram.max = new_instancemethod(_cmf.Histogram_max,None,Histogram)
Histogram.barwidth = new_instancemethod(_cmf.Histogram_barwidth,None,Histogram)
Histogram.size = new_instancemethod(_cmf.Histogram_size,None,Histogram)
Histogram.sum = new_instancemethod(_cmf.Histogram_sum,None,Histogram)
Histogram.frequency = new_instancemethod(_cmf.Histogram_frequency,None,Histogram)
Histogram.relfrequency = new_instancemethod(_cmf.Histogram_relfrequency,None,Histogram)
Histogram.pos = new_instancemethod(_cmf.Histogram_pos,None,Histogram)
Histogram.barcenter = new_instancemethod(_cmf.Histogram_barcenter,None,Histogram)
Histogram.quantile = new_instancemethod(_cmf.Histogram_quantile,None,Histogram)
Histogram.CountValue = new_instancemethod(_cmf.Histogram_CountValue,None,Histogram)
Histogram_swigregister = _cmf.Histogram_swigregister
Histogram_swigregister(Histogram)

class DoubleRaster(object):
    """
    Represents a raster dataset.

    C++ includes: Raster.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Xllcorner(self):
        """
        Xllcorner(self) -> double

        double
        Xllcorner() const

        x-Coordinate for the Lower Left corner (in cellsize units) 
        """
        return _cmf.DoubleRaster_Xllcorner(self)

    def Yllcorner(self):
        """
        Yllcorner(self) -> double

        double
        Yllcorner() const

        y-Coordinate for the Lower Left corner (in cellsize units) 
        """
        return _cmf.DoubleRaster_Yllcorner(self)

    def XCellsize(self):
        """
        XCellsize(self) -> double

        double
        XCellsize() const

        Cellsize of the raster. 
        """
        return _cmf.DoubleRaster_XCellsize(self)

    def YCellsize(self):
        """
        YCellsize(self) -> double

        double
        YCellsize() const

        Cellsize of the raster. 
        """
        return _cmf.DoubleRaster_YCellsize(self)

    def ColumnCount(self):
        """
        ColumnCount(self) -> int

        int
        ColumnCount() const

        Number of columns in the raster. 
        """
        return _cmf.DoubleRaster_ColumnCount(self)

    def RowCount(self):
        """
        RowCount(self) -> int

        int
        RowCount() const

        Number of rows in the raster. 
        """
        return _cmf.DoubleRaster_RowCount(self)

    def Width(self):
        """
        Width(self) -> double

        double Width()
        const

        Extent W-E in cellsize units. 
        """
        return _cmf.DoubleRaster_Width(self)

    def Height(self):
        """
        Height(self) -> double

        double Height()
        const

        Extent N-S in cellsize units. 
        """
        return _cmf.DoubleRaster_Height(self)

    def NoData(self):
        """
        NoData(self) -> double

        rasterType
        NoData() const

        Returns rasterType (NoData). 
        """
        return _cmf.DoubleRaster_NoData(self)

    def GetBounds(self):
        """
        GetBounds(self) -> BoundingBox

        BoundingBox
        GetBounds() const

        Returns the bounding box of the raster. 
        """
        return _cmf.DoubleRaster_GetBounds(self)

    def IdentifyXY(self, *args):
        """
        IdentifyXY(self, double x, double y) -> double

        rasterType
        IdentifyXY(double x, double y) const

        Returns the value of the raster at the given position. 
        """
        return _cmf.DoubleRaster_IdentifyXY(self, *args)

    def IdentifyRowCol(self, *args):
        """
        IdentifyRowCol(self, int row, int col) -> double

        rasterType IdentifyRowCol(int row, int col) const

        Returns the value of the raster at the given cell. 
        """
        return _cmf.DoubleRaster_IdentifyRowCol(self, *args)

    def IdentifyColRow(self, *args):
        """
        IdentifyColRow(self, int col, int row) -> double

        rasterType IdentifyColRow(int col, int row) const

        Returns the value of the raster at the given cell. 
        """
        return _cmf.DoubleRaster_IdentifyColRow(self, *args)

    def HasData(self, *args):
        """
        HasData(self, double x, double y) -> bool
        HasData(self, int col, int row) -> bool

        bool
        HasData(int col, int row) const

        Returns true if there is data at the given position. 
        """
        return _cmf.DoubleRaster_HasData(self, *args)

    def SetData(self, *args):
        """
        SetData(self, double x, double y, double val)
        SetData(self, int col, int row, double val)

        void
        SetData(int col, int row, rasterType val)

        Sets a value at the given position.

        Parameters:
        -----------

        col:  Column of the raster

        row:  Row of the raster

        val:  Value to set at (col,row) 
        """
        return _cmf.DoubleRaster_SetData(self, *args)

    def GetXPosition(self, *args):
        """
        GetXPosition(self, int col) -> double

        double
        GetXPosition(int col)

        Returns the real world x position of a column. 
        """
        return _cmf.DoubleRaster_GetXPosition(self, *args)

    def GetYPosition(self, *args):
        """
        GetYPosition(self, int row) -> double

        double
        GetYPosition(int row)

        Returns the real world y position of a row. 
        """
        return _cmf.DoubleRaster_GetYPosition(self, *args)

    def statistics(self):
        """
        statistics(self) -> RasterStatistics

        RasterStatistics statistics()

        Creates statistics for the raster. 
        """
        return _cmf.DoubleRaster_statistics(self)

    def histogram(self, bins = 100):
        """
        histogram(self, size_t bins = 100) -> Histogram
        histogram(self) -> Histogram

        Histogram
        histogram(size_t bins=100) 
        """
        return _cmf.DoubleRaster_histogram(self, bins)

    def __imul__(self, *args):
        """
        __imul__(self, double scalar) -> DoubleRaster
        __imul__(self, DoubleRaster raster) -> DoubleRaster
        """
        return _cmf.DoubleRaster___imul__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, double scalar) -> DoubleRaster
        __iadd__(self, DoubleRaster raster) -> DoubleRaster
        """
        return _cmf.DoubleRaster___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, double scalar) -> DoubleRaster
        __isub__(self, DoubleRaster raster) -> DoubleRaster
        """
        return _cmf.DoubleRaster___isub__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, int ncols, int nrows, double xllcorner, double yllcorner, 
            double xcellsize, double ycellsize, double nodata, 
            double initialValue = 0) -> DoubleRaster
        __init__(self, int ncols, int nrows, double xllcorner, double yllcorner, 
            double xcellsize, double ycellsize, double nodata) -> DoubleRaster
        __init__(self, DoubleRaster R) -> DoubleRaster
        __init__(self, DoubleRaster R, double FixedValue) -> DoubleRaster
        __init__(self, string FileName) -> DoubleRaster
        __init__(self, std::istream ASCFile) -> DoubleRaster

        Raster(std::istream &ASCFile)

        Loads an ESRI ASCII-raster data set. 
        """
        _cmf.DoubleRaster_swiginit(self,_cmf.new_DoubleRaster(*args))
    def WriteToASCFile(self, *args):
        """
        WriteToASCFile(self, std::ostream ASCFile)
        WriteToASCFile(self, string filename)

        void
        WriteToASCFile(std::string filename)

        Writes the raster to a filename. 
        """
        return _cmf.DoubleRaster_WriteToASCFile(self, *args)

    def WriteToBinary(self, *args):
        """
        WriteToBinary(self, string filename)

        void
        WriteToBinary(std::string filename) const

        Writes the data to the file with the given file name and the header to
        a filename with the extension .hdr.

        If the filename has the extension .flt and the raster is a float
        raster the saved file can be read by ArcGIS 
        """
        return _cmf.DoubleRaster_WriteToBinary(self, *args)

    def ToInt(self):
        """
        ToInt(self) -> IntRaster

        Raster<int>
        ToInt() const

        Converts the raster to a raster of int. 
        """
        return _cmf.DoubleRaster_ToInt(self)

    def ToFloat(self):
        """
        ToFloat(self) -> SingleRaster

        Raster<float>
        ToFloat()

        Converts the raster to a raster of float (32bit). 
        """
        return _cmf.DoubleRaster_ToFloat(self)

    def ToDouble(self):
        """
        ToDouble(self) -> DoubleRaster

        Raster<double> ToDouble()

        Converts the raster to a raster of float (64bit). 
        """
        return _cmf.DoubleRaster_ToDouble(self)

    def focal_min(self, n = 3):
        """
        focal_min(self, int n = 3) -> DoubleRaster
        focal_min(self) -> DoubleRaster

        Raster<rasterType> focal_min(int n=3)

        Creates a raster, which contains for each cell the minimum of the
        surrounding n x n window. 
        """
        return _cmf.DoubleRaster_focal_min(self, n)

    def focal_max(self, n = 3):
        """
        focal_max(self, int n = 3) -> DoubleRaster
        focal_max(self) -> DoubleRaster

        Raster<rasterType> focal_max(int n=3)

        Creates a raster, which contains for each cell the maximum of the
        surrounding n x n window. 
        """
        return _cmf.DoubleRaster_focal_max(self, n)

    def focal_mean(self, n = 3):
        """
        focal_mean(self, int n = 3) -> DoubleRaster
        focal_mean(self) -> DoubleRaster

        Raster<rasterType> focal_mean(int n=3)

        Creates a raster, which contains for each cell the mean of the
        surrounding n x n window. 
        """
        return _cmf.DoubleRaster_focal_mean(self, n)

    def focal_stdev(self, n = 3):
        """
        focal_stdev(self, int n = 3) -> DoubleRaster
        focal_stdev(self) -> DoubleRaster

        Raster<rasterType> focal_stdev(int n=3)

        Creates a raster, which contains for each cell the standard deviation
        of the surrounding n x n window. 
        """
        return _cmf.DoubleRaster_focal_stdev(self, n)

    def focal_majority(self, n = 3):
        """
        focal_majority(self, int n = 3) -> DoubleRaster
        focal_majority(self) -> DoubleRaster

        Raster<rasterType> focal_majority(int n=3)

        Creates a raster, which contains for each cell the majority value of
        the surrounding n x n window (usually only used for integer raster).

        """
        return _cmf.DoubleRaster_focal_majority(self, n)

    def focal_mean_difference(self, n = 3):
        """
        focal_mean_difference(self, int n = 3) -> DoubleRaster
        focal_mean_difference(self) -> DoubleRaster

        Raster<rasterType> focal_mean_difference(int n=3)

        Creates a raster, which contains for each cell the difference between
        the actual value and the mean of the surrounding n x n window (usually
        only used for integer raster) This function can be used to identify
        very important points (VIP) for triangulation. 
        """
        return _cmf.DoubleRaster_focal_mean_difference(self, n)

    def __len__(self):
        """
        __len__(self) -> int

        int __len__()

        """
        return _cmf.DoubleRaster___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(self, int index) -> double

        rasterType
        __getitem__(int index) 
        """
        return _cmf.DoubleRaster___getitem__(self, *args)

    __swig_destroy__ = _cmf.delete_DoubleRaster
DoubleRaster.Xllcorner = new_instancemethod(_cmf.DoubleRaster_Xllcorner,None,DoubleRaster)
DoubleRaster.Yllcorner = new_instancemethod(_cmf.DoubleRaster_Yllcorner,None,DoubleRaster)
DoubleRaster.XCellsize = new_instancemethod(_cmf.DoubleRaster_XCellsize,None,DoubleRaster)
DoubleRaster.YCellsize = new_instancemethod(_cmf.DoubleRaster_YCellsize,None,DoubleRaster)
DoubleRaster.ColumnCount = new_instancemethod(_cmf.DoubleRaster_ColumnCount,None,DoubleRaster)
DoubleRaster.RowCount = new_instancemethod(_cmf.DoubleRaster_RowCount,None,DoubleRaster)
DoubleRaster.Width = new_instancemethod(_cmf.DoubleRaster_Width,None,DoubleRaster)
DoubleRaster.Height = new_instancemethod(_cmf.DoubleRaster_Height,None,DoubleRaster)
DoubleRaster.NoData = new_instancemethod(_cmf.DoubleRaster_NoData,None,DoubleRaster)
DoubleRaster.GetBounds = new_instancemethod(_cmf.DoubleRaster_GetBounds,None,DoubleRaster)
DoubleRaster.IdentifyXY = new_instancemethod(_cmf.DoubleRaster_IdentifyXY,None,DoubleRaster)
DoubleRaster.IdentifyRowCol = new_instancemethod(_cmf.DoubleRaster_IdentifyRowCol,None,DoubleRaster)
DoubleRaster.IdentifyColRow = new_instancemethod(_cmf.DoubleRaster_IdentifyColRow,None,DoubleRaster)
DoubleRaster.HasData = new_instancemethod(_cmf.DoubleRaster_HasData,None,DoubleRaster)
DoubleRaster.SetData = new_instancemethod(_cmf.DoubleRaster_SetData,None,DoubleRaster)
DoubleRaster.GetXPosition = new_instancemethod(_cmf.DoubleRaster_GetXPosition,None,DoubleRaster)
DoubleRaster.GetYPosition = new_instancemethod(_cmf.DoubleRaster_GetYPosition,None,DoubleRaster)
DoubleRaster.statistics = new_instancemethod(_cmf.DoubleRaster_statistics,None,DoubleRaster)
DoubleRaster.histogram = new_instancemethod(_cmf.DoubleRaster_histogram,None,DoubleRaster)
DoubleRaster.__imul__ = new_instancemethod(_cmf.DoubleRaster___imul__,None,DoubleRaster)
DoubleRaster.__iadd__ = new_instancemethod(_cmf.DoubleRaster___iadd__,None,DoubleRaster)
DoubleRaster.__isub__ = new_instancemethod(_cmf.DoubleRaster___isub__,None,DoubleRaster)
DoubleRaster.WriteToASCFile = new_instancemethod(_cmf.DoubleRaster_WriteToASCFile,None,DoubleRaster)
DoubleRaster.WriteToBinary = new_instancemethod(_cmf.DoubleRaster_WriteToBinary,None,DoubleRaster)
DoubleRaster.ToInt = new_instancemethod(_cmf.DoubleRaster_ToInt,None,DoubleRaster)
DoubleRaster.ToFloat = new_instancemethod(_cmf.DoubleRaster_ToFloat,None,DoubleRaster)
DoubleRaster.ToDouble = new_instancemethod(_cmf.DoubleRaster_ToDouble,None,DoubleRaster)
DoubleRaster.focal_min = new_instancemethod(_cmf.DoubleRaster_focal_min,None,DoubleRaster)
DoubleRaster.focal_max = new_instancemethod(_cmf.DoubleRaster_focal_max,None,DoubleRaster)
DoubleRaster.focal_mean = new_instancemethod(_cmf.DoubleRaster_focal_mean,None,DoubleRaster)
DoubleRaster.focal_stdev = new_instancemethod(_cmf.DoubleRaster_focal_stdev,None,DoubleRaster)
DoubleRaster.focal_majority = new_instancemethod(_cmf.DoubleRaster_focal_majority,None,DoubleRaster)
DoubleRaster.focal_mean_difference = new_instancemethod(_cmf.DoubleRaster_focal_mean_difference,None,DoubleRaster)
DoubleRaster.__len__ = new_instancemethod(_cmf.DoubleRaster___len__,None,DoubleRaster)
DoubleRaster.__getitem__ = new_instancemethod(_cmf.DoubleRaster___getitem__,None,DoubleRaster)
DoubleRaster_swigregister = _cmf.DoubleRaster_swigregister
DoubleRaster_swigregister(DoubleRaster)

class IntRaster(object):
    """
    Represents a raster dataset.

    C++ includes: Raster.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Xllcorner(self):
        """
        Xllcorner(self) -> double

        double
        Xllcorner() const

        x-Coordinate for the Lower Left corner (in cellsize units) 
        """
        return _cmf.IntRaster_Xllcorner(self)

    def Yllcorner(self):
        """
        Yllcorner(self) -> double

        double
        Yllcorner() const

        y-Coordinate for the Lower Left corner (in cellsize units) 
        """
        return _cmf.IntRaster_Yllcorner(self)

    def XCellsize(self):
        """
        XCellsize(self) -> double

        double
        XCellsize() const

        Cellsize of the raster. 
        """
        return _cmf.IntRaster_XCellsize(self)

    def YCellsize(self):
        """
        YCellsize(self) -> double

        double
        YCellsize() const

        Cellsize of the raster. 
        """
        return _cmf.IntRaster_YCellsize(self)

    def ColumnCount(self):
        """
        ColumnCount(self) -> int

        int
        ColumnCount() const

        Number of columns in the raster. 
        """
        return _cmf.IntRaster_ColumnCount(self)

    def RowCount(self):
        """
        RowCount(self) -> int

        int
        RowCount() const

        Number of rows in the raster. 
        """
        return _cmf.IntRaster_RowCount(self)

    def Width(self):
        """
        Width(self) -> double

        double Width()
        const

        Extent W-E in cellsize units. 
        """
        return _cmf.IntRaster_Width(self)

    def Height(self):
        """
        Height(self) -> double

        double Height()
        const

        Extent N-S in cellsize units. 
        """
        return _cmf.IntRaster_Height(self)

    def NoData(self):
        """
        NoData(self) -> int

        rasterType
        NoData() const

        Returns rasterType (NoData). 
        """
        return _cmf.IntRaster_NoData(self)

    def GetBounds(self):
        """
        GetBounds(self) -> BoundingBox

        BoundingBox
        GetBounds() const

        Returns the bounding box of the raster. 
        """
        return _cmf.IntRaster_GetBounds(self)

    def IdentifyXY(self, *args):
        """
        IdentifyXY(self, double x, double y) -> int

        rasterType
        IdentifyXY(double x, double y) const

        Returns the value of the raster at the given position. 
        """
        return _cmf.IntRaster_IdentifyXY(self, *args)

    def IdentifyRowCol(self, *args):
        """
        IdentifyRowCol(self, int row, int col) -> int

        rasterType IdentifyRowCol(int row, int col) const

        Returns the value of the raster at the given cell. 
        """
        return _cmf.IntRaster_IdentifyRowCol(self, *args)

    def IdentifyColRow(self, *args):
        """
        IdentifyColRow(self, int col, int row) -> int

        rasterType IdentifyColRow(int col, int row) const

        Returns the value of the raster at the given cell. 
        """
        return _cmf.IntRaster_IdentifyColRow(self, *args)

    def HasData(self, *args):
        """
        HasData(self, double x, double y) -> bool
        HasData(self, int col, int row) -> bool

        bool
        HasData(int col, int row) const

        Returns true if there is data at the given position. 
        """
        return _cmf.IntRaster_HasData(self, *args)

    def SetData(self, *args):
        """
        SetData(self, double x, double y, int val)
        SetData(self, int col, int row, int val)

        void
        SetData(int col, int row, rasterType val)

        Sets a value at the given position.

        Parameters:
        -----------

        col:  Column of the raster

        row:  Row of the raster

        val:  Value to set at (col,row) 
        """
        return _cmf.IntRaster_SetData(self, *args)

    def GetXPosition(self, *args):
        """
        GetXPosition(self, int col) -> double

        double
        GetXPosition(int col)

        Returns the real world x position of a column. 
        """
        return _cmf.IntRaster_GetXPosition(self, *args)

    def GetYPosition(self, *args):
        """
        GetYPosition(self, int row) -> double

        double
        GetYPosition(int row)

        Returns the real world y position of a row. 
        """
        return _cmf.IntRaster_GetYPosition(self, *args)

    def statistics(self):
        """
        statistics(self) -> RasterStatistics

        RasterStatistics statistics()

        Creates statistics for the raster. 
        """
        return _cmf.IntRaster_statistics(self)

    def histogram(self, bins = 100):
        """
        histogram(self, size_t bins = 100) -> Histogram
        histogram(self) -> Histogram

        Histogram
        histogram(size_t bins=100) 
        """
        return _cmf.IntRaster_histogram(self, bins)

    def __imul__(self, *args):
        """
        __imul__(self, int scalar) -> IntRaster
        __imul__(self, IntRaster raster) -> IntRaster
        """
        return _cmf.IntRaster___imul__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, int scalar) -> IntRaster
        __iadd__(self, IntRaster raster) -> IntRaster
        """
        return _cmf.IntRaster___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, int scalar) -> IntRaster
        __isub__(self, IntRaster raster) -> IntRaster
        """
        return _cmf.IntRaster___isub__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, int ncols, int nrows, double xllcorner, double yllcorner, 
            double xcellsize, double ycellsize, int nodata, 
            int initialValue = 0) -> IntRaster
        __init__(self, int ncols, int nrows, double xllcorner, double yllcorner, 
            double xcellsize, double ycellsize, int nodata) -> IntRaster
        __init__(self, IntRaster R) -> IntRaster
        __init__(self, IntRaster R, int FixedValue) -> IntRaster
        __init__(self, string FileName) -> IntRaster
        __init__(self, std::istream ASCFile) -> IntRaster

        Raster(std::istream &ASCFile)

        Loads an ESRI ASCII-raster data set. 
        """
        _cmf.IntRaster_swiginit(self,_cmf.new_IntRaster(*args))
    def WriteToASCFile(self, *args):
        """
        WriteToASCFile(self, std::ostream ASCFile)
        WriteToASCFile(self, string filename)

        void
        WriteToASCFile(std::string filename)

        Writes the raster to a filename. 
        """
        return _cmf.IntRaster_WriteToASCFile(self, *args)

    def WriteToBinary(self, *args):
        """
        WriteToBinary(self, string filename)

        void
        WriteToBinary(std::string filename) const

        Writes the data to the file with the given file name and the header to
        a filename with the extension .hdr.

        If the filename has the extension .flt and the raster is a float
        raster the saved file can be read by ArcGIS 
        """
        return _cmf.IntRaster_WriteToBinary(self, *args)

    def ToInt(self):
        """
        ToInt(self) -> IntRaster

        Raster<int>
        ToInt() const

        Converts the raster to a raster of int. 
        """
        return _cmf.IntRaster_ToInt(self)

    def ToFloat(self):
        """
        ToFloat(self) -> SingleRaster

        Raster<float>
        ToFloat()

        Converts the raster to a raster of float (32bit). 
        """
        return _cmf.IntRaster_ToFloat(self)

    def ToDouble(self):
        """
        ToDouble(self) -> DoubleRaster

        Raster<double> ToDouble()

        Converts the raster to a raster of float (64bit). 
        """
        return _cmf.IntRaster_ToDouble(self)

    def focal_min(self, n = 3):
        """
        focal_min(self, int n = 3) -> IntRaster
        focal_min(self) -> IntRaster

        Raster<rasterType> focal_min(int n=3)

        Creates a raster, which contains for each cell the minimum of the
        surrounding n x n window. 
        """
        return _cmf.IntRaster_focal_min(self, n)

    def focal_max(self, n = 3):
        """
        focal_max(self, int n = 3) -> IntRaster
        focal_max(self) -> IntRaster

        Raster<rasterType> focal_max(int n=3)

        Creates a raster, which contains for each cell the maximum of the
        surrounding n x n window. 
        """
        return _cmf.IntRaster_focal_max(self, n)

    def focal_mean(self, n = 3):
        """
        focal_mean(self, int n = 3) -> IntRaster
        focal_mean(self) -> IntRaster

        Raster<rasterType> focal_mean(int n=3)

        Creates a raster, which contains for each cell the mean of the
        surrounding n x n window. 
        """
        return _cmf.IntRaster_focal_mean(self, n)

    def focal_stdev(self, n = 3):
        """
        focal_stdev(self, int n = 3) -> IntRaster
        focal_stdev(self) -> IntRaster

        Raster<rasterType> focal_stdev(int n=3)

        Creates a raster, which contains for each cell the standard deviation
        of the surrounding n x n window. 
        """
        return _cmf.IntRaster_focal_stdev(self, n)

    def focal_majority(self, n = 3):
        """
        focal_majority(self, int n = 3) -> IntRaster
        focal_majority(self) -> IntRaster

        Raster<rasterType> focal_majority(int n=3)

        Creates a raster, which contains for each cell the majority value of
        the surrounding n x n window (usually only used for integer raster).

        """
        return _cmf.IntRaster_focal_majority(self, n)

    def focal_mean_difference(self, n = 3):
        """
        focal_mean_difference(self, int n = 3) -> IntRaster
        focal_mean_difference(self) -> IntRaster

        Raster<rasterType> focal_mean_difference(int n=3)

        Creates a raster, which contains for each cell the difference between
        the actual value and the mean of the surrounding n x n window (usually
        only used for integer raster) This function can be used to identify
        very important points (VIP) for triangulation. 
        """
        return _cmf.IntRaster_focal_mean_difference(self, n)

    def __len__(self):
        """
        __len__(self) -> int

        int __len__()

        """
        return _cmf.IntRaster___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(self, int index) -> int

        rasterType
        __getitem__(int index) 
        """
        return _cmf.IntRaster___getitem__(self, *args)

    __swig_destroy__ = _cmf.delete_IntRaster
IntRaster.Xllcorner = new_instancemethod(_cmf.IntRaster_Xllcorner,None,IntRaster)
IntRaster.Yllcorner = new_instancemethod(_cmf.IntRaster_Yllcorner,None,IntRaster)
IntRaster.XCellsize = new_instancemethod(_cmf.IntRaster_XCellsize,None,IntRaster)
IntRaster.YCellsize = new_instancemethod(_cmf.IntRaster_YCellsize,None,IntRaster)
IntRaster.ColumnCount = new_instancemethod(_cmf.IntRaster_ColumnCount,None,IntRaster)
IntRaster.RowCount = new_instancemethod(_cmf.IntRaster_RowCount,None,IntRaster)
IntRaster.Width = new_instancemethod(_cmf.IntRaster_Width,None,IntRaster)
IntRaster.Height = new_instancemethod(_cmf.IntRaster_Height,None,IntRaster)
IntRaster.NoData = new_instancemethod(_cmf.IntRaster_NoData,None,IntRaster)
IntRaster.GetBounds = new_instancemethod(_cmf.IntRaster_GetBounds,None,IntRaster)
IntRaster.IdentifyXY = new_instancemethod(_cmf.IntRaster_IdentifyXY,None,IntRaster)
IntRaster.IdentifyRowCol = new_instancemethod(_cmf.IntRaster_IdentifyRowCol,None,IntRaster)
IntRaster.IdentifyColRow = new_instancemethod(_cmf.IntRaster_IdentifyColRow,None,IntRaster)
IntRaster.HasData = new_instancemethod(_cmf.IntRaster_HasData,None,IntRaster)
IntRaster.SetData = new_instancemethod(_cmf.IntRaster_SetData,None,IntRaster)
IntRaster.GetXPosition = new_instancemethod(_cmf.IntRaster_GetXPosition,None,IntRaster)
IntRaster.GetYPosition = new_instancemethod(_cmf.IntRaster_GetYPosition,None,IntRaster)
IntRaster.statistics = new_instancemethod(_cmf.IntRaster_statistics,None,IntRaster)
IntRaster.histogram = new_instancemethod(_cmf.IntRaster_histogram,None,IntRaster)
IntRaster.__imul__ = new_instancemethod(_cmf.IntRaster___imul__,None,IntRaster)
IntRaster.__iadd__ = new_instancemethod(_cmf.IntRaster___iadd__,None,IntRaster)
IntRaster.__isub__ = new_instancemethod(_cmf.IntRaster___isub__,None,IntRaster)
IntRaster.WriteToASCFile = new_instancemethod(_cmf.IntRaster_WriteToASCFile,None,IntRaster)
IntRaster.WriteToBinary = new_instancemethod(_cmf.IntRaster_WriteToBinary,None,IntRaster)
IntRaster.ToInt = new_instancemethod(_cmf.IntRaster_ToInt,None,IntRaster)
IntRaster.ToFloat = new_instancemethod(_cmf.IntRaster_ToFloat,None,IntRaster)
IntRaster.ToDouble = new_instancemethod(_cmf.IntRaster_ToDouble,None,IntRaster)
IntRaster.focal_min = new_instancemethod(_cmf.IntRaster_focal_min,None,IntRaster)
IntRaster.focal_max = new_instancemethod(_cmf.IntRaster_focal_max,None,IntRaster)
IntRaster.focal_mean = new_instancemethod(_cmf.IntRaster_focal_mean,None,IntRaster)
IntRaster.focal_stdev = new_instancemethod(_cmf.IntRaster_focal_stdev,None,IntRaster)
IntRaster.focal_majority = new_instancemethod(_cmf.IntRaster_focal_majority,None,IntRaster)
IntRaster.focal_mean_difference = new_instancemethod(_cmf.IntRaster_focal_mean_difference,None,IntRaster)
IntRaster.__len__ = new_instancemethod(_cmf.IntRaster___len__,None,IntRaster)
IntRaster.__getitem__ = new_instancemethod(_cmf.IntRaster___getitem__,None,IntRaster)
IntRaster_swigregister = _cmf.IntRaster_swigregister
IntRaster_swigregister(IntRaster)

class SingleRaster(object):
    """
    Represents a raster dataset.

    C++ includes: Raster.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Xllcorner(self):
        """
        Xllcorner(self) -> double

        double
        Xllcorner() const

        x-Coordinate for the Lower Left corner (in cellsize units) 
        """
        return _cmf.SingleRaster_Xllcorner(self)

    def Yllcorner(self):
        """
        Yllcorner(self) -> double

        double
        Yllcorner() const

        y-Coordinate for the Lower Left corner (in cellsize units) 
        """
        return _cmf.SingleRaster_Yllcorner(self)

    def XCellsize(self):
        """
        XCellsize(self) -> double

        double
        XCellsize() const

        Cellsize of the raster. 
        """
        return _cmf.SingleRaster_XCellsize(self)

    def YCellsize(self):
        """
        YCellsize(self) -> double

        double
        YCellsize() const

        Cellsize of the raster. 
        """
        return _cmf.SingleRaster_YCellsize(self)

    def ColumnCount(self):
        """
        ColumnCount(self) -> int

        int
        ColumnCount() const

        Number of columns in the raster. 
        """
        return _cmf.SingleRaster_ColumnCount(self)

    def RowCount(self):
        """
        RowCount(self) -> int

        int
        RowCount() const

        Number of rows in the raster. 
        """
        return _cmf.SingleRaster_RowCount(self)

    def Width(self):
        """
        Width(self) -> double

        double Width()
        const

        Extent W-E in cellsize units. 
        """
        return _cmf.SingleRaster_Width(self)

    def Height(self):
        """
        Height(self) -> double

        double Height()
        const

        Extent N-S in cellsize units. 
        """
        return _cmf.SingleRaster_Height(self)

    def NoData(self):
        """
        NoData(self) -> float

        rasterType
        NoData() const

        Returns rasterType (NoData). 
        """
        return _cmf.SingleRaster_NoData(self)

    def GetBounds(self):
        """
        GetBounds(self) -> BoundingBox

        BoundingBox
        GetBounds() const

        Returns the bounding box of the raster. 
        """
        return _cmf.SingleRaster_GetBounds(self)

    def IdentifyXY(self, *args):
        """
        IdentifyXY(self, double x, double y) -> float

        rasterType
        IdentifyXY(double x, double y) const

        Returns the value of the raster at the given position. 
        """
        return _cmf.SingleRaster_IdentifyXY(self, *args)

    def IdentifyRowCol(self, *args):
        """
        IdentifyRowCol(self, int row, int col) -> float

        rasterType IdentifyRowCol(int row, int col) const

        Returns the value of the raster at the given cell. 
        """
        return _cmf.SingleRaster_IdentifyRowCol(self, *args)

    def IdentifyColRow(self, *args):
        """
        IdentifyColRow(self, int col, int row) -> float

        rasterType IdentifyColRow(int col, int row) const

        Returns the value of the raster at the given cell. 
        """
        return _cmf.SingleRaster_IdentifyColRow(self, *args)

    def HasData(self, *args):
        """
        HasData(self, double x, double y) -> bool
        HasData(self, int col, int row) -> bool

        bool
        HasData(int col, int row) const

        Returns true if there is data at the given position. 
        """
        return _cmf.SingleRaster_HasData(self, *args)

    def SetData(self, *args):
        """
        SetData(self, double x, double y, float val)
        SetData(self, int col, int row, float val)

        void
        SetData(int col, int row, rasterType val)

        Sets a value at the given position.

        Parameters:
        -----------

        col:  Column of the raster

        row:  Row of the raster

        val:  Value to set at (col,row) 
        """
        return _cmf.SingleRaster_SetData(self, *args)

    def GetXPosition(self, *args):
        """
        GetXPosition(self, int col) -> double

        double
        GetXPosition(int col)

        Returns the real world x position of a column. 
        """
        return _cmf.SingleRaster_GetXPosition(self, *args)

    def GetYPosition(self, *args):
        """
        GetYPosition(self, int row) -> double

        double
        GetYPosition(int row)

        Returns the real world y position of a row. 
        """
        return _cmf.SingleRaster_GetYPosition(self, *args)

    def statistics(self):
        """
        statistics(self) -> RasterStatistics

        RasterStatistics statistics()

        Creates statistics for the raster. 
        """
        return _cmf.SingleRaster_statistics(self)

    def histogram(self, bins = 100):
        """
        histogram(self, size_t bins = 100) -> Histogram
        histogram(self) -> Histogram

        Histogram
        histogram(size_t bins=100) 
        """
        return _cmf.SingleRaster_histogram(self, bins)

    def __imul__(self, *args):
        """
        __imul__(self, float scalar) -> SingleRaster
        __imul__(self, SingleRaster raster) -> SingleRaster
        """
        return _cmf.SingleRaster___imul__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, float scalar) -> SingleRaster
        __iadd__(self, SingleRaster raster) -> SingleRaster
        """
        return _cmf.SingleRaster___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, float scalar) -> SingleRaster
        __isub__(self, SingleRaster raster) -> SingleRaster
        """
        return _cmf.SingleRaster___isub__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, int ncols, int nrows, double xllcorner, double yllcorner, 
            double xcellsize, double ycellsize, float nodata, 
            float initialValue = 0) -> SingleRaster
        __init__(self, int ncols, int nrows, double xllcorner, double yllcorner, 
            double xcellsize, double ycellsize, float nodata) -> SingleRaster
        __init__(self, SingleRaster R) -> SingleRaster
        __init__(self, SingleRaster R, float FixedValue) -> SingleRaster
        __init__(self, string FileName) -> SingleRaster
        __init__(self, std::istream ASCFile) -> SingleRaster

        Raster(std::istream &ASCFile)

        Loads an ESRI ASCII-raster data set. 
        """
        _cmf.SingleRaster_swiginit(self,_cmf.new_SingleRaster(*args))
    def WriteToASCFile(self, *args):
        """
        WriteToASCFile(self, std::ostream ASCFile)
        WriteToASCFile(self, string filename)

        void
        WriteToASCFile(std::string filename)

        Writes the raster to a filename. 
        """
        return _cmf.SingleRaster_WriteToASCFile(self, *args)

    def WriteToBinary(self, *args):
        """
        WriteToBinary(self, string filename)

        void
        WriteToBinary(std::string filename) const

        Writes the data to the file with the given file name and the header to
        a filename with the extension .hdr.

        If the filename has the extension .flt and the raster is a float
        raster the saved file can be read by ArcGIS 
        """
        return _cmf.SingleRaster_WriteToBinary(self, *args)

    def ToInt(self):
        """
        ToInt(self) -> IntRaster

        Raster<int>
        ToInt() const

        Converts the raster to a raster of int. 
        """
        return _cmf.SingleRaster_ToInt(self)

    def ToFloat(self):
        """
        ToFloat(self) -> SingleRaster

        Raster<float>
        ToFloat()

        Converts the raster to a raster of float (32bit). 
        """
        return _cmf.SingleRaster_ToFloat(self)

    def ToDouble(self):
        """
        ToDouble(self) -> DoubleRaster

        Raster<double> ToDouble()

        Converts the raster to a raster of float (64bit). 
        """
        return _cmf.SingleRaster_ToDouble(self)

    def focal_min(self, n = 3):
        """
        focal_min(self, int n = 3) -> SingleRaster
        focal_min(self) -> SingleRaster

        Raster<rasterType> focal_min(int n=3)

        Creates a raster, which contains for each cell the minimum of the
        surrounding n x n window. 
        """
        return _cmf.SingleRaster_focal_min(self, n)

    def focal_max(self, n = 3):
        """
        focal_max(self, int n = 3) -> SingleRaster
        focal_max(self) -> SingleRaster

        Raster<rasterType> focal_max(int n=3)

        Creates a raster, which contains for each cell the maximum of the
        surrounding n x n window. 
        """
        return _cmf.SingleRaster_focal_max(self, n)

    def focal_mean(self, n = 3):
        """
        focal_mean(self, int n = 3) -> SingleRaster
        focal_mean(self) -> SingleRaster

        Raster<rasterType> focal_mean(int n=3)

        Creates a raster, which contains for each cell the mean of the
        surrounding n x n window. 
        """
        return _cmf.SingleRaster_focal_mean(self, n)

    def focal_stdev(self, n = 3):
        """
        focal_stdev(self, int n = 3) -> SingleRaster
        focal_stdev(self) -> SingleRaster

        Raster<rasterType> focal_stdev(int n=3)

        Creates a raster, which contains for each cell the standard deviation
        of the surrounding n x n window. 
        """
        return _cmf.SingleRaster_focal_stdev(self, n)

    def focal_majority(self, n = 3):
        """
        focal_majority(self, int n = 3) -> SingleRaster
        focal_majority(self) -> SingleRaster

        Raster<rasterType> focal_majority(int n=3)

        Creates a raster, which contains for each cell the majority value of
        the surrounding n x n window (usually only used for integer raster).

        """
        return _cmf.SingleRaster_focal_majority(self, n)

    def focal_mean_difference(self, n = 3):
        """
        focal_mean_difference(self, int n = 3) -> SingleRaster
        focal_mean_difference(self) -> SingleRaster

        Raster<rasterType> focal_mean_difference(int n=3)

        Creates a raster, which contains for each cell the difference between
        the actual value and the mean of the surrounding n x n window (usually
        only used for integer raster) This function can be used to identify
        very important points (VIP) for triangulation. 
        """
        return _cmf.SingleRaster_focal_mean_difference(self, n)

    def __len__(self):
        """
        __len__(self) -> int

        int __len__()

        """
        return _cmf.SingleRaster___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(self, int index) -> float

        rasterType
        __getitem__(int index) 
        """
        return _cmf.SingleRaster___getitem__(self, *args)

    __swig_destroy__ = _cmf.delete_SingleRaster
SingleRaster.Xllcorner = new_instancemethod(_cmf.SingleRaster_Xllcorner,None,SingleRaster)
SingleRaster.Yllcorner = new_instancemethod(_cmf.SingleRaster_Yllcorner,None,SingleRaster)
SingleRaster.XCellsize = new_instancemethod(_cmf.SingleRaster_XCellsize,None,SingleRaster)
SingleRaster.YCellsize = new_instancemethod(_cmf.SingleRaster_YCellsize,None,SingleRaster)
SingleRaster.ColumnCount = new_instancemethod(_cmf.SingleRaster_ColumnCount,None,SingleRaster)
SingleRaster.RowCount = new_instancemethod(_cmf.SingleRaster_RowCount,None,SingleRaster)
SingleRaster.Width = new_instancemethod(_cmf.SingleRaster_Width,None,SingleRaster)
SingleRaster.Height = new_instancemethod(_cmf.SingleRaster_Height,None,SingleRaster)
SingleRaster.NoData = new_instancemethod(_cmf.SingleRaster_NoData,None,SingleRaster)
SingleRaster.GetBounds = new_instancemethod(_cmf.SingleRaster_GetBounds,None,SingleRaster)
SingleRaster.IdentifyXY = new_instancemethod(_cmf.SingleRaster_IdentifyXY,None,SingleRaster)
SingleRaster.IdentifyRowCol = new_instancemethod(_cmf.SingleRaster_IdentifyRowCol,None,SingleRaster)
SingleRaster.IdentifyColRow = new_instancemethod(_cmf.SingleRaster_IdentifyColRow,None,SingleRaster)
SingleRaster.HasData = new_instancemethod(_cmf.SingleRaster_HasData,None,SingleRaster)
SingleRaster.SetData = new_instancemethod(_cmf.SingleRaster_SetData,None,SingleRaster)
SingleRaster.GetXPosition = new_instancemethod(_cmf.SingleRaster_GetXPosition,None,SingleRaster)
SingleRaster.GetYPosition = new_instancemethod(_cmf.SingleRaster_GetYPosition,None,SingleRaster)
SingleRaster.statistics = new_instancemethod(_cmf.SingleRaster_statistics,None,SingleRaster)
SingleRaster.histogram = new_instancemethod(_cmf.SingleRaster_histogram,None,SingleRaster)
SingleRaster.__imul__ = new_instancemethod(_cmf.SingleRaster___imul__,None,SingleRaster)
SingleRaster.__iadd__ = new_instancemethod(_cmf.SingleRaster___iadd__,None,SingleRaster)
SingleRaster.__isub__ = new_instancemethod(_cmf.SingleRaster___isub__,None,SingleRaster)
SingleRaster.WriteToASCFile = new_instancemethod(_cmf.SingleRaster_WriteToASCFile,None,SingleRaster)
SingleRaster.WriteToBinary = new_instancemethod(_cmf.SingleRaster_WriteToBinary,None,SingleRaster)
SingleRaster.ToInt = new_instancemethod(_cmf.SingleRaster_ToInt,None,SingleRaster)
SingleRaster.ToFloat = new_instancemethod(_cmf.SingleRaster_ToFloat,None,SingleRaster)
SingleRaster.ToDouble = new_instancemethod(_cmf.SingleRaster_ToDouble,None,SingleRaster)
SingleRaster.focal_min = new_instancemethod(_cmf.SingleRaster_focal_min,None,SingleRaster)
SingleRaster.focal_max = new_instancemethod(_cmf.SingleRaster_focal_max,None,SingleRaster)
SingleRaster.focal_mean = new_instancemethod(_cmf.SingleRaster_focal_mean,None,SingleRaster)
SingleRaster.focal_stdev = new_instancemethod(_cmf.SingleRaster_focal_stdev,None,SingleRaster)
SingleRaster.focal_majority = new_instancemethod(_cmf.SingleRaster_focal_majority,None,SingleRaster)
SingleRaster.focal_mean_difference = new_instancemethod(_cmf.SingleRaster_focal_mean_difference,None,SingleRaster)
SingleRaster.__len__ = new_instancemethod(_cmf.SingleRaster___len__,None,SingleRaster)
SingleRaster.__getitem__ = new_instancemethod(_cmf.SingleRaster___getitem__,None,SingleRaster)
SingleRaster_swigregister = _cmf.SingleRaster_swigregister
SingleRaster_swigregister(SingleRaster)

import datetime


def minimum(*args):
  """
    minimum(real a, real b) -> real

    real minimum(real a, real b)

    Returns the minimum of two values. 
    """
  return _cmf.minimum(*args)

def maximum(*args):
  """
    maximum(real a, real b) -> real

    real maximum(real a, real b) 
    """
  return _cmf.maximum(*args)

def minmax(*args):
  """
    minmax(real x, real min, real max) -> real

    real minmax(real x, real min, real
    max) 
    """
  return _cmf.minmax(*args)

def mean(*args):
  """mean(real a, real b) -> real"""
  return _cmf.mean(*args)

def geo_mean(*args):
  """geo_mean(real a, real b) -> real"""
  return _cmf.geo_mean(*args)

def boltzmann(*args):
  """boltzmann(real x, real tau, real x_half) -> real"""
  return _cmf.boltzmann(*args)

def sign(*args):
  """sign(real x) -> real"""
  return _cmf.sign(*args)

def square(*args):
  """square(real x) -> real"""
  return _cmf.square(*args)
JULIANDAY_0_1_1900 = _cmf.JULIANDAY_0_1_1900
class Time(object):
    """
    A time class, used to pass around current modelling times.

    Timespans and dates in cmf are used with a special object, called
    Time. The advantage of an extra class has the advantage, that the user
    does not has to rememember, which unit of time he or she uses or what
    time unit is accepted by a specific function of the model. Arithmetic
    and boolean operators are supported by Time. Internally the time
    classes stores the time as integer milliseconds, therefore rounding
    issues will only appear at very small time ranges. Absolute time (like
    dates) are represented as milliseconds gone by from Dec, 31st 1899.
    Microsoft Excel dates are represented as days from that time, using
    floating point numbers, therefore it is very simple to convert Excel
    time representations to cmf time.

    Another object is Date, which is doesn't provide the operators, but
    has a nice printed version and some special date functions, like day
    of year (DOY) and provides access to the current hour of day and so
    on, which only applyto dates and not to time spans. You can convert
    Time to Date an vice versa. The printing is not culture aware and uses
    the European representation. If you use the Python standard library
    datetime, conversion between Python time and cmf time is
    possibleCreating absolute time values (dates)

    import CMFlib as cmf                 # Create the time: Jan, 5th 2001,
    2:30 pm, 20s, 412 ms                 t=cmf.Time(5,1,2001,14,30,20,412)
    print t # Prints: '36896d:14:30:20.412h'                 print
    t.AsDate() # Prints: '05.01.2001 14:30:20.412'Creating time spans

    In principle, there are three ways to create time spans. One is to use
    one of the static functions, another is to multiply an existing time
    span (like one of the build in constants) or to substrate two absolute
    times.Available static functions, the default value is always 1

    Milliseconds(): t=cmf.Time.Milliseconds(4100), create a timespan of
    4.1 seconds

    Seconds(): t=cmf. Time.Seconds(4.1), create a timespan of 4.1 seconds

    Minutes(): t=cmf.Time.Minutes(138), create a timespan of 2.3 hours
    (138 min)

    Hours(): t=cmf. Time.Hours(2.3), create a timespan of 2.3 hours (138
    min)

    Days(): t=cmf. Time.Days(2.5), create a timespan of 60 hours

    Years(): t=cmf. Time.Years(), create a timespan of 365 days Available
    constants

    cmf.sec * 4.1: 4.1 seconds

    cmf.min * 138: 2.3 hours (138 min)

    cmf.h * 2.3: 2.3 hours (138 min)

    cmf.day * 2.5: 60 hours (2.5 days)

    cmf.week: 7 days

    cmf.month: 365/12 days (30.4167 days)

    cmf.year: 365 days Available operators:

    time + time = time, time - time = time

    time * float = time ,time / float = time

    time/time=float

    &gt, &lt, ==, != Conversions

    Converting to python datetime

    import CMFlib as cmf                 pythontime = cmf.year.AsPython()
    cmftime=cmf.AsCMFTime(pythontime)                 print
    type(pythontime) # '<type 'datetime.datetime'>'                 print
    type(cmftime)    # '<class 'CMFLib.Time'>'Converting to numbers

    t.AsMilliseconds()

    t.AsSeconds()

    t.AsMinutes()

    t.AsHours()

    t.AsDays()

    t.AsYears() Creating time ranges

    import CMFLib as cmf                 start=cmf.Time(5,1,2001)
    end=cmf.Time(6,1,2001)                 step=cmf.h * 6 for t in
    cmf.timerange(start,end,step):                     print t.AsDate()
    # Prints:                 # 05.01.2001 # 05.01.2001 06:00
    # 05.01.2001 12:00 # 05.01.2001 18:00

    C++ includes: Time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ms_per_day = _cmf.Time_ms_per_day
    def __init__(self, *args): 
        """
        __init__(self, double days) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0, 
            int minute = 0, int second = 0, int ms = 0) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0, 
            int minute = 0, int second = 0) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0, 
            int minute = 0) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0) -> Time
        __init__(self, int day, int month, int year = 2001) -> Time
        __init__(self, int day, int month) -> Time
        __init__(self, Date date) -> Time
        __init__(self, Time t) -> Time
        __init__(self) -> Time

        Time()

        Standard constructor. 
        """
        _cmf.Time_swiginit(self,_cmf.new_Time(*args))
    def AsDays(self):
        """
        AsDays(self) -> double

        double AsDays() const

        Time in days. 
        """
        return _cmf.Time_AsDays(self)

    def AsHours(self):
        """
        AsHours(self) -> double

        double AsHours()
        const

        Time in hours. 
        """
        return _cmf.Time_AsHours(self)

    def AsMinutes(self):
        """
        AsMinutes(self) -> double

        double AsMinutes()
        const

        Time in minutes. 
        """
        return _cmf.Time_AsMinutes(self)

    def AsSeconds(self):
        """
        AsSeconds(self) -> double

        double AsSeconds()
        const

        Time in seconds. 
        """
        return _cmf.Time_AsSeconds(self)

    def AsMilliseconds(self):
        """
        AsMilliseconds(self) -> long long

        long long
        AsMilliseconds() const

        Time in milliseconds. 
        """
        return _cmf.Time_AsMilliseconds(self)

    def AsDate(self):
        """
        AsDate(self) -> Date

        Date AsDate() const

        """
        return _cmf.Time_AsDate(self)

    def ToString(self, seperator = ':'):
        """
        ToString(self, char seperator = ':') -> string
        ToString(self) -> string

        std::string
        ToString(char seperator=':') 
        """
        return _cmf.Time_ToString(self, seperator)

    def __add__(self, *args):
        """__add__(self, Time t1) -> Time"""
        return _cmf.Time___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Time t1) -> Time"""
        return _cmf.Time___sub__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, Time t1) -> Time"""
        return _cmf.Time___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Time t1) -> Time"""
        return _cmf.Time___isub__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, double x) -> Time
        __mul__(self, int x) -> Time
        """
        return _cmf.Time___mul__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, double x) -> Time
        __imul__(self, int x) -> Time
        """
        return _cmf.Time___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, double x) -> Time
        __idiv__(self, int x) -> Time
        """
        return _cmf.Time___idiv__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, double x) -> Time
        __div__(self, int x) -> Time
        __div__(self, Time t1) -> double
        """
        return _cmf.Time___div__(self, *args)

    def __lt__(self, *args):
        """__lt__(self, Time t1) -> bool"""
        return _cmf.Time___lt__(self, *args)

    def __gt__(self, *args):
        """__gt__(self, Time t1) -> bool"""
        return _cmf.Time___gt__(self, *args)

    def __le__(self, *args):
        """__le__(self, Time t1) -> bool"""
        return _cmf.Time___le__(self, *args)

    def __ge__(self, *args):
        """__ge__(self, Time t1) -> bool"""
        return _cmf.Time___ge__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Time t1) -> bool"""
        return _cmf.Time___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Time t1) -> bool"""
        return _cmf.Time___ne__(self, *args)

    def NextDay(self):
        """
        NextDay(self) -> Time

        Time NextDay() const

        Returns the beginning of the next day. 
        """
        return _cmf.Time_NextDay(self)

    def NextFullHour(self):
        """
        NextFullHour(self) -> Time

        Time
        NextFullHour() const

        Returns the next full hour. 
        """
        return _cmf.Time_NextFullHour(self)

    def Years(y = 1):
        """
        Years(double y = 1) -> Time
        Years() -> Time
        """
        return _cmf.Time_Years(y)

    Years = staticmethod(Years)
    def Days(d = 1):
        """
        Days(double d = 1) -> Time
        Days() -> Time
        """
        return _cmf.Time_Days(d)

    Days = staticmethod(Days)
    def Hours(h = 1):
        """
        Hours(double h = 1) -> Time
        Hours() -> Time
        """
        return _cmf.Time_Hours(h)

    Hours = staticmethod(Hours)
    def Minutes(min = 1):
        """
        Minutes(double min = 1) -> Time
        Minutes() -> Time
        """
        return _cmf.Time_Minutes(min)

    Minutes = staticmethod(Minutes)
    def Seconds(secs = 1):
        """
        Seconds(double secs = 1) -> Time
        Seconds() -> Time
        """
        return _cmf.Time_Seconds(secs)

    Seconds = staticmethod(Seconds)
    def Milliseconds(ms = 1):
        """
        Milliseconds(long long ms = 1) -> Time
        Milliseconds() -> Time
        """
        return _cmf.Time_Milliseconds(ms)

    Milliseconds = staticmethod(Milliseconds)
    def __str__(self):
        """__str__(self) -> string"""
        return _cmf.Time___str__(self)

    def AsPython(self):
        d=self.AsDate()
        return datetime.datetime(d.year,d.month,d.day,d.hour,d.minute,d.second,d.ms*1000)

    __swig_destroy__ = _cmf.delete_Time
Time.AsDays = new_instancemethod(_cmf.Time_AsDays,None,Time)
Time.AsHours = new_instancemethod(_cmf.Time_AsHours,None,Time)
Time.AsMinutes = new_instancemethod(_cmf.Time_AsMinutes,None,Time)
Time.AsSeconds = new_instancemethod(_cmf.Time_AsSeconds,None,Time)
Time.AsMilliseconds = new_instancemethod(_cmf.Time_AsMilliseconds,None,Time)
Time.AsDate = new_instancemethod(_cmf.Time_AsDate,None,Time)
Time.ToString = new_instancemethod(_cmf.Time_ToString,None,Time)
Time.__add__ = new_instancemethod(_cmf.Time___add__,None,Time)
Time.__sub__ = new_instancemethod(_cmf.Time___sub__,None,Time)
Time.__iadd__ = new_instancemethod(_cmf.Time___iadd__,None,Time)
Time.__isub__ = new_instancemethod(_cmf.Time___isub__,None,Time)
Time.__mul__ = new_instancemethod(_cmf.Time___mul__,None,Time)
Time.__imul__ = new_instancemethod(_cmf.Time___imul__,None,Time)
Time.__idiv__ = new_instancemethod(_cmf.Time___idiv__,None,Time)
Time.__div__ = new_instancemethod(_cmf.Time___div__,None,Time)
Time.__lt__ = new_instancemethod(_cmf.Time___lt__,None,Time)
Time.__gt__ = new_instancemethod(_cmf.Time___gt__,None,Time)
Time.__le__ = new_instancemethod(_cmf.Time___le__,None,Time)
Time.__ge__ = new_instancemethod(_cmf.Time___ge__,None,Time)
Time.__eq__ = new_instancemethod(_cmf.Time___eq__,None,Time)
Time.__ne__ = new_instancemethod(_cmf.Time___ne__,None,Time)
Time.NextDay = new_instancemethod(_cmf.Time_NextDay,None,Time)
Time.NextFullHour = new_instancemethod(_cmf.Time_NextFullHour,None,Time)
Time.__str__ = new_instancemethod(_cmf.Time___str__,None,Time)
Time_swigregister = _cmf.Time_swigregister
Time_swigregister(Time)
Debug = cvar.Debug
CompileDate = cvar.CompileDate

def piecewise_linear(*args):
  """
    piecewise_linear(real x, real xmin, real xmax, real ymin = 0, real ymax = 1) -> real
    piecewise_linear(real x, real xmin, real xmax, real ymin = 0) -> real
    piecewise_linear(real x, real xmin, real xmax) -> real

    real piecewise_linear(real
    x, real xmin, real xmax, real ymin=0, real ymax=1) 
    """
  return _cmf.piecewise_linear(*args)
Pi = cvar.Pi

def Time_Years(y = 1):
  """
    Years(double y = 1) -> Time
    Time_Years() -> Time
    """
  return _cmf.Time_Years(y)

def Time_Days(d = 1):
  """
    Days(double d = 1) -> Time
    Time_Days() -> Time
    """
  return _cmf.Time_Days(d)

def Time_Hours(h = 1):
  """
    Hours(double h = 1) -> Time
    Time_Hours() -> Time
    """
  return _cmf.Time_Hours(h)

def Time_Minutes(min = 1):
  """
    Minutes(double min = 1) -> Time
    Time_Minutes() -> Time
    """
  return _cmf.Time_Minutes(min)

def Time_Seconds(secs = 1):
  """
    Seconds(double secs = 1) -> Time
    Time_Seconds() -> Time
    """
  return _cmf.Time_Seconds(secs)

def Time_Milliseconds(ms = 1):
  """
    Milliseconds(long long ms = 1) -> Time
    Time_Milliseconds() -> Time
    """
  return _cmf.Time_Milliseconds(ms)

class Date(object):
    """
    An absolute time, not for calculation. Date and Time are
    interchangable.

    C++ includes: Time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    year = _swig_property(_cmf.Date_year_get, _cmf.Date_year_set)
    month = _swig_property(_cmf.Date_month_get, _cmf.Date_month_set)
    day = _swig_property(_cmf.Date_day_get, _cmf.Date_day_set)
    hour = _swig_property(_cmf.Date_hour_get, _cmf.Date_hour_set)
    minute = _swig_property(_cmf.Date_minute_get, _cmf.Date_minute_set)
    second = _swig_property(_cmf.Date_second_get, _cmf.Date_second_set)
    ms = _swig_property(_cmf.Date_ms_get, _cmf.Date_ms_set)
    def __init__(self, *args): 
        """
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0, 
            int _minute = 0, int _second = 0, int _ms = 0) -> Date
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0, 
            int _minute = 0, int _second = 0) -> Date
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0, 
            int _minute = 0) -> Date
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0) -> Date
        __init__(self, int _day, int _month, int _year = 2001) -> Date
        __init__(self, int _day, int _month) -> Date
        __init__(self, Time time) -> Date

        Date(const Time &time)

        Creates a new date from time (based on the 31.12.1899, like in
        Excel(TM)). 
        """
        _cmf.Date_swiginit(self,_cmf.new_Date(*args))
    def ToTime(self):
        """
        ToTime(self) -> Time

        Time ToTime()

        Converts a date to Time (based on the 31.12.1899, like in Excel(TM).

        """
        return _cmf.Date_ToTime(self)

    def DOY(self):
        """
        DOY(self) -> int

        int DOY()

        Returns the day of year. 
        """
        return _cmf.Date_DOY(self)

    def ToString(self):
        """
        ToString(self) -> string

        std::string
        ToString()

        Returns a string representing the date. 
        """
        return _cmf.Date_ToString(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _cmf.Date___str__(self)

    def AsPython(self):
        return datetime.datetime(self.year,self.month,self.day,self.hour,self.minute,self.second,self.ms*1000)

    __swig_destroy__ = _cmf.delete_Date
Date.ToTime = new_instancemethod(_cmf.Date_ToTime,None,Date)
Date.DOY = new_instancemethod(_cmf.Date_DOY,None,Date)
Date.ToString = new_instancemethod(_cmf.Date_ToString,None,Date)
Date.__str__ = new_instancemethod(_cmf.Date___str__,None,Date)
Date_swigregister = _cmf.Date_swigregister
Date_swigregister(Date)

class timeseries(object):
    """
    A timeseries is a list of values, equally distributed over time. To
    create one, one have to provide as start date and a step size. The end
    time is calculated from the number of values. Values queried for times
    before the start time are returned as the first item, values after the
    end time equal the last item. A timeseries with only one item reacts
    like a scalar value.

    Creating a time series

    import CMFLib as cmf                 # Start date is the January 5th
    2001 at 2:30 pm start=cmf.Time(5,1,2001,14,30)
    # time step of the timeseries is 20 minutes
    step=cmf.min*20                 # Type of interpolation between values
    # 0 - Nearest neighbor,                 # 1 - Linear,
    # 2 - Squared, # 3 - Cubic, etc.                 interpolation=1 #
    Create timeseries
    timeseries=cmf.timeseries(start,step,interpolation) # Add data
    timeseries.Add(0.1) # Value at 2001/5/1 2:30pm is 0.1
    timeseries.Add(0.2) # Value at 2001/5/1 2:50pm is 0.2
    timeseries.Add(0.1) # Value at 2001/5/1 3:10pm is 0.1

    With this technic it is simple to read files or databases to fill
    timeseries.Using a timeseries

    # Query every minute between 2:15 and 3:14 pm for t in
    cmf.timerange(start,start+cmf.h,cmf.min): print
    "Time:",t.AsDate(),"Value:", timeseries[t]                 # Query
    a specific position of the timeseries                 print
    timeseries[2]

    C++ includes: timeseries.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    begin = _swig_property(_cmf.timeseries_begin_get, _cmf.timeseries_begin_set)
    step = _swig_property(_cmf.timeseries_step_get, _cmf.timeseries_step_set)
    def end(self):
        """
        end(self) -> Time

        cmf::math::Time
        end() const

        Last date of measurements. 
        """
        return _cmf.timeseries_end(self)

    interpolationpower = _swig_property(_cmf.timeseries_interpolationpower_get, _cmf.timeseries_interpolationpower_set)
    def Add(self, *args):
        """
        Add(self, double Value)

        void Add(double
        Value)

        Appends a measurement. 
        """
        return _cmf.timeseries_Add(self, *args)

    def isempty(self):
        """
        isempty(self) -> bool

        bool isempty()
        const

        returns true if no values are added to the timeseries 
        """
        return _cmf.timeseries_isempty(self)

    def clear(self):
        """
        clear(self)

        void clear() 
        """
        return _cmf.timeseries_clear(self)

    def size(self):
        """
        size(self) -> int

        int size() const

        """
        return _cmf.timeseries_size(self)

    def __iadd__(self, *args):
        """
        __iadd__(self, timeseries arg0) -> timeseries
        __iadd__(self, double arg0) -> timeseries
        """
        return _cmf.timeseries___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, timeseries arg0) -> timeseries
        __isub__(self, double arg0) -> timeseries
        """
        return _cmf.timeseries___isub__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, timeseries arg0) -> timeseries
        __imul__(self, double arg0) -> timeseries
        """
        return _cmf.timeseries___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, timeseries arg0) -> timeseries
        __idiv__(self, double arg0) -> timeseries
        """
        return _cmf.timeseries___idiv__(self, *args)

    def power(self, *args):
        """
        power(self, double arg0) -> timeseries

        timeseries&
        power(double)

        raises the timeseries to a power 
        """
        return _cmf.timeseries_power(self, *args)

    def reduce_min(self, *args):
        """
        reduce_min(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_min(cmf::math::Time begin, cmf::math::Time step) const 
        """
        return _cmf.timeseries_reduce_min(self, *args)

    def reduce_max(self, *args):
        """
        reduce_max(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_max(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the minimum.

        """
        return _cmf.timeseries_reduce_max(self, *args)

    def reduce_sum(self, *args):
        """
        reduce_sum(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_sum(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the maximum.

        """
        return _cmf.timeseries_reduce_sum(self, *args)

    def reduce_avg(self, *args):
        """
        reduce_avg(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_avg(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the sum. 
        """
        return _cmf.timeseries_reduce_avg(self, *args)

    def Save(self, *args):
        """
        Save(self, std::ostream file)

        void
        Save(std::ostream &file)

        Save the Meteorology data to an ASCII File with fixed format. 
        """
        return _cmf.timeseries_Save(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, Time _begin, Time _step, int _interpolationmethod = 0) -> timeseries
        __init__(self, Time _begin, Time _step) -> timeseries
        __init__(self, Time _begin, Time _step, int size, int _interpolationmethod) -> timeseries
        __init__(self) -> timeseries
        __init__(self, timeseries ts) -> timeseries
        __init__(self, double scalar) -> timeseries
        __init__(self, std::istream file) -> timeseries

        timeseries(const cmf::math::timeseries &ts) 
        """
        _cmf.timeseries_swiginit(self,_cmf.new_timeseries(*args))
    def __size__(self):
        """__size__(self) -> double"""
        return _cmf.timeseries___size__(self)

    def __getitem__(self, *args):
        """
        __getitem__(self, Time t) -> double
        __getitem__(self, int i) -> double
        """
        return _cmf.timeseries___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, int i, double value)"""
        return _cmf.timeseries___setitem__(self, *args)

    def AddList(list) :
        """ Adds the values of a list to the timeseries"""
        for item in list :
            self.Add(float(item))

    __swig_destroy__ = _cmf.delete_timeseries
timeseries.end = new_instancemethod(_cmf.timeseries_end,None,timeseries)
timeseries.Add = new_instancemethod(_cmf.timeseries_Add,None,timeseries)
timeseries.isempty = new_instancemethod(_cmf.timeseries_isempty,None,timeseries)
timeseries.clear = new_instancemethod(_cmf.timeseries_clear,None,timeseries)
timeseries.size = new_instancemethod(_cmf.timeseries_size,None,timeseries)
timeseries.__iadd__ = new_instancemethod(_cmf.timeseries___iadd__,None,timeseries)
timeseries.__isub__ = new_instancemethod(_cmf.timeseries___isub__,None,timeseries)
timeseries.__imul__ = new_instancemethod(_cmf.timeseries___imul__,None,timeseries)
timeseries.__idiv__ = new_instancemethod(_cmf.timeseries___idiv__,None,timeseries)
timeseries.power = new_instancemethod(_cmf.timeseries_power,None,timeseries)
timeseries.reduce_min = new_instancemethod(_cmf.timeseries_reduce_min,None,timeseries)
timeseries.reduce_max = new_instancemethod(_cmf.timeseries_reduce_max,None,timeseries)
timeseries.reduce_sum = new_instancemethod(_cmf.timeseries_reduce_sum,None,timeseries)
timeseries.reduce_avg = new_instancemethod(_cmf.timeseries_reduce_avg,None,timeseries)
timeseries.Save = new_instancemethod(_cmf.timeseries_Save,None,timeseries)
timeseries.__size__ = new_instancemethod(_cmf.timeseries___size__,None,timeseries)
timeseries.__getitem__ = new_instancemethod(_cmf.timeseries___getitem__,None,timeseries)
timeseries.__setitem__ = new_instancemethod(_cmf.timeseries___setitem__,None,timeseries)
timeseries_swigregister = _cmf.timeseries_swigregister
timeseries_swigregister(timeseries)
ms = cvar.ms
sec = cvar.sec
min = cvar.min
h = cvar.h
day = cvar.day
week = cvar.week
month = cvar.month
year = cvar.year

class numVector(object):
    """
    A valarray kind of vector implementation with OpenMP capabilities.

    C++ includes: numVector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, int count, real Value = 0) -> numVector
        __init__(self, int count) -> numVector
        __init__(self, size_t count, real Value = 0) -> numVector
        __init__(self, size_t count) -> numVector
        __init__(self) -> numVector
        __init__(self, numVector Vector) -> numVector

        numVector(const std::valarray< real > &Vector)

        Convert from valarray<real>. 
        """
        _cmf.numVector_swiginit(self,_cmf.new_numVector(*args))
    __swig_destroy__ = _cmf.delete_numVector
    def size(self):
        """
        size(self) -> int

        int size() const

        Size of the vector. 
        """
        return _cmf.numVector_size(self)

    def resize(self, *args):
        """
        resize(self, int count)
        resize(self, size_t count)

        void
        resize(size_t count) 
        """
        return _cmf.numVector_resize(self, *args)

    def __neg__(self):
        """__neg__(self) -> numVector"""
        return _cmf.numVector___neg__(self)

    def power(self, *args):
        """
        power(self, numVector arg0) -> numVector
        power(self, real exponent) -> numVector

        numVector
        power(real exponent) const

        Return each element to the power "exponent". 
        """
        return _cmf.numVector_power(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, numVector arg0) -> numVector
        __iadd__(self, real arg0) -> numVector
        """
        return _cmf.numVector___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, numVector arg0) -> numVector
        __isub__(self, real arg0) -> numVector
        """
        return _cmf.numVector___isub__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, numVector arg0) -> numVector
        __imul__(self, real arg0) -> numVector
        """
        return _cmf.numVector___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, numVector arg0) -> numVector
        __idiv__(self, real arg0) -> numVector
        """
        return _cmf.numVector___idiv__(self, *args)

    def apply(self, *args):
        """
        apply(self, real funct) -> numVector

        numVector
        apply(real funct(real)) const

        Return funct(this).

        Parameters:
        -----------

        funct:  a function of signature real funct(real)

        Example: Return the sinus of each element of vector x 
        """
        return _cmf.numVector_apply(self, *args)

    def dot(self, *args):
        """
        dot(self, numVector arg0) -> real

        real dot(const
        numVector &) const

        Return dot product of this and vector. 
        """
        return _cmf.numVector_dot(self, *args)

    def sum(self):
        """
        sum(self) -> real

        real sum() const

        Return sum of vector. 
        """
        return _cmf.numVector_sum(self)

    def max(self):
        """
        max(self) -> real

        real max() const

        Return max of vector. 
        """
        return _cmf.numVector_max(self)

    def min(self):
        """
        min(self) -> real

        real min() const

        Return min of vector. 
        """
        return _cmf.numVector_min(self)

    def norm(self, normtype = 0):
        """
        norm(self, int normtype = 0) -> real
        norm(self) -> real

        real norm(int
        normtype=0) const

        Returns a norm of the vector, implemented norms: 1 - sum of abs, 2 -
        Euclidean distance, 0 Maximum of abs.

        Parameters:
        -----------

        normtype:  An integer indicating the type of norm 
        """
        return _cmf.numVector_norm(self, normtype)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> double"""
        return _cmf.numVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, int index, double value)"""
        return _cmf.numVector___setitem__(self, *args)

    def __len__(self):
        """__len__(self) -> int"""
        return _cmf.numVector___len__(self)

numVector.size = new_instancemethod(_cmf.numVector_size,None,numVector)
numVector.resize = new_instancemethod(_cmf.numVector_resize,None,numVector)
numVector.__neg__ = new_instancemethod(_cmf.numVector___neg__,None,numVector)
numVector.power = new_instancemethod(_cmf.numVector_power,None,numVector)
numVector.__iadd__ = new_instancemethod(_cmf.numVector___iadd__,None,numVector)
numVector.__isub__ = new_instancemethod(_cmf.numVector___isub__,None,numVector)
numVector.__imul__ = new_instancemethod(_cmf.numVector___imul__,None,numVector)
numVector.__idiv__ = new_instancemethod(_cmf.numVector___idiv__,None,numVector)
numVector.apply = new_instancemethod(_cmf.numVector_apply,None,numVector)
numVector.dot = new_instancemethod(_cmf.numVector_dot,None,numVector)
numVector.sum = new_instancemethod(_cmf.numVector_sum,None,numVector)
numVector.max = new_instancemethod(_cmf.numVector_max,None,numVector)
numVector.min = new_instancemethod(_cmf.numVector_min,None,numVector)
numVector.norm = new_instancemethod(_cmf.numVector_norm,None,numVector)
numVector.__getitem__ = new_instancemethod(_cmf.numVector___getitem__,None,numVector)
numVector.__setitem__ = new_instancemethod(_cmf.numVector___setitem__,None,numVector)
numVector.__len__ = new_instancemethod(_cmf.numVector___len__,None,numVector)
numVector_swigregister = _cmf.numVector_swigregister
numVector_swigregister(numVector)

class svVector(object):
    """Proxy of C++ std::vector<(p.cmf::math::StateVariable)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.svVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.svVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.svVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.svVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.svVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> svVector"""
        return _cmf.svVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, svVector v)"""
        return _cmf.svVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.svVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.svVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> svVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.svVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, svVector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.svVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.svVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.svVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.svVector_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.svVector_clear(self)

    def swap(self, *args):
        """swap(self, svVector v)"""
        return _cmf.svVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.svVector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.svVector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.svVector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.svVector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.svVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.svVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.svVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> svVector
        __init__(self, svVector arg0) -> svVector
        __init__(self, size_type size) -> svVector
        __init__(self, size_type size, value_type value) -> svVector
        """
        _cmf.svVector_swiginit(self,_cmf.new_svVector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.svVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.svVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.svVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.svVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.svVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.svVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.svVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.svVector_capacity(self)

    __swig_destroy__ = _cmf.delete_svVector
svVector.iterator = new_instancemethod(_cmf.svVector_iterator,None,svVector)
svVector.__nonzero__ = new_instancemethod(_cmf.svVector___nonzero__,None,svVector)
svVector.__bool__ = new_instancemethod(_cmf.svVector___bool__,None,svVector)
svVector.__len__ = new_instancemethod(_cmf.svVector___len__,None,svVector)
svVector.pop = new_instancemethod(_cmf.svVector_pop,None,svVector)
svVector.__getslice__ = new_instancemethod(_cmf.svVector___getslice__,None,svVector)
svVector.__setslice__ = new_instancemethod(_cmf.svVector___setslice__,None,svVector)
svVector.__delslice__ = new_instancemethod(_cmf.svVector___delslice__,None,svVector)
svVector.__delitem__ = new_instancemethod(_cmf.svVector___delitem__,None,svVector)
svVector.__getitem__ = new_instancemethod(_cmf.svVector___getitem__,None,svVector)
svVector.__setitem__ = new_instancemethod(_cmf.svVector___setitem__,None,svVector)
svVector.append = new_instancemethod(_cmf.svVector_append,None,svVector)
svVector.empty = new_instancemethod(_cmf.svVector_empty,None,svVector)
svVector.size = new_instancemethod(_cmf.svVector_size,None,svVector)
svVector.clear = new_instancemethod(_cmf.svVector_clear,None,svVector)
svVector.swap = new_instancemethod(_cmf.svVector_swap,None,svVector)
svVector.get_allocator = new_instancemethod(_cmf.svVector_get_allocator,None,svVector)
svVector.begin = new_instancemethod(_cmf.svVector_begin,None,svVector)
svVector.end = new_instancemethod(_cmf.svVector_end,None,svVector)
svVector.rbegin = new_instancemethod(_cmf.svVector_rbegin,None,svVector)
svVector.rend = new_instancemethod(_cmf.svVector_rend,None,svVector)
svVector.pop_back = new_instancemethod(_cmf.svVector_pop_back,None,svVector)
svVector.erase = new_instancemethod(_cmf.svVector_erase,None,svVector)
svVector.push_back = new_instancemethod(_cmf.svVector_push_back,None,svVector)
svVector.front = new_instancemethod(_cmf.svVector_front,None,svVector)
svVector.back = new_instancemethod(_cmf.svVector_back,None,svVector)
svVector.assign = new_instancemethod(_cmf.svVector_assign,None,svVector)
svVector.resize = new_instancemethod(_cmf.svVector_resize,None,svVector)
svVector.insert = new_instancemethod(_cmf.svVector_insert,None,svVector)
svVector.reserve = new_instancemethod(_cmf.svVector_reserve,None,svVector)
svVector.capacity = new_instancemethod(_cmf.svVector_capacity,None,svVector)
svVector_swigregister = _cmf.svVector_swigregister
svVector_swigregister(svVector)

def __add__(*args):
  """
    __add__(numVector _Left, numVector _Right) -> numVector
    __add__(numVector _Left, real _Right) -> numVector
    __add__(real _Left, numVector _Right) -> numVector
    """
  return _cmf.__add__(*args)

def __sub__(*args):
  """
    __sub__(numVector _Left, numVector _Right) -> numVector
    __sub__(numVector _Left, real _Right) -> numVector
    __sub__(real _Left, numVector _Right) -> numVector
    """
  return _cmf.__sub__(*args)

def __mul__(*args):
  """
    __mul__(double f, Time t) -> Time
    __mul__(int f, Time t) -> Time
    __mul__(numVector _Left, numVector _Right) -> numVector
    __mul__(numVector _Left, real _Right) -> numVector
    __mul__(real _Left, numVector _Right) -> numVector
    """
  return _cmf.__mul__(*args)

def __div__(*args):
  """
    __div__(numVector _Left, numVector _Right) -> numVector
    __div__(numVector _Left, real _Right) -> numVector
    __div__(real _Left, numVector _Right) -> numVector
    """
  return _cmf.__div__(*args)

class StateVariable(object):
    """
    Abstract class state variable

    Simple exponential system class header implementing a state variable:

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Derivate(self, *args):
        """
        Derivate(self, Time time) -> real

        virtual
        real Derivate(const cmf::math::Time &time)=0

        Returns the derivate of the state variable at time time. 
        """
        return _cmf.StateVariable_Derivate(self, *args)

    def State(self, *args):
        """
        State(self) -> real
        State(self, real newState)

        void
        State(const real &newState)

        Gives access to the state variable. 
        """
        return _cmf.StateVariable_State(self, *args)

    def StateIsChanged(self):
        """
        StateIsChanged(self) -> bool

        bool
        StateIsChanged()

        Returns if the state was currently updated. 
        """
        return _cmf.StateVariable_StateIsChanged(self)

    state=property(State,None,"Gets the currect state")

    __swig_destroy__ = _cmf.delete_StateVariable
StateVariable.Derivate = new_instancemethod(_cmf.StateVariable_Derivate,None,StateVariable)
StateVariable.State = new_instancemethod(_cmf.StateVariable_State,None,StateVariable)
StateVariable.StateIsChanged = new_instancemethod(_cmf.StateVariable_StateIsChanged,None,StateVariable)
StateVariable_swigregister = _cmf.StateVariable_swigregister
StateVariable_swigregister(StateVariable)

class StateVariableVector(svVector):
    """
    A vector of state variables, can be solved by RKFIntegrator.

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def CopyStates(self, *args):
        """
        CopyStates(self, numVector destination)
        CopyStates(self, real destination)

        void CopyStates(numVector &destination) const

        Copies the states to a numeric vector using OpenMP. 
        """
        return _cmf.StateVariableVector_CopyStates(self, *args)

    def SetStates(self, *args):
        """
        SetStates(self, numVector newStates)
        SetStates(self, real newStates)

        void SetStates(const numVector &newStates)

        Copies the new states to the actual states. 
        """
        return _cmf.StateVariableVector_SetStates(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, numVector aVector) -> StateVariableVector"""
        return _cmf.StateVariableVector___iadd__(self, *args)

    def CopyDerivs(self, *args):
        """
        CopyDerivs(self, Time time, numVector destination, real factor = 1)
        CopyDerivs(self, Time time, numVector destination)
        CopyDerivs(self, Time time, real destination, real factor = 1)
        CopyDerivs(self, Time time, real destination)

        void CopyDerivs(Time time, numVector &destination, real factor=1)
        const

        Copies the derivatives at time step "time" to a numeric vector using
        OpenMP.

        Parameters:
        -----------

        time:   Time at which the derivatives should be calculated

        destination:  Vector to be overwritten by the results

        factor:  A factor that is multiplied to the derivate (e.g. unit
        conversion or integration length) 
        """
        return _cmf.StateVariableVector_CopyDerivs(self, *args)

    def GetStates(self):
        """
        GetStates(self) -> numVector

        numVector GetStates() const

        Returns the states in a numeric vector using :CopyStates, but is
        slower because of additional memory allocation. 
        """
        return _cmf.StateVariableVector_GetStates(self)

    def GetDerivs(self, *args):
        """
        GetDerivs(self, Time time) -> numVector

        numVector GetDerivs(Time time) const

        Returns the derivatives at time step "time" in a numeric vector
        using :CopyDerivs, but is slower because of additional memory
        allocation. 
        """
        return _cmf.StateVariableVector_GetDerivs(self, *args)

    def __init__(self): 
        """__init__(self) -> StateVariableVector"""
        _cmf.StateVariableVector_swiginit(self,_cmf.new_StateVariableVector())
    __swig_destroy__ = _cmf.delete_StateVariableVector
StateVariableVector.CopyStates = new_instancemethod(_cmf.StateVariableVector_CopyStates,None,StateVariableVector)
StateVariableVector.SetStates = new_instancemethod(_cmf.StateVariableVector_SetStates,None,StateVariableVector)
StateVariableVector.__iadd__ = new_instancemethod(_cmf.StateVariableVector___iadd__,None,StateVariableVector)
StateVariableVector.CopyDerivs = new_instancemethod(_cmf.StateVariableVector_CopyDerivs,None,StateVariableVector)
StateVariableVector.GetStates = new_instancemethod(_cmf.StateVariableVector_GetStates,None,StateVariableVector)
StateVariableVector.GetDerivs = new_instancemethod(_cmf.StateVariableVector_GetDerivs,None,StateVariableVector)
StateVariableVector_swigregister = _cmf.StateVariableVector_swigregister
StateVariableVector_swigregister(StateVariableVector)

class StateVariableOwner(object):
    """
    An abstract class, that owns one or more state variables, that can add
    them to a vector of state variables in a certain order.

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def AddStateVariables(self, *args):
        """
        AddStateVariables(self, StateVariableVector vector)

        virtual void
        AddStateVariables(cmf::math::StateVariableVector &vector)=0

        Add the state variables, owned by an object derived from
        StateVariableOwner, to the given vector. 
        """
        return _cmf.StateVariableOwner_AddStateVariables(self, *args)

    __swig_destroy__ = _cmf.delete_StateVariableOwner
StateVariableOwner.AddStateVariables = new_instancemethod(_cmf.StateVariableOwner_AddStateVariables,None,StateVariableOwner)
StateVariableOwner_swigregister = _cmf.StateVariableOwner_swigregister
StateVariableOwner_swigregister(StateVariableOwner)

class Integrator(object):
    """
    Base class for any kind of integrator.

    Pure virtual functions: Integrate

    Copy Please provide a custom copy constructorTodo Put the methods of
    StateVariableVector here, and delete StateVariableVector

    C++ includes: Integrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Tag = _swig_property(_cmf.Integrator_Tag_get, _cmf.Integrator_Tag_set)
    UseEulerAtTmin = _swig_property(_cmf.Integrator_UseEulerAtTmin_get, _cmf.Integrator_UseEulerAtTmin_set)
    def count(self):
        """
        count(self) -> int

        int count()
        const

        returns the number of state variables 
        """
        return _cmf.Integrator_count(self)

    def state(self, *args):
        """
        state(self, int position) -> real
        state(self, int position, real newState)

        void state(int
        position, real newState)

        Simplifies the assessment of state variables. 
        """
        return _cmf.Integrator_state(self, *args)

    def AddStatesFromOwner(self, *args):
        """
        AddStatesFromOwner(self, StateVariableOwner stateOwner)

        virtual void AddStatesFromOwner(cmf::math::StateVariableOwner
        &stateOwner)

        Adds the state variables of a StateVariableOwner to the state
        variables of the solver. 
        """
        return _cmf.Integrator_AddStatesFromOwner(self, *args)

    def AddState(self, *args):
        """AddState(self, StateVariable statevar)"""
        return _cmf.Integrator_AddState(self, *args)

    def ModelTime(self, *args):
        """
        ModelTime(self) -> Time
        ModelTime(self, Time val)

        void
        ModelTime(cmf::math::Time val)

        Sets the current model time. 
        """
        return _cmf.Integrator_ModelTime(self, *args)

    def TimeStep(self):
        """
        TimeStep(self) -> Time

        cmf::math::Time TimeStep() const

        Returns the last time step. 
        """
        return _cmf.Integrator_TimeStep(self)

    def NextTimeStep(self, *args):
        """
        NextTimeStep(self) -> Time
        NextTimeStep(self, Time val)

        void
        NextTimeStep(cmf::math::Time val)

        Sets the next time step width. 
        """
        return _cmf.Integrator_NextTimeStep(self, *args)

    def MinTimestep(self):
        """
        MinTimestep(self) -> Time

        const
        cmf::math::Time MinTimestep() const

        Returns The minimal allowed time step length. 
        """
        return _cmf.Integrator_MinTimestep(self)

    def Iterations(self):
        """
        Iterations(self) -> int

        int
        Iterations() const 
        """
        return _cmf.Integrator_Iterations(self)

    def ResetIterations(self):
        """
        ResetIterations(self)

        void
        ResetIterations() 
        """
        return _cmf.Integrator_ResetIterations(self)

    def Reset(self):
        """Reset(self)"""
        return _cmf.Integrator_Reset(self)

    def Copy(self):
        """
        Copy(self) -> Integrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf.Integrator_Copy(self)

    def Integrate(self, *args):
        """
        Integrate(self, Time MaxTime, Time TimeStep) -> int
        Integrate(self, Time MaxTime) -> int

        int
        Integrate(cmf::math::Time MaxTime) 
        """
        return _cmf.Integrator_Integrate(self, *args)

    def IntegrateUntil(self, *args):
        """
        IntegrateUntil(self, Time MaxTime)
        IntegrateUntil(self, Time MaxTime, Time TimeStep)

        void
        IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

        Integrates the vector of state variables until MaxTime. 
        """
        return _cmf.Integrator_IntegrateUntil(self, *args)

    def __call__(self, *args):
        """
        __call__(self, Time t)

        void
        __call__(cmf::math::Time until)

        Calls IntegrateUntil. 
        """
        return _cmf.Integrator___call__(self, *args)

    t=property(ModelTime,ModelTime,"Gets or sets the model time of the integrator")
    dt=property(TimeStep,None,"Gets the length of the last internal time step of the integrator")

    __swig_destroy__ = _cmf.delete_Integrator
Integrator.count = new_instancemethod(_cmf.Integrator_count,None,Integrator)
Integrator.state = new_instancemethod(_cmf.Integrator_state,None,Integrator)
Integrator.AddStatesFromOwner = new_instancemethod(_cmf.Integrator_AddStatesFromOwner,None,Integrator)
Integrator.AddState = new_instancemethod(_cmf.Integrator_AddState,None,Integrator)
Integrator.ModelTime = new_instancemethod(_cmf.Integrator_ModelTime,None,Integrator)
Integrator.TimeStep = new_instancemethod(_cmf.Integrator_TimeStep,None,Integrator)
Integrator.NextTimeStep = new_instancemethod(_cmf.Integrator_NextTimeStep,None,Integrator)
Integrator.MinTimestep = new_instancemethod(_cmf.Integrator_MinTimestep,None,Integrator)
Integrator.Iterations = new_instancemethod(_cmf.Integrator_Iterations,None,Integrator)
Integrator.ResetIterations = new_instancemethod(_cmf.Integrator_ResetIterations,None,Integrator)
Integrator.Reset = new_instancemethod(_cmf.Integrator_Reset,None,Integrator)
Integrator.Copy = new_instancemethod(_cmf.Integrator_Copy,None,Integrator)
Integrator.Integrate = new_instancemethod(_cmf.Integrator_Integrate,None,Integrator)
Integrator.IntegrateUntil = new_instancemethod(_cmf.Integrator_IntegrateUntil,None,Integrator)
Integrator.__call__ = new_instancemethod(_cmf.Integrator___call__,None,Integrator)
Integrator_swigregister = _cmf.Integrator_swigregister
Integrator_swigregister(Integrator)

class BDF2(Integrator):
    """
    An order 2 BDF-Method with fixed-point iteration and variable step
    size.

    Recommended integrator for CMF (so far)

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8 and

    Eckert S., Baaser H., Gross D. and Scherf O. (2004) "A BDF2
    integration method with step size control for elasto-plasticity",
    Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1

    Most important function: Integrate

    C++ includes: BDF2.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get_error_position(self):
        """get_error_position(self) -> int"""
        return _cmf.BDF2_get_error_position(self)

    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> BDF2
        __init__(self, StateVariableVector states) -> BDF2
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, real epsilon = 1e-9) -> BDF2
        __init__(self) -> BDF2
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, StateVariableOwner states, real epsilon = 1e-9) -> BDF2
        __init__(self, StateVariableOwner states) -> BDF2
        __init__(self, Integrator templ) -> BDF2

        BDF2(const Integrator
        &templ) 
        """
        _cmf.BDF2_swiginit(self,_cmf.new_BDF2(*args))
    __swig_destroy__ = _cmf.delete_BDF2
BDF2.get_error_position = new_instancemethod(_cmf.BDF2_get_error_position,None,BDF2)
BDF2_swigregister = _cmf.BDF2_swigregister
BDF2_swigregister(BDF2)

class ExplicitEuler_fixed(Integrator):
    """
    An explicit Euler integrator, with a fixed time step.

    C++ includes: ExplicitEuler_fixed.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> ExplicitEuler_fixed
        __init__(self, StateVariableVector states) -> ExplicitEuler_fixed
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, real epsilon = 1e-9) -> ExplicitEuler_fixed
        __init__(self) -> ExplicitEuler_fixed
        __init__(self, Integrator copy) -> ExplicitEuler_fixed

        ExplicitEuler_fixed(const Integrator &copy)

        Copy constructor. 
        """
        _cmf.ExplicitEuler_fixed_swiginit(self,_cmf.new_ExplicitEuler_fixed(*args))
    __swig_destroy__ = _cmf.delete_ExplicitEuler_fixed
ExplicitEuler_fixed_swigregister = _cmf.ExplicitEuler_fixed_swigregister
ExplicitEuler_fixed_swigregister(ExplicitEuler_fixed)

class ExplicitEuler_variable(Integrator):
    """
    An explicit Euler integrator with variable step size.

    C++ includes: ExplicitEuler_variable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    WithStepsizeControl = _swig_property(_cmf.ExplicitEuler_variable_WithStepsizeControl_get, _cmf.ExplicitEuler_variable_WithStepsizeControl_set)
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_variable
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> ExplicitEuler_variable
        __init__(self, StateVariableVector states) -> ExplicitEuler_variable
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_variable
        __init__(self, real epsilon = 1e-9) -> ExplicitEuler_variable
        __init__(self) -> ExplicitEuler_variable
        __init__(self, Integrator copy) -> ExplicitEuler_variable

        ExplicitEuler_variable(const Integrator &copy)

        Copy constructor. 
        """
        _cmf.ExplicitEuler_variable_swiginit(self,_cmf.new_ExplicitEuler_variable(*args))
    __swig_destroy__ = _cmf.delete_ExplicitEuler_variable
ExplicitEuler_variable_swigregister = _cmf.ExplicitEuler_variable_swigregister
ExplicitEuler_variable_swigregister(ExplicitEuler_variable)

class ImplicitEuler(Integrator):
    """
    An implicit (backward) Euler integrator using fixpoint iteration.

    C++ includes: FixpointImplicitEuler.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ImplicitEuler
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> ImplicitEuler
        __init__(self, StateVariableVector states) -> ImplicitEuler
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ImplicitEuler
        __init__(self, real epsilon = 1e-9) -> ImplicitEuler
        __init__(self) -> ImplicitEuler
        __init__(self, Integrator arg0) -> ImplicitEuler

        ImplicitEuler(const Integrator &)

        Copy constructor. 
        """
        _cmf.ImplicitEuler_swiginit(self,_cmf.new_ImplicitEuler(*args))
    __swig_destroy__ = _cmf.delete_ImplicitEuler
ImplicitEuler_swigregister = _cmf.ImplicitEuler_swigregister
ImplicitEuler_swigregister(ImplicitEuler)

class RKFIntegrator(Integrator):
    """
    Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
    Fehlberg (RKF54) method.

    C++ includes: RKFIntegrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> RKFIntegrator
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> RKFIntegrator
        __init__(self, StateVariableVector states) -> RKFIntegrator
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> RKFIntegrator
        __init__(self, real epsilon = 1e-9) -> RKFIntegrator
        __init__(self) -> RKFIntegrator
        __init__(self, Integrator forCopy) -> RKFIntegrator

        RKFIntegrator(const Integrator &forCopy)

        Copy constructor, does not copy. 
        """
        _cmf.RKFIntegrator_swiginit(self,_cmf.new_RKFIntegrator(*args))
    __swig_destroy__ = _cmf.delete_RKFIntegrator
RKFIntegrator_swigregister = _cmf.RKFIntegrator_swigregister
RKFIntegrator_swigregister(RKFIntegrator)

GEAR_MAX_ITER = _cmf.GEAR_MAX_ITER
GEAR_RECOVER_AFTER_STEPS = _cmf.GEAR_RECOVER_AFTER_STEPS
class Gears_Fixpoint(Integrator):
    """
    An up to 4 step Gears-Method with fixpoint iteration, needs bug
    fixing.

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8

    C++ includes: Gears_Fixpoint.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Time_reduce_stage(self):
        """
        Time_reduce_stage(self) -> int

        int Time_reduce_stage() const

        Returns int Stage oof time reduction. 
        """
        return _cmf.Gears_Fixpoint_Time_reduce_stage(self)

    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10), 
            int maxOrder = 4) -> Gears_Fixpoint
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> Gears_Fixpoint
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> Gears_Fixpoint
        __init__(self, StateVariableVector states) -> Gears_Fixpoint
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10), 
            int maxOrder = 4) -> Gears_Fixpoint
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> Gears_Fixpoint
        __init__(self, real epsilon = 1e-9) -> Gears_Fixpoint
        __init__(self) -> Gears_Fixpoint
        __init__(self, Integrator arg0) -> Gears_Fixpoint

        Gears_Fixpoint(const Integrator &)

        Copy constructor. 
        """
        _cmf.Gears_Fixpoint_swiginit(self,_cmf.new_Gears_Fixpoint(*args))
    __swig_destroy__ = _cmf.delete_Gears_Fixpoint
Gears_Fixpoint.Time_reduce_stage = new_instancemethod(_cmf.Gears_Fixpoint_Time_reduce_stage,None,Gears_Fixpoint)
Gears_Fixpoint_swigregister = _cmf.Gears_Fixpoint_swigregister
Gears_Fixpoint_swigregister(Gears_Fixpoint)

class CVodeIntegrator(Integrator):
    """Proxy of C++ cmf::math::CVodeIntegrator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    preconditioner = _swig_property(_cmf.CVodeIntegrator_preconditioner_get, _cmf.CVodeIntegrator_preconditioner_set)
    MaxNonLinearIterations = _swig_property(_cmf.CVodeIntegrator_MaxNonLinearIterations_get, _cmf.CVodeIntegrator_MaxNonLinearIterations_set)
    MaxConvergenceFailures = _swig_property(_cmf.CVodeIntegrator_MaxConvergenceFailures_get, _cmf.CVodeIntegrator_MaxConvergenceFailures_set)
    MaxErrorTestFailures = _swig_property(_cmf.CVodeIntegrator_MaxErrorTestFailures_get, _cmf.CVodeIntegrator_MaxErrorTestFailures_set)
    maxl = _swig_property(_cmf.CVodeIntegrator_maxl_get, _cmf.CVodeIntegrator_maxl_set)
    LinearSolver = _swig_property(_cmf.CVodeIntegrator_LinearSolver_get, _cmf.CVodeIntegrator_LinearSolver_set)
    MaxOrder = _swig_property(_cmf.CVodeIntegrator_MaxOrder_get, _cmf.CVodeIntegrator_MaxOrder_set)
    reinit_always = _swig_property(_cmf.CVodeIntegrator_reinit_always_get, _cmf.CVodeIntegrator_reinit_always_set)
    def GetOrder(self):
        """GetOrder(self) -> int"""
        return _cmf.CVodeIntegrator_GetOrder(self)

    def ReInit(self, *args):
        """
        ReInit(self, Time initdt, real epsilon = 0)
        ReInit(self, Time initdt)
        """
        return _cmf.CVodeIntegrator_ReInit(self, *args)

    def Initialize(self, *args):
        """
        Initialize(self, Time max_step = day)
        Initialize(self)
        """
        return _cmf.CVodeIntegrator_Initialize(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(50)) -> CVodeIntegrator
        __init__(self, real epsilon = 1e-9) -> CVodeIntegrator
        __init__(self) -> CVodeIntegrator
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(50)) -> CVodeIntegrator
        __init__(self, StateVariableOwner states, real epsilon = 1e-9) -> CVodeIntegrator
        __init__(self, StateVariableOwner states) -> CVodeIntegrator
        __init__(self, CVodeIntegrator templ) -> CVodeIntegrator
        """
        _cmf.CVodeIntegrator_swiginit(self,_cmf.new_CVodeIntegrator(*args))
    def Copy(self):
        """
        Copy(self) -> CVodeIntegrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf.CVodeIntegrator_Copy(self)

    __swig_destroy__ = _cmf.delete_CVodeIntegrator
CVodeIntegrator.GetOrder = new_instancemethod(_cmf.CVodeIntegrator_GetOrder,None,CVodeIntegrator)
CVodeIntegrator.ReInit = new_instancemethod(_cmf.CVodeIntegrator_ReInit,None,CVodeIntegrator)
CVodeIntegrator.Initialize = new_instancemethod(_cmf.CVodeIntegrator_Initialize,None,CVodeIntegrator)
CVodeIntegrator.Copy = new_instancemethod(_cmf.CVodeIntegrator_Copy,None,CVodeIntegrator)
CVodeIntegrator_swigregister = _cmf.CVodeIntegrator_swigregister
CVodeIntegrator_swigregister(CVodeIntegrator)

def AsCMFtime(date):
    """Converts a python datetime to cmf.Time"""
    return Time(date.day,date.month,date.year,date.hour,date.minute,date.second,date.microsecond/1000)
def timerange(start,end,step=day):
    """Creates a list of cmf.Time, similar to the Python range function"""
    return [start+step*x for x in range(0,int((end-start)/step+0.999))]

class IMap_Double(object):
    """Proxy of C++ cmf::maps::IMap<(double)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get(self, *args):
        """
        get(self, point p) -> double
        get(self, double x, double y) -> double
        """
        return _cmf.IMap_Double_get(self, *args)

    def has(self, *args):
        """
        has(self, double x, double y) -> bool
        has(self, point p) -> bool
        """
        return _cmf.IMap_Double_has(self, *args)

    def __call__(self, *args):
        """__call__(self, double x, double y) -> double"""
        return _cmf.IMap_Double___call__(self, *args)

    __swig_destroy__ = _cmf.delete_IMap_Double
IMap_Double.get = new_instancemethod(_cmf.IMap_Double_get,None,IMap_Double)
IMap_Double.has = new_instancemethod(_cmf.IMap_Double_has,None,IMap_Double)
IMap_Double.__call__ = new_instancemethod(_cmf.IMap_Double___call__,None,IMap_Double)
IMap_Double_swigregister = _cmf.IMap_Double_swigregister
IMap_Double_swigregister(IMap_Double)

class SingleValueMap_Double(IMap_Double):
    """Proxy of C++ cmf::maps::SingleValueMap<(double)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double value) -> SingleValueMap_Double"""
        _cmf.SingleValueMap_Double_swiginit(self,_cmf.new_SingleValueMap_Double(*args))
    __swig_destroy__ = _cmf.delete_SingleValueMap_Double
SingleValueMap_Double_swigregister = _cmf.SingleValueMap_Double_swigregister
SingleValueMap_Double_swigregister(SingleValueMap_Double)

class ContinuousRasterMap_Double(IMap_Double):
    """Proxy of C++ cmf::maps::ContinuousRasterMap<(double)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, DoubleRaster raster) -> ContinuousRasterMap_Double
        __init__(self, string ASCFileName, double factor = 1, double nodata = -9999) -> ContinuousRasterMap_Double
        __init__(self, string ASCFileName, double factor = 1) -> ContinuousRasterMap_Double
        __init__(self, string ASCFileName) -> ContinuousRasterMap_Double
        """
        _cmf.ContinuousRasterMap_Double_swiginit(self,_cmf.new_ContinuousRasterMap_Double(*args))
    Raster = _swig_property(_cmf.ContinuousRasterMap_Double_Raster_get, _cmf.ContinuousRasterMap_Double_Raster_set)
    __swig_destroy__ = _cmf.delete_ContinuousRasterMap_Double
ContinuousRasterMap_Double_swigregister = _cmf.ContinuousRasterMap_Double_swigregister
ContinuousRasterMap_Double_swigregister(ContinuousRasterMap_Double)

class DiscreteRasterMap_Double(IMap_Double):
    """Proxy of C++ cmf::maps::DiscreteRasterMap<(double)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Raster = _swig_property(_cmf.DiscreteRasterMap_Double_Raster_get, _cmf.DiscreteRasterMap_Double_Raster_set)
    def add(self, *args):
        """add(self, int index, double value)"""
        return _cmf.DiscreteRasterMap_Double_add(self, *args)

    def erase(self, *args):
        """erase(self, int index)"""
        return _cmf.DiscreteRasterMap_Double_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, IntRaster raster, double NoDataValue = double()) -> DiscreteRasterMap_Double
        __init__(self, IntRaster raster) -> DiscreteRasterMap_Double
        __init__(self, string RasterFileName, double NoDataValue = double()) -> DiscreteRasterMap_Double
        __init__(self, string RasterFileName) -> DiscreteRasterMap_Double
        """
        _cmf.DiscreteRasterMap_Double_swiginit(self,_cmf.new_DiscreteRasterMap_Double(*args))
    __swig_destroy__ = _cmf.delete_DiscreteRasterMap_Double
DiscreteRasterMap_Double.add = new_instancemethod(_cmf.DiscreteRasterMap_Double_add,None,DiscreteRasterMap_Double)
DiscreteRasterMap_Double.erase = new_instancemethod(_cmf.DiscreteRasterMap_Double_erase,None,DiscreteRasterMap_Double)
DiscreteRasterMap_Double_swigregister = _cmf.DiscreteRasterMap_Double_swigregister
DiscreteRasterMap_Double_swigregister(DiscreteRasterMap_Double)

class NearestNeighborMap_Double(IMap_Double):
    """Proxy of C++ cmf::maps::NearestNeighborMap<(double)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, point p, double value)
        add(self, double x, double y, double value)
        """
        return _cmf.NearestNeighborMap_Double_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.NearestNeighborMap_Double_erase(self, *args)

    zWeight = _swig_property(_cmf.NearestNeighborMap_Double_zWeight_get, _cmf.NearestNeighborMap_Double_zWeight_set)
    def size(self):
        """size(self) -> int"""
        return _cmf.NearestNeighborMap_Double_size(self)

    def Position(self, *args):
        """Position(self, int index) -> point"""
        return _cmf.NearestNeighborMap_Double_Position(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> double"""
        return _cmf.NearestNeighborMap_Double_Value(self, *args)

    def __init__(self, z_Weight = 0): 
        """
        __init__(self, double z_Weight = 0) -> NearestNeighborMap_Double
        __init__(self) -> NearestNeighborMap_Double
        """
        _cmf.NearestNeighborMap_Double_swiginit(self,_cmf.new_NearestNeighborMap_Double(z_Weight))
    __swig_destroy__ = _cmf.delete_NearestNeighborMap_Double
NearestNeighborMap_Double.add = new_instancemethod(_cmf.NearestNeighborMap_Double_add,None,NearestNeighborMap_Double)
NearestNeighborMap_Double.erase = new_instancemethod(_cmf.NearestNeighborMap_Double_erase,None,NearestNeighborMap_Double)
NearestNeighborMap_Double.size = new_instancemethod(_cmf.NearestNeighborMap_Double_size,None,NearestNeighborMap_Double)
NearestNeighborMap_Double.Position = new_instancemethod(_cmf.NearestNeighborMap_Double_Position,None,NearestNeighborMap_Double)
NearestNeighborMap_Double.Value = new_instancemethod(_cmf.NearestNeighborMap_Double_Value,None,NearestNeighborMap_Double)
NearestNeighborMap_Double_swigregister = _cmf.NearestNeighborMap_Double_swigregister
NearestNeighborMap_Double_swigregister(NearestNeighborMap_Double)

class PolygonMap_Double(IMap_Double):
    """Proxy of C++ cmf::maps::PolygonMap<(double)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double nodata = double()) -> PolygonMap_Double
        __init__(self) -> PolygonMap_Double
        """
        _cmf.PolygonMap_Double_swiginit(self,_cmf.new_PolygonMap_Double(*args))
    def add(self, *args):
        """add(self, Ring polygon, double value)"""
        return _cmf.PolygonMap_Double_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.PolygonMap_Double_erase(self, *args)

    def size(self):
        """size(self) -> int"""
        return _cmf.PolygonMap_Double_size(self)

    def Polygon(self, *args):
        """Polygon(self, int index) -> Ring"""
        return _cmf.PolygonMap_Double_Polygon(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> double"""
        return _cmf.PolygonMap_Double_Value(self, *args)

    __swig_destroy__ = _cmf.delete_PolygonMap_Double
PolygonMap_Double.add = new_instancemethod(_cmf.PolygonMap_Double_add,None,PolygonMap_Double)
PolygonMap_Double.erase = new_instancemethod(_cmf.PolygonMap_Double_erase,None,PolygonMap_Double)
PolygonMap_Double.size = new_instancemethod(_cmf.PolygonMap_Double_size,None,PolygonMap_Double)
PolygonMap_Double.Polygon = new_instancemethod(_cmf.PolygonMap_Double_Polygon,None,PolygonMap_Double)
PolygonMap_Double.Value = new_instancemethod(_cmf.PolygonMap_Double_Value,None,PolygonMap_Double)
PolygonMap_Double_swigregister = _cmf.PolygonMap_Double_swigregister
PolygonMap_Double_swigregister(PolygonMap_Double)

class IMap_Float(object):
    """Proxy of C++ cmf::maps::IMap<(float)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get(self, *args):
        """
        get(self, point p) -> float
        get(self, double x, double y) -> float
        """
        return _cmf.IMap_Float_get(self, *args)

    def has(self, *args):
        """
        has(self, double x, double y) -> bool
        has(self, point p) -> bool
        """
        return _cmf.IMap_Float_has(self, *args)

    def __call__(self, *args):
        """__call__(self, double x, double y) -> float"""
        return _cmf.IMap_Float___call__(self, *args)

    __swig_destroy__ = _cmf.delete_IMap_Float
IMap_Float.get = new_instancemethod(_cmf.IMap_Float_get,None,IMap_Float)
IMap_Float.has = new_instancemethod(_cmf.IMap_Float_has,None,IMap_Float)
IMap_Float.__call__ = new_instancemethod(_cmf.IMap_Float___call__,None,IMap_Float)
IMap_Float_swigregister = _cmf.IMap_Float_swigregister
IMap_Float_swigregister(IMap_Float)

class SingleValueMap_Float(IMap_Float):
    """Proxy of C++ cmf::maps::SingleValueMap<(float)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, float value) -> SingleValueMap_Float"""
        _cmf.SingleValueMap_Float_swiginit(self,_cmf.new_SingleValueMap_Float(*args))
    __swig_destroy__ = _cmf.delete_SingleValueMap_Float
SingleValueMap_Float_swigregister = _cmf.SingleValueMap_Float_swigregister
SingleValueMap_Float_swigregister(SingleValueMap_Float)

class ContinuousRasterMap_Float(IMap_Float):
    """Proxy of C++ cmf::maps::ContinuousRasterMap<(float)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SingleRaster raster) -> ContinuousRasterMap_Float
        __init__(self, string ASCFileName, float factor = 1, float nodata = -9999) -> ContinuousRasterMap_Float
        __init__(self, string ASCFileName, float factor = 1) -> ContinuousRasterMap_Float
        __init__(self, string ASCFileName) -> ContinuousRasterMap_Float
        """
        _cmf.ContinuousRasterMap_Float_swiginit(self,_cmf.new_ContinuousRasterMap_Float(*args))
    Raster = _swig_property(_cmf.ContinuousRasterMap_Float_Raster_get, _cmf.ContinuousRasterMap_Float_Raster_set)
    __swig_destroy__ = _cmf.delete_ContinuousRasterMap_Float
ContinuousRasterMap_Float_swigregister = _cmf.ContinuousRasterMap_Float_swigregister
ContinuousRasterMap_Float_swigregister(ContinuousRasterMap_Float)

class DiscreteRasterMap_Float(IMap_Float):
    """Proxy of C++ cmf::maps::DiscreteRasterMap<(float)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Raster = _swig_property(_cmf.DiscreteRasterMap_Float_Raster_get, _cmf.DiscreteRasterMap_Float_Raster_set)
    def add(self, *args):
        """add(self, int index, float value)"""
        return _cmf.DiscreteRasterMap_Float_add(self, *args)

    def erase(self, *args):
        """erase(self, int index)"""
        return _cmf.DiscreteRasterMap_Float_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, IntRaster raster, float NoDataValue = float()) -> DiscreteRasterMap_Float
        __init__(self, IntRaster raster) -> DiscreteRasterMap_Float
        __init__(self, string RasterFileName, float NoDataValue = float()) -> DiscreteRasterMap_Float
        __init__(self, string RasterFileName) -> DiscreteRasterMap_Float
        """
        _cmf.DiscreteRasterMap_Float_swiginit(self,_cmf.new_DiscreteRasterMap_Float(*args))
    __swig_destroy__ = _cmf.delete_DiscreteRasterMap_Float
DiscreteRasterMap_Float.add = new_instancemethod(_cmf.DiscreteRasterMap_Float_add,None,DiscreteRasterMap_Float)
DiscreteRasterMap_Float.erase = new_instancemethod(_cmf.DiscreteRasterMap_Float_erase,None,DiscreteRasterMap_Float)
DiscreteRasterMap_Float_swigregister = _cmf.DiscreteRasterMap_Float_swigregister
DiscreteRasterMap_Float_swigregister(DiscreteRasterMap_Float)

class NearestNeighborMap_Float(IMap_Float):
    """Proxy of C++ cmf::maps::NearestNeighborMap<(float)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, point p, float value)
        add(self, double x, double y, float value)
        """
        return _cmf.NearestNeighborMap_Float_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.NearestNeighborMap_Float_erase(self, *args)

    zWeight = _swig_property(_cmf.NearestNeighborMap_Float_zWeight_get, _cmf.NearestNeighborMap_Float_zWeight_set)
    def size(self):
        """size(self) -> int"""
        return _cmf.NearestNeighborMap_Float_size(self)

    def Position(self, *args):
        """Position(self, int index) -> point"""
        return _cmf.NearestNeighborMap_Float_Position(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> float"""
        return _cmf.NearestNeighborMap_Float_Value(self, *args)

    def __init__(self, z_Weight = 0): 
        """
        __init__(self, double z_Weight = 0) -> NearestNeighborMap_Float
        __init__(self) -> NearestNeighborMap_Float
        """
        _cmf.NearestNeighborMap_Float_swiginit(self,_cmf.new_NearestNeighborMap_Float(z_Weight))
    __swig_destroy__ = _cmf.delete_NearestNeighborMap_Float
NearestNeighborMap_Float.add = new_instancemethod(_cmf.NearestNeighborMap_Float_add,None,NearestNeighborMap_Float)
NearestNeighborMap_Float.erase = new_instancemethod(_cmf.NearestNeighborMap_Float_erase,None,NearestNeighborMap_Float)
NearestNeighborMap_Float.size = new_instancemethod(_cmf.NearestNeighborMap_Float_size,None,NearestNeighborMap_Float)
NearestNeighborMap_Float.Position = new_instancemethod(_cmf.NearestNeighborMap_Float_Position,None,NearestNeighborMap_Float)
NearestNeighborMap_Float.Value = new_instancemethod(_cmf.NearestNeighborMap_Float_Value,None,NearestNeighborMap_Float)
NearestNeighborMap_Float_swigregister = _cmf.NearestNeighborMap_Float_swigregister
NearestNeighborMap_Float_swigregister(NearestNeighborMap_Float)

class PolygonMap_Float(IMap_Float):
    """Proxy of C++ cmf::maps::PolygonMap<(float)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, float nodata = float()) -> PolygonMap_Float
        __init__(self) -> PolygonMap_Float
        """
        _cmf.PolygonMap_Float_swiginit(self,_cmf.new_PolygonMap_Float(*args))
    def add(self, *args):
        """add(self, Ring polygon, float value)"""
        return _cmf.PolygonMap_Float_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.PolygonMap_Float_erase(self, *args)

    def size(self):
        """size(self) -> int"""
        return _cmf.PolygonMap_Float_size(self)

    def Polygon(self, *args):
        """Polygon(self, int index) -> Ring"""
        return _cmf.PolygonMap_Float_Polygon(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> float"""
        return _cmf.PolygonMap_Float_Value(self, *args)

    __swig_destroy__ = _cmf.delete_PolygonMap_Float
PolygonMap_Float.add = new_instancemethod(_cmf.PolygonMap_Float_add,None,PolygonMap_Float)
PolygonMap_Float.erase = new_instancemethod(_cmf.PolygonMap_Float_erase,None,PolygonMap_Float)
PolygonMap_Float.size = new_instancemethod(_cmf.PolygonMap_Float_size,None,PolygonMap_Float)
PolygonMap_Float.Polygon = new_instancemethod(_cmf.PolygonMap_Float_Polygon,None,PolygonMap_Float)
PolygonMap_Float.Value = new_instancemethod(_cmf.PolygonMap_Float_Value,None,PolygonMap_Float)
PolygonMap_Float_swigregister = _cmf.PolygonMap_Float_swigregister
PolygonMap_Float_swigregister(PolygonMap_Float)

class IMap_Int(object):
    """Proxy of C++ cmf::maps::IMap<(int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get(self, *args):
        """
        get(self, point p) -> int
        get(self, double x, double y) -> int
        """
        return _cmf.IMap_Int_get(self, *args)

    def has(self, *args):
        """
        has(self, double x, double y) -> bool
        has(self, point p) -> bool
        """
        return _cmf.IMap_Int_has(self, *args)

    def __call__(self, *args):
        """__call__(self, double x, double y) -> int"""
        return _cmf.IMap_Int___call__(self, *args)

    __swig_destroy__ = _cmf.delete_IMap_Int
IMap_Int.get = new_instancemethod(_cmf.IMap_Int_get,None,IMap_Int)
IMap_Int.has = new_instancemethod(_cmf.IMap_Int_has,None,IMap_Int)
IMap_Int.__call__ = new_instancemethod(_cmf.IMap_Int___call__,None,IMap_Int)
IMap_Int_swigregister = _cmf.IMap_Int_swigregister
IMap_Int_swigregister(IMap_Int)

class SingleValueMap_Int(IMap_Int):
    """Proxy of C++ cmf::maps::SingleValueMap<(int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, int value) -> SingleValueMap_Int"""
        _cmf.SingleValueMap_Int_swiginit(self,_cmf.new_SingleValueMap_Int(*args))
    __swig_destroy__ = _cmf.delete_SingleValueMap_Int
SingleValueMap_Int_swigregister = _cmf.SingleValueMap_Int_swigregister
SingleValueMap_Int_swigregister(SingleValueMap_Int)

class ContinuousRasterMap_Int(IMap_Int):
    """Proxy of C++ cmf::maps::ContinuousRasterMap<(int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, IntRaster raster) -> ContinuousRasterMap_Int
        __init__(self, string ASCFileName, int factor = 1, int nodata = -9999) -> ContinuousRasterMap_Int
        __init__(self, string ASCFileName, int factor = 1) -> ContinuousRasterMap_Int
        __init__(self, string ASCFileName) -> ContinuousRasterMap_Int
        """
        _cmf.ContinuousRasterMap_Int_swiginit(self,_cmf.new_ContinuousRasterMap_Int(*args))
    Raster = _swig_property(_cmf.ContinuousRasterMap_Int_Raster_get, _cmf.ContinuousRasterMap_Int_Raster_set)
    __swig_destroy__ = _cmf.delete_ContinuousRasterMap_Int
ContinuousRasterMap_Int_swigregister = _cmf.ContinuousRasterMap_Int_swigregister
ContinuousRasterMap_Int_swigregister(ContinuousRasterMap_Int)

class DiscreteRasterMap_Int(IMap_Int):
    """Proxy of C++ cmf::maps::DiscreteRasterMap<(int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Raster = _swig_property(_cmf.DiscreteRasterMap_Int_Raster_get, _cmf.DiscreteRasterMap_Int_Raster_set)
    def add(self, *args):
        """add(self, int index, int value)"""
        return _cmf.DiscreteRasterMap_Int_add(self, *args)

    def erase(self, *args):
        """erase(self, int index)"""
        return _cmf.DiscreteRasterMap_Int_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, IntRaster raster, int NoDataValue = int()) -> DiscreteRasterMap_Int
        __init__(self, IntRaster raster) -> DiscreteRasterMap_Int
        __init__(self, string RasterFileName, int NoDataValue = int()) -> DiscreteRasterMap_Int
        __init__(self, string RasterFileName) -> DiscreteRasterMap_Int
        """
        _cmf.DiscreteRasterMap_Int_swiginit(self,_cmf.new_DiscreteRasterMap_Int(*args))
    __swig_destroy__ = _cmf.delete_DiscreteRasterMap_Int
DiscreteRasterMap_Int.add = new_instancemethod(_cmf.DiscreteRasterMap_Int_add,None,DiscreteRasterMap_Int)
DiscreteRasterMap_Int.erase = new_instancemethod(_cmf.DiscreteRasterMap_Int_erase,None,DiscreteRasterMap_Int)
DiscreteRasterMap_Int_swigregister = _cmf.DiscreteRasterMap_Int_swigregister
DiscreteRasterMap_Int_swigregister(DiscreteRasterMap_Int)

class NearestNeighborMap_Int(IMap_Int):
    """Proxy of C++ cmf::maps::NearestNeighborMap<(int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, point p, int value)
        add(self, double x, double y, int value)
        """
        return _cmf.NearestNeighborMap_Int_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.NearestNeighborMap_Int_erase(self, *args)

    zWeight = _swig_property(_cmf.NearestNeighborMap_Int_zWeight_get, _cmf.NearestNeighborMap_Int_zWeight_set)
    def size(self):
        """size(self) -> int"""
        return _cmf.NearestNeighborMap_Int_size(self)

    def Position(self, *args):
        """Position(self, int index) -> point"""
        return _cmf.NearestNeighborMap_Int_Position(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> int"""
        return _cmf.NearestNeighborMap_Int_Value(self, *args)

    def __init__(self, z_Weight = 0): 
        """
        __init__(self, double z_Weight = 0) -> NearestNeighborMap_Int
        __init__(self) -> NearestNeighborMap_Int
        """
        _cmf.NearestNeighborMap_Int_swiginit(self,_cmf.new_NearestNeighborMap_Int(z_Weight))
    __swig_destroy__ = _cmf.delete_NearestNeighborMap_Int
NearestNeighborMap_Int.add = new_instancemethod(_cmf.NearestNeighborMap_Int_add,None,NearestNeighborMap_Int)
NearestNeighborMap_Int.erase = new_instancemethod(_cmf.NearestNeighborMap_Int_erase,None,NearestNeighborMap_Int)
NearestNeighborMap_Int.size = new_instancemethod(_cmf.NearestNeighborMap_Int_size,None,NearestNeighborMap_Int)
NearestNeighborMap_Int.Position = new_instancemethod(_cmf.NearestNeighborMap_Int_Position,None,NearestNeighborMap_Int)
NearestNeighborMap_Int.Value = new_instancemethod(_cmf.NearestNeighborMap_Int_Value,None,NearestNeighborMap_Int)
NearestNeighborMap_Int_swigregister = _cmf.NearestNeighborMap_Int_swigregister
NearestNeighborMap_Int_swigregister(NearestNeighborMap_Int)

class PolygonMap_Int(IMap_Int):
    """Proxy of C++ cmf::maps::PolygonMap<(int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, int nodata = int()) -> PolygonMap_Int
        __init__(self) -> PolygonMap_Int
        """
        _cmf.PolygonMap_Int_swiginit(self,_cmf.new_PolygonMap_Int(*args))
    def add(self, *args):
        """add(self, Ring polygon, int value)"""
        return _cmf.PolygonMap_Int_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.PolygonMap_Int_erase(self, *args)

    def size(self):
        """size(self) -> int"""
        return _cmf.PolygonMap_Int_size(self)

    def Polygon(self, *args):
        """Polygon(self, int index) -> Ring"""
        return _cmf.PolygonMap_Int_Polygon(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> int"""
        return _cmf.PolygonMap_Int_Value(self, *args)

    __swig_destroy__ = _cmf.delete_PolygonMap_Int
PolygonMap_Int.add = new_instancemethod(_cmf.PolygonMap_Int_add,None,PolygonMap_Int)
PolygonMap_Int.erase = new_instancemethod(_cmf.PolygonMap_Int_erase,None,PolygonMap_Int)
PolygonMap_Int.size = new_instancemethod(_cmf.PolygonMap_Int_size,None,PolygonMap_Int)
PolygonMap_Int.Polygon = new_instancemethod(_cmf.PolygonMap_Int_Polygon,None,PolygonMap_Int)
PolygonMap_Int.Value = new_instancemethod(_cmf.PolygonMap_Int_Value,None,PolygonMap_Int)
PolygonMap_Int_swigregister = _cmf.PolygonMap_Int_swigregister
PolygonMap_Int_swigregister(PolygonMap_Int)

class IMap_Py(object):
    """Proxy of C++ cmf::maps::IMap<(p.PyObject)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get(self, *args):
        """
        get(self, point p) -> PyObject
        get(self, double x, double y) -> PyObject
        """
        return _cmf.IMap_Py_get(self, *args)

    def has(self, *args):
        """
        has(self, double x, double y) -> bool
        has(self, point p) -> bool
        """
        return _cmf.IMap_Py_has(self, *args)

    def __call__(self, *args):
        """__call__(self, double x, double y) -> PyObject"""
        return _cmf.IMap_Py___call__(self, *args)

    __swig_destroy__ = _cmf.delete_IMap_Py
IMap_Py.get = new_instancemethod(_cmf.IMap_Py_get,None,IMap_Py)
IMap_Py.has = new_instancemethod(_cmf.IMap_Py_has,None,IMap_Py)
IMap_Py.__call__ = new_instancemethod(_cmf.IMap_Py___call__,None,IMap_Py)
IMap_Py_swigregister = _cmf.IMap_Py_swigregister
IMap_Py_swigregister(IMap_Py)

class SingleValueMap_Py(IMap_Py):
    """Proxy of C++ cmf::maps::SingleValueMap<(p.PyObject)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, PyObject value) -> SingleValueMap_Py"""
        _cmf.SingleValueMap_Py_swiginit(self,_cmf.new_SingleValueMap_Py(*args))
    __swig_destroy__ = _cmf.delete_SingleValueMap_Py
SingleValueMap_Py_swigregister = _cmf.SingleValueMap_Py_swigregister
SingleValueMap_Py_swigregister(SingleValueMap_Py)

class DiscreteRasterMap_Py(IMap_Py):
    """Proxy of C++ cmf::maps::DiscreteRasterMap<(p.PyObject)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Raster = _swig_property(_cmf.DiscreteRasterMap_Py_Raster_get, _cmf.DiscreteRasterMap_Py_Raster_set)
    def add(self, *args):
        """add(self, int index, PyObject value)"""
        return _cmf.DiscreteRasterMap_Py_add(self, *args)

    def erase(self, *args):
        """erase(self, int index)"""
        return _cmf.DiscreteRasterMap_Py_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, IntRaster raster, PyObject NoDataValue = PyObject *()) -> DiscreteRasterMap_Py
        __init__(self, IntRaster raster) -> DiscreteRasterMap_Py
        __init__(self, string RasterFileName, PyObject NoDataValue = PyObject *()) -> DiscreteRasterMap_Py
        __init__(self, string RasterFileName) -> DiscreteRasterMap_Py
        """
        _cmf.DiscreteRasterMap_Py_swiginit(self,_cmf.new_DiscreteRasterMap_Py(*args))
    __swig_destroy__ = _cmf.delete_DiscreteRasterMap_Py
DiscreteRasterMap_Py.add = new_instancemethod(_cmf.DiscreteRasterMap_Py_add,None,DiscreteRasterMap_Py)
DiscreteRasterMap_Py.erase = new_instancemethod(_cmf.DiscreteRasterMap_Py_erase,None,DiscreteRasterMap_Py)
DiscreteRasterMap_Py_swigregister = _cmf.DiscreteRasterMap_Py_swigregister
DiscreteRasterMap_Py_swigregister(DiscreteRasterMap_Py)

class NearestNeighborMap_Py(IMap_Py):
    """Proxy of C++ cmf::maps::NearestNeighborMap<(p.PyObject)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, point p, PyObject value)
        add(self, double x, double y, PyObject value)
        """
        return _cmf.NearestNeighborMap_Py_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.NearestNeighborMap_Py_erase(self, *args)

    zWeight = _swig_property(_cmf.NearestNeighborMap_Py_zWeight_get, _cmf.NearestNeighborMap_Py_zWeight_set)
    def size(self):
        """size(self) -> int"""
        return _cmf.NearestNeighborMap_Py_size(self)

    def Position(self, *args):
        """Position(self, int index) -> point"""
        return _cmf.NearestNeighborMap_Py_Position(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> PyObject"""
        return _cmf.NearestNeighborMap_Py_Value(self, *args)

    def __init__(self, z_Weight = 0): 
        """
        __init__(self, double z_Weight = 0) -> NearestNeighborMap_Py
        __init__(self) -> NearestNeighborMap_Py
        """
        _cmf.NearestNeighborMap_Py_swiginit(self,_cmf.new_NearestNeighborMap_Py(z_Weight))
    __swig_destroy__ = _cmf.delete_NearestNeighborMap_Py
NearestNeighborMap_Py.add = new_instancemethod(_cmf.NearestNeighborMap_Py_add,None,NearestNeighborMap_Py)
NearestNeighborMap_Py.erase = new_instancemethod(_cmf.NearestNeighborMap_Py_erase,None,NearestNeighborMap_Py)
NearestNeighborMap_Py.size = new_instancemethod(_cmf.NearestNeighborMap_Py_size,None,NearestNeighborMap_Py)
NearestNeighborMap_Py.Position = new_instancemethod(_cmf.NearestNeighborMap_Py_Position,None,NearestNeighborMap_Py)
NearestNeighborMap_Py.Value = new_instancemethod(_cmf.NearestNeighborMap_Py_Value,None,NearestNeighborMap_Py)
NearestNeighborMap_Py_swigregister = _cmf.NearestNeighborMap_Py_swigregister
NearestNeighborMap_Py_swigregister(NearestNeighborMap_Py)

class PolygonMap_Py(IMap_Py):
    """Proxy of C++ cmf::maps::PolygonMap<(p.PyObject)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, PyObject nodata = PyObject *()) -> PolygonMap_Py
        __init__(self) -> PolygonMap_Py
        """
        _cmf.PolygonMap_Py_swiginit(self,_cmf.new_PolygonMap_Py(*args))
    def add(self, *args):
        """add(self, Ring polygon, PyObject value)"""
        return _cmf.PolygonMap_Py_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.PolygonMap_Py_erase(self, *args)

    def size(self):
        """size(self) -> int"""
        return _cmf.PolygonMap_Py_size(self)

    def Polygon(self, *args):
        """Polygon(self, int index) -> Ring"""
        return _cmf.PolygonMap_Py_Polygon(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> PyObject"""
        return _cmf.PolygonMap_Py_Value(self, *args)

    __swig_destroy__ = _cmf.delete_PolygonMap_Py
PolygonMap_Py.add = new_instancemethod(_cmf.PolygonMap_Py_add,None,PolygonMap_Py)
PolygonMap_Py.erase = new_instancemethod(_cmf.PolygonMap_Py_erase,None,PolygonMap_Py)
PolygonMap_Py.size = new_instancemethod(_cmf.PolygonMap_Py_size,None,PolygonMap_Py)
PolygonMap_Py.Polygon = new_instancemethod(_cmf.PolygonMap_Py_Polygon,None,PolygonMap_Py)
PolygonMap_Py.Value = new_instancemethod(_cmf.PolygonMap_Py_Value,None,PolygonMap_Py)
PolygonMap_Py_swigregister = _cmf.PolygonMap_Py_swigregister
PolygonMap_Py_swigregister(PolygonMap_Py)

class Solute(object):
    """
    A structure to identify a solute.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, Solute copy) -> Solute

        Solute(const
        Solute &copy) 
        """
        _cmf.Solute_swiginit(self,_cmf.new_Solute(*args))
    Name = _swig_property(_cmf.Solute_Name_get, _cmf.Solute_Name_set)
    Unit = _swig_property(_cmf.Solute_Unit_get, _cmf.Solute_Unit_set)
    Uptake = _swig_property(_cmf.Solute_Uptake_get, _cmf.Solute_Uptake_set)
    Id = _swig_property(_cmf.Solute_Id_get)
    def create(*args):
        """
        create(string name, string unit = "", double uptake = 1) -> Solute
        create(string name, string unit = "") -> Solute
        create(string name) -> Solute
        """
        return _cmf.Solute_create(*args)

    create = staticmethod(create)
    __swig_destroy__ = _cmf.delete_Solute
Solute_swigregister = _cmf.Solute_swigregister
Solute_swigregister(Solute)

def Solute_create(*args):
  """
    create(string name, string unit = "", double uptake = 1) -> Solute
    create(string name, string unit = "") -> Solute
    Solute_create(string name) -> Solute
    """
  return _cmf.Solute_create(*args)

class Solutes(object):
    """
    Manages the solutes of the whole model. The static member All is the
    only instance. Before you are creating any cmf object (like
    UpslopeCell, Reach or IVegetation or Meteorology), make sure you have
    added all solutes you are interest in to Solutes::All Generally you
    are free to add any kind of Solute to the model, but each additional
    will slow down calculations remarkably, and if you intend to use one
    or more ExternalFunctionReaction special requirements apply.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, string name, string unit = "", double uptake = 1) -> Solute
        add(self, string name, string unit = "") -> Solute
        add(self, string name) -> Solute

        const Solute&
        add(const std::string &name, const std::string &unit="", double
        uptake=1)

        Creates a solute in Solute::All.

        Parameters:
        -----------

        name:  the name of the solute, e.g. 'Tracer', 'NO3'

        unit:  Used unit for amount of solute e.g. 'mol','mmol','g','mg' etc.

        uptake:  Fraction of the available concentration, that is taken up by
        vegetation 
        """
        return _cmf.Solutes_add(self, *args)

    def size(self):
        """
        size(self) -> size_t

        size_t size() 
        """
        return _cmf.Solutes_size(self)

    def SetInUse(self):
        """
        SetInUse(self)

        void SetInUse()

        If the Solutes of the model are marked as "InUse", no more solutes
        may be added. They get marked as "InUse" as soon as an object
        depending on the number of solutes is created (e.g. an UpslopeCell,
        Reach, IVegetation or Meteorology). 
        """
        return _cmf.Solutes_SetInUse(self)

    def all():
        """all() -> Solutes"""
        return _cmf.Solutes_all()

    all = staticmethod(all)
    def __getitem__(self, *args):
        """__getitem__(self, int i) -> Solute"""
        return _cmf.Solutes___getitem__(self, *args)

    __swig_destroy__ = _cmf.delete_Solutes
Solutes.add = new_instancemethod(_cmf.Solutes_add,None,Solutes)
Solutes.size = new_instancemethod(_cmf.Solutes_size,None,Solutes)
Solutes.SetInUse = new_instancemethod(_cmf.Solutes_SetInUse,None,Solutes)
Solutes.__getitem__ = new_instancemethod(_cmf.Solutes___getitem__,None,Solutes)
Solutes_swigregister = _cmf.Solutes_swigregister
Solutes_swigregister(Solutes)

def Solutes_all():
  """Solutes_all() -> Solutes"""
  return _cmf.Solutes_all()

class WaterQuality(object):
    """
    Map of concentrations for different solutes.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def size(self):
        """
        size(self) -> size_t

        size_t size()
        const

        Returns the number of solutes. 
        """
        return _cmf.WaterQuality_size(self)

    def tostring(self):
        """
        tostring(self) -> string

        std::string tostring() const 
        """
        return _cmf.WaterQuality_tostring(self)

    def clear(self):
        """
        clear(self)

        void clear()

        Clears the water. 
        """
        return _cmf.WaterQuality_clear(self)

    def __init__(self, *args): 
        """
        __init__(self) -> WaterQuality
        __init__(self, WaterQuality wq) -> WaterQuality

        WaterQuality(const cmf::water::WaterQuality &wq) 
        """
        _cmf.WaterQuality_swiginit(self,_cmf.new_WaterQuality(*args))
    def __getitem__(self, *args):
        """__getitem__(self, Solute solute) -> double"""
        return _cmf.WaterQuality___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, Solute solute, double concentration)"""
        return _cmf.WaterQuality___setitem__(self, *args)

    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf.WaterQuality___len__(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _cmf.WaterQuality___str__(self)

    __swig_destroy__ = _cmf.delete_WaterQuality
WaterQuality.size = new_instancemethod(_cmf.WaterQuality_size,None,WaterQuality)
WaterQuality.tostring = new_instancemethod(_cmf.WaterQuality_tostring,None,WaterQuality)
WaterQuality.clear = new_instancemethod(_cmf.WaterQuality_clear,None,WaterQuality)
WaterQuality.__getitem__ = new_instancemethod(_cmf.WaterQuality___getitem__,None,WaterQuality)
WaterQuality.__setitem__ = new_instancemethod(_cmf.WaterQuality___setitem__,None,WaterQuality)
WaterQuality.__len__ = new_instancemethod(_cmf.WaterQuality___len__,None,WaterQuality)
WaterQuality.__str__ = new_instancemethod(_cmf.WaterQuality___str__,None,WaterQuality)
WaterQuality_swigregister = _cmf.WaterQuality_swigregister
WaterQuality_swigregister(WaterQuality)

class SoluteTimeseries(object):
    """
    A map of concentration time series for solutes.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def conc(self, *args):
        """
        conc(self, Time t) -> WaterQuality

        WaterQuality conc(cmf::math::Time t) 
        """
        return _cmf.SoluteTimeseries_conc(self, *args)

    def size(self):
        """
        size(self) -> size_t

        size_t
        size() const

        Returns the number of solutes in the solution. 
        """
        return _cmf.SoluteTimeseries_size(self)

    def __init__(self, *args): 
        """
        __init__(self) -> SoluteTimeseries
        __init__(self, Time begin, Time step) -> SoluteTimeseries
        __init__(self, SoluteTimeseries sts) -> SoluteTimeseries

        SoluteTimeseries(const cmf::water::SoluteTimeseries &sts) 
        """
        _cmf.SoluteTimeseries_swiginit(self,_cmf.new_SoluteTimeseries(*args))
    def __getitem__(self, *args):
        """__getitem__(self, Solute solute) -> timeseries"""
        return _cmf.SoluteTimeseries___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, Solute solute, timeseries concentration)"""
        return _cmf.SoluteTimeseries___setitem__(self, *args)

    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf.SoluteTimeseries___len__(self)

    __swig_destroy__ = _cmf.delete_SoluteTimeseries
SoluteTimeseries.conc = new_instancemethod(_cmf.SoluteTimeseries_conc,None,SoluteTimeseries)
SoluteTimeseries.size = new_instancemethod(_cmf.SoluteTimeseries_size,None,SoluteTimeseries)
SoluteTimeseries.__getitem__ = new_instancemethod(_cmf.SoluteTimeseries___getitem__,None,SoluteTimeseries)
SoluteTimeseries.__setitem__ = new_instancemethod(_cmf.SoluteTimeseries___setitem__,None,SoluteTimeseries)
SoluteTimeseries.__len__ = new_instancemethod(_cmf.SoluteTimeseries___len__,None,SoluteTimeseries)
SoluteTimeseries_swigregister = _cmf.SoluteTimeseries_swigregister
SoluteTimeseries_swigregister(SoluteTimeseries)

class WaterFlux(object):
    """
    Water fluxes consist of the flux in $\\frac{m^3}{day}$ and a map of
    concentrations (ConcentrationMap).

    C++ includes: WaterFlux.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Update(self, *args):
        """
        Update(self, real waterflux, WaterStorage origin, bool uptake = False) -> WaterFlux
        Update(self, real waterflux, WaterStorage origin) -> WaterFlux

        WaterFlux&
        Update(real waterflux, const cmf::water::WaterStorage &origin, bool
        uptake=false) 
        """
        return _cmf.WaterFlux_Update(self, *args)

    c = _swig_property(_cmf.WaterFlux_c_get, _cmf.WaterFlux_c_set)
    q = _swig_property(_cmf.WaterFlux_q_get, _cmf.WaterFlux_q_set)
    def __init__(self, *args): 
        """
        __init__(self) -> WaterFlux
        __init__(self, WaterFlux forcopy) -> WaterFlux
        __init__(self, real flux) -> WaterFlux
        __init__(self, real flux, WaterStorage origin, bool uptake = False) -> WaterFlux
        __init__(self, real flux, WaterStorage origin) -> WaterFlux
        __init__(self, real flux, WaterQuality wq) -> WaterFlux

        WaterFlux(real flux, const cmf::water::WaterStorage &origin, bool
        uptake=false) 
        """
        _cmf.WaterFlux_swiginit(self,_cmf.new_WaterFlux(*args))
    def Add(self, *args):
        """
        Add(self, real flux, WaterStorage origin) -> WaterFlux
        Add(self, real flux, WaterQuality concentrations) -> WaterFlux

        WaterFlux&
        Add(real flux, const cmf::water::WaterQuality &concentrations)

        Adds water of a certain water quality to the flux (mixing) Both fluxes
        may be negative, but mixed signs will throw an error
        \\begin{eqnarray*} q&=& \\mbox{Flux in }\\frac{m^3}{day}
        \\\\ c&=& \\mbox{Vector of concentrations in }
        \\frac{mol}{m^3} \\\\
        c_{this}&=&\\frac{c_{this}q_{this}+c_{other}q_{other}}{q_{this}+q_{other}}
        \\\\ q_{this}&=&q_{this}+q_{other} \\\\ \\end{eqnarray*}. 
        """
        return _cmf.WaterFlux_Add(self, *args)

    def Abs(self):
        """
        Abs(self) -> WaterFlux

        WaterFlux& Abs()

        Changes the sign of the flux to positive. 
        """
        return _cmf.WaterFlux_Abs(self)

    def matterflux(self, *args):
        """
        matterflux(self, Solute solute) -> real

        real
        matterflux(const cmf::water::Solute &solute)

        Returns the water flux of the given solute in $\\frac{mol}{day}$,
        depending on the unit of the concentration (see cmf::water )
        \\begin{eqnarray*} Q_{Solute} &=&
        q_{H_2O}\\left[\\frac{m^3}{day}\\right] c_{Solute}
        \\left[\\frac{mol}{m^3}\\right] \\end{eqnarray*}. 
        """
        return _cmf.WaterFlux_matterflux(self, *args)

    def clear(self):
        """
        clear(self)

        void clear()

        Sets all concentrations and the flux to 0. 
        """
        return _cmf.WaterFlux_clear(self)

    def __iadd__(self, *args):
        """__iadd__(self, WaterFlux add) -> WaterFlux"""
        return _cmf.WaterFlux___iadd__(self, *args)

    def __imul__(self, *args):
        """__imul__(self, real factor) -> WaterFlux"""
        return _cmf.WaterFlux___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, real factor) -> WaterFlux"""
        return _cmf.WaterFlux___idiv__(self, *args)

    def __neg__(self):
        """__neg__(self) -> WaterFlux"""
        return _cmf.WaterFlux___neg__(self)

    def __call__(self, *args):
        """__call__(self, double waterflux, WaterStorage origin) -> WaterFlux"""
        return _cmf.WaterFlux___call__(self, *args)

    __swig_destroy__ = _cmf.delete_WaterFlux
WaterFlux.Update = new_instancemethod(_cmf.WaterFlux_Update,None,WaterFlux)
WaterFlux.Add = new_instancemethod(_cmf.WaterFlux_Add,None,WaterFlux)
WaterFlux.Abs = new_instancemethod(_cmf.WaterFlux_Abs,None,WaterFlux)
WaterFlux.matterflux = new_instancemethod(_cmf.WaterFlux_matterflux,None,WaterFlux)
WaterFlux.clear = new_instancemethod(_cmf.WaterFlux_clear,None,WaterFlux)
WaterFlux.__iadd__ = new_instancemethod(_cmf.WaterFlux___iadd__,None,WaterFlux)
WaterFlux.__imul__ = new_instancemethod(_cmf.WaterFlux___imul__,None,WaterFlux)
WaterFlux.__idiv__ = new_instancemethod(_cmf.WaterFlux___idiv__,None,WaterFlux)
WaterFlux.__neg__ = new_instancemethod(_cmf.WaterFlux___neg__,None,WaterFlux)
WaterFlux.__call__ = new_instancemethod(_cmf.WaterFlux___call__,None,WaterFlux)
WaterFlux_swigregister = _cmf.WaterFlux_swigregister
WaterFlux_swigregister(WaterFlux)

class SoluteStorage(StateVariable):
    """
    A class for the storage of any tracer. The state is the amount (mol,
    kg etc. see cmf::water) of the tracer in the storage
    \\begin{eqnarray*} \\frac{dX}{dt}&=&\\sum_{f=1}^{F}\\left( q_f
    [X]_f\\right) +
    \\sum_{r=1}^R\\left(f_r\\left([A],...,[Z]\\right)\\
    V\\right) \\left[\\frac{mol}{day}\\right]\\\\ F&=&
    \\mbox{Number of fluxes in water storage} \\\\ q_f&=&
    \\mbox{Water flux in } \\frac{m^3}{day} \\\\
    \\left[X\\right]_f &=& \\mbox{Concentration of solute X in flux
    }q_f \\mbox{ in } \\frac{mol}{m^3} \\\\ R&=& \\mbox{Number
    of reactions defined for this solute storage} \\\\
    f_r\\left([A],...,[Z]\\right)&=& \\mbox{Reactive flux of }[X]
    \\mbox{ in environment } [A],...,[Z] \\left[\\frac{mol}{m^3\\
    day}\\right] \\\\ V &=& \\mbox{Volume of water in water
    storage }\\left[m^3\\right] \\end{eqnarray*}.

    C++ includes: SoluteStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    AdditionalFlux = _swig_property(_cmf.SoluteStorage_AdditionalFlux_get, _cmf.SoluteStorage_AdditionalFlux_set)
    def __iadd__(self, *args):
        """__iadd__(self, real additionalRate) -> SoluteStorage"""
        return _cmf.SoluteStorage___iadd__(self, *args)

    Storage = _swig_property(_cmf.SoluteStorage_Storage_get)
    Solute = _swig_property(_cmf.SoluteStorage_Solute_get)
    def conc(self):
        """
        conc(self) -> real

        real conc()
        const

        Returns the concentration of the solute. 
        """
        return _cmf.SoluteStorage_conc(self)

    __swig_destroy__ = _cmf.delete_SoluteStorage
SoluteStorage.__iadd__ = new_instancemethod(_cmf.SoluteStorage___iadd__,None,SoluteStorage)
SoluteStorage.conc = new_instancemethod(_cmf.SoluteStorage_conc,None,SoluteStorage)
SoluteStorage_swigregister = _cmf.SoluteStorage_swigregister
SoluteStorage_swigregister(SoluteStorage)

class connection_vector(object):
    """Proxy of C++ std::vector<(p.cmf::water::FluxConnection)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.connection_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.connection_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.connection_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.connection_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.connection_vector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> connection_vector"""
        return _cmf.connection_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, connection_vector v)"""
        return _cmf.connection_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.connection_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.connection_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> connection_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.connection_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, connection_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.connection_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.connection_vector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.connection_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.connection_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.connection_vector_clear(self)

    def swap(self, *args):
        """swap(self, connection_vector v)"""
        return _cmf.connection_vector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.connection_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.connection_vector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.connection_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.connection_vector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.connection_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.connection_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.connection_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> connection_vector
        __init__(self, connection_vector arg0) -> connection_vector
        __init__(self, size_type size) -> connection_vector
        __init__(self, size_type size, value_type value) -> connection_vector
        """
        _cmf.connection_vector_swiginit(self,_cmf.new_connection_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.connection_vector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.connection_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.connection_vector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.connection_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.connection_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.connection_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.connection_vector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.connection_vector_capacity(self)

    __swig_destroy__ = _cmf.delete_connection_vector
connection_vector.iterator = new_instancemethod(_cmf.connection_vector_iterator,None,connection_vector)
connection_vector.__nonzero__ = new_instancemethod(_cmf.connection_vector___nonzero__,None,connection_vector)
connection_vector.__bool__ = new_instancemethod(_cmf.connection_vector___bool__,None,connection_vector)
connection_vector.__len__ = new_instancemethod(_cmf.connection_vector___len__,None,connection_vector)
connection_vector.pop = new_instancemethod(_cmf.connection_vector_pop,None,connection_vector)
connection_vector.__getslice__ = new_instancemethod(_cmf.connection_vector___getslice__,None,connection_vector)
connection_vector.__setslice__ = new_instancemethod(_cmf.connection_vector___setslice__,None,connection_vector)
connection_vector.__delslice__ = new_instancemethod(_cmf.connection_vector___delslice__,None,connection_vector)
connection_vector.__delitem__ = new_instancemethod(_cmf.connection_vector___delitem__,None,connection_vector)
connection_vector.__getitem__ = new_instancemethod(_cmf.connection_vector___getitem__,None,connection_vector)
connection_vector.__setitem__ = new_instancemethod(_cmf.connection_vector___setitem__,None,connection_vector)
connection_vector.append = new_instancemethod(_cmf.connection_vector_append,None,connection_vector)
connection_vector.empty = new_instancemethod(_cmf.connection_vector_empty,None,connection_vector)
connection_vector.size = new_instancemethod(_cmf.connection_vector_size,None,connection_vector)
connection_vector.clear = new_instancemethod(_cmf.connection_vector_clear,None,connection_vector)
connection_vector.swap = new_instancemethod(_cmf.connection_vector_swap,None,connection_vector)
connection_vector.get_allocator = new_instancemethod(_cmf.connection_vector_get_allocator,None,connection_vector)
connection_vector.begin = new_instancemethod(_cmf.connection_vector_begin,None,connection_vector)
connection_vector.end = new_instancemethod(_cmf.connection_vector_end,None,connection_vector)
connection_vector.rbegin = new_instancemethod(_cmf.connection_vector_rbegin,None,connection_vector)
connection_vector.rend = new_instancemethod(_cmf.connection_vector_rend,None,connection_vector)
connection_vector.pop_back = new_instancemethod(_cmf.connection_vector_pop_back,None,connection_vector)
connection_vector.erase = new_instancemethod(_cmf.connection_vector_erase,None,connection_vector)
connection_vector.push_back = new_instancemethod(_cmf.connection_vector_push_back,None,connection_vector)
connection_vector.front = new_instancemethod(_cmf.connection_vector_front,None,connection_vector)
connection_vector.back = new_instancemethod(_cmf.connection_vector_back,None,connection_vector)
connection_vector.assign = new_instancemethod(_cmf.connection_vector_assign,None,connection_vector)
connection_vector.resize = new_instancemethod(_cmf.connection_vector_resize,None,connection_vector)
connection_vector.insert = new_instancemethod(_cmf.connection_vector_insert,None,connection_vector)
connection_vector.reserve = new_instancemethod(_cmf.connection_vector_reserve,None,connection_vector)
connection_vector.capacity = new_instancemethod(_cmf.connection_vector_capacity,None,connection_vector)
connection_vector_swigregister = _cmf.connection_vector_swigregister
connection_vector_swigregister(connection_vector)

class connection_set(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.connection_set_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.connection_set___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.connection_set___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.connection_set___len__(self)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.connection_set_append(self, *args)

    def __contains__(self, *args):
        """__contains__(self, value_type x) -> bool"""
        return _cmf.connection_set___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _cmf.connection_set___getitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(p.cmf::water::FluxConnection)> arg0) -> connection_set
        __init__(self) -> connection_set
        __init__(self, connection_set arg0) -> connection_set
        """
        _cmf.connection_set_swiginit(self,_cmf.new_connection_set(*args))
    def empty(self):
        """empty(self) -> bool"""
        return _cmf.connection_set_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.connection_set_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.connection_set_clear(self)

    def swap(self, *args):
        """swap(self, connection_set v)"""
        return _cmf.connection_set_swap(self, *args)

    def count(self, *args):
        """count(self, key_type x) -> size_type"""
        return _cmf.connection_set_count(self, *args)

    def begin(self):
        """begin(self) -> iterator"""
        return _cmf.connection_set_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _cmf.connection_set_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _cmf.connection_set_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _cmf.connection_set_rend(self)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator pos)
        erase(self, iterator first, iterator last)
        """
        return _cmf.connection_set_erase(self, *args)

    def find(self, *args):
        """find(self, key_type x) -> iterator"""
        return _cmf.connection_set_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(self, key_type x) -> iterator"""
        return _cmf.connection_set_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(self, key_type x) -> iterator"""
        return _cmf.connection_set_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(self, key_type x) -> std::pair<(std::set<(p.cmf::water::FluxConnection)>::iterator,std::set<(p.cmf::water::FluxConnection)>::iterator)>"""
        return _cmf.connection_set_equal_range(self, *args)

    def insert(self, *args):
        """insert(self, value_type __x) -> std::pair<(std::set<(p.cmf::water::FluxConnection)>::iterator,bool)>"""
        return _cmf.connection_set_insert(self, *args)

    __swig_destroy__ = _cmf.delete_connection_set
connection_set.iterator = new_instancemethod(_cmf.connection_set_iterator,None,connection_set)
connection_set.__nonzero__ = new_instancemethod(_cmf.connection_set___nonzero__,None,connection_set)
connection_set.__bool__ = new_instancemethod(_cmf.connection_set___bool__,None,connection_set)
connection_set.__len__ = new_instancemethod(_cmf.connection_set___len__,None,connection_set)
connection_set.append = new_instancemethod(_cmf.connection_set_append,None,connection_set)
connection_set.__contains__ = new_instancemethod(_cmf.connection_set___contains__,None,connection_set)
connection_set.__getitem__ = new_instancemethod(_cmf.connection_set___getitem__,None,connection_set)
connection_set.empty = new_instancemethod(_cmf.connection_set_empty,None,connection_set)
connection_set.size = new_instancemethod(_cmf.connection_set_size,None,connection_set)
connection_set.clear = new_instancemethod(_cmf.connection_set_clear,None,connection_set)
connection_set.swap = new_instancemethod(_cmf.connection_set_swap,None,connection_set)
connection_set.count = new_instancemethod(_cmf.connection_set_count,None,connection_set)
connection_set.begin = new_instancemethod(_cmf.connection_set_begin,None,connection_set)
connection_set.end = new_instancemethod(_cmf.connection_set_end,None,connection_set)
connection_set.rbegin = new_instancemethod(_cmf.connection_set_rbegin,None,connection_set)
connection_set.rend = new_instancemethod(_cmf.connection_set_rend,None,connection_set)
connection_set.erase = new_instancemethod(_cmf.connection_set_erase,None,connection_set)
connection_set.find = new_instancemethod(_cmf.connection_set_find,None,connection_set)
connection_set.lower_bound = new_instancemethod(_cmf.connection_set_lower_bound,None,connection_set)
connection_set.upper_bound = new_instancemethod(_cmf.connection_set_upper_bound,None,connection_set)
connection_set.equal_range = new_instancemethod(_cmf.connection_set_equal_range,None,connection_set)
connection_set.insert = new_instancemethod(_cmf.connection_set_insert,None,connection_set)
connection_set_swigregister = _cmf.connection_set_swigregister
connection_set_swigregister(connection_set)

class node_vector(object):
    """Proxy of C++ std::vector<(p.cmf::water::FluxNode)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.node_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.node_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.node_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.node_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.node_vector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> node_vector"""
        return _cmf.node_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, node_vector v)"""
        return _cmf.node_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.node_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.node_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> node_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.node_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, node_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.node_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.node_vector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.node_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.node_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.node_vector_clear(self)

    def swap(self, *args):
        """swap(self, node_vector v)"""
        return _cmf.node_vector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.node_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.node_vector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.node_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.node_vector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.node_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.node_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.node_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> node_vector
        __init__(self, node_vector arg0) -> node_vector
        __init__(self, size_type size) -> node_vector
        __init__(self, size_type size, value_type value) -> node_vector
        """
        _cmf.node_vector_swiginit(self,_cmf.new_node_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.node_vector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.node_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.node_vector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.node_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.node_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.node_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.node_vector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.node_vector_capacity(self)

    __swig_destroy__ = _cmf.delete_node_vector
node_vector.iterator = new_instancemethod(_cmf.node_vector_iterator,None,node_vector)
node_vector.__nonzero__ = new_instancemethod(_cmf.node_vector___nonzero__,None,node_vector)
node_vector.__bool__ = new_instancemethod(_cmf.node_vector___bool__,None,node_vector)
node_vector.__len__ = new_instancemethod(_cmf.node_vector___len__,None,node_vector)
node_vector.pop = new_instancemethod(_cmf.node_vector_pop,None,node_vector)
node_vector.__getslice__ = new_instancemethod(_cmf.node_vector___getslice__,None,node_vector)
node_vector.__setslice__ = new_instancemethod(_cmf.node_vector___setslice__,None,node_vector)
node_vector.__delslice__ = new_instancemethod(_cmf.node_vector___delslice__,None,node_vector)
node_vector.__delitem__ = new_instancemethod(_cmf.node_vector___delitem__,None,node_vector)
node_vector.__getitem__ = new_instancemethod(_cmf.node_vector___getitem__,None,node_vector)
node_vector.__setitem__ = new_instancemethod(_cmf.node_vector___setitem__,None,node_vector)
node_vector.append = new_instancemethod(_cmf.node_vector_append,None,node_vector)
node_vector.empty = new_instancemethod(_cmf.node_vector_empty,None,node_vector)
node_vector.size = new_instancemethod(_cmf.node_vector_size,None,node_vector)
node_vector.clear = new_instancemethod(_cmf.node_vector_clear,None,node_vector)
node_vector.swap = new_instancemethod(_cmf.node_vector_swap,None,node_vector)
node_vector.get_allocator = new_instancemethod(_cmf.node_vector_get_allocator,None,node_vector)
node_vector.begin = new_instancemethod(_cmf.node_vector_begin,None,node_vector)
node_vector.end = new_instancemethod(_cmf.node_vector_end,None,node_vector)
node_vector.rbegin = new_instancemethod(_cmf.node_vector_rbegin,None,node_vector)
node_vector.rend = new_instancemethod(_cmf.node_vector_rend,None,node_vector)
node_vector.pop_back = new_instancemethod(_cmf.node_vector_pop_back,None,node_vector)
node_vector.erase = new_instancemethod(_cmf.node_vector_erase,None,node_vector)
node_vector.push_back = new_instancemethod(_cmf.node_vector_push_back,None,node_vector)
node_vector.front = new_instancemethod(_cmf.node_vector_front,None,node_vector)
node_vector.back = new_instancemethod(_cmf.node_vector_back,None,node_vector)
node_vector.assign = new_instancemethod(_cmf.node_vector_assign,None,node_vector)
node_vector.resize = new_instancemethod(_cmf.node_vector_resize,None,node_vector)
node_vector.insert = new_instancemethod(_cmf.node_vector_insert,None,node_vector)
node_vector.reserve = new_instancemethod(_cmf.node_vector_reserve,None,node_vector)
node_vector.capacity = new_instancemethod(_cmf.node_vector_capacity,None,node_vector)
node_vector_swigregister = _cmf.node_vector_swigregister
node_vector_swigregister(node_vector)

class FluxNode(object):
    """
    Base class for everything that can be connected by fluxes. Flux nodes
    can be WaterStorages, flux end points, sinks, sources and bridges to
    other model domains (e.g. Ponded water to river system). The base
    class can be used where a simple routing, potentially with mixing, is
    needed.

    C++ includes: FluxConnection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def project(self):
        """project(self) -> project"""
        return _cmf.FluxNode_project(self)

    node_id = _swig_property(_cmf.FluxNode_node_id_get)
    def IsStorage(self):
        """IsStorage(self) -> bool"""
        return _cmf.FluxNode_IsStorage(self)

    Name = _swig_property(_cmf.FluxNode_Name_get, _cmf.FluxNode_Name_set)
    def Connections(self):
        """Connections(self) -> connection_vector"""
        return _cmf.FluxNode_Connections(self)

    __swig_destroy__ = _cmf.delete_FluxNode
    def __eq__(self, *args):
        """__eq__(self, FluxNode other) -> bool"""
        return _cmf.FluxNode___eq__(self, *args)

    def RecalcFluxes(self, *args):
        """
        RecalcFluxes(self, Time t) -> bool

        virtual
        bool RecalcFluxes(cmf::math::Time t)

        Pure FluxNodes do not influence fluxes, therefore no recalculation of
        fluxes is required by fluxnode. WaterStorage overrides this, since
        state changes require an update of the fluxes. 
        """
        return _cmf.FluxNode_RecalcFluxes(self, *args)

    def Connection(self, *args):
        """Connection(self, FluxNode target) -> FluxConnection"""
        return _cmf.FluxNode_Connection(self, *args)

    def RemoveConnection(self, *args):
        """RemoveConnection(self, FluxNode To)"""
        return _cmf.FluxNode_RemoveConnection(self, *args)

    def FluxTo(self, *args):
        """
        FluxTo(self, FluxNode target, Time t) -> real

        real
        FluxTo(const FluxNode &target, cmf::math::Time t)

        Returns the actual flux between this and target (positive sign means
        "from target into this"). 
        """
        return _cmf.FluxNode_FluxTo(self, *args)

    def Waterbalance(self, *args):
        """
        Waterbalance(self, Time t, FluxConnection Without = None) -> real
        Waterbalance(self, Time t) -> real

        real
        Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

        Returns the sum of all fluxes (positive and negative) at time t.
        Single fluxes can be excluded from the calculation.

        Parameters:
        -----------

        t:  Time of the query

        except:  A FluxConnection that is excluded from the Waterbalance (e.g.
        to prevent closed circuits) 
        """
        return _cmf.FluxNode_Waterbalance(self, *args)

    def conc(self, *args):
        """
        conc(self, Time t) -> WaterQuality

        virtual
        cmf::water::WaterQuality conc(cmf::math::Time t)

        Returns the water quality of the FluxNode, if it is not overridden
        this is the mix of the incoming fluxes. 
        """
        return _cmf.FluxNode_conc(self, *args)

    Location = _swig_property(_cmf.FluxNode_Location_get, _cmf.FluxNode_Location_set)
    def Potential(self):
        """
        Potential(self) -> real

        virtual real
        Potential()

        Returns the water potential of the node in m waterhead The base class
        water storage always returns the height of the location. 
        """
        return _cmf.FluxNode_Potential(self)

    def Empty(self):
        """
        Empty(self) -> bool

        virtual bool
        Empty() 
        """
        return _cmf.FluxNode_Empty(self)

    def __init__(self, *args): 
        """
        __init__(self, project _project, point location = cmf::geometry::point()) -> FluxNode
        __init__(self, project _project) -> FluxNode
        """
        _cmf.FluxNode_swiginit(self,_cmf.new_FluxNode(*args))
    def copy(self):
        """
        copy(self) -> FluxNode

        virtual FluxNode*
        copy() const 
        """
        return _cmf.FluxNode_copy(self)

    def __str__(self):
        return self.Name
    def fluxes(self,t):
        for con in self.Connections():
            yield (con.q(self,t),con.Target(self))
    def connections(self):
        for con in self.Connections():
            yield con.Target(self)

    def AsStorage(self):
        """AsStorage(self) -> WaterStorage"""
        return _cmf.FluxNode_AsStorage(self)

FluxNode.project = new_instancemethod(_cmf.FluxNode_project,None,FluxNode)
FluxNode.IsStorage = new_instancemethod(_cmf.FluxNode_IsStorage,None,FluxNode)
FluxNode.Connections = new_instancemethod(_cmf.FluxNode_Connections,None,FluxNode)
FluxNode.__eq__ = new_instancemethod(_cmf.FluxNode___eq__,None,FluxNode)
FluxNode.RecalcFluxes = new_instancemethod(_cmf.FluxNode_RecalcFluxes,None,FluxNode)
FluxNode.Connection = new_instancemethod(_cmf.FluxNode_Connection,None,FluxNode)
FluxNode.RemoveConnection = new_instancemethod(_cmf.FluxNode_RemoveConnection,None,FluxNode)
FluxNode.FluxTo = new_instancemethod(_cmf.FluxNode_FluxTo,None,FluxNode)
FluxNode.Waterbalance = new_instancemethod(_cmf.FluxNode_Waterbalance,None,FluxNode)
FluxNode.conc = new_instancemethod(_cmf.FluxNode_conc,None,FluxNode)
FluxNode.Potential = new_instancemethod(_cmf.FluxNode_Potential,None,FluxNode)
FluxNode.Empty = new_instancemethod(_cmf.FluxNode_Empty,None,FluxNode)
FluxNode.copy = new_instancemethod(_cmf.FluxNode_copy,None,FluxNode)
FluxNode.AsStorage = new_instancemethod(_cmf.FluxNode_AsStorage,None,FluxNode)
FluxNode_swigregister = _cmf.FluxNode_swigregister
FluxNode_swigregister(FluxNode)


def replace_node(*args):
  """replace_node(FluxNode oldnode, FluxNode newnode)"""
  return _cmf.replace_node(*args)
class FluxConnection(object):
    """
    Represents a connection between FluxNodes, where water fluxes occur.

    C++ includes: FluxConnection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    connection_id = _swig_property(_cmf.FluxConnection_connection_id_get)
    def __eq__(self, *args):
        """__eq__(self, FluxConnection other) -> bool"""
        return _cmf.FluxConnection___eq__(self, *args)

    def ExchangeTarget(self, *args):
        """ExchangeTarget(self, FluxNode oldtarget, FluxNode newTarget)"""
        return _cmf.FluxConnection_ExchangeTarget(self, *args)

    def Target(self, *args):
        """
        Target(self, FluxNode inquirer) -> FluxNode
        Target(self, int index) -> FluxNode
        Target(self, FluxNode inquirer) -> FluxNode

        const
        FluxNode& Target(const FluxNode &inquirer) const

        Returns the other end of a connection than the asking end (const). 
        """
        return _cmf.FluxConnection_Target(self, *args)

    def q(self, *args):
        """
        q(self, FluxNode inquirer, Time t) -> real

        real q(const
        FluxNode &inquirer, cmf::math::Time t)

        Returns the current flux through a connection. Negative signs mean out
        of the inquirer, positive are inflows to the inquirer. 
        """
        return _cmf.FluxConnection_q(self, *args)

    def conc(self, *args):
        """
        conc(self, FluxNode inquirer, Time t) -> WaterQuality

        WaterQuality
        conc(const FluxNode &inquirer, cmf::math::Time t)

        Returns the concentration of the flux. If not overridden, it returns
        the concentration of the source of the flux (direction depending). 
        """
        return _cmf.FluxConnection_conc(self, *args)

    type = _swig_property(_cmf.FluxConnection_type_get)
    def ToString(self):
        """ToString(self) -> string"""
        return _cmf.FluxConnection_ToString(self)

    __swig_destroy__ = _cmf.delete_FluxConnection
    def __str__(self):
        return self.ToString()
    def __getitem__(self,index):
        return self.Target(index)
    def __iter__(self):
        yield self.Target(0)
        yield self.Target(1)
    def __contains__(self,cmp):
        return cmp==self[0] or cmp==self[1]

FluxConnection.__eq__ = new_instancemethod(_cmf.FluxConnection___eq__,None,FluxConnection)
FluxConnection.ExchangeTarget = new_instancemethod(_cmf.FluxConnection_ExchangeTarget,None,FluxConnection)
FluxConnection.Target = new_instancemethod(_cmf.FluxConnection_Target,None,FluxConnection)
FluxConnection.q = new_instancemethod(_cmf.FluxConnection_q,None,FluxConnection)
FluxConnection.conc = new_instancemethod(_cmf.FluxConnection_conc,None,FluxConnection)
FluxConnection.ToString = new_instancemethod(_cmf.FluxConnection_ToString,None,FluxConnection)
FluxConnection_swigregister = _cmf.FluxConnection_swigregister
FluxConnection_swigregister(FluxConnection)

class WaterStorage(StateVariable,StateVariableOwner,FluxNode):
    """
    A state variable for the storage of water A class for the storage of
    any tracer. The state is the amount (mol, kg etc. see cmf::water) of
    the tracer in the storage \\begin{eqnarray*}
    \\frac{dV}{dt}&=&\\sum_{f=1}^{F} q_f \\\\ F&=& \\mbox{Number
    of fluxes in water storage} \\\\ q_f&=& \\mbox{Water flux in }
    \\frac{m^3}{day} \\\\ \\end{eqnarray*} The vector fluxes is
    used used by concentration to get the amount of water mixing.

    C++ includes: WaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, project _project, double InitialState = 0) -> WaterStorage
        __init__(self, project _project) -> WaterStorage
        __init__(self, WaterStorage forcopy) -> WaterStorage

        WaterStorage(const WaterStorage &forcopy) 
        """
        _cmf.WaterStorage_swiginit(self,_cmf.new_WaterStorage(*args))
    def FromNode(*args):
        """FromNode(FluxNode node) -> WaterStorage"""
        return _cmf.WaterStorage_FromNode(*args)

    FromNode = staticmethod(FromNode)
    def Solute(self, *args):
        """
        Solute(self, Solute solute) -> SoluteStorage
        Solute(self, Solute solute) -> SoluteStorage

        const
        SoluteStorage& Solute(const cmf::water::Solute &solute) const 
        """
        return _cmf.WaterStorage_Solute(self, *args)

    def conc(self, *args):
        """
        conc(self, Solute solute) -> real
        conc(self, Time t) -> WaterQuality
        conc(self, Solute solute, real NewConcetration)

        void
        conc(const cmf::water::Solute &solute, real NewConcetration)

        Sets a new concentration. 
        """
        return _cmf.WaterStorage_conc(self, *args)

    def water(self, *args):
        """
        water(self) -> real
        water(self, real newwatercontent)

        void
        water(real newwatercontent)

        Sets the volume of water in this storage in m3. 
        """
        return _cmf.WaterStorage_water(self, *args)

    def ToString(self):
        """
        ToString(self) -> string

        virtual
        std::string ToString() const 
        """
        return _cmf.WaterStorage_ToString(self)

    def copy(self):
        """
        copy(self) -> WaterStorage

        virtual
        WaterStorage* copy() const 
        """
        return _cmf.WaterStorage_copy(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _cmf.WaterStorage___str__(self)

    __swig_destroy__ = _cmf.delete_WaterStorage
WaterStorage.Solute = new_instancemethod(_cmf.WaterStorage_Solute,None,WaterStorage)
WaterStorage.conc = new_instancemethod(_cmf.WaterStorage_conc,None,WaterStorage)
WaterStorage.water = new_instancemethod(_cmf.WaterStorage_water,None,WaterStorage)
WaterStorage.ToString = new_instancemethod(_cmf.WaterStorage_ToString,None,WaterStorage)
WaterStorage.copy = new_instancemethod(_cmf.WaterStorage_copy,None,WaterStorage)
WaterStorage.__str__ = new_instancemethod(_cmf.WaterStorage___str__,None,WaterStorage)
WaterStorage_swigregister = _cmf.WaterStorage_swigregister
WaterStorage_swigregister(WaterStorage)

def WaterStorage_FromNode(*args):
  """WaterStorage_FromNode(FluxNode node) -> WaterStorage"""
  return _cmf.WaterStorage_FromNode(*args)


def vapour_pressure(*args):
  """vapour_pressure(double T) -> double"""
  return _cmf.vapour_pressure(*args)

def Pressure(*args):
  """Pressure(double height) -> double"""
  return _cmf.Pressure(*args)
class Weather(object):
    """
    A structure to return all parts of the incoming radiation, all values
    in $\\frac{MJ}{m^2 day}$.

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    T = _swig_property(_cmf.Weather_T_get, _cmf.Weather_T_set)
    Tmax = _swig_property(_cmf.Weather_Tmax_get, _cmf.Weather_Tmax_set)
    Tmin = _swig_property(_cmf.Weather_Tmin_get, _cmf.Weather_Tmin_set)
    Tground = _swig_property(_cmf.Weather_Tground_get, _cmf.Weather_Tground_set)
    Prec = _swig_property(_cmf.Weather_Prec_get, _cmf.Weather_Prec_set)
    Windspeed = _swig_property(_cmf.Weather_Windspeed_get, _cmf.Weather_Windspeed_set)
    e_a = _swig_property(_cmf.Weather_e_a_get, _cmf.Weather_e_a_set)
    e_s = _swig_property(_cmf.Weather_e_s_get, _cmf.Weather_e_s_set)
    sunshine = _swig_property(_cmf.Weather_sunshine_get, _cmf.Weather_sunshine_set)
    Rs = _swig_property(_cmf.Weather_Rs_get, _cmf.Weather_Rs_set)
    def Rn(self, *args):
        """
        Rn(self, double albedo, bool daily = False) -> double
        Rn(self, double albedo) -> double

        double Rn(double
        albedo, bool daily=false)

        Calculates the net radiation flux $R_n \\left[\\frac{MJ}{m^2
        day}\\right]$.

        \\begin{eqnarray*} R_{n} &=& R_{ns} - R_{nl} \\\\ \\mbox{ Net
        short wave radiation: }R_{ns} &=& (1-\\alpha) R_s \\\\ \\mbox{
        Net long wave radiation: }R_{nl} &=& R_{black}\\ \\beta_{v}\\
        \\beta_{c} \\\\ \\mbox{Black body radiation: } R_{black} &=&
        \\left\\{\\begin{array}{cl} \\sigma T^4 & \\mbox{for less
        than daily time steps} \\\\ \\sigma \\frac {T_{max}^4 +
        T_{min}^4} 2 & \\mbox{for daily time steps} \\end{array}
        \\right. \\\\ T &=& \\mbox{Temperature }[K] \\\\ \\sigma
        &=& 4.903\\ 10^{-9} \\frac{MJ}{K^4 m^2 day} \\mbox{ Stefan-
        Boltzmann constant } \\\\ \\mbox{Long wave reflectance: }
        \\\\ \\mbox{by water vapor: }\\beta_{v} &=& 0.34 - 0.14
        \\sqrt{e_a} \\\\ \\mbox{ by clouds: }\\beta_{c} &=& 0.1 +
        0.9 \\frac n N \\end{eqnarray*}

        Parameters:
        -----------

        albedo:  the albedo $\\alpha$ of the surface

        daily:  If true, the net radiation for daily averages will be
        calculated 
        """
        return _cmf.Weather_Rn(self, *args)

    def __init__(self): 
        """__init__(self) -> Weather"""
        _cmf.Weather_swiginit(self,_cmf.new_Weather())
    def ToString(self):
        """ToString(self) -> string"""
        return _cmf.Weather_ToString(self)

    __swig_destroy__ = _cmf.delete_Weather
Weather.Rn = new_instancemethod(_cmf.Weather_Rn,None,Weather)
Weather.ToString = new_instancemethod(_cmf.Weather_ToString,None,Weather)
Weather_swigregister = _cmf.Weather_swigregister
Weather_swigregister(Weather)

def AsWaterStorage(*args):
  """
    AsWaterStorage(StateVariable state) -> WaterStorage
    AsWaterStorage(FluxNode node) -> WaterStorage
    """
  return _cmf.AsWaterStorage(*args)

def global_radiation(*args):
  """
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8, 
        double latitude = 51, int time_zone = 1, 
        bool daily = 0) -> double
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8, 
        double latitude = 51, int time_zone = 1) -> double
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8, 
        double latitude = 51) -> double
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8) -> double
    global_radiation(Time t, double height, double sunshine_fraction) -> double
    """
  return _cmf.global_radiation(*args)

class Meteorology(object):
    """
    In order to calculate ETpot with cmf a big amount of meteorological
    data is needed, more data than usually available. The Meteorology
    class can estimate missing data from a minimal set. As more data, as
    one provides, the better the calculation of ETpot becomes. The minimal
    data needed is Tmin and Tmax (daily) and precipitation. To calculate
    the global radiation (although measured global radiation could be
    inserted), the position of meteorological station in geographic
    coordinates has to be set.

    There are two modes for the meteorology: daily=true and daily=false.
    If daily=true, Radiation is given as a daily mean value. If
    daily=false, Radiation is given as an hourly mean value, which shows
    the dial ETpot variation but results in erronous results if the
    timestep is daily.

    In the following, we will assume a meteorological station with given
    Tmin, Tmax, precipitation and daily mean relative humidity. To use
    other meteorological data, please consult the description of the
    Meteorology class in the API documentationCreating a meteorological
    station

    import CMFlib as cmf                  latitude=51.2 # Latitude of
    station in decimal degrees                  longitude=8.1 # Longitude
    of station in decimal degrees (only needed for daily=false) timezone=1
    # Timezone, pos. values mean east of GMT, negative west (Germany=1,
    Pacific time=-8, only needed for daily=false) start=cmf.Time(1,1,2001)
    # Creates all timeseries with this start time, one can change them
    later                  step=cmf.day # s. start
    name="Giessen"           # A name for the station (optional)
    meteo=cmf.Meteorology(latitude,longitude,timezone,start,step,name)

    The daily flag is automatically set to true, since the step width is
    &ge cmf.dayLoading data into the meteorological station

    # MeteoData.txt is tab seperated file containing # Tmin [deg C],Tmax
    [deg C],rHmean [%] and precipitation [mm/day] values for every day
    f=file('MeteoData.txt') for line in file:
    meteo.Tmin.Add(float(line.split('\\t')[0]))
    meteo.Tmax.Add(float(line.split('\\t')[1]))
    meteo.rHmean.Add(float(line.split('\\t')[2]))
    meteo.Prec.Add(float(line.split('\\t')[3]))Using a meteorological
    station

    weather=meteo.GetData(cmf.Time(3,2,2001,14)) # Weather at Feb. 3rd,
    2001, 2pm                  print 'Global Radiation: ',weather.Rs
    # Daily mean Rs, since daily=true print 'Temperature:',weather.T
    # Daily mean T, since nothing else in known

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def GetData(self, *args):
        """
        GetData(self, Time t, double x, double y, double z) -> Weather

        Weather
        GetData(cmf::math::Time t, double height) const

        Returns the current Atmosphere state. Uses default values for missing
        timeseries. 
        """
        return _cmf.Meteorology_GetData(self, *args)

    SnowThresholdTemperature = _swig_property(_cmf.Meteorology_SnowThresholdTemperature_get, _cmf.Meteorology_SnowThresholdTemperature_set)
    def copy(self):
        """copy(self) -> Meteorology"""
        return _cmf.Meteorology_copy(self)

    Name = _swig_property(_cmf.Meteorology_Name_get, _cmf.Meteorology_Name_set)
    __swig_destroy__ = _cmf.delete_Meteorology
Meteorology.GetData = new_instancemethod(_cmf.Meteorology_GetData,None,Meteorology)
Meteorology.copy = new_instancemethod(_cmf.Meteorology_copy,None,Meteorology)
Meteorology_swigregister = _cmf.Meteorology_swigregister
Meteorology_swigregister(Meteorology)

class ConstantMeteorology(Meteorology):
    """Proxy of C++ cmf::atmosphere::ConstantMeteorology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    weather = _swig_property(_cmf.ConstantMeteorology_weather_get, _cmf.ConstantMeteorology_weather_set)
    def __init__(self, *args): 
        """
        __init__(self) -> ConstantMeteorology
        __init__(self, Weather w) -> ConstantMeteorology
        __init__(self, ConstantMeteorology other) -> ConstantMeteorology
        """
        _cmf.ConstantMeteorology_swiginit(self,_cmf.new_ConstantMeteorology(*args))
    def copy(self):
        """copy(self) -> ConstantMeteorology"""
        return _cmf.ConstantMeteorology_copy(self)

    __swig_destroy__ = _cmf.delete_ConstantMeteorology
ConstantMeteorology.copy = new_instancemethod(_cmf.ConstantMeteorology_copy,None,ConstantMeteorology)
ConstantMeteorology_swigregister = _cmf.ConstantMeteorology_swigregister
ConstantMeteorology_swigregister(ConstantMeteorology)

class SingleMeteorology(Meteorology):
    """Proxy of C++ cmf::atmosphere::SingleMeteorology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Latitude = _swig_property(_cmf.SingleMeteorology_Latitude_get, _cmf.SingleMeteorology_Latitude_set)
    Longitude = _swig_property(_cmf.SingleMeteorology_Longitude_get, _cmf.SingleMeteorology_Longitude_set)
    Timezone = _swig_property(_cmf.SingleMeteorology_Timezone_get, _cmf.SingleMeteorology_Timezone_set)
    Elevation = _swig_property(_cmf.SingleMeteorology_Elevation_get, _cmf.SingleMeteorology_Elevation_set)
    daily = _swig_property(_cmf.SingleMeteorology_daily_get, _cmf.SingleMeteorology_daily_set)
    def copy(self):
        """copy(self) -> SingleMeteorology"""
        return _cmf.SingleMeteorology_copy(self)

    def GetData(self, *args):
        """
        GetData(self, Time t, double height) -> Weather
        GetData(self, Time t, double x, double y, double z) -> Weather

        Weather
        GetData(cmf::math::Time t, double height) const

        Returns the current Atmosphere state. Uses default values for missing
        timeseries. 
        """
        return _cmf.SingleMeteorology_GetData(self, *args)

    def GetRs(self, *args):
        """
        GetRs(self, Time t, double height, double sunshine_fraction) -> double

        double
        GetRs(cmf::math::Time t, double height, double sunshine_fraction)
        const

        Returns the global radiation at a given time step $ R_s
        \\frac{MJ}{m^2day}$,
        seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
        \\begin{eqnarray*} \\phi &=& \\frac{(\\mbox{geogr.
        Latitude})^\\circ \\pi}{180^\\circ} \\mbox{ Latitude in }rad
        \\\\ \\delta &=& 0.409 \\sin\\left(\\frac{2\\pi}{365}DOY
        - 1.39\\right) \\mbox{ Declination, DOY is day of year}\\\\
        \\omega_s &=& \\arccos(-\\tan\\phi\\tan\\delta) \\mbox{
        Sunset angle} \\\\ G_{sc} &=& 0.0802 \\frac{MJ}{m^2min}
        \\mbox{Solar constant} \\\\ d_r &=& 1+0.033
        \\cos\\left(\\frac{2\\pi}{365}DOY\\right) \\mbox{Inverse
        relative distance Earth-Sun} \\\\ b &=&
        \\frac{2\\pi(DOY-81)}{364}\\\\ S_c &=&
        0.1645\\sin(2b)-0.1255\\cos(b)-0.025\\sin(b) \\mbox{ Seasonal
        correction for solar time} \\\\ \\omega &=& \\frac {\\pi}
        {12} \\left(t_h+\\frac{(\\mbox{geogr.
        Longitude})^\\circ}{15}-\\mbox{Timezone}+S_c-12\\right)
        \\mbox{ solar time in }rad \\\\ \\mbox{If daily} \\\\ R_a
        &=& \\frac{24\\ 60}{\\pi}G_{sc}\\ d_r \\left(\\omega_s
        \\sin\\phi \\sin\\delta + \\cos\\phi \\cos\\delta
        \\sin\\omega_s\\right) \\mbox{Extraterrestrial radiation }
        \\frac{MJ}{m^2 day} \\\\ \\mbox{If hourly} \\\\ R_a &=&
        \\frac{12\\ 24\\ 60}{\\pi}G_{sc}\\ d_r
        \\left(\\left(\\omega^+ -\\omega^-\\right) \\sin\\phi
        \\sin\\delta + \\cos\\phi \\cos\\delta
        \\left(\\sin\\omega^+ - \\sin\\omega^-\\right)\\right)
        \\\\ && \\omega^+,\\omega^- = \\omega
        \\pm\\frac{\\pi}{24} \\\\ \\frac n N &=&
        \\mbox{Fractional sunshine duration} \\\\ R_s &=&
        \\left(0.25+\\left(0.5+2\\
        10^{-5}z\\right)\\frac{n}{N}\\right)R_a \\mbox{Global
        radiation in }\\frac{MJ}{m^2 day} \\\\ && z=\\mbox{Height
        a.s.l. in }m \\\\ \\end{eqnarray*}. 
        """
        return _cmf.SingleMeteorology_GetRs(self, *args)

    def SetSunshineFraction(self, *args):
        """
        SetSunshineFraction(self, timeseries sunshine_duration)

        void
        SetSunshineFraction(cmf::math::timeseries sunshine_duration) const

        Calculates a timeseries of the sunshine fraction (to put into
        Sunshine) from a timeseries of absolute sunshine duration, using the
        potential sunshine duration in hours,
        seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
        \\begin{eqnarray*} \\phi &=& \\frac{(\\mbox{geogr.
        Latitude})^\\circ \\pi}{180^\\circ} \\mbox{ Latitude in }rad
        \\\\ \\delta &=& 0.409 \\sin\\left(\\frac{2\\pi}{365}DOY
        - 1.39\\right) \\mbox{ Declination, DOY is day of year}\\\\
        \\omega_s &=& \\arccos(-\\tan\\phi\\tan\\delta) \\mbox{
        Sunset angle} \\\\ N &=& \\frac{24}{\\pi}\\omega_s \\mbox{
        potential duration of sunshine in }h \\\\ \\frac n N &&
        n\\mbox{Absolute sunshine duration} \\end{eqnarray*}. 
        """
        return _cmf.SingleMeteorology_SetSunshineFraction(self, *args)

    temp_height_slope = _swig_property(_cmf.SingleMeteorology_temp_height_slope_get, _cmf.SingleMeteorology_temp_height_slope_set)
    Prec = _swig_property(_cmf.SingleMeteorology_Prec_get, _cmf.SingleMeteorology_Prec_set)
    T = _swig_property(_cmf.SingleMeteorology_T_get, _cmf.SingleMeteorology_T_set)
    Tmax = _swig_property(_cmf.SingleMeteorology_Tmax_get, _cmf.SingleMeteorology_Tmax_set)
    Tmin = _swig_property(_cmf.SingleMeteorology_Tmin_get, _cmf.SingleMeteorology_Tmin_set)
    Tground = _swig_property(_cmf.SingleMeteorology_Tground_get, _cmf.SingleMeteorology_Tground_set)
    Windspeed = _swig_property(_cmf.SingleMeteorology_Windspeed_get, _cmf.SingleMeteorology_Windspeed_set)
    rHmean = _swig_property(_cmf.SingleMeteorology_rHmean_get, _cmf.SingleMeteorology_rHmean_set)
    rHmin = _swig_property(_cmf.SingleMeteorology_rHmin_get, _cmf.SingleMeteorology_rHmin_set)
    rHmax = _swig_property(_cmf.SingleMeteorology_rHmax_get, _cmf.SingleMeteorology_rHmax_set)
    Tdew = _swig_property(_cmf.SingleMeteorology_Tdew_get, _cmf.SingleMeteorology_Tdew_set)
    Sunshine = _swig_property(_cmf.SingleMeteorology_Sunshine_get, _cmf.SingleMeteorology_Sunshine_set)
    Rs = _swig_property(_cmf.SingleMeteorology_Rs_get, _cmf.SingleMeteorology_Rs_set)
    Deposition = _swig_property(_cmf.SingleMeteorology_Deposition_get, _cmf.SingleMeteorology_Deposition_set)
    def GetDeposition(self, *args):
        """
        GetDeposition(self, Time t) -> WaterFlux

        cmf::water::WaterFlux GetDeposition(cmf::math::Time t)

        Returns the rainfall with its current concentration. The concentration
        is derived from Deposition. 
        """
        return _cmf.SingleMeteorology_GetDeposition(self, *args)

    def Save(self, *args):
        """
        Save(self, string filename)

        void
        Save(const std::string &filename)

        Save the Meteorology data to an ASCII File with fixed format(
        uses cmf::math::timeseries::Save ). 
        """
        return _cmf.SingleMeteorology_Save(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1, 
            double elevation = 0, Time startTime = cmf::math::Time(1,1,2001), 
            Time timestep = day, 
            string name = "") -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1, 
            double elevation = 0, Time startTime = cmf::math::Time(1,1,2001), 
            Time timestep = day) -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1, 
            double elevation = 0, Time startTime = cmf::math::Time(1,1,2001)) -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1, 
            double elevation = 0) -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1) -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8) -> SingleMeteorology
        __init__(self, double latitude = 51) -> SingleMeteorology
        __init__(self) -> SingleMeteorology
        __init__(self, SingleMeteorology other) -> SingleMeteorology
        __init__(self, string filename) -> SingleMeteorology
        """
        _cmf.SingleMeteorology_swiginit(self,_cmf.new_SingleMeteorology(*args))
    def TimeseriesDictionary(self):
        return {"Tmin":self.Tmin,
                "Tmax":self.Tmax,
                "Tdew":self.Tdew,
                "T":self.T,
                "Prec":self.Prec,
                "rHmean":self.rHmean,
                "rHmax":self.rHmax,
                "rHmin":self.rHmin,
                "Sunshine":self.Sunshine,
                "Windspeed":self.Windspeed,
    				"Rs" : self.Rs}

    __swig_destroy__ = _cmf.delete_SingleMeteorology
SingleMeteorology.copy = new_instancemethod(_cmf.SingleMeteorology_copy,None,SingleMeteorology)
SingleMeteorology.GetData = new_instancemethod(_cmf.SingleMeteorology_GetData,None,SingleMeteorology)
SingleMeteorology.GetRs = new_instancemethod(_cmf.SingleMeteorology_GetRs,None,SingleMeteorology)
SingleMeteorology.SetSunshineFraction = new_instancemethod(_cmf.SingleMeteorology_SetSunshineFraction,None,SingleMeteorology)
SingleMeteorology.GetDeposition = new_instancemethod(_cmf.SingleMeteorology_GetDeposition,None,SingleMeteorology)
SingleMeteorology.Save = new_instancemethod(_cmf.SingleMeteorology_Save,None,SingleMeteorology)
SingleMeteorology_swigregister = _cmf.SingleMeteorology_swigregister
SingleMeteorology_swigregister(SingleMeteorology)

class nnMapMeteorology(Meteorology):
    """Proxy of C++ cmf::atmosphere::nnMapMeteorology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def precalc_temp_lapse(self, *args):
        """precalc_temp_lapse(self, Time begin, Time step, Time end) -> double"""
        return _cmf.nnMapMeteorology_precalc_temp_lapse(self, *args)

    def copy(self):
        """copy(self) -> nnMapMeteorology"""
        return _cmf.nnMapMeteorology_copy(self)

    def __init__(self): 
        """__init__(self) -> nnMapMeteorology"""
        _cmf.nnMapMeteorology_swiginit(self,_cmf.new_nnMapMeteorology())
    __swig_destroy__ = _cmf.delete_nnMapMeteorology
nnMapMeteorology.precalc_temp_lapse = new_instancemethod(_cmf.nnMapMeteorology_precalc_temp_lapse,None,nnMapMeteorology)
nnMapMeteorology.copy = new_instancemethod(_cmf.nnMapMeteorology_copy,None,nnMapMeteorology)
nnMapMeteorology_swigregister = _cmf.nnMapMeteorology_swigregister
nnMapMeteorology_swigregister(nnMapMeteorology)

class PrecipitationData(object):
    """
    Holds the precipitation and concentration timeseries.

    C++ includes: Precipitation.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def q(self, *args):
        """
        q(self, Time t, double x, double y, double z) -> real
        q(self, Time t, point p) -> real
        """
        return _cmf.PrecipitationData_q(self, *args)

    def copy(self):
        """
        copy(self) -> PrecipitationData

        virtual FluxNode* copy() const 
        """
        return _cmf.PrecipitationData_copy(self)

    def conc(self, *args):
        """
        conc(self, Time t, double x, double y, double z) -> WaterQuality

        virtual cmf::water::WaterQuality conc(cmf::math::Time t)

        Returns the concentration of the rainfall at time t. 
        """
        return _cmf.PrecipitationData_conc(self, *args)

    def RecalcFluxes(self, *args):
        """
        RecalcFluxes(self, Time t) -> bool

        virtual bool
        RecalcFluxes(cmf::math::Time t)

        Pure FluxNodes do not influence fluxes, therefore no recalculation of
        fluxes is required by fluxnode. WaterStorage overrides this, since
        state changes require an update of the fluxes. 
        """
        return _cmf.PrecipitationData_RecalcFluxes(self, *args)

    __swig_destroy__ = _cmf.delete_PrecipitationData
PrecipitationData.q = new_instancemethod(_cmf.PrecipitationData_q,None,PrecipitationData)
PrecipitationData.copy = new_instancemethod(_cmf.PrecipitationData_copy,None,PrecipitationData)
PrecipitationData.conc = new_instancemethod(_cmf.PrecipitationData_conc,None,PrecipitationData)
PrecipitationData.RecalcFluxes = new_instancemethod(_cmf.PrecipitationData_RecalcFluxes,None,PrecipitationData)
PrecipitationData_swigregister = _cmf.PrecipitationData_swigregister
PrecipitationData_swigregister(PrecipitationData)

class RainfallNode(FluxNode):
    """Proxy of C++ cmf::atmosphere::RainfallNode class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetSource(self, *args):
        """SetSource(self, PrecipitationData other)"""
        return _cmf.RainfallNode_SetSource(self, *args)

    def q(self, *args):
        """q(self, Time t, double x, double y, double z) -> real"""
        return _cmf.RainfallNode_q(self, *args)

    def conc(self, *args):
        """
        conc(self, Time t, double x, double y, double z) -> WaterQuality

        virtual
        cmf::water::WaterQuality conc(cmf::math::Time t)

        Returns the water quality of the FluxNode, if it is not overridden
        this is the mix of the incoming fluxes. 
        """
        return _cmf.RainfallNode_conc(self, *args)

    def __init__(self, *args): 
        """__init__(self, project _project) -> RainfallNode"""
        _cmf.RainfallNode_swiginit(self,_cmf.new_RainfallNode(*args))
    def copy(self):
        """
        copy(self) -> RainfallNode

        virtual FluxNode*
        copy() const 
        """
        return _cmf.RainfallNode_copy(self)

    __swig_destroy__ = _cmf.delete_RainfallNode
RainfallNode.SetSource = new_instancemethod(_cmf.RainfallNode_SetSource,None,RainfallNode)
RainfallNode.q = new_instancemethod(_cmf.RainfallNode_q,None,RainfallNode)
RainfallNode.conc = new_instancemethod(_cmf.RainfallNode_conc,None,RainfallNode)
RainfallNode.copy = new_instancemethod(_cmf.RainfallNode_copy,None,RainfallNode)
RainfallNode_swigregister = _cmf.RainfallNode_swigregister
RainfallNode_swigregister(RainfallNode)

class SinglePrecipitationTimeseries(PrecipitationData):
    """Proxy of C++ cmf::atmosphere::SinglePrecipitationTimeseries class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Data = _swig_property(_cmf.SinglePrecipitationTimeseries_Data_get, _cmf.SinglePrecipitationTimeseries_Data_set)
    RainFallConcentration = _swig_property(_cmf.SinglePrecipitationTimeseries_RainFallConcentration_get, _cmf.SinglePrecipitationTimeseries_RainFallConcentration_set)
    def __init__(self, *args): 
        """
        __init__(self, timeseries data) -> SinglePrecipitationTimeseries
        __init__(self, timeseries data, SoluteTimeseries concentration) -> SinglePrecipitationTimeseries
        __init__(self, double constantPrecipitation) -> SinglePrecipitationTimeseries
        """
        _cmf.SinglePrecipitationTimeseries_swiginit(self,_cmf.new_SinglePrecipitationTimeseries(*args))
    def copy(self):
        """
        copy(self) -> SinglePrecipitationTimeseries

        virtual FluxNode* copy() const 
        """
        return _cmf.SinglePrecipitationTimeseries_copy(self)

    __swig_destroy__ = _cmf.delete_SinglePrecipitationTimeseries
SinglePrecipitationTimeseries.copy = new_instancemethod(_cmf.SinglePrecipitationTimeseries_copy,None,SinglePrecipitationTimeseries)
SinglePrecipitationTimeseries_swigregister = _cmf.SinglePrecipitationTimeseries_swigregister
SinglePrecipitationTimeseries_swigregister(SinglePrecipitationTimeseries)


def pressure_to_waterhead(*args):
  """pressure_to_waterhead(double Pressure) -> double"""
  return _cmf.pressure_to_waterhead(*args)

def waterhead_to_pressure(*args):
  """waterhead_to_pressure(double waterhead) -> double"""
  return _cmf.waterhead_to_pressure(*args)

def pF_to_waterhead(*args):
  """pF_to_waterhead(double pF) -> double"""
  return _cmf.pF_to_waterhead(*args)

def waterhead_to_pF(*args):
  """waterhead_to_pF(double waterhead) -> double"""
  return _cmf.waterhead_to_pF(*args)
class RetentionCurve(object):
    """
    Abstract base class for different types of retention curves.

    This class, and its children uses wetness instead of volumetric water
    content. The wetness of a soil is defined as water content per void
    volume

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def K(self, *args):
        """
        K(self, real wetness, real depth) -> real

        virtual real
        K(real wetness, real depth) const =0

        Returns the conductivity in m/day at a certain depth and water
        content. 
        """
        return _cmf.RetentionCurve_K(self, *args)

    def Porosity(self, *args):
        """
        Porosity(self, real depth) -> real

        virtual real Porosity(real depth) const =0

        Returns the porosity at a certain depth. 
        """
        return _cmf.RetentionCurve_Porosity(self, *args)

    def VoidVolume(self, *args):
        """
        VoidVolume(self, real upperDepth, real lowerDepth, real Area) -> real

        virtual real VoidVolume(real upperDepth, real lowerDepth, real Area)
        const =0

        Returns the void volume of a soil column. 
        """
        return _cmf.RetentionCurve_VoidVolume(self, *args)

    def FillHeight(self, *args):
        """
        FillHeight(self, real lowerDepth, real Area, real Volume) -> real

        virtual real FillHeight(real lowerDepth, real Area, real Volume) const
        =0

        Returns the thickness of a soil column with a certain pore volume. 
        """
        return _cmf.RetentionCurve_FillHeight(self, *args)

    def Transmissivity(self, *args):
        """
        Transmissivity(self, real upperDepth, real lowerDepth, real wetness) -> real

        virtual real Transmissivity(real upperDepth, real lowerDepth, real
        theta) const =0

        Returns the transmissivity of a part of a soil column. 
        """
        return _cmf.RetentionCurve_Transmissivity(self, *args)

    def Wetness(self, *args):
        """
        Wetness(self, real suction) -> real

        virtual
        real Wetness(real suction) const =0

        returns the wetness (volumetric water content per pore space) at a
        given suction pressure 
        """
        return _cmf.RetentionCurve_Wetness(self, *args)

    def Wetness_pF(self, *args):
        """
        Wetness_pF(self, real pF) -> real

        real
        Wetness_pF(real pF) const

        returns the volumetric water content at a given pF value 
        """
        return _cmf.RetentionCurve_Wetness_pF(self, *args)

    def MatricPotential(self, *args):
        """
        MatricPotential(self, real wetness) -> real

        virtual real MatricPotential(real wetness) const =0

        returns the wetness of the soil at given water content 
        """
        return _cmf.RetentionCurve_MatricPotential(self, *args)

    def copy(self):
        """
        copy(self) -> RetentionCurve

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf.RetentionCurve_copy(self)

    __swig_destroy__ = _cmf.delete_RetentionCurve
RetentionCurve.K = new_instancemethod(_cmf.RetentionCurve_K,None,RetentionCurve)
RetentionCurve.Porosity = new_instancemethod(_cmf.RetentionCurve_Porosity,None,RetentionCurve)
RetentionCurve.VoidVolume = new_instancemethod(_cmf.RetentionCurve_VoidVolume,None,RetentionCurve)
RetentionCurve.FillHeight = new_instancemethod(_cmf.RetentionCurve_FillHeight,None,RetentionCurve)
RetentionCurve.Transmissivity = new_instancemethod(_cmf.RetentionCurve_Transmissivity,None,RetentionCurve)
RetentionCurve.Wetness = new_instancemethod(_cmf.RetentionCurve_Wetness,None,RetentionCurve)
RetentionCurve.Wetness_pF = new_instancemethod(_cmf.RetentionCurve_Wetness_pF,None,RetentionCurve)
RetentionCurve.MatricPotential = new_instancemethod(_cmf.RetentionCurve_MatricPotential,None,RetentionCurve)
RetentionCurve.copy = new_instancemethod(_cmf.RetentionCurve_copy,None,RetentionCurve)
RetentionCurve_swigregister = _cmf.RetentionCurve_swigregister
RetentionCurve_swigregister(RetentionCurve)
rho_wg = cvar.rho_wg

class BrooksCoreyRetentionCurve(RetentionCurve):
    """
    Provides the use of the Brooks-Corey retention curve
    \\begin{eqnarray*} K(W) &=& K_{sat} W^{2+3b} \\\\ \\Psi(W) &=&
    \\Psi_X \\left(\\frac{W}{W_X}\\right)^{-b} \\\\ W &=&
    {\\left( \\frac{\\Psi_X}{\\Psi}\\right)
    }^{\\frac{1}{b}}\\ W_X \\end{eqnarray*} where:  $K$ is the
    conductivity in $\\frac m {day}$

    $W$ is the wetness (Volume of soil water per volume of pores)

    $b$ is the shape of the retention curve (usually between 4 (sand) and
    14 (clay))

    $\\Psi(W)$ is the matric potential in $m H_2O$ at wetness W

    $\\Psi_X$ is a matric potential at a known wetness in $m H_2O$

    $\\W_X$ is the wetness with a known matric potential for dynamic
    changes with depth, exponential decays of porosity and saturated
    conductivity are used The decay function is: $ v(d)=v(0) (1+a)^{-d} $,
    where v is the value ( $ K_{sat},\\Phi$), d is the depth in m and a
    is the fractional decay per m. E.g. 0.1 means the value has in 1 m
    depth 90% of the value at the surface.

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetKsat(self, *args):
        """
        SetKsat(self, real ksat, real ksat_decay)

        real SetKsat(real
        ksat, real ksat_decay) 
        """
        return _cmf.BrooksCoreyRetentionCurve_SetKsat(self, *args)

    def SetPorosity(self, *args):
        """
        SetPorosity(self, real porosity, real porosity_decay = 0)
        SetPorosity(self, real porosity)

        void
        SetPorosity(real porosity, real porosity_decay=0)

        Sets the porosity (Volume of pores per volume of soil) and the
        exponential porosity decline with depth. 
        """
        return _cmf.BrooksCoreyRetentionCurve_SetPorosity(self, *args)

    wetness_X = _swig_property(_cmf.BrooksCoreyRetentionCurve_wetness_X_get, _cmf.BrooksCoreyRetentionCurve_wetness_X_set)
    Psi_X = _swig_property(_cmf.BrooksCoreyRetentionCurve_Psi_X_get, _cmf.BrooksCoreyRetentionCurve_Psi_X_set)
    def b(self):
        """b(self) -> real"""
        return _cmf.BrooksCoreyRetentionCurve_b(self)

    def Set_b(self, *args):
        """Set_b(self, real new_b)"""
        return _cmf.BrooksCoreyRetentionCurve_Set_b(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2, 
            real psi_x = cmf::upslope::pF_to_waterhead(2.5), 
            real ksat_decay = 0, real porosity_decay = 0) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2, 
            real psi_x = cmf::upslope::pF_to_waterhead(2.5), 
            real ksat_decay = 0) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2, 
            real psi_x = cmf::upslope::pF_to_waterhead(2.5)) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15) -> BrooksCoreyRetentionCurve
        __init__(self) -> BrooksCoreyRetentionCurve

        BrooksCoreyRetentionCurve(real ksat, real porosity, real theta1, real
        theta2, real psi_1=pF_to_waterhead(2.5), real
        psi_2=pF_to_waterhead(4.2))

        Creates a soiltype from two known points of the retention curve (e.g.
        fieldcapacity and wilting point).

        Parameters:
        -----------

        ksat:  Saturated conductivity $\\frac{m}{day}$

        porosity:   $\\frac {m^3 Pores}{m^3 Soil}$

        theta1:   $\\theta_1$ First water content at a specific suction
        pressure (e.g. fieldcapacity)

        theta2:   $\\theta_2$ Second water content at a specific suction
        pressure (e.g. wiltingpoint)

        psi_1:   $ \\Psi_1$ Suction pressure for $\\theta_1$ in m water
        column, use the conversion functions pF_to_waterhead,
        pressure_to_waterhead to convert pressure in to waterhead height
        (default pF=2.5)

        psi_2:   $ \\Psi_2$ Suction pressure for $\\theta_2$ in m water
        column, use the conversion functions pF_to_waterhead,
        pressure_to_waterhead to convert pressure in to waterhead height
        (default pF=4.2)

        The paramter b (shape of the retention curve) is calculated by: \\[
        b =
        \\frac{\\log\\left(\\frac{\\Psi_1}{\\Psi_2}\\right)}{\\log\\left(\\frac{\\theta_2}{\\theta_1}\\right)}
        \\] 
        """
        _cmf.BrooksCoreyRetentionCurve_swiginit(self,_cmf.new_BrooksCoreyRetentionCurve(*args))
    def CreateFrom2Points(*args):
        """
        CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
            real psi_1 = cmf::upslope::pF_to_waterhead(2.5), 
            real psi_2 = cmf::upslope::pF_to_waterhead(4.2)) -> BrooksCoreyRetentionCurve
        CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
            real psi_1 = cmf::upslope::pF_to_waterhead(2.5)) -> BrooksCoreyRetentionCurve
        CreateFrom2Points(real ksat, real porosity, real theta1, real theta2) -> BrooksCoreyRetentionCurve
        """
        return _cmf.BrooksCoreyRetentionCurve_CreateFrom2Points(*args)

    CreateFrom2Points = staticmethod(CreateFrom2Points)
    def copy(self):
        """
        copy(self) -> BrooksCoreyRetentionCurve

        virtual BrooksCoreyRetentionCurve* copy() const 
        """
        return _cmf.BrooksCoreyRetentionCurve_copy(self)

    __swig_destroy__ = _cmf.delete_BrooksCoreyRetentionCurve
BrooksCoreyRetentionCurve.SetKsat = new_instancemethod(_cmf.BrooksCoreyRetentionCurve_SetKsat,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.SetPorosity = new_instancemethod(_cmf.BrooksCoreyRetentionCurve_SetPorosity,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.b = new_instancemethod(_cmf.BrooksCoreyRetentionCurve_b,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.Set_b = new_instancemethod(_cmf.BrooksCoreyRetentionCurve_Set_b,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.copy = new_instancemethod(_cmf.BrooksCoreyRetentionCurve_copy,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve_swigregister = _cmf.BrooksCoreyRetentionCurve_swigregister
BrooksCoreyRetentionCurve_swigregister(BrooksCoreyRetentionCurve)

def BrooksCoreyRetentionCurve_CreateFrom2Points(*args):
  """
    CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
        real psi_1 = cmf::upslope::pF_to_waterhead(2.5), 
        real psi_2 = cmf::upslope::pF_to_waterhead(4.2)) -> BrooksCoreyRetentionCurve
    CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
        real psi_1 = cmf::upslope::pF_to_waterhead(2.5)) -> BrooksCoreyRetentionCurve
    BrooksCoreyRetentionCurve_CreateFrom2Points(real ksat, real porosity, real theta1, real theta2) -> BrooksCoreyRetentionCurve
    """
  return _cmf.BrooksCoreyRetentionCurve_CreateFrom2Points(*args)

class VanGenuchtenMualem(RetentionCurve):
    """Proxy of C++ cmf::upslope::VanGenuchtenMualem class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = _swig_property(_cmf.VanGenuchtenMualem_alpha_get, _cmf.VanGenuchtenMualem_alpha_set)
    n = _swig_property(_cmf.VanGenuchtenMualem_n_get, _cmf.VanGenuchtenMualem_n_set)
    Ksat = _swig_property(_cmf.VanGenuchtenMualem_Ksat_get, _cmf.VanGenuchtenMualem_Ksat_set)
    Phi = _swig_property(_cmf.VanGenuchtenMualem_Phi_get, _cmf.VanGenuchtenMualem_Phi_set)
    def copy(self):
        """
        copy(self) -> VanGenuchtenMualem

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf.VanGenuchtenMualem_copy(self)

    def __init__(self, *args): 
        """
        __init__(self) -> VanGenuchtenMualem
        __init__(self, real _n, real _alpha, real _phi, real _Ksat) -> VanGenuchtenMualem
        """
        _cmf.VanGenuchtenMualem_swiginit(self,_cmf.new_VanGenuchtenMualem(*args))
    __swig_destroy__ = _cmf.delete_VanGenuchtenMualem
VanGenuchtenMualem.copy = new_instancemethod(_cmf.VanGenuchtenMualem_copy,None,VanGenuchtenMualem)
VanGenuchtenMualem_swigregister = _cmf.VanGenuchtenMualem_swigregister
VanGenuchtenMualem_swigregister(VanGenuchtenMualem)

class RCurve(object):
    """Proxy of C++ cmf::upslope::RCurve class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Wetness(self, *args):
        """Wetness(self, real suction) -> real"""
        return _cmf.RCurve_Wetness(self, *args)

    def MatricPotential(self, *args):
        """MatricPotential(self, real wetness) -> real"""
        return _cmf.RCurve_MatricPotential(self, *args)

    def K(self, *args):
        """K(self, real wetness, real depth) -> real"""
        return _cmf.RCurve_K(self, *args)

    def VoidVolume(self, *args):
        """VoidVolume(self, real upperDepth, real lowerDepth, real Area) -> real"""
        return _cmf.RCurve_VoidVolume(self, *args)

    def Transmissivity(self, *args):
        """Transmissivity(self, real upperDepth, real lowerDepth, real wetness) -> real"""
        return _cmf.RCurve_Transmissivity(self, *args)

    def Porosity(self, *args):
        """Porosity(self, real depth) -> real"""
        return _cmf.RCurve_Porosity(self, *args)

    def FillHeight(self, *args):
        """FillHeight(self, real lowerDepth, real Area, real Volume) -> real"""
        return _cmf.RCurve_FillHeight(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, RetentionCurve forcopy, bool Shared = False) -> RCurve
        __init__(self, RetentionCurve forcopy) -> RCurve
        __init__(self, RCurve forcopy) -> RCurve
        __init__(self, bool Shared = False) -> RCurve
        __init__(self) -> RCurve
        """
        _cmf.RCurve_swiginit(self,_cmf.new_RCurve(*args))
    def AsVanGenuchten(self):
        """AsVanGenuchten(self) -> VanGenuchtenMualem"""
        return _cmf.RCurve_AsVanGenuchten(self)

    def AsBrooksCorey(self):
        """AsBrooksCorey(self) -> BrooksCoreyRetentionCurve"""
        return _cmf.RCurve_AsBrooksCorey(self)

    shared = _swig_property(_cmf.RCurve_shared_get, _cmf.RCurve_shared_set)
    def AsMap(self):
        """AsMap(self) -> SingleValueMap_RetentionCurve"""
        return _cmf.RCurve_AsMap(self)

    __swig_destroy__ = _cmf.delete_RCurve
RCurve.Wetness = new_instancemethod(_cmf.RCurve_Wetness,None,RCurve)
RCurve.MatricPotential = new_instancemethod(_cmf.RCurve_MatricPotential,None,RCurve)
RCurve.K = new_instancemethod(_cmf.RCurve_K,None,RCurve)
RCurve.VoidVolume = new_instancemethod(_cmf.RCurve_VoidVolume,None,RCurve)
RCurve.Transmissivity = new_instancemethod(_cmf.RCurve_Transmissivity,None,RCurve)
RCurve.Porosity = new_instancemethod(_cmf.RCurve_Porosity,None,RCurve)
RCurve.FillHeight = new_instancemethod(_cmf.RCurve_FillHeight,None,RCurve)
RCurve.AsVanGenuchten = new_instancemethod(_cmf.RCurve_AsVanGenuchten,None,RCurve)
RCurve.AsBrooksCorey = new_instancemethod(_cmf.RCurve_AsBrooksCorey,None,RCurve)
RCurve.AsMap = new_instancemethod(_cmf.RCurve_AsMap,None,RCurve)
RCurve_swigregister = _cmf.RCurve_swigregister
RCurve_swigregister(RCurve)

class Profile(object):
    """Proxy of C++ cmf::upslope::Profile class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def AddProfileLayer(self, *args):
        """AddProfileLayer(self, RCurve _r_curve, double _lowerboundary)"""
        return _cmf.Profile_AddProfileLayer(self, *args)

    def size(self):
        """size(self) -> int"""
        return _cmf.Profile_size(self)

    def lowerboundary(self, *args):
        """lowerboundary(self, int index) -> double"""
        return _cmf.Profile_lowerboundary(self, *args)

    def upperboundary(self, *args):
        """upperboundary(self, int index) -> double"""
        return _cmf.Profile_upperboundary(self, *args)

    def thickness(self, *args):
        """thickness(self, int index) -> double"""
        return _cmf.Profile_thickness(self, *args)

    def r_curve(self, *args):
        """r_curve(self, int index) -> RCurve"""
        return _cmf.Profile_r_curve(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Profile
        __init__(self, Profile forcopy) -> Profile
        """
        _cmf.Profile_swiginit(self,_cmf.new_Profile(*args))
    def __getitem__(self,index):
        return (self.r_curve(index),self.upperboundary(index),self.lowerboundary(index))
    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def AsMap(self):
        """AsMap(self) -> SingleValueMap_Profile"""
        return _cmf.Profile_AsMap(self)

    __swig_destroy__ = _cmf.delete_Profile
Profile.AddProfileLayer = new_instancemethod(_cmf.Profile_AddProfileLayer,None,Profile)
Profile.size = new_instancemethod(_cmf.Profile_size,None,Profile)
Profile.lowerboundary = new_instancemethod(_cmf.Profile_lowerboundary,None,Profile)
Profile.upperboundary = new_instancemethod(_cmf.Profile_upperboundary,None,Profile)
Profile.thickness = new_instancemethod(_cmf.Profile_thickness,None,Profile)
Profile.r_curve = new_instancemethod(_cmf.Profile_r_curve,None,Profile)
Profile.AsMap = new_instancemethod(_cmf.Profile_AsMap,None,Profile)
Profile_swigregister = _cmf.Profile_swigregister
Profile_swigregister(Profile)

class SoilWaterStorage(WaterStorage):
    """
    A representation of a Layer.

    C++ includes: SoilWaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Position = _swig_property(_cmf.SoilWaterStorage_Position_get)
    cell = _swig_property(_cmf.SoilWaterStorage_cell_get)
    def UpperBoundary(self):
        """
        UpperBoundary(self) -> double

        virtual double UpperBoundary() const

        Returns the upper boundary of the water storage below ground in m. 
        """
        return _cmf.SoilWaterStorage_UpperBoundary(self)

    def LowerBoundary(self):
        """
        LowerBoundary(self) -> double

        virtual double LowerBoundary() const

        Returns the lower boundary of the water storage below ground in m. 
        """
        return _cmf.SoilWaterStorage_LowerBoundary(self)

    def Thickness(self):
        """
        Thickness(self) -> double

        double Thickness() const 
        """
        return _cmf.SoilWaterStorage_Thickness(self)

    def Soil(self, *args):
        """
        Soil(self) -> RCurve
        Soil(self) -> RCurve

        virtual
        RetentionCurve& Soil() 
        """
        return _cmf.SoilWaterStorage_Soil(self, *args)

    def theta(self, *args):
        """
        theta(self) -> real
        theta(self, real Value)

        virtual
        void theta(real Value) 
        """
        return _cmf.SoilWaterStorage_theta(self, *args)

    def K(self):
        """
        K(self) -> double

        double K()
        const

        Returns the actual conductivity $\\frac{m}{day}$. 
        """
        return _cmf.SoilWaterStorage_K(self)

    def Ksat(self):
        """Ksat(self) -> double"""
        return _cmf.SoilWaterStorage_Ksat(self)

    def Wetness(self, *args):
        """
        Wetness(self) -> double
        Wetness(self, double wetness)

        virtual double Wetness() const

        Returns the wetness of the soil $ \\frac{V_{H_2O}}{V_{pores}} $. 
        """
        return _cmf.SoilWaterStorage_Wetness(self, *args)

    def MatrixPotential(self):
        """
        MatrixPotential(self) -> real

        virtual real MatrixPotential() const

        Calls RetentionCurve::Matrixpotential. 
        """
        return _cmf.SoilWaterStorage_MatrixPotential(self)

    def GravitationalPotential(self):
        """
        GravitationalPotential(self) -> real

        real
        GravitationalPotential() const

        Gravitational Potential in m, reference height is sea level \\[
        \\Psi_G=h \\]. 
        """
        return _cmf.SoilWaterStorage_GravitationalPotential(self)

    def Capacity(self):
        """
        Capacity(self) -> real

        virtual real Capacity()

        Returns the capacity of the water storage in m3. 
        """
        return _cmf.SoilWaterStorage_Capacity(self)

    def SetPotential(self, *args):
        """
        SetPotential(self, real waterhead)

        void SetPotential(real waterhead)

        Sets the potential of this soil water storage. 
        """
        return _cmf.SoilWaterStorage_SetPotential(self, *args)

    def SaturatedDepth(self):
        """SaturatedDepth(self) -> real"""
        return _cmf.SoilWaterStorage_SaturatedDepth(self)

    def GetFlowCrosssection(self, *args):
        """
        GetFlowCrosssection(self, SoilWaterStorage target, bool HorizontalLayers = False) -> real
        GetFlowCrosssection(self, SoilWaterStorage target) -> real
        """
        return _cmf.SoilWaterStorage_GetFlowCrosssection(self, *args)

    def copy(self):
        """
        copy(self) -> SoilWaterStorage

        SoilWaterStorage* copy() 
        """
        return _cmf.SoilWaterStorage_copy(self)

    def Create(*args):
        """
        Create(Cell _cell, real lowerboundary, RCurve r_curve, real saturateddepth = -10) -> SoilWaterStorage
        Create(Cell _cell, real lowerboundary, RCurve r_curve) -> SoilWaterStorage
        """
        return _cmf.SoilWaterStorage_Create(*args)

    Create = staticmethod(Create)
    boundary=property(lambda self:(self.LowerBoundary(),self.UpperBoundary()),None,"Returns the upper and lower boundary of the layer")

    __swig_destroy__ = _cmf.delete_SoilWaterStorage
SoilWaterStorage.UpperBoundary = new_instancemethod(_cmf.SoilWaterStorage_UpperBoundary,None,SoilWaterStorage)
SoilWaterStorage.LowerBoundary = new_instancemethod(_cmf.SoilWaterStorage_LowerBoundary,None,SoilWaterStorage)
SoilWaterStorage.Thickness = new_instancemethod(_cmf.SoilWaterStorage_Thickness,None,SoilWaterStorage)
SoilWaterStorage.Soil = new_instancemethod(_cmf.SoilWaterStorage_Soil,None,SoilWaterStorage)
SoilWaterStorage.theta = new_instancemethod(_cmf.SoilWaterStorage_theta,None,SoilWaterStorage)
SoilWaterStorage.K = new_instancemethod(_cmf.SoilWaterStorage_K,None,SoilWaterStorage)
SoilWaterStorage.Ksat = new_instancemethod(_cmf.SoilWaterStorage_Ksat,None,SoilWaterStorage)
SoilWaterStorage.Wetness = new_instancemethod(_cmf.SoilWaterStorage_Wetness,None,SoilWaterStorage)
SoilWaterStorage.MatrixPotential = new_instancemethod(_cmf.SoilWaterStorage_MatrixPotential,None,SoilWaterStorage)
SoilWaterStorage.GravitationalPotential = new_instancemethod(_cmf.SoilWaterStorage_GravitationalPotential,None,SoilWaterStorage)
SoilWaterStorage.Capacity = new_instancemethod(_cmf.SoilWaterStorage_Capacity,None,SoilWaterStorage)
SoilWaterStorage.SetPotential = new_instancemethod(_cmf.SoilWaterStorage_SetPotential,None,SoilWaterStorage)
SoilWaterStorage.SaturatedDepth = new_instancemethod(_cmf.SoilWaterStorage_SaturatedDepth,None,SoilWaterStorage)
SoilWaterStorage.GetFlowCrosssection = new_instancemethod(_cmf.SoilWaterStorage_GetFlowCrosssection,None,SoilWaterStorage)
SoilWaterStorage.copy = new_instancemethod(_cmf.SoilWaterStorage_copy,None,SoilWaterStorage)
SoilWaterStorage_swigregister = _cmf.SoilWaterStorage_swigregister
SoilWaterStorage_swigregister(SoilWaterStorage)

def SoilWaterStorage_Create(*args):
  """
    Create(Cell _cell, real lowerboundary, RCurve r_curve, real saturateddepth = -10) -> SoilWaterStorage
    SoilWaterStorage_Create(Cell _cell, real lowerboundary, RCurve r_curve) -> SoilWaterStorage
    """
  return _cmf.SoilWaterStorage_Create(*args)

class FlexibleSizeSaturatedZone(SoilWaterStorage):
    """
    A soil water storage with a flexible (non constant) upper boundary,
    according to its fill state. This soil water storage is always
    saturated.

    C++ includes: SoilWaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Create(*args):
        """Create(Cell cell, real lowerboundary, RCurve r_curve) -> FlexibleSizeSaturatedZone"""
        return _cmf.FlexibleSizeSaturatedZone_Create(*args)

    Create = staticmethod(Create)
    __swig_destroy__ = _cmf.delete_FlexibleSizeSaturatedZone
FlexibleSizeSaturatedZone_swigregister = _cmf.FlexibleSizeSaturatedZone_swigregister
FlexibleSizeSaturatedZone_swigregister(FlexibleSizeSaturatedZone)

def FlexibleSizeSaturatedZone_Create(*args):
  """FlexibleSizeSaturatedZone_Create(Cell cell, real lowerboundary, RCurve r_curve) -> FlexibleSizeSaturatedZone"""
  return _cmf.FlexibleSizeSaturatedZone_Create(*args)

class FlexibleSizeLayer(SoilWaterStorage):
    """
    A soil water storage above a FlexibleSizeSaturatedLayer, can only be
    created by FlexibleSaturatedLayer.

    C++ includes: SoilWaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf.delete_FlexibleSizeLayer
FlexibleSizeLayer_swigregister = _cmf.FlexibleSizeLayer_swigregister
FlexibleSizeLayer_swigregister(FlexibleSizeLayer)


def AsSoilWater(*args):
  """AsSoilWater(FluxNode node) -> SoilWaterStorage"""
  return _cmf.AsSoilWater(*args)
class Vegetation(object):
    """Proxy of C++ cmf::upslope::vegetation::Vegetation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LAI = _swig_property(_cmf.Vegetation_LAI_get, _cmf.Vegetation_LAI_set)
    Height = _swig_property(_cmf.Vegetation_Height_get, _cmf.Vegetation_Height_set)
    albedo = _swig_property(_cmf.Vegetation_albedo_get, _cmf.Vegetation_albedo_set)
    CanopyCapacityPerLAI = _swig_property(_cmf.Vegetation_CanopyCapacityPerLAI_get, _cmf.Vegetation_CanopyCapacityPerLAI_set)
    RootDepth = _swig_property(_cmf.Vegetation_RootDepth_get, _cmf.Vegetation_RootDepth_set)
    fraction_at_rootdepth = _swig_property(_cmf.Vegetation_fraction_at_rootdepth_get, _cmf.Vegetation_fraction_at_rootdepth_set)
    StomatalResistance = _swig_property(_cmf.Vegetation_StomatalResistance_get, _cmf.Vegetation_StomatalResistance_set)
    CanopyClosure = _swig_property(_cmf.Vegetation_CanopyClosure_get, _cmf.Vegetation_CanopyClosure_set)
    LeafWidth = _swig_property(_cmf.Vegetation_LeafWidth_get, _cmf.Vegetation_LeafWidth_set)
    def RootFraction(self, *args):
        """
        RootFraction(self, double upperBoundary, double lowerBoundary) -> double

        virtual double
        RootFraction(double upperBoundary, double lowerBoundary) const 
        """
        return _cmf.Vegetation_RootFraction(self, *args)

    def __init__(self, _LAI = 12, _Height = 0.12, _RootDepth = 0.25, _StomatalResistance = 100, 
    _albedo = 0.23, _CanopyClosure = 1, 
    _CanopyCapacityPerLAI = 0.1, _fraction_at_rootdepth = 1.0): 
        """
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23, double _CanopyClosure = 1, 
            double _CanopyCapacityPerLAI = 0.1, 
            double _fraction_at_rootdepth = 1.0) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23, double _CanopyClosure = 1, 
            double _CanopyCapacityPerLAI = 0.1) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23, double _CanopyClosure = 1) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12) -> Vegetation
        __init__(self, double _LAI = 12) -> Vegetation
        __init__(self) -> Vegetation

        Vegetation(double
        _LAI=12, double _Height=0.12, double _RootDepth=0.25, double
        _StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
        double _CanopyCapacityPerLAI=0.01) 
        """
        _cmf.Vegetation_swiginit(self,_cmf.new_Vegetation(_LAI, _Height, _RootDepth, _StomatalResistance, _albedo, 
    _CanopyClosure, _CanopyCapacityPerLAI, 
    _fraction_at_rootdepth))
    def AsMap(self):
        """AsMap(self) -> SingleValueMap_Vegetation"""
        return _cmf.Vegetation_AsMap(self)

    __swig_destroy__ = _cmf.delete_Vegetation
Vegetation.RootFraction = new_instancemethod(_cmf.Vegetation_RootFraction,None,Vegetation)
Vegetation.AsMap = new_instancemethod(_cmf.Vegetation_AsMap,None,Vegetation)
Vegetation_swigregister = _cmf.Vegetation_swigregister
Vegetation_swigregister(Vegetation)

class CellConnector(object):
    """Proxy of C++ cmf::upslope::CellConnector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def connect(self, *args):
        """
        connect(self, Cell cell1, Cell cell2, int start_at_layer = 0)
        connect(self, Cell cell1, Cell cell2)
        """
        return _cmf.CellConnector_connect(self, *args)

    __swig_destroy__ = _cmf.delete_CellConnector
CellConnector.connect = new_instancemethod(_cmf.CellConnector_connect,None,CellConnector)
CellConnector_swigregister = _cmf.CellConnector_swigregister
CellConnector_swigregister(CellConnector)

class Cell(StateVariableOwner):
    """Proxy of C++ cmf::upslope::Cell class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    x = _swig_property(_cmf.Cell_x_get, _cmf.Cell_x_set)
    y = _swig_property(_cmf.Cell_y_get, _cmf.Cell_y_set)
    z = _swig_property(_cmf.Cell_z_get, _cmf.Cell_z_set)
    def Center(self):
        """
        Center(self) -> point

        cmf::geometry::point Center() const

        Returns the location of the cell. 
        """
        return _cmf.Cell_Center(self)

    def Area(self):
        """
        Area(self) -> double

        double Area() const

        Returns the area of the cell. 
        """
        return _cmf.Cell_Area(self)

    def InvalidateSatDepth(self):
        """InvalidateSatDepth(self)"""
        return _cmf.Cell_InvalidateSatDepth(self)

    def SaturatedDepth(self):
        """
        SaturatedDepth(self) -> real

        real
        SaturatedDepth() 
        """
        return _cmf.Cell_SaturatedDepth(self)

    def SetSaturatedDepth(self, *args):
        """SetSaturatedDepth(self, real depth)"""
        return _cmf.Cell_SetSaturatedDepth(self, *args)

    def Evaporation(self):
        """Evaporation(self) -> FluxNode"""
        return _cmf.Cell_Evaporation(self)

    def Transpiration(self):
        """Transpiration(self) -> FluxNode"""
        return _cmf.Cell_Transpiration(self)

    def SurfaceWater(self):
        """
        SurfaceWater(self) -> FluxNode

        cmf::water::FluxNode& SurfaceWater()

        returns the surface water of this cell 
        """
        return _cmf.Cell_SurfaceWater(self)

    def AddStorage(self, *args):
        """
        AddStorage(self, string Name, char storage_role = 'N', bool isopenwater = False) -> WaterStorage
        AddStorage(self, string Name, char storage_role = 'N') -> WaterStorage
        AddStorage(self, string Name) -> WaterStorage
        """
        return _cmf.Cell_AddStorage(self, *args)

    def RemoveStorage(self, *args):
        """RemoveStorage(self, WaterStorage storage)"""
        return _cmf.Cell_RemoveStorage(self, *args)

    def AddReach(self, *args):
        """
        AddReach(self, double length, char shape = 'T', double depth = 0.25, 
            double width = 1., string Name = "Reach") -> Reach
        AddReach(self, double length, char shape = 'T', double depth = 0.25, 
            double width = 1.) -> Reach
        AddReach(self, double length, char shape = 'T', double depth = 0.25) -> Reach
        AddReach(self, double length, char shape = 'T') -> Reach
        AddReach(self, double length) -> Reach
        """
        return _cmf.Cell_AddReach(self, *args)

    def StorageCount(self):
        """StorageCount(self) -> int"""
        return _cmf.Cell_StorageCount(self)

    def GetStorage(self, *args):
        """
        GetStorage(self, int index) -> WaterStorage
        GetStorage(self, int index) -> WaterStorage
        """
        return _cmf.Cell_GetStorage(self, *args)

    def GetReach(self, index = 0):
        """
        GetReach(self, int index = 0) -> Reach
        GetReach(self) -> Reach
        """
        return _cmf.Cell_GetReach(self, index)

    def ReachCount(self):
        """ReachCount(self) -> size_t"""
        return _cmf.Cell_ReachCount(self)

    def GetCanopy(self):
        """GetCanopy(self) -> WaterStorage"""
        return _cmf.Cell_GetCanopy(self)

    def GetSnow(self):
        """GetSnow(self) -> WaterStorage"""
        return _cmf.Cell_GetSnow(self)

    def HasSnowStorage(self):
        """HasSnowStorage(self) -> bool"""
        return _cmf.Cell_HasSnowStorage(self)

    def SnowCover(self):
        """SnowCover(self) -> real"""
        return _cmf.Cell_SnowCover(self)

    def HasInterceptedWater(self):
        """HasInterceptedWater(self) -> bool"""
        return _cmf.Cell_HasInterceptedWater(self)

    def HasSurfaceWater(self):
        """HasSurfaceWater(self) -> bool"""
        return _cmf.Cell_HasSurfaceWater(self)

    Vegetation = _swig_property(_cmf.Cell_Vegetation_get, _cmf.Cell_Vegetation_set)
    def GetVegetation(self):
        """GetVegetation(self) -> Vegetation"""
        return _cmf.Cell_GetVegetation(self)

    Id = _swig_property(_cmf.Cell_Id_get, _cmf.Cell_Id_set)
    def project(self):
        """project(self) -> project"""
        return _cmf.Cell_project(self)

    def Weather(self, *args):
        """Weather(self, Time t) -> Weather"""
        return _cmf.Cell_Weather(self, *args)

    def Rain(self, *args):
        """Rain(self, Time t) -> real"""
        return _cmf.Cell_Rain(self, *args)

    def LayerCount(self):
        """
        LayerCount(self) -> int

        int
        LayerCount() const 
        """
        return _cmf.Cell_LayerCount(self)

    def Layer(self, *args):
        """
        Layer(self, int ndx) -> SoilWaterStorage
        Layer(self, int ndx) -> SoilWaterStorage

        const
        cmf::upslope::SoilWaterStorage& Layer(int ndx) const 
        """
        return _cmf.Cell_Layer(self, *args)

    def AddLayer(self, *args):
        """
        AddLayer(self, real lowerboundary, RCurve r_curve, real saturateddepth = -10)
        AddLayer(self, real lowerboundary, RCurve r_curve)

        void
        AddLayer(cmf::upslope::SoilWaterStorage *layer)

        Registers a layer at the cell. This function is used by the ctor's of
        the layers and should never be used in other code. 
        """
        return _cmf.Cell_AddLayer(self, *args)

    def AddVariableLayerPair(self, *args):
        """AddVariableLayerPair(self, real lowerboundary, RCurve r_curve)"""
        return _cmf.Cell_AddVariableLayerPair(self, *args)

    def RemoveLastLayer(self):
        """RemoveLastLayer(self)"""
        return _cmf.Cell_RemoveLastLayer(self)

    def RemoveLayers(self):
        """RemoveLayers(self)"""
        return _cmf.Cell_RemoveLayers(self)

    __swig_destroy__ = _cmf.delete_Cell
    def __init__(self, *args): 
        """
        __init__(self, double x, double y, double z, double area, project _project) -> Cell

        Cell(double x,
        double y, double z, double area) 
        """
        _cmf.Cell_swiginit(self,_cmf.new_Cell(*args))
    def ToString(self):
        """ToString(self) -> string"""
        return _cmf.Cell_ToString(self)

    topology = _swig_property(_cmf.Cell_topology_get)
    def __repr__(self):
        """__repr__(self) -> string"""
        return _cmf.Cell___repr__(self)

    def __getitem__(self, *args):
        """__getitem__(self, int i) -> SoilWaterStorage"""
        return _cmf.Cell___getitem__(self, *args)

    @property
    def neighbors(self):
        c_iter=NeighborIterator(self)
        while c_iter.valid():
            yield (c_iter.cell(),c_iter.flowwidth())
            c_iter.next()
    storages=property(lambda c:_cell_object_list(c,'A'),None,"Provides access to all storages of the cell (surface storages and layers)")
    surface_storages=property(lambda c:_cell_object_list(c,'S'),None,"Provides access to all surface storages of the cell, like canopy, snow, surface water etc")
    layers=property(lambda c:_cell_object_list(c,'L'),None,"Provides access to all soil water storages (layers) of the cell")
    surface_water=property(SurfaceWater,None,"Gives access to the surface water, which is either a distributing flux node, or the storage for all surface water")
    canopy=property(GetCanopy,None,"The canopy water storage of the cell, if it exists")
    snow=property(GetSnow,None,"The snow pack of the cell, if a storage for the snow exists")
    saturated_depth=property(SaturatedDepth,SetSaturatedDepth,"Gets or sets the saturated depth of a cell, if setting each layer of the cell will get a new water content")
    area=property(Area,None,"The area of the cell in m2")
    soildepth=property(lambda self:0 if self.layercount()==0 else self[-1].boundary[-1],None,"the soildepth in m (lower boundary of lowest layer)")
    reach=property(lambda self:self.GetReach(0),None,"The first reach of the cell, other reaches are accessible via reaches[n]")
    reaches=property(lambda self:[self.GetReach(i) for i in range(self.ReachCount())],None,"The reaches of this cell")
    def connect_soil_with_node(self,node,type,flowwidth,distance,upper_boundary=0,lower_boundary=None):
        """Connects all layers between the boundaries with a node using a flux connection
        node: Target node (FluxNode)
        type: Type of the connection (e.g. cmf.Richards_lateral)
        flowwidth: Width of the connection
        distance: distance of the connection
        upper_boundary: Connect only layers, whose lower depth is greater then this value
        lower_boundary: Connect only  layers, whose upper depth is smaller then this value
        """
        if lower_boundary is None:
            lower_boundary=self.soildepth
        for l in self:
            if l.boundary[0]<lower_boundary and l.boundary[1]>upper_boundary:
                type(l,node,flowwidth,distance).thisown=0
    def __hash__(self):
        return hash((self.x,self.y,self.z,self.area,self.Id))
    def __eq__(self,cmp):
        return hash(self)==hash(cmp)

Cell.Center = new_instancemethod(_cmf.Cell_Center,None,Cell)
Cell.Area = new_instancemethod(_cmf.Cell_Area,None,Cell)
Cell.InvalidateSatDepth = new_instancemethod(_cmf.Cell_InvalidateSatDepth,None,Cell)
Cell.SaturatedDepth = new_instancemethod(_cmf.Cell_SaturatedDepth,None,Cell)
Cell.SetSaturatedDepth = new_instancemethod(_cmf.Cell_SetSaturatedDepth,None,Cell)
Cell.Evaporation = new_instancemethod(_cmf.Cell_Evaporation,None,Cell)
Cell.Transpiration = new_instancemethod(_cmf.Cell_Transpiration,None,Cell)
Cell.SurfaceWater = new_instancemethod(_cmf.Cell_SurfaceWater,None,Cell)
Cell.AddStorage = new_instancemethod(_cmf.Cell_AddStorage,None,Cell)
Cell.RemoveStorage = new_instancemethod(_cmf.Cell_RemoveStorage,None,Cell)
Cell.AddReach = new_instancemethod(_cmf.Cell_AddReach,None,Cell)
Cell.StorageCount = new_instancemethod(_cmf.Cell_StorageCount,None,Cell)
Cell.GetStorage = new_instancemethod(_cmf.Cell_GetStorage,None,Cell)
Cell.GetReach = new_instancemethod(_cmf.Cell_GetReach,None,Cell)
Cell.ReachCount = new_instancemethod(_cmf.Cell_ReachCount,None,Cell)
Cell.GetCanopy = new_instancemethod(_cmf.Cell_GetCanopy,None,Cell)
Cell.GetSnow = new_instancemethod(_cmf.Cell_GetSnow,None,Cell)
Cell.HasSnowStorage = new_instancemethod(_cmf.Cell_HasSnowStorage,None,Cell)
Cell.SnowCover = new_instancemethod(_cmf.Cell_SnowCover,None,Cell)
Cell.HasInterceptedWater = new_instancemethod(_cmf.Cell_HasInterceptedWater,None,Cell)
Cell.HasSurfaceWater = new_instancemethod(_cmf.Cell_HasSurfaceWater,None,Cell)
Cell.GetVegetation = new_instancemethod(_cmf.Cell_GetVegetation,None,Cell)
Cell.project = new_instancemethod(_cmf.Cell_project,None,Cell)
Cell.Weather = new_instancemethod(_cmf.Cell_Weather,None,Cell)
Cell.Rain = new_instancemethod(_cmf.Cell_Rain,None,Cell)
Cell.LayerCount = new_instancemethod(_cmf.Cell_LayerCount,None,Cell)
Cell.Layer = new_instancemethod(_cmf.Cell_Layer,None,Cell)
Cell.AddLayer = new_instancemethod(_cmf.Cell_AddLayer,None,Cell)
Cell.AddVariableLayerPair = new_instancemethod(_cmf.Cell_AddVariableLayerPair,None,Cell)
Cell.RemoveLastLayer = new_instancemethod(_cmf.Cell_RemoveLastLayer,None,Cell)
Cell.RemoveLayers = new_instancemethod(_cmf.Cell_RemoveLayers,None,Cell)
Cell.ToString = new_instancemethod(_cmf.Cell_ToString,None,Cell)
Cell.__repr__ = new_instancemethod(_cmf.Cell___repr__,None,Cell)
Cell.__getitem__ = new_instancemethod(_cmf.Cell___getitem__,None,Cell)
Cell_swigregister = _cmf.Cell_swigregister
Cell_swigregister(Cell)

class _cell_object_list:
    def __init__(self,c,kind):
        self.c=c
        self.kind=kind
    def get(self,index):
        if self.kind=="L":
            return self.c.Layer(index)
        elif self.kind=="S":
            return self.c.GetStorage(index)
        else:
             ndx=index if index>=0 else self.c.StorageCount()+self.c.LayerCount()+index
             lndx=index-self.c.StorageCount()
             if lndx<0:
                 return self.c.GetStorage(ndx)
             else:
                 return self.c.Layer(lndx)
    def __getitem__(self,index):
        if (type(index)==slice):
             indices=index.indices(len(self))
             return list(map(self.get,range(*index.indices(len(self)))))
        try:
             gen=iter(index)
             return list(map(self.get,gen))
        except TypeError:
             return self.get(index)
    def find_by_name(self,name):
        for s in self:
            if s.Name==name:
                return s
        raise IndexError("No storage %s in %s of %s" % (name,"layers" if self.kind=='L' else "non layer storages" if self.kind=='S' else "storages",self.c))
    def __len__(self):
        return self.c.LayerCount() if self.kind=='L' else (self.c.StorageCount() if self.kind=='S' else self.c.LayerCount()+self.c.StorageCount())
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

class Topology(object):
    """Proxy of C++ cmf::upslope::Topology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    cell = _swig_property(_cmf.Topology_cell_get)
    x = _swig_property(_cmf.Topology_x_get, _cmf.Topology_x_set)
    y = _swig_property(_cmf.Topology_y_get, _cmf.Topology_y_set)
    z = _swig_property(_cmf.Topology_z_get, _cmf.Topology_z_set)
    def Center(self):
        """Center(self) -> point"""
        return _cmf.Topology_Center(self)

    def flowwidth(self, *args):
        """
        flowwidth(self, Cell target) -> double
        flowwidth(self, Topology target) -> double
        """
        return _cmf.Topology_flowwidth(self, *args)

    def AddNeighbor(self, *args):
        """
        AddNeighbor(self, Cell target, double flowwidth)
        AddNeighbor(self, Topology target, double flowwidth)
        """
        return _cmf.Topology_AddNeighbor(self, *args)

    def RemoveNeighbor(self, *args):
        """RemoveNeighbor(self, Topology target)"""
        return _cmf.Topology_RemoveNeighbor(self, *args)

    def neighbor_count(self):
        """neighbor_count(self) -> size_t"""
        return _cmf.Topology_neighbor_count(self)

    def MainOutlet(self, forceRecalc = False):
        """
        MainOutlet(self, bool forceRecalc = False) -> Cell
        MainOutlet(self) -> Cell
        """
        return _cmf.Topology_MainOutlet(self, forceRecalc)

    def ContributingArea(self, forceRecalc = False):
        """
        ContributingArea(self, bool forceRecalc = False) -> double
        ContributingArea(self) -> double
        """
        return _cmf.Topology_ContributingArea(self, forceRecalc)

    def __eq__(self, *args):
        """__eq__(self, Topology cmp) -> bool"""
        return _cmf.Topology___eq__(self, *args)

    __swig_destroy__ = _cmf.delete_Topology
Topology.Center = new_instancemethod(_cmf.Topology_Center,None,Topology)
Topology.flowwidth = new_instancemethod(_cmf.Topology_flowwidth,None,Topology)
Topology.AddNeighbor = new_instancemethod(_cmf.Topology_AddNeighbor,None,Topology)
Topology.RemoveNeighbor = new_instancemethod(_cmf.Topology_RemoveNeighbor,None,Topology)
Topology.neighbor_count = new_instancemethod(_cmf.Topology_neighbor_count,None,Topology)
Topology.MainOutlet = new_instancemethod(_cmf.Topology_MainOutlet,None,Topology)
Topology.ContributingArea = new_instancemethod(_cmf.Topology_ContributingArea,None,Topology)
Topology.__eq__ = new_instancemethod(_cmf.Topology___eq__,None,Topology)
Topology_swigregister = _cmf.Topology_swigregister
Topology_swigregister(Topology)

class NeighborIterator(object):
    """Proxy of C++ cmf::upslope::NeighborIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Cell cell) -> NeighborIterator"""
        _cmf.NeighborIterator_swiginit(self,_cmf.new_NeighborIterator(*args))
    def cell(self):
        """cell(self) -> Cell"""
        return _cmf.NeighborIterator_cell(self)

    def flowwidth(self):
        """flowwidth(self) -> double"""
        return _cmf.NeighborIterator_flowwidth(self)

    def valid(self):
        """valid(self) -> bool"""
        return _cmf.NeighborIterator_valid(self)

    def next(self):
        """next(self) -> NeighborIterator"""
        return _cmf.NeighborIterator_next(self)

    def __eq__(self, *args):
        """__eq__(self, NeighborIterator cmp) -> bool"""
        return _cmf.NeighborIterator___eq__(self, *args)

    def __neq__(self, *args):
        """__neq__(self, NeighborIterator cmp) -> bool"""
        return _cmf.NeighborIterator___neq__(self, *args)

    __swig_destroy__ = _cmf.delete_NeighborIterator
NeighborIterator.cell = new_instancemethod(_cmf.NeighborIterator_cell,None,NeighborIterator)
NeighborIterator.flowwidth = new_instancemethod(_cmf.NeighborIterator_flowwidth,None,NeighborIterator)
NeighborIterator.valid = new_instancemethod(_cmf.NeighborIterator_valid,None,NeighborIterator)
NeighborIterator.next = new_instancemethod(_cmf.NeighborIterator_next,None,NeighborIterator)
NeighborIterator.__eq__ = new_instancemethod(_cmf.NeighborIterator___eq__,None,NeighborIterator)
NeighborIterator.__neq__ = new_instancemethod(_cmf.NeighborIterator___neq__,None,NeighborIterator)
NeighborIterator_swigregister = _cmf.NeighborIterator_swigregister
NeighborIterator_swigregister(NeighborIterator)

class cell_vector(object):
    """Proxy of C++ std::vector<(p.cmf::upslope::Cell)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf.cell_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf.cell_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf.cell_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf.cell_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf.cell_vector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> cell_vector"""
        return _cmf.cell_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, cell_vector v)"""
        return _cmf.cell_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf.cell_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf.cell_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> cell_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf.cell_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, cell_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf.cell_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf.cell_vector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf.cell_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf.cell_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf.cell_vector_clear(self)

    def swap(self, *args):
        """swap(self, cell_vector v)"""
        return _cmf.cell_vector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf.cell_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf.cell_vector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf.cell_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf.cell_vector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf.cell_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf.cell_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf.cell_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> cell_vector
        __init__(self, cell_vector arg0) -> cell_vector
        __init__(self, size_type size) -> cell_vector
        __init__(self, size_type size, value_type value) -> cell_vector
        """
        _cmf.cell_vector_swiginit(self,_cmf.new_cell_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf.cell_vector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf.cell_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf.cell_vector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf.cell_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf.cell_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf.cell_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf.cell_vector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf.cell_vector_capacity(self)

    __swig_destroy__ = _cmf.delete_cell_vector
cell_vector.iterator = new_instancemethod(_cmf.cell_vector_iterator,None,cell_vector)
cell_vector.__nonzero__ = new_instancemethod(_cmf.cell_vector___nonzero__,None,cell_vector)
cell_vector.__bool__ = new_instancemethod(_cmf.cell_vector___bool__,None,cell_vector)
cell_vector.__len__ = new_instancemethod(_cmf.cell_vector___len__,None,cell_vector)
cell_vector.pop = new_instancemethod(_cmf.cell_vector_pop,None,cell_vector)
cell_vector.__getslice__ = new_instancemethod(_cmf.cell_vector___getslice__,None,cell_vector)
cell_vector.__setslice__ = new_instancemethod(_cmf.cell_vector___setslice__,None,cell_vector)
cell_vector.__delslice__ = new_instancemethod(_cmf.cell_vector___delslice__,None,cell_vector)
cell_vector.__delitem__ = new_instancemethod(_cmf.cell_vector___delitem__,None,cell_vector)
cell_vector.__getitem__ = new_instancemethod(_cmf.cell_vector___getitem__,None,cell_vector)
cell_vector.__setitem__ = new_instancemethod(_cmf.cell_vector___setitem__,None,cell_vector)
cell_vector.append = new_instancemethod(_cmf.cell_vector_append,None,cell_vector)
cell_vector.empty = new_instancemethod(_cmf.cell_vector_empty,None,cell_vector)
cell_vector.size = new_instancemethod(_cmf.cell_vector_size,None,cell_vector)
cell_vector.clear = new_instancemethod(_cmf.cell_vector_clear,None,cell_vector)
cell_vector.swap = new_instancemethod(_cmf.cell_vector_swap,None,cell_vector)
cell_vector.get_allocator = new_instancemethod(_cmf.cell_vector_get_allocator,None,cell_vector)
cell_vector.begin = new_instancemethod(_cmf.cell_vector_begin,None,cell_vector)
cell_vector.end = new_instancemethod(_cmf.cell_vector_end,None,cell_vector)
cell_vector.rbegin = new_instancemethod(_cmf.cell_vector_rbegin,None,cell_vector)
cell_vector.rend = new_instancemethod(_cmf.cell_vector_rend,None,cell_vector)
cell_vector.pop_back = new_instancemethod(_cmf.cell_vector_pop_back,None,cell_vector)
cell_vector.erase = new_instancemethod(_cmf.cell_vector_erase,None,cell_vector)
cell_vector.push_back = new_instancemethod(_cmf.cell_vector_push_back,None,cell_vector)
cell_vector.front = new_instancemethod(_cmf.cell_vector_front,None,cell_vector)
cell_vector.back = new_instancemethod(_cmf.cell_vector_back,None,cell_vector)
cell_vector.assign = new_instancemethod(_cmf.cell_vector_assign,None,cell_vector)
cell_vector.resize = new_instancemethod(_cmf.cell_vector_resize,None,cell_vector)
cell_vector.insert = new_instancemethod(_cmf.cell_vector_insert,None,cell_vector)
cell_vector.reserve = new_instancemethod(_cmf.cell_vector_reserve,None,cell_vector)
cell_vector.capacity = new_instancemethod(_cmf.cell_vector_capacity,None,cell_vector)
cell_vector_swigregister = _cmf.cell_vector_swigregister
cell_vector_swigregister(cell_vector)

class UnsatSatPercolation(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::UnsatSatPercolation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, FlexibleSizeLayer unsat, FlexibleSizeSaturatedZone sat) -> UnsatSatPercolation"""
        _cmf.UnsatSatPercolation_swiginit(self,_cmf.new_UnsatSatPercolation(*args))
    __swig_destroy__ = _cmf.delete_UnsatSatPercolation
UnsatSatPercolation_swigregister = _cmf.UnsatSatPercolation_swigregister
UnsatSatPercolation_swigregister(UnsatSatPercolation)

class Darcy(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::Darcy class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0, 
            real Distance = 0) -> Darcy
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0) -> Darcy
        __init__(self, SoilWaterStorage left, FluxNode right) -> Darcy
        """
        _cmf.Darcy_swiginit(self,_cmf.new_Darcy(*args))
    __swig_destroy__ = _cmf.delete_Darcy
Darcy_swigregister = _cmf.Darcy_swigregister
Darcy_swigregister(Darcy)
Darcy.cell_connector = _cmf.cvar.Darcy_cell_connector

class TopographicGradientDarcy(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::TopographicGradientDarcy class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0, 
            real Distance = 0) -> TopographicGradientDarcy
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0) -> TopographicGradientDarcy
        __init__(self, SoilWaterStorage left, FluxNode right) -> TopographicGradientDarcy
        """
        _cmf.TopographicGradientDarcy_swiginit(self,_cmf.new_TopographicGradientDarcy(*args))
    __swig_destroy__ = _cmf.delete_TopographicGradientDarcy
TopographicGradientDarcy_swigregister = _cmf.TopographicGradientDarcy_swigregister
TopographicGradientDarcy_swigregister(TopographicGradientDarcy)
TopographicGradientDarcy.cell_connector = _cmf.cvar.TopographicGradientDarcy_cell_connector

class SWATPercolation(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::SWATPercolation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def use_for_cell(*args):
        """
        use_for_cell(Cell cell, bool no_override = True)
        use_for_cell(Cell cell)
        """
        return _cmf.SWATPercolation_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    def __init__(self, *args): 
        """__init__(self, SoilWaterStorage upperLayer, SoilWaterStorage lowerLayer) -> SWATPercolation"""
        _cmf.SWATPercolation_swiginit(self,_cmf.new_SWATPercolation(*args))
    __swig_destroy__ = _cmf.delete_SWATPercolation
SWATPercolation_swigregister = _cmf.SWATPercolation_swigregister
SWATPercolation_swigregister(SWATPercolation)

def SWATPercolation_use_for_cell(*args):
  """
    use_for_cell(Cell cell, bool no_override = True)
    SWATPercolation_use_for_cell(Cell cell)
    """
  return _cmf.SWATPercolation_use_for_cell(*args)

class Richards(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::Richards class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowArea = 0, 
            real Distance = 0) -> Richards
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowArea = 0) -> Richards
        __init__(self, SoilWaterStorage left, FluxNode right) -> Richards
        """
        _cmf.Richards_swiginit(self,_cmf.new_Richards(*args))
    def use_for_cell(*args):
        """
        use_for_cell(Cell cell, bool no_override = True)
        use_for_cell(Cell cell)
        """
        return _cmf.Richards_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_Richards
Richards_swigregister = _cmf.Richards_swigregister
Richards_swigregister(Richards)
Richards.cell_connector = _cmf.cvar.Richards_cell_connector

def Richards_use_for_cell(*args):
  """
    use_for_cell(Cell cell, bool no_override = True)
    Richards_use_for_cell(Cell cell)
    """
  return _cmf.Richards_use_for_cell(*args)

class Richards_lateral(Richards):
    """Proxy of C++ cmf::upslope::connections::Richards_lateral class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0, 
            real Distance = 0) -> Richards_lateral
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0) -> Richards_lateral
        __init__(self, SoilWaterStorage left, FluxNode right) -> Richards_lateral
        """
        _cmf.Richards_lateral_swiginit(self,_cmf.new_Richards_lateral(*args))
    __swig_destroy__ = _cmf.delete_Richards_lateral
Richards_lateral_swigregister = _cmf.Richards_lateral_swigregister
Richards_lateral_swigregister(Richards_lateral)

class UnsaturatedDarcy(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::UnsaturatedDarcy class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, SoilWaterStorage right, real FlowArea = 0, 
            real Distance = 0) -> UnsaturatedDarcy
        __init__(self, SoilWaterStorage left, SoilWaterStorage right, real FlowArea = 0) -> UnsaturatedDarcy
        __init__(self, SoilWaterStorage left, SoilWaterStorage right) -> UnsaturatedDarcy
        """
        _cmf.UnsaturatedDarcy_swiginit(self,_cmf.new_UnsaturatedDarcy(*args))
    def use_for_cell(*args):
        """
        use_for_cell(Cell cell, bool no_override = True)
        use_for_cell(Cell cell)
        """
        return _cmf.UnsaturatedDarcy_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_UnsaturatedDarcy
UnsaturatedDarcy_swigregister = _cmf.UnsaturatedDarcy_swigregister
UnsaturatedDarcy_swigregister(UnsaturatedDarcy)

def UnsaturatedDarcy_use_for_cell(*args):
  """
    use_for_cell(Cell cell, bool no_override = True)
    UnsaturatedDarcy_use_for_cell(Cell cell)
    """
  return _cmf.UnsaturatedDarcy_use_for_cell(*args)
UnsaturatedDarcy.cell_connector = _cmf.cvar.UnsaturatedDarcy_cell_connector

class CanopyOverflow(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::CanopyOverflow class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage Canopy, FluxNode target, Cell cell) -> CanopyOverflow

        CanopyOverflow(cmf::water::WaterStorage &Canopy, cmf::water::FluxNode
        &target, cmf::upslope::Cell &cell) 
        """
        _cmf.CanopyOverflow_swiginit(self,_cmf.new_CanopyOverflow(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell) -> CanopyOverflow"""
        return _cmf.CanopyOverflow_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_CanopyOverflow
CanopyOverflow_swigregister = _cmf.CanopyOverflow_swigregister
CanopyOverflow_swigregister(CanopyOverflow)

def CanopyOverflow_use_for_cell(*args):
  """CanopyOverflow_use_for_cell(Cell cell) -> CanopyOverflow"""
  return _cmf.CanopyOverflow_use_for_cell(*args)

class SimpleTindexSnowMelt(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::SimpleTindexSnowMelt class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SnowMeltRate = _swig_property(_cmf.SimpleTindexSnowMelt_SnowMeltRate_get, _cmf.SimpleTindexSnowMelt_SnowMeltRate_set)
    def __init__(self, *args): 
        """__init__(self, WaterStorage snow, FluxNode surface_water, Cell cell) -> SimpleTindexSnowMelt"""
        _cmf.SimpleTindexSnowMelt_swiginit(self,_cmf.new_SimpleTindexSnowMelt(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf.SimpleTindexSnowMelt_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_SimpleTindexSnowMelt
SimpleTindexSnowMelt_swigregister = _cmf.SimpleTindexSnowMelt_swigregister
SimpleTindexSnowMelt_swigregister(SimpleTindexSnowMelt)

def SimpleTindexSnowMelt_use_for_cell(*args):
  """SimpleTindexSnowMelt_use_for_cell(Cell cell)"""
  return _cmf.SimpleTindexSnowMelt_use_for_cell(*args)

class SnowWaterOverflow(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::SnowWaterOverflow class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    RelCapacity = _swig_property(_cmf.SnowWaterOverflow_RelCapacity_get, _cmf.SnowWaterOverflow_RelCapacity_set)
    SnowConductivity = _swig_property(_cmf.SnowWaterOverflow_SnowConductivity_get, _cmf.SnowWaterOverflow_SnowConductivity_set)
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage snow_water, FluxNode surface_water, WaterStorage snow, 
            Cell cell, real relative_capacity = 0.1, 
            real snowConductivity = 864.) -> SnowWaterOverflow
        __init__(self, WaterStorage snow_water, FluxNode surface_water, WaterStorage snow, 
            Cell cell, real relative_capacity = 0.1) -> SnowWaterOverflow
        __init__(self, WaterStorage snow_water, FluxNode surface_water, WaterStorage snow, 
            Cell cell) -> SnowWaterOverflow
        """
        _cmf.SnowWaterOverflow_swiginit(self,_cmf.new_SnowWaterOverflow(*args))
    __swig_destroy__ = _cmf.delete_SnowWaterOverflow
SnowWaterOverflow_swigregister = _cmf.SnowWaterOverflow_swigregister
SnowWaterOverflow_swigregister(SnowWaterOverflow)

class HBVSnowMelt(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::HBVSnowMelt class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SnowMeltRate = _swig_property(_cmf.HBVSnowMelt_SnowMeltRate_get, _cmf.HBVSnowMelt_SnowMeltRate_set)
    RefreezeRate = _swig_property(_cmf.HBVSnowMelt_RefreezeRate_get, _cmf.HBVSnowMelt_RefreezeRate_set)
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage snow, WaterStorage snow_water, Cell cell, 
            real snowmeltrate = 7, real refreezeRate = 0.05) -> HBVSnowMelt
        __init__(self, WaterStorage snow, WaterStorage snow_water, Cell cell, 
            real snowmeltrate = 7) -> HBVSnowMelt
        __init__(self, WaterStorage snow, WaterStorage snow_water, Cell cell) -> HBVSnowMelt
        """
        _cmf.HBVSnowMelt_swiginit(self,_cmf.new_HBVSnowMelt(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell) -> HBVSnowMelt"""
        return _cmf.HBVSnowMelt_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_HBVSnowMelt
HBVSnowMelt_swigregister = _cmf.HBVSnowMelt_swigregister
HBVSnowMelt_swigregister(HBVSnowMelt)

def HBVSnowMelt_use_for_cell(*args):
  """HBVSnowMelt_use_for_cell(Cell cell) -> HBVSnowMelt"""
  return _cmf.HBVSnowMelt_use_for_cell(*args)

class Rainfall(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::Rainfall class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Throughfall = _swig_property(_cmf.Rainfall_Throughfall_get, _cmf.Rainfall_Throughfall_set)
    InterceptedRainfall = _swig_property(_cmf.Rainfall_InterceptedRainfall_get, _cmf.Rainfall_InterceptedRainfall_set)
    def __init__(self, *args): 
        """
        __init__(self, FluxNode target, Cell cell, bool getthroughfall = True, 
            bool getintercepted = True) -> Rainfall
        __init__(self, FluxNode target, Cell cell, bool getthroughfall = True) -> Rainfall
        __init__(self, FluxNode target, Cell cell) -> Rainfall
        """
        _cmf.Rainfall_swiginit(self,_cmf.new_Rainfall(*args))
    __swig_destroy__ = _cmf.delete_Rainfall
Rainfall_swigregister = _cmf.Rainfall_swigregister
Rainfall_swigregister(Rainfall)

class Snowfall(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::Snowfall class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, FluxNode target, Cell cell) -> Snowfall"""
        _cmf.Snowfall_swiginit(self,_cmf.new_Snowfall(*args))
    __swig_destroy__ = _cmf.delete_Snowfall
Snowfall_swigregister = _cmf.Snowfall_swigregister
Snowfall_swigregister(Snowfall)

class MatrixInfiltration(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::MatrixInfiltration class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, SoilWaterStorage soilwater, FluxNode surfacewater) -> MatrixInfiltration"""
        _cmf.MatrixInfiltration_swiginit(self,_cmf.new_MatrixInfiltration(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell c)"""
        return _cmf.MatrixInfiltration_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_MatrixInfiltration
MatrixInfiltration_swigregister = _cmf.MatrixInfiltration_swigregister
MatrixInfiltration_swigregister(MatrixInfiltration)

def MatrixInfiltration_use_for_cell(*args):
  """MatrixInfiltration_use_for_cell(Cell c)"""
  return _cmf.MatrixInfiltration_use_for_cell(*args)

class CompleteInfiltration(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::CompleteInfiltration class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, SoilWaterStorage soilwater, FluxNode surfacewater) -> CompleteInfiltration"""
        _cmf.CompleteInfiltration_swiginit(self,_cmf.new_CompleteInfiltration(*args))
    __swig_destroy__ = _cmf.delete_CompleteInfiltration
CompleteInfiltration_swigregister = _cmf.CompleteInfiltration_swigregister
CompleteInfiltration_swigregister(CompleteInfiltration)


def Tact(*args):
  """Tact(real Tpot, SoilWaterStorage sw, Vegetation veg) -> real"""
  return _cmf.Tact(*args)
class constantETpot(FluxConnection):
    """Proxy of C++ cmf::upslope::ET::constantETpot class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    ETpot_value = _swig_property(_cmf.constantETpot_ETpot_value_get, _cmf.constantETpot_ETpot_value_set)
    def GetETpot(self, *args):
        """
        GetETpot(self, Time t) -> real

        real GetETpot(cmf::math::Time t) const =0 
        """
        return _cmf.constantETpot_GetETpot(self, *args)

    __swig_destroy__ = _cmf.delete_constantETpot
constantETpot.GetETpot = new_instancemethod(_cmf.constantETpot_GetETpot,None,constantETpot)
constantETpot_swigregister = _cmf.constantETpot_swigregister
constantETpot_swigregister(constantETpot)

def PenmanMonteith(*args):
  """
    PenmanMonteith(real Rn, real ra, real rs, real T, real vap_press_deficit) -> real
    PenmanMonteith(Weather A, Vegetation veg, double h) -> real

    real
    cmf::upslope::ET::PenmanMonteith(cmf::atmosphere::Weather A, const
    cmf::upslope::vegetation::Vegetation &veg, double h) 
    """
  return _cmf.PenmanMonteith(*args)

class PenmanMonteithET(FluxConnection):
    """
    Calculates the potential evapotranspiration according to FAO(1998)
    \\begin{eqnarray*} \\lambda ET &=& \\frac{\\Delta\\left(R_n
    - G\\right)+\\rho_a c_p \\frac{e_s - e_a}{r_a}}{\\Delta +
    \\gamma\\left(1+\\frac{r_s}{r_a}\\right)} \\mbox{ FAO 1998,
    Eq. 3} \\\\ \\mbox{With:} \\\\ \\Delta &=& 4098
    \\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\frac{kPa}{^\\circ C}
    \\mbox{ (FAO 1998, Eq. 13): Slope of vapor pressure } \\\\ T &=&
    \\mbox{Actual Temperature in } ^\\circ C \\\\ R_n &=&
    \\mbox{net Radiation (see Atmosphere) in } \\frac{MJ}{m^2day}
    \\\\ G &=& 0 \\ \\frac{MJ}{m^2day} \\mbox{ if daily average
    (FAO 1998, Eq. 42)} \\\\ && 0.1 R_n \\ \\mbox{ if day time
    (FAO 1998, Eq. 45)} \\\\ && 0.5 R_n \\ \\mbox{ if night time
    (FAO 1998, Eq. 46)} \\\\ \\gamma &=& \\frac{c_p P}{\\epsilon
    \\lambda} \\mbox{ (FAO 1998,Eq. 8): Psychrometric constant }
    \\frac{kPa}{^\\circ C} \\\\ c_p &=& 0.001013
    \\frac{MJ}{kg\\ ^\\circ C}\\mbox{ specific heat at constant
    pressure } \\\\ P &=& 101.3
    \\left(\\frac{293-0.0065z}{293}\\right)^{5.26} \\mbox{ (FAO
    1998,Eq. 7): Mean pressure kPa as a function of elevation above sea
    level in m} \\\\ \\epsilon &=& 0.622 \\mbox{ ratio molecular
    weight of water vapour/dry air} \\\\ \\lambda &=& 2.45
    \\frac{MJ}{kg} \\mbox{ (FAO 1998,Eq. 8): latent heat of
    vaporization} \\\\ R &=& 0.287 \\frac{kJ}{kg\\ k}\\mbox{
    Specific gas constant } \\\\ \\rho_a &=&
    \\frac{P}{1.01(T+273)R} \\mbox{ (FAO 1998,Box. 6): Mean air
    density at constant pressure} \\\\ e_s &=& \\mbox{ Saturated
    vapor pressure (see Atmosphere) in } kPa \\\\ e_a &=& \\mbox{
    Actual vapor pressure (see Atmosphere) in } kPa \\\\ r_a &=&
    \\frac{\\ln\\left(\\frac{2-d}{z_{om}}\\right)\\ln\\left(\\frac{2-d}{z_{oh}}\\right)}{k^2
    u_2} \\mbox{ (FAO 1998, Eq. 4/Box 4): Aerodynamic resitance in }
    \\frac s m \\\\ && d=\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1
    z_{om}, k=0.41 \\\\ h &=& \\mbox{ Vegetation height in }m
    \\\\ u_2 &=& \\mbox{ Windspeed in 2m above ground (see
    Atmosphere) } \\frac m s \\\\ r_s &=&
    \\frac{r_l}{LAI_{Active}} \\mbox{ (FAO 1998, Eq. 5/Box 5): bulk
    surface resistance} \\frac s m \\\\ && r_l=100 \\frac s m,
    LAI_{Active}=0.5 LAI \\end{eqnarray*}.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    daily = _swig_property(_cmf.PenmanMonteithET_daily_get, _cmf.PenmanMonteithET_daily_set)
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage source, FluxNode ET_target) -> PenmanMonteithET

        PenmanMonteithET(cmf::upslope::SoilWaterStorage &source,
        cmf::water::FluxNode &ET_target, cmf::upslope::vegetation::Vegetation
        &VegetationAttributes, cmf::atmosphere::Meteorology &meteo) 
        """
        _cmf.PenmanMonteithET_swiginit(self,_cmf.new_PenmanMonteithET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf.PenmanMonteithET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_PenmanMonteithET
PenmanMonteithET_swigregister = _cmf.PenmanMonteithET_swigregister
PenmanMonteithET_swigregister(PenmanMonteithET)

def PenmanMonteithET_use_for_cell(*args):
  """PenmanMonteithET_use_for_cell(Cell cell)"""
  return _cmf.PenmanMonteithET_use_for_cell(*args)

class ShuttleworthWallaceET(FluxConnection):
    """
    Calculates the actual transpiration and the soil evaporation from a
    soil layer.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage source, FluxNode ET_target, Cell cell, 
            string Type = "Shuttleworth Wallace Evaporation") -> ShuttleworthWallaceET
        __init__(self, WaterStorage source, FluxNode ET_target, Cell cell) -> ShuttleworthWallaceET

        ShuttleworthWallaceET(cmf::upslope::SoilWaterStorage &source,
        cmf::water::FluxNode &ET_target, cmf::atmosphere::Meteorology &meteo)

        """
        _cmf.ShuttleworthWallaceET_swiginit(self,_cmf.new_ShuttleworthWallaceET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf.ShuttleworthWallaceET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_ShuttleworthWallaceET
ShuttleworthWallaceET_swigregister = _cmf.ShuttleworthWallaceET_swigregister
ShuttleworthWallaceET_swigregister(ShuttleworthWallaceET)

def ShuttleworthWallaceET_use_for_cell(*args):
  """ShuttleworthWallaceET_use_for_cell(Cell cell)"""
  return _cmf.ShuttleworthWallaceET_use_for_cell(*args)

class HargreaveET(FluxConnection):
    """Proxy of C++ cmf::upslope::ET::HargreaveET class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, SoilWaterStorage source, FluxNode ET_target) -> HargreaveET"""
        _cmf.HargreaveET_swiginit(self,_cmf.new_HargreaveET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf.HargreaveET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf.delete_HargreaveET
HargreaveET_swigregister = _cmf.HargreaveET_swigregister
HargreaveET_swigregister(HargreaveET)

def HargreaveET_use_for_cell(*args):
  """HargreaveET_use_for_cell(Cell cell)"""
  return _cmf.HargreaveET_use_for_cell(*args)

class CanopyStorageEvaporation(FluxConnection):
    """
    Calculates the evaporation from a canopy storage.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage CanopyStorage, FluxNode ET_target, Cell cell) -> CanopyStorageEvaporation

        CanopyStorageEvaporation(cmf::water::FluxNode &CanopyStorage,
        cmf::water::FluxNode &ET_target, const cmf::atmosphere::Meteorology
        &meteo, cmf::upslope::Cell &cell) 
        """
        _cmf.CanopyStorageEvaporation_swiginit(self,_cmf.new_CanopyStorageEvaporation(*args))
    __swig_destroy__ = _cmf.delete_CanopyStorageEvaporation
CanopyStorageEvaporation_swigregister = _cmf.CanopyStorageEvaporation_swigregister
CanopyStorageEvaporation_swigregister(CanopyStorageEvaporation)

def connect(type,left_node,right_node,*args):
    connection=type(left_node,right_node,*args)
    connection.thisown=0

class IMap_Vegetation(object):
    """Proxy of C++ cmf::maps::IMap<(cmf::upslope::vegetation::Vegetation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get(self, *args):
        """
        get(self, point p) -> Vegetation
        get(self, double x, double y) -> Vegetation
        """
        return _cmf.IMap_Vegetation_get(self, *args)

    def has(self, *args):
        """
        has(self, double x, double y) -> bool
        has(self, point p) -> bool
        """
        return _cmf.IMap_Vegetation_has(self, *args)

    def __call__(self, *args):
        """__call__(self, double x, double y) -> Vegetation"""
        return _cmf.IMap_Vegetation___call__(self, *args)

    __swig_destroy__ = _cmf.delete_IMap_Vegetation
IMap_Vegetation.get = new_instancemethod(_cmf.IMap_Vegetation_get,None,IMap_Vegetation)
IMap_Vegetation.has = new_instancemethod(_cmf.IMap_Vegetation_has,None,IMap_Vegetation)
IMap_Vegetation.__call__ = new_instancemethod(_cmf.IMap_Vegetation___call__,None,IMap_Vegetation)
IMap_Vegetation_swigregister = _cmf.IMap_Vegetation_swigregister
IMap_Vegetation_swigregister(IMap_Vegetation)

class SingleValueMap_Vegetation(IMap_Vegetation):
    """Proxy of C++ cmf::maps::SingleValueMap<(cmf::upslope::vegetation::Vegetation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Vegetation value) -> SingleValueMap_Vegetation"""
        _cmf.SingleValueMap_Vegetation_swiginit(self,_cmf.new_SingleValueMap_Vegetation(*args))
    __swig_destroy__ = _cmf.delete_SingleValueMap_Vegetation
SingleValueMap_Vegetation_swigregister = _cmf.SingleValueMap_Vegetation_swigregister
SingleValueMap_Vegetation_swigregister(SingleValueMap_Vegetation)

class DiscreteRasterMap_Vegetation(IMap_Vegetation):
    """Proxy of C++ cmf::maps::DiscreteRasterMap<(cmf::upslope::vegetation::Vegetation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Raster = _swig_property(_cmf.DiscreteRasterMap_Vegetation_Raster_get, _cmf.DiscreteRasterMap_Vegetation_Raster_set)
    def add(self, *args):
        """add(self, int index, Vegetation value)"""
        return _cmf.DiscreteRasterMap_Vegetation_add(self, *args)

    def erase(self, *args):
        """erase(self, int index)"""
        return _cmf.DiscreteRasterMap_Vegetation_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, IntRaster raster, Vegetation NoDataValue = cmf::upslope::vegetation::Vegetation()) -> DiscreteRasterMap_Vegetation
        __init__(self, IntRaster raster) -> DiscreteRasterMap_Vegetation
        __init__(self, string RasterFileName, Vegetation NoDataValue = cmf::upslope::vegetation::Vegetation()) -> DiscreteRasterMap_Vegetation
        __init__(self, string RasterFileName) -> DiscreteRasterMap_Vegetation
        """
        _cmf.DiscreteRasterMap_Vegetation_swiginit(self,_cmf.new_DiscreteRasterMap_Vegetation(*args))
    __swig_destroy__ = _cmf.delete_DiscreteRasterMap_Vegetation
DiscreteRasterMap_Vegetation.add = new_instancemethod(_cmf.DiscreteRasterMap_Vegetation_add,None,DiscreteRasterMap_Vegetation)
DiscreteRasterMap_Vegetation.erase = new_instancemethod(_cmf.DiscreteRasterMap_Vegetation_erase,None,DiscreteRasterMap_Vegetation)
DiscreteRasterMap_Vegetation_swigregister = _cmf.DiscreteRasterMap_Vegetation_swigregister
DiscreteRasterMap_Vegetation_swigregister(DiscreteRasterMap_Vegetation)

class NearestNeighborMap_Vegetation(IMap_Vegetation):
    """Proxy of C++ cmf::maps::NearestNeighborMap<(cmf::upslope::vegetation::Vegetation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, point p, Vegetation value)
        add(self, double x, double y, Vegetation value)
        """
        return _cmf.NearestNeighborMap_Vegetation_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.NearestNeighborMap_Vegetation_erase(self, *args)

    zWeight = _swig_property(_cmf.NearestNeighborMap_Vegetation_zWeight_get, _cmf.NearestNeighborMap_Vegetation_zWeight_set)
    def size(self):
        """size(self) -> int"""
        return _cmf.NearestNeighborMap_Vegetation_size(self)

    def Position(self, *args):
        """Position(self, int index) -> point"""
        return _cmf.NearestNeighborMap_Vegetation_Position(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> Vegetation"""
        return _cmf.NearestNeighborMap_Vegetation_Value(self, *args)

    def __init__(self, z_Weight = 0): 
        """
        __init__(self, double z_Weight = 0) -> NearestNeighborMap_Vegetation
        __init__(self) -> NearestNeighborMap_Vegetation
        """
        _cmf.NearestNeighborMap_Vegetation_swiginit(self,_cmf.new_NearestNeighborMap_Vegetation(z_Weight))
    __swig_destroy__ = _cmf.delete_NearestNeighborMap_Vegetation
NearestNeighborMap_Vegetation.add = new_instancemethod(_cmf.NearestNeighborMap_Vegetation_add,None,NearestNeighborMap_Vegetation)
NearestNeighborMap_Vegetation.erase = new_instancemethod(_cmf.NearestNeighborMap_Vegetation_erase,None,NearestNeighborMap_Vegetation)
NearestNeighborMap_Vegetation.size = new_instancemethod(_cmf.NearestNeighborMap_Vegetation_size,None,NearestNeighborMap_Vegetation)
NearestNeighborMap_Vegetation.Position = new_instancemethod(_cmf.NearestNeighborMap_Vegetation_Position,None,NearestNeighborMap_Vegetation)
NearestNeighborMap_Vegetation.Value = new_instancemethod(_cmf.NearestNeighborMap_Vegetation_Value,None,NearestNeighborMap_Vegetation)
NearestNeighborMap_Vegetation_swigregister = _cmf.NearestNeighborMap_Vegetation_swigregister
NearestNeighborMap_Vegetation_swigregister(NearestNeighborMap_Vegetation)

class PolygonMap_Vegetation(IMap_Vegetation):
    """Proxy of C++ cmf::maps::PolygonMap<(cmf::upslope::vegetation::Vegetation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, Vegetation nodata = cmf::upslope::vegetation::Vegetation()) -> PolygonMap_Vegetation
        __init__(self) -> PolygonMap_Vegetation
        """
        _cmf.PolygonMap_Vegetation_swiginit(self,_cmf.new_PolygonMap_Vegetation(*args))
    def add(self, *args):
        """add(self, Ring polygon, Vegetation value)"""
        return _cmf.PolygonMap_Vegetation_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.PolygonMap_Vegetation_erase(self, *args)

    def size(self):
        """size(self) -> int"""
        return _cmf.PolygonMap_Vegetation_size(self)

    def Polygon(self, *args):
        """Polygon(self, int index) -> Ring"""
        return _cmf.PolygonMap_Vegetation_Polygon(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> Vegetation"""
        return _cmf.PolygonMap_Vegetation_Value(self, *args)

    __swig_destroy__ = _cmf.delete_PolygonMap_Vegetation
PolygonMap_Vegetation.add = new_instancemethod(_cmf.PolygonMap_Vegetation_add,None,PolygonMap_Vegetation)
PolygonMap_Vegetation.erase = new_instancemethod(_cmf.PolygonMap_Vegetation_erase,None,PolygonMap_Vegetation)
PolygonMap_Vegetation.size = new_instancemethod(_cmf.PolygonMap_Vegetation_size,None,PolygonMap_Vegetation)
PolygonMap_Vegetation.Polygon = new_instancemethod(_cmf.PolygonMap_Vegetation_Polygon,None,PolygonMap_Vegetation)
PolygonMap_Vegetation.Value = new_instancemethod(_cmf.PolygonMap_Vegetation_Value,None,PolygonMap_Vegetation)
PolygonMap_Vegetation_swigregister = _cmf.PolygonMap_Vegetation_swigregister
PolygonMap_Vegetation_swigregister(PolygonMap_Vegetation)

class IMap_RetentionCurve(object):
    """Proxy of C++ cmf::maps::IMap<(cmf::upslope::RCurve)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get(self, *args):
        """
        get(self, point p) -> RCurve
        get(self, double x, double y) -> RCurve
        """
        return _cmf.IMap_RetentionCurve_get(self, *args)

    def has(self, *args):
        """
        has(self, double x, double y) -> bool
        has(self, point p) -> bool
        """
        return _cmf.IMap_RetentionCurve_has(self, *args)

    def __call__(self, *args):
        """__call__(self, double x, double y) -> RCurve"""
        return _cmf.IMap_RetentionCurve___call__(self, *args)

    __swig_destroy__ = _cmf.delete_IMap_RetentionCurve
IMap_RetentionCurve.get = new_instancemethod(_cmf.IMap_RetentionCurve_get,None,IMap_RetentionCurve)
IMap_RetentionCurve.has = new_instancemethod(_cmf.IMap_RetentionCurve_has,None,IMap_RetentionCurve)
IMap_RetentionCurve.__call__ = new_instancemethod(_cmf.IMap_RetentionCurve___call__,None,IMap_RetentionCurve)
IMap_RetentionCurve_swigregister = _cmf.IMap_RetentionCurve_swigregister
IMap_RetentionCurve_swigregister(IMap_RetentionCurve)

class SingleValueMap_RetentionCurve(IMap_RetentionCurve):
    """Proxy of C++ cmf::maps::SingleValueMap<(cmf::upslope::RCurve)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, RCurve value) -> SingleValueMap_RetentionCurve"""
        _cmf.SingleValueMap_RetentionCurve_swiginit(self,_cmf.new_SingleValueMap_RetentionCurve(*args))
    __swig_destroy__ = _cmf.delete_SingleValueMap_RetentionCurve
SingleValueMap_RetentionCurve_swigregister = _cmf.SingleValueMap_RetentionCurve_swigregister
SingleValueMap_RetentionCurve_swigregister(SingleValueMap_RetentionCurve)

class DiscreteRasterMap_RetentionCurve(IMap_RetentionCurve):
    """Proxy of C++ cmf::maps::DiscreteRasterMap<(cmf::upslope::RCurve)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Raster = _swig_property(_cmf.DiscreteRasterMap_RetentionCurve_Raster_get, _cmf.DiscreteRasterMap_RetentionCurve_Raster_set)
    def add(self, *args):
        """add(self, int index, RCurve value)"""
        return _cmf.DiscreteRasterMap_RetentionCurve_add(self, *args)

    def erase(self, *args):
        """erase(self, int index)"""
        return _cmf.DiscreteRasterMap_RetentionCurve_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, IntRaster raster, RCurve NoDataValue = cmf::upslope::RCurve()) -> DiscreteRasterMap_RetentionCurve
        __init__(self, IntRaster raster) -> DiscreteRasterMap_RetentionCurve
        __init__(self, string RasterFileName, RCurve NoDataValue = cmf::upslope::RCurve()) -> DiscreteRasterMap_RetentionCurve
        __init__(self, string RasterFileName) -> DiscreteRasterMap_RetentionCurve
        """
        _cmf.DiscreteRasterMap_RetentionCurve_swiginit(self,_cmf.new_DiscreteRasterMap_RetentionCurve(*args))
    __swig_destroy__ = _cmf.delete_DiscreteRasterMap_RetentionCurve
DiscreteRasterMap_RetentionCurve.add = new_instancemethod(_cmf.DiscreteRasterMap_RetentionCurve_add,None,DiscreteRasterMap_RetentionCurve)
DiscreteRasterMap_RetentionCurve.erase = new_instancemethod(_cmf.DiscreteRasterMap_RetentionCurve_erase,None,DiscreteRasterMap_RetentionCurve)
DiscreteRasterMap_RetentionCurve_swigregister = _cmf.DiscreteRasterMap_RetentionCurve_swigregister
DiscreteRasterMap_RetentionCurve_swigregister(DiscreteRasterMap_RetentionCurve)

class NearestNeighborMap_RetentionCurve(IMap_RetentionCurve):
    """Proxy of C++ cmf::maps::NearestNeighborMap<(cmf::upslope::RCurve)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, point p, RCurve value)
        add(self, double x, double y, RCurve value)
        """
        return _cmf.NearestNeighborMap_RetentionCurve_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.NearestNeighborMap_RetentionCurve_erase(self, *args)

    zWeight = _swig_property(_cmf.NearestNeighborMap_RetentionCurve_zWeight_get, _cmf.NearestNeighborMap_RetentionCurve_zWeight_set)
    def size(self):
        """size(self) -> int"""
        return _cmf.NearestNeighborMap_RetentionCurve_size(self)

    def Position(self, *args):
        """Position(self, int index) -> point"""
        return _cmf.NearestNeighborMap_RetentionCurve_Position(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> RCurve"""
        return _cmf.NearestNeighborMap_RetentionCurve_Value(self, *args)

    def __init__(self, z_Weight = 0): 
        """
        __init__(self, double z_Weight = 0) -> NearestNeighborMap_RetentionCurve
        __init__(self) -> NearestNeighborMap_RetentionCurve
        """
        _cmf.NearestNeighborMap_RetentionCurve_swiginit(self,_cmf.new_NearestNeighborMap_RetentionCurve(z_Weight))
    __swig_destroy__ = _cmf.delete_NearestNeighborMap_RetentionCurve
NearestNeighborMap_RetentionCurve.add = new_instancemethod(_cmf.NearestNeighborMap_RetentionCurve_add,None,NearestNeighborMap_RetentionCurve)
NearestNeighborMap_RetentionCurve.erase = new_instancemethod(_cmf.NearestNeighborMap_RetentionCurve_erase,None,NearestNeighborMap_RetentionCurve)
NearestNeighborMap_RetentionCurve.size = new_instancemethod(_cmf.NearestNeighborMap_RetentionCurve_size,None,NearestNeighborMap_RetentionCurve)
NearestNeighborMap_RetentionCurve.Position = new_instancemethod(_cmf.NearestNeighborMap_RetentionCurve_Position,None,NearestNeighborMap_RetentionCurve)
NearestNeighborMap_RetentionCurve.Value = new_instancemethod(_cmf.NearestNeighborMap_RetentionCurve_Value,None,NearestNeighborMap_RetentionCurve)
NearestNeighborMap_RetentionCurve_swigregister = _cmf.NearestNeighborMap_RetentionCurve_swigregister
NearestNeighborMap_RetentionCurve_swigregister(NearestNeighborMap_RetentionCurve)

class PolygonMap_RetentionCurve(IMap_RetentionCurve):
    """Proxy of C++ cmf::maps::PolygonMap<(cmf::upslope::RCurve)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, RCurve nodata = cmf::upslope::RCurve()) -> PolygonMap_RetentionCurve
        __init__(self) -> PolygonMap_RetentionCurve
        """
        _cmf.PolygonMap_RetentionCurve_swiginit(self,_cmf.new_PolygonMap_RetentionCurve(*args))
    def add(self, *args):
        """add(self, Ring polygon, RCurve value)"""
        return _cmf.PolygonMap_RetentionCurve_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.PolygonMap_RetentionCurve_erase(self, *args)

    def size(self):
        """size(self) -> int"""
        return _cmf.PolygonMap_RetentionCurve_size(self)

    def Polygon(self, *args):
        """Polygon(self, int index) -> Ring"""
        return _cmf.PolygonMap_RetentionCurve_Polygon(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> RCurve"""
        return _cmf.PolygonMap_RetentionCurve_Value(self, *args)

    __swig_destroy__ = _cmf.delete_PolygonMap_RetentionCurve
PolygonMap_RetentionCurve.add = new_instancemethod(_cmf.PolygonMap_RetentionCurve_add,None,PolygonMap_RetentionCurve)
PolygonMap_RetentionCurve.erase = new_instancemethod(_cmf.PolygonMap_RetentionCurve_erase,None,PolygonMap_RetentionCurve)
PolygonMap_RetentionCurve.size = new_instancemethod(_cmf.PolygonMap_RetentionCurve_size,None,PolygonMap_RetentionCurve)
PolygonMap_RetentionCurve.Polygon = new_instancemethod(_cmf.PolygonMap_RetentionCurve_Polygon,None,PolygonMap_RetentionCurve)
PolygonMap_RetentionCurve.Value = new_instancemethod(_cmf.PolygonMap_RetentionCurve_Value,None,PolygonMap_RetentionCurve)
PolygonMap_RetentionCurve_swigregister = _cmf.PolygonMap_RetentionCurve_swigregister
PolygonMap_RetentionCurve_swigregister(PolygonMap_RetentionCurve)

class IMap_Profile(object):
    """Proxy of C++ cmf::maps::IMap<(cmf::upslope::Profile)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get(self, *args):
        """
        get(self, point p) -> Profile
        get(self, double x, double y) -> Profile
        """
        return _cmf.IMap_Profile_get(self, *args)

    def has(self, *args):
        """
        has(self, double x, double y) -> bool
        has(self, point p) -> bool
        """
        return _cmf.IMap_Profile_has(self, *args)

    def __call__(self, *args):
        """__call__(self, double x, double y) -> Profile"""
        return _cmf.IMap_Profile___call__(self, *args)

    __swig_destroy__ = _cmf.delete_IMap_Profile
IMap_Profile.get = new_instancemethod(_cmf.IMap_Profile_get,None,IMap_Profile)
IMap_Profile.has = new_instancemethod(_cmf.IMap_Profile_has,None,IMap_Profile)
IMap_Profile.__call__ = new_instancemethod(_cmf.IMap_Profile___call__,None,IMap_Profile)
IMap_Profile_swigregister = _cmf.IMap_Profile_swigregister
IMap_Profile_swigregister(IMap_Profile)

class SingleValueMap_Profile(IMap_Profile):
    """Proxy of C++ cmf::maps::SingleValueMap<(cmf::upslope::Profile)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Profile value) -> SingleValueMap_Profile"""
        _cmf.SingleValueMap_Profile_swiginit(self,_cmf.new_SingleValueMap_Profile(*args))
    __swig_destroy__ = _cmf.delete_SingleValueMap_Profile
SingleValueMap_Profile_swigregister = _cmf.SingleValueMap_Profile_swigregister
SingleValueMap_Profile_swigregister(SingleValueMap_Profile)

class DiscreteRasterMap_Profile(IMap_Profile):
    """Proxy of C++ cmf::maps::DiscreteRasterMap<(cmf::upslope::Profile)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Raster = _swig_property(_cmf.DiscreteRasterMap_Profile_Raster_get, _cmf.DiscreteRasterMap_Profile_Raster_set)
    def add(self, *args):
        """add(self, int index, Profile value)"""
        return _cmf.DiscreteRasterMap_Profile_add(self, *args)

    def erase(self, *args):
        """erase(self, int index)"""
        return _cmf.DiscreteRasterMap_Profile_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, IntRaster raster, Profile NoDataValue = cmf::upslope::Profile()) -> DiscreteRasterMap_Profile
        __init__(self, IntRaster raster) -> DiscreteRasterMap_Profile
        __init__(self, string RasterFileName, Profile NoDataValue = cmf::upslope::Profile()) -> DiscreteRasterMap_Profile
        __init__(self, string RasterFileName) -> DiscreteRasterMap_Profile
        """
        _cmf.DiscreteRasterMap_Profile_swiginit(self,_cmf.new_DiscreteRasterMap_Profile(*args))
    __swig_destroy__ = _cmf.delete_DiscreteRasterMap_Profile
DiscreteRasterMap_Profile.add = new_instancemethod(_cmf.DiscreteRasterMap_Profile_add,None,DiscreteRasterMap_Profile)
DiscreteRasterMap_Profile.erase = new_instancemethod(_cmf.DiscreteRasterMap_Profile_erase,None,DiscreteRasterMap_Profile)
DiscreteRasterMap_Profile_swigregister = _cmf.DiscreteRasterMap_Profile_swigregister
DiscreteRasterMap_Profile_swigregister(DiscreteRasterMap_Profile)

class NearestNeighborMap_Profile(IMap_Profile):
    """Proxy of C++ cmf::maps::NearestNeighborMap<(cmf::upslope::Profile)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, point p, Profile value)
        add(self, double x, double y, Profile value)
        """
        return _cmf.NearestNeighborMap_Profile_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.NearestNeighborMap_Profile_erase(self, *args)

    zWeight = _swig_property(_cmf.NearestNeighborMap_Profile_zWeight_get, _cmf.NearestNeighborMap_Profile_zWeight_set)
    def size(self):
        """size(self) -> int"""
        return _cmf.NearestNeighborMap_Profile_size(self)

    def Position(self, *args):
        """Position(self, int index) -> point"""
        return _cmf.NearestNeighborMap_Profile_Position(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> Profile"""
        return _cmf.NearestNeighborMap_Profile_Value(self, *args)

    def __init__(self, z_Weight = 0): 
        """
        __init__(self, double z_Weight = 0) -> NearestNeighborMap_Profile
        __init__(self) -> NearestNeighborMap_Profile
        """
        _cmf.NearestNeighborMap_Profile_swiginit(self,_cmf.new_NearestNeighborMap_Profile(z_Weight))
    __swig_destroy__ = _cmf.delete_NearestNeighborMap_Profile
NearestNeighborMap_Profile.add = new_instancemethod(_cmf.NearestNeighborMap_Profile_add,None,NearestNeighborMap_Profile)
NearestNeighborMap_Profile.erase = new_instancemethod(_cmf.NearestNeighborMap_Profile_erase,None,NearestNeighborMap_Profile)
NearestNeighborMap_Profile.size = new_instancemethod(_cmf.NearestNeighborMap_Profile_size,None,NearestNeighborMap_Profile)
NearestNeighborMap_Profile.Position = new_instancemethod(_cmf.NearestNeighborMap_Profile_Position,None,NearestNeighborMap_Profile)
NearestNeighborMap_Profile.Value = new_instancemethod(_cmf.NearestNeighborMap_Profile_Value,None,NearestNeighborMap_Profile)
NearestNeighborMap_Profile_swigregister = _cmf.NearestNeighborMap_Profile_swigregister
NearestNeighborMap_Profile_swigregister(NearestNeighborMap_Profile)

class PolygonMap_Profile(IMap_Profile):
    """Proxy of C++ cmf::maps::PolygonMap<(cmf::upslope::Profile)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, Profile nodata = cmf::upslope::Profile()) -> PolygonMap_Profile
        __init__(self) -> PolygonMap_Profile
        """
        _cmf.PolygonMap_Profile_swiginit(self,_cmf.new_PolygonMap_Profile(*args))
    def add(self, *args):
        """add(self, Ring polygon, Profile value)"""
        return _cmf.PolygonMap_Profile_add(self, *args)

    def erase(self, *args):
        """erase(self, int pos)"""
        return _cmf.PolygonMap_Profile_erase(self, *args)

    def size(self):
        """size(self) -> int"""
        return _cmf.PolygonMap_Profile_size(self)

    def Polygon(self, *args):
        """Polygon(self, int index) -> Ring"""
        return _cmf.PolygonMap_Profile_Polygon(self, *args)

    def Value(self, *args):
        """Value(self, int index) -> Profile"""
        return _cmf.PolygonMap_Profile_Value(self, *args)

    __swig_destroy__ = _cmf.delete_PolygonMap_Profile
PolygonMap_Profile.add = new_instancemethod(_cmf.PolygonMap_Profile_add,None,PolygonMap_Profile)
PolygonMap_Profile.erase = new_instancemethod(_cmf.PolygonMap_Profile_erase,None,PolygonMap_Profile)
PolygonMap_Profile.size = new_instancemethod(_cmf.PolygonMap_Profile_size,None,PolygonMap_Profile)
PolygonMap_Profile.Polygon = new_instancemethod(_cmf.PolygonMap_Profile_Polygon,None,PolygonMap_Profile)
PolygonMap_Profile.Value = new_instancemethod(_cmf.PolygonMap_Profile_Value,None,PolygonMap_Profile)
PolygonMap_Profile_swigregister = _cmf.PolygonMap_Profile_swigregister
PolygonMap_Profile_swigregister(PolygonMap_Profile)

class ReachType(object):
    """
    Structure for the description of structural parameters of a reach
    Abstract base class for different channel geometries.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    nManning = _swig_property(_cmf.ReachType_nManning_get, _cmf.ReachType_nManning_set)
    def Width(self, *args):
        """
        Width(self, double depth) -> double

        virtual double
        Width(double depth) const =0

        Calculates the flow width from a given actual depth [m] using the
        actual channel geometry. 
        """
        return _cmf.ReachType_Width(self, *args)

    def Perimeter(self, *args):
        """
        Perimeter(self, double depth) -> double

        virtual
        double Perimeter(double depth) const =0

        Calculates the wetted perimeter from a given actual depth [m] using
        the actual channel geometry. 
        """
        return _cmf.ReachType_Perimeter(self, *args)

    def Depth(self, *args):
        """
        Depth(self, double area) -> double

        virtual double
        Depth(double area) const =0

        Calculates the actual depth of the reach using the channel geometry.

        Depth of the reach [m]

        Parameters:
        -----------

        area:  Wetted area of a river cross section [m2], can be obtained by
        V/l, where V is the stored volume and l is the reach length 
        """
        return _cmf.ReachType_Depth(self, *args)

    def Area(self, *args):
        """
        Area(self, double depth) -> double

        virtual double
        Area(double depth) const =0

        Calculates the wetted area from a given depth using the channel
        geometry. In most cases use Area=V/l, where V is the stored volume and
        l is the reach length.

        Wetted area of a river cross section [m2]

        Parameters:
        -----------

        depth:  Depth of the reach [m] 
        """
        return _cmf.ReachType_Area(self, *args)

    def qManning(self, *args):
        """
        qManning(self, double A, double slope) -> double

        double
        qManning(double A, double slope) const

        Calculates the flow rate from a given water volume in the reach
        \\begin{eqnarray*} q_{Manning}&=& A R^{\\frac 23}
        \\sqrt{\\frac {\\Delta_z} n} \\\\ A &=& \\frac V l
        \\mbox{ Area of the wetted crossection, Volume per length}\\\\
        R&=&\\frac A P(d) \\\\ P(d)&=& \\mbox{ Perimeter of the wetted
        crossection, a function of reach depth} \\\\ d(V)&=& \\mbox{
        Depth of the reach} \\\\ \\Delta_z&=& \\frac{z_{max} -
        z_{min}}{l} \\mbox{ Slope of the reach} \\\\ \\end{eqnarray*}.

        Flow rate [m3/s]

        Parameters:
        -----------

        A:  The area of the cross section [m2]

        slope:  The slope of the reach [m/m] 
        """
        return _cmf.ReachType_qManning(self, *args)

    def copy(self):
        """copy(self) -> ReachType"""
        return _cmf.ReachType_copy(self)

    def AsChannel(self, *args):
        """AsChannel(self, double length) -> Channel"""
        return _cmf.ReachType_AsChannel(self, *args)

    __swig_destroy__ = _cmf.delete_ReachType
ReachType.Width = new_instancemethod(_cmf.ReachType_Width,None,ReachType)
ReachType.Perimeter = new_instancemethod(_cmf.ReachType_Perimeter,None,ReachType)
ReachType.Depth = new_instancemethod(_cmf.ReachType_Depth,None,ReachType)
ReachType.Area = new_instancemethod(_cmf.ReachType_Area,None,ReachType)
ReachType.qManning = new_instancemethod(_cmf.ReachType_qManning,None,ReachType)
ReachType.copy = new_instancemethod(_cmf.ReachType_copy,None,ReachType)
ReachType.AsChannel = new_instancemethod(_cmf.ReachType_AsChannel,None,ReachType)
ReachType_swigregister = _cmf.ReachType_swigregister
ReachType_swigregister(ReachType)

class SWATReachType(ReachType):
    """
    Structure for the description of structural parameters of a reach.

    Uses the SWAT channel geometry (see SWAT Theoretical Documentation,
    Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
    referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
    plain is not plain, but has a small slope=0.5%, but has an infinite
    width

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BottomWidth = _swig_property(_cmf.SWATReachType_BottomWidth_get, _cmf.SWATReachType_BottomWidth_set)
    ChannelDepth = _swig_property(_cmf.SWATReachType_ChannelDepth_get, _cmf.SWATReachType_ChannelDepth_set)
    BankSlope = _swig_property(_cmf.SWATReachType_BankSlope_get, _cmf.SWATReachType_BankSlope_set)
    FloodPlainSlope = _swig_property(_cmf.SWATReachType_FloodPlainSlope_get, _cmf.SWATReachType_FloodPlainSlope_set)
    def __init__(self, *args): 
        """
        __init__(self) -> SWATReachType
        __init__(self, double BankWidth, double Depth) -> SWATReachType

        SWATReachType(double BankWidth, double Depth)

        Creates a new reach structure from a give width and depth.

        Parameters:
        -----------

        BankWidth:  Width of the reach from bank to bank [m]

        Depth:  Depth of the reach [m] 
        """
        _cmf.SWATReachType_swiginit(self,_cmf.new_SWATReachType(*args))
    def copy(self):
        """copy(self) -> SWATReachType"""
        return _cmf.SWATReachType_copy(self)

    __swig_destroy__ = _cmf.delete_SWATReachType
SWATReachType.copy = new_instancemethod(_cmf.SWATReachType_copy,None,SWATReachType)
SWATReachType_swigregister = _cmf.SWATReachType_swigregister
SWATReachType_swigregister(SWATReachType)

class TriangularReach(ReachType):
    """
    Structure for the description of reaches with a triangular cross
    section.

    Although real triangular cross section reach are rarely met, a
    triangular reach does scale with its water load, and is therefore
    preferable in case where nothing about channel geometry is known

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BankSlope = _swig_property(_cmf.TriangularReach_BankSlope_get, _cmf.TriangularReach_BankSlope_set)
    def __init__(self, bankSlope = 2): 
        """
        __init__(self, double bankSlope = 2) -> TriangularReach
        __init__(self) -> TriangularReach

        TriangularReach(double bankSlope=2)

        Creates a new triangular reach type. 
        """
        _cmf.TriangularReach_swiginit(self,_cmf.new_TriangularReach(bankSlope))
    def copy(self):
        """copy(self) -> TriangularReach"""
        return _cmf.TriangularReach_copy(self)

    __swig_destroy__ = _cmf.delete_TriangularReach
TriangularReach.copy = new_instancemethod(_cmf.TriangularReach_copy,None,TriangularReach)
TriangularReach_swigregister = _cmf.TriangularReach_swigregister
TriangularReach_swigregister(TriangularReach)

class RectangularReach(ReachType):
    """Proxy of C++ cmf::river::RectangularReach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double width) -> RectangularReach"""
        _cmf.RectangularReach_swiginit(self,_cmf.new_RectangularReach(*args))
    def copy(self):
        """copy(self) -> RectangularReach"""
        return _cmf.RectangularReach_copy(self)

    __swig_destroy__ = _cmf.delete_RectangularReach
RectangularReach.copy = new_instancemethod(_cmf.RectangularReach_copy,None,RectangularReach)
RectangularReach_swigregister = _cmf.RectangularReach_swigregister
RectangularReach_swigregister(RectangularReach)

class PipeReach(ReachType):
    """Proxy of C++ cmf::river::PipeReach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double diameter) -> PipeReach"""
        _cmf.PipeReach_swiginit(self,_cmf.new_PipeReach(*args))
    def copy(self):
        """copy(self) -> PipeReach"""
        return _cmf.PipeReach_copy(self)

    __swig_destroy__ = _cmf.delete_PipeReach
PipeReach.copy = new_instancemethod(_cmf.PipeReach_copy,None,PipeReach)
PipeReach_swigregister = _cmf.PipeReach_swigregister
PipeReach_swigregister(PipeReach)

class VolumeHeightRelation(object):
    """Proxy of C++ cmf::river::VolumeHeightRelation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def h(self, *args):
        """h(self, real V) -> real"""
        return _cmf.VolumeHeightRelation_h(self, *args)

    def A(self, *args):
        """A(self, real V) -> real"""
        return _cmf.VolumeHeightRelation_A(self, *args)

    def copy(self):
        """copy(self) -> VolumeHeightRelation"""
        return _cmf.VolumeHeightRelation_copy(self)

    def __call__(self, *args):
        """__call__(self, real V) -> real"""
        return _cmf.VolumeHeightRelation___call__(self, *args)

    __swig_destroy__ = _cmf.delete_VolumeHeightRelation
VolumeHeightRelation.h = new_instancemethod(_cmf.VolumeHeightRelation_h,None,VolumeHeightRelation)
VolumeHeightRelation.A = new_instancemethod(_cmf.VolumeHeightRelation_A,None,VolumeHeightRelation)
VolumeHeightRelation.copy = new_instancemethod(_cmf.VolumeHeightRelation_copy,None,VolumeHeightRelation)
VolumeHeightRelation.__call__ = new_instancemethod(_cmf.VolumeHeightRelation___call__,None,VolumeHeightRelation)
VolumeHeightRelation_swigregister = _cmf.VolumeHeightRelation_swigregister
VolumeHeightRelation_swigregister(VolumeHeightRelation)

def create_reachtype(*args):
  """
    create_reachtype(char shortcut, double width = 1., double depth = 0.25) -> ReachType
    create_reachtype(char shortcut, double width = 1.) -> ReachType
    create_reachtype(char shortcut) -> ReachType
    """
  return _cmf.create_reachtype(*args)

class cuboid(VolumeHeightRelation):
    """Proxy of C++ cmf::river::cuboid class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Area = _swig_property(_cmf.cuboid_Area_get, _cmf.cuboid_Area_set)
    def __init__(self, *args): 
        """__init__(self, real base_area) -> cuboid"""
        _cmf.cuboid_swiginit(self,_cmf.new_cuboid(*args))
    def copy(self):
        """copy(self) -> cuboid"""
        return _cmf.cuboid_copy(self)

    __swig_destroy__ = _cmf.delete_cuboid
cuboid.copy = new_instancemethod(_cmf.cuboid_copy,None,cuboid)
cuboid_swigregister = _cmf.cuboid_swigregister
cuboid_swigregister(cuboid)

class exponential_area_decline(VolumeHeightRelation):
    """Proxy of C++ cmf::river::exponential_area_decline class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Area = _swig_property(_cmf.exponential_area_decline_Area_get, _cmf.exponential_area_decline_Area_set)
    half_area_depth = _swig_property(_cmf.exponential_area_decline_half_area_depth_get, _cmf.exponential_area_decline_half_area_depth_set)
    def A_d(self, *args):
        """A_d(self, real h) -> real"""
        return _cmf.exponential_area_decline_A_d(self, *args)

    def copy(self):
        """copy(self) -> exponential_area_decline"""
        return _cmf.exponential_area_decline_copy(self)

    def __init__(self, *args): 
        """__init__(self, real area, real _half_area_depth) -> exponential_area_decline"""
        _cmf.exponential_area_decline_swiginit(self,_cmf.new_exponential_area_decline(*args))
    __swig_destroy__ = _cmf.delete_exponential_area_decline
exponential_area_decline.A_d = new_instancemethod(_cmf.exponential_area_decline_A_d,None,exponential_area_decline)
exponential_area_decline.copy = new_instancemethod(_cmf.exponential_area_decline_copy,None,exponential_area_decline)
exponential_area_decline_swigregister = _cmf.exponential_area_decline_swigregister
exponential_area_decline_swigregister(exponential_area_decline)

class Channel(VolumeHeightRelation):
    """Proxy of C++ cmf::river::Channel class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Length = _swig_property(_cmf.Channel_Length_get, _cmf.Channel_Length_set)
    def __init__(self, *args): 
        """
        __init__(self, ReachType _type, real l) -> Channel
        __init__(self, char reach_type_shortcut, real l, real d = 0.25, real w = 1.) -> Channel
        __init__(self, char reach_type_shortcut, real l, real d = 0.25) -> Channel
        __init__(self, char reach_type_shortcut, real l) -> Channel
        """
        _cmf.Channel_swiginit(self,_cmf.new_Channel(*args))
    def copy(self):
        """copy(self) -> Channel"""
        return _cmf.Channel_copy(self)

    __swig_destroy__ = _cmf.delete_Channel
Channel.copy = new_instancemethod(_cmf.Channel_copy,None,Channel)
Channel_swigregister = _cmf.Channel_swigregister
Channel_swigregister(Channel)

class OpenWaterStorage(WaterStorage):
    """Proxy of C++ cmf::river::OpenWaterStorage class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetBaseTopography(self, *args):
        """SetBaseTopography(self, VolumeHeightRelation new_base_topo)"""
        return _cmf.OpenWaterStorage_SetBaseTopography(self, *args)

    def BaseTopography(self):
        """BaseTopography(self) -> VolumeHeightRelation"""
        return _cmf.OpenWaterStorage_BaseTopography(self)

    def h(self):
        """h(self) -> real"""
        return _cmf.OpenWaterStorage_h(self)

    def wet_area(self):
        """wet_area(self) -> real"""
        return _cmf.OpenWaterStorage_wet_area(self)

    def __init__(self, *args): 
        """
        __init__(self, project _project, real Area) -> OpenWaterStorage
        __init__(self, project _project, VolumeHeightRelation base_geo) -> OpenWaterStorage
        """
        _cmf.OpenWaterStorage_swiginit(self,_cmf.new_OpenWaterStorage(*args))
    def FromNode(*args):
        """FromNode(FluxNode node, real Area) -> OpenWaterStorage"""
        return _cmf.OpenWaterStorage_FromNode(*args)

    FromNode = staticmethod(FromNode)
    def cast(*args):
        """cast(FluxNode node) -> OpenWaterStorage"""
        return _cmf.OpenWaterStorage_cast(*args)

    cast = staticmethod(cast)
    __swig_destroy__ = _cmf.delete_OpenWaterStorage
OpenWaterStorage.SetBaseTopography = new_instancemethod(_cmf.OpenWaterStorage_SetBaseTopography,None,OpenWaterStorage)
OpenWaterStorage.BaseTopography = new_instancemethod(_cmf.OpenWaterStorage_BaseTopography,None,OpenWaterStorage)
OpenWaterStorage.h = new_instancemethod(_cmf.OpenWaterStorage_h,None,OpenWaterStorage)
OpenWaterStorage.wet_area = new_instancemethod(_cmf.OpenWaterStorage_wet_area,None,OpenWaterStorage)
OpenWaterStorage_swigregister = _cmf.OpenWaterStorage_swigregister
OpenWaterStorage_swigregister(OpenWaterStorage)

def OpenWaterStorage_FromNode(*args):
  """OpenWaterStorage_FromNode(FluxNode node, real Area) -> OpenWaterStorage"""
  return _cmf.OpenWaterStorage_FromNode(*args)

def OpenWaterStorage_cast(*args):
  """OpenWaterStorage_cast(FluxNode node) -> OpenWaterStorage"""
  return _cmf.OpenWaterStorage_cast(*args)


def AsOpenWater(*args):
  """AsOpenWater(FluxNode node) -> OpenWaterStorage"""
  return _cmf.AsOpenWater(*args)
class Manning(FluxConnection):
    """Proxy of C++ cmf::river::Manning class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def ChannelGeometry(self, *args):
        """
        ChannelGeometry(self) -> ReachType
        ChannelGeometry(self) -> ReachType
        """
        return _cmf.Manning_ChannelGeometry(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, OpenWaterStorage left, FluxNode right, ReachType ChannelShape, 
            real Distance) -> Manning
        """
        _cmf.Manning_swiginit(self,_cmf.new_Manning(*args))
    __swig_destroy__ = _cmf.delete_Manning
Manning.ChannelGeometry = new_instancemethod(_cmf.Manning_ChannelGeometry,None,Manning)
Manning_swigregister = _cmf.Manning_swigregister
Manning_swigregister(Manning)
Manning.cell_connector = _cmf.cvar.Manning_cell_connector

class TechnicalFlux(FluxConnection):
    """Proxy of C++ cmf::river::TechnicalFlux class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    MaxFlux = _swig_property(_cmf.TechnicalFlux_MaxFlux_get, _cmf.TechnicalFlux_MaxFlux_set)
    MinState = _swig_property(_cmf.TechnicalFlux_MinState_get, _cmf.TechnicalFlux_MinState_set)
    FluxDecreaseTime = _swig_property(_cmf.TechnicalFlux_FluxDecreaseTime_get, _cmf.TechnicalFlux_FluxDecreaseTime_set)
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage source, FluxNode target, real maximum_flux, 
            real minimal_state = 0, Time flux_decrease_time = h) -> TechnicalFlux
        __init__(self, WaterStorage source, FluxNode target, real maximum_flux, 
            real minimal_state = 0) -> TechnicalFlux
        __init__(self, WaterStorage source, FluxNode target, real maximum_flux) -> TechnicalFlux
        """
        _cmf.TechnicalFlux_swiginit(self,_cmf.new_TechnicalFlux(*args))
    __swig_destroy__ = _cmf.delete_TechnicalFlux
TechnicalFlux_swigregister = _cmf.TechnicalFlux_swigregister
TechnicalFlux_swigregister(TechnicalFlux)

class Reach(object):
    """Proxy of C++ cmf::river::Reach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_downstream(self, *args):
        """set_downstream(self, Reach downstream_reach)"""
        return _cmf.Reach_set_downstream(self, *args)

    def set_outlet(self, *args):
        """set_outlet(self, FluxNode outlet)"""
        return _cmf.Reach_set_outlet(self, *args)

    def set_dead_end(self):
        """set_dead_end(self)"""
        return _cmf.Reach_set_dead_end(self)

    def get_water(self):
        """get_water(self) -> OpenWaterStorage"""
        return _cmf.Reach_get_water(self)

    length = _swig_property(_cmf.Reach_length_get, _cmf.Reach_length_set)
    def get_upstream(self, *args):
        """get_upstream(self, int index) -> Reach"""
        return _cmf.Reach_get_upstream(self, *args)

    def upstream_count(self):
        """upstream_count(self) -> int"""
        return _cmf.Reach_upstream_count(self)

    def get_downstream(self):
        """get_downstream(self) -> Reach"""
        return _cmf.Reach_get_downstream(self)

    def get_root(self):
        """get_root(self) -> Reach"""
        return _cmf.Reach_get_root(self)

    def __lt__(self, *args):
        """__lt__(self, Reach cmp) -> bool"""
        return _cmf.Reach___lt__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Reach cmp) -> bool"""
        return _cmf.Reach___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Reach cmp) -> bool"""
        return _cmf.Reach___ne__(self, *args)

    @property
    def upstream(self):
        """Returns a generator to iterate over each reach upstream from self, inlcuding self"""
        return [self.get_upstream(i) for i in range(self.upstream_count)]

    __swig_destroy__ = _cmf.delete_Reach
Reach.set_downstream = new_instancemethod(_cmf.Reach_set_downstream,None,Reach)
Reach.set_outlet = new_instancemethod(_cmf.Reach_set_outlet,None,Reach)
Reach.set_dead_end = new_instancemethod(_cmf.Reach_set_dead_end,None,Reach)
Reach.get_water = new_instancemethod(_cmf.Reach_get_water,None,Reach)
Reach.get_upstream = new_instancemethod(_cmf.Reach_get_upstream,None,Reach)
Reach.upstream_count = new_instancemethod(_cmf.Reach_upstream_count,None,Reach)
Reach.get_downstream = new_instancemethod(_cmf.Reach_get_downstream,None,Reach)
Reach.get_root = new_instancemethod(_cmf.Reach_get_root,None,Reach)
Reach.__lt__ = new_instancemethod(_cmf.Reach___lt__,None,Reach)
Reach.__eq__ = new_instancemethod(_cmf.Reach___eq__,None,Reach)
Reach.__ne__ = new_instancemethod(_cmf.Reach___ne__,None,Reach)
Reach_swigregister = _cmf.Reach_swigregister
Reach_swigregister(Reach)

class ReachIterator(object):
    """Proxy of C++ cmf::river::ReachIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def next(self):
        """next(self) -> Reach"""
        return _cmf.ReachIterator_next(self)

    def valid(self):
        """valid(self) -> bool"""
        return _cmf.ReachIterator_valid(self)

    def __init__(self, *args): 
        """__init__(self, Reach first) -> ReachIterator"""
        _cmf.ReachIterator_swiginit(self,_cmf.new_ReachIterator(*args))
    def reach(self):
        """reach(self) -> Reach"""
        return _cmf.ReachIterator_reach(self)

    def __iter__(self):
        while self.valid():
            yield self.next()

    __swig_destroy__ = _cmf.delete_ReachIterator
ReachIterator.next = new_instancemethod(_cmf.ReachIterator_next,None,ReachIterator)
ReachIterator.valid = new_instancemethod(_cmf.ReachIterator_valid,None,ReachIterator)
ReachIterator.reach = new_instancemethod(_cmf.ReachIterator_reach,None,ReachIterator)
ReachIterator_swigregister = _cmf.ReachIterator_swigregister
ReachIterator_swigregister(ReachIterator)


def make_river_gap(*args):
  """make_river_gap(Reach root_reach) -> double"""
  return _cmf.make_river_gap(*args)

def boundary_cells(*args):
  """boundary_cells(cell_vector cells) -> cell_vector"""
  return _cmf.boundary_cells(*args)
class project(StateVariableOwner):
    """Proxy of C++ cmf::project class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    debug = _swig_property(_cmf.project_debug_get, _cmf.project_debug_set)
    def __init__(self): 
        """__init__(self) -> project"""
        _cmf.project_swiginit(self,_cmf.new_project())
    __swig_destroy__ = _cmf.delete_project
    def Meteorology(self):
        """Meteorology(self) -> Meteorology"""
        return _cmf.project_Meteorology(self)

    def LoadMeteorology(self, *args):
        """LoadMeteorology(self, string filename)"""
        return _cmf.project_LoadMeteorology(self, *args)

    def Weather(self, *args):
        """Weather(self, Time t, double x, double y, double z) -> Weather"""
        return _cmf.project_Weather(self, *args)

    def SetMeteorology(self, *args):
        """SetMeteorology(self, Meteorology meteo)"""
        return _cmf.project_SetMeteorology(self, *args)

    def Rainfall(self, *args):
        """
        Rainfall(self) -> RainfallNode
        Rainfall(self, Time t, double x, double y, double z) -> real
        """
        return _cmf.project_Rainfall(self, *args)

    def SetPrecipitation(self, *args):
        """SetPrecipitation(self, PrecipitationData rainfall)"""
        return _cmf.project_SetPrecipitation(self, *args)

    def CellCount(self):
        """CellCount(self) -> int"""
        return _cmf.project_CellCount(self)

    def Area(self):
        """Area(self) -> double"""
        return _cmf.project_Area(self)

    def Cell(self, *args):
        """
        Cell(self, int ndx) -> Cell
        Cell(self, point p, double max_dist = 1e20) -> Cell
        Cell(self, point p) -> Cell
        """
        return _cmf.project_Cell(self, *args)

    def NewCell(self, *args):
        """
        NewCell(self, double x, double y, double z, double Area) -> Cell
        NewCell(self, point p, double Area) -> Cell
        """
        return _cmf.project_NewCell(self, *args)

    def AddOutlet(self, *args):
        """
        AddOutlet(self, string Name, point Location = cmf::geometry::point())
        AddOutlet(self, string Name)
        """
        return _cmf.project_AddOutlet(self, *args)

    def GetOutlet(self, *args):
        """GetOutlet(self, int index) -> FluxNode"""
        return _cmf.project_GetOutlet(self, *args)

    def OutletCount(self):
        """OutletCount(self) -> int"""
        return _cmf.project_OutletCount(self)

    def SetVegetation(self, *args):
        """SetVegetation(self, IMap_Vegetation vegmap)"""
        return _cmf.project_SetVegetation(self, *args)

    def AddCellsFromDEM(self, *args):
        """
        AddCellsFromDEM(self, DoubleRaster dem)
        AddCellsFromDEM(self, string ASCFileName)
        """
        return _cmf.project_AddCellsFromDEM(self, *args)

    def AddCellsFromPolygons(self, *args):
        """
        AddCellsFromPolygons(self, Polygons polygons, Points centers, double slither_tolerance = 0.1)
        AddCellsFromPolygons(self, Polygons polygons, Points centers)
        """
        return _cmf.project_AddCellsFromPolygons(self, *args)

    def AddFlexibleSaturatedZone(self, *args):
        """
        AddFlexibleSaturatedZone(self, IMap_RetentionCurve r_curve_map, IMap_Double soildepth_map)
        AddFlexibleSaturatedZone(self, IMap_RetentionCurve r_curve_map, double soildepth = 1.0)
        AddFlexibleSaturatedZone(self, IMap_RetentionCurve r_curve_map)
        """
        return _cmf.project_AddFlexibleSaturatedZone(self, *args)

    def AddLayers(self, *args):
        """
        AddLayers(self, IMap_Profile r_curve_map, IMap_Double soildepth_map)
        AddLayers(self, IMap_Profile r_curve_map)
        """
        return _cmf.project_AddLayers(self, *args)

    def Connect(self, *args):
        """
        Connect(self, CellConnector connect, int start_at_layer = 0)
        Connect(self, CellConnector connect)
        """
        return _cmf.project_Connect(self, *args)

    def get_connections(self):
        """get_connections(self) -> connection_set"""
        return _cmf.project_get_connections(self)

    def ClearLayers(self):
        """ClearLayers(self)"""
        return _cmf.project_ClearLayers(self)

    @property
    def cells(self):
        for i in range(self.CellCount()):
            yield self.Cell(i)
    def __iter__(self):
        return self.cells
    def __len__(self):
        return self.CellCount()
    def __getitem__(self,index):
        if isinstance(index,slice):
            return [self.Cell(i) for i in range(*index.indices(len(p)))]
        return self.Cell(index)
    def cell_list(self,expression='True'):
        res=[]
        f=lambda cell:eval(expression)
        for cell in self.cells():
            if f(cell):
                res.append(cell)
        return res

project.Meteorology = new_instancemethod(_cmf.project_Meteorology,None,project)
project.LoadMeteorology = new_instancemethod(_cmf.project_LoadMeteorology,None,project)
project.Weather = new_instancemethod(_cmf.project_Weather,None,project)
project.SetMeteorology = new_instancemethod(_cmf.project_SetMeteorology,None,project)
project.Rainfall = new_instancemethod(_cmf.project_Rainfall,None,project)
project.SetPrecipitation = new_instancemethod(_cmf.project_SetPrecipitation,None,project)
project.CellCount = new_instancemethod(_cmf.project_CellCount,None,project)
project.Area = new_instancemethod(_cmf.project_Area,None,project)
project.Cell = new_instancemethod(_cmf.project_Cell,None,project)
project.NewCell = new_instancemethod(_cmf.project_NewCell,None,project)
project.AddOutlet = new_instancemethod(_cmf.project_AddOutlet,None,project)
project.GetOutlet = new_instancemethod(_cmf.project_GetOutlet,None,project)
project.OutletCount = new_instancemethod(_cmf.project_OutletCount,None,project)
project.SetVegetation = new_instancemethod(_cmf.project_SetVegetation,None,project)
project.AddCellsFromDEM = new_instancemethod(_cmf.project_AddCellsFromDEM,None,project)
project.AddCellsFromPolygons = new_instancemethod(_cmf.project_AddCellsFromPolygons,None,project)
project.AddFlexibleSaturatedZone = new_instancemethod(_cmf.project_AddFlexibleSaturatedZone,None,project)
project.AddLayers = new_instancemethod(_cmf.project_AddLayers,None,project)
project.Connect = new_instancemethod(_cmf.project_Connect,None,project)
project.get_connections = new_instancemethod(_cmf.project_get_connections,None,project)
project.ClearLayers = new_instancemethod(_cmf.project_ClearLayers,None,project)
project_swigregister = _cmf.project_swigregister
project_swigregister(project)

def find_cell(*args):
  """
    find_cell(cell_vector cells, point p, double max_dist = 1e20) -> Cell
    find_cell(cell_vector cells, point p) -> Cell
    """
  return _cmf.find_cell(*args)

def get_layers(cells):
    for c in cells:
        for l in c:
           yield l
def count_layers(cells):
    res=0
    for c in cells:
        res+=c.LayerCount()
    return res
def query_layers(layers,expr='layer.theta()'):
    f=lambda layer:eval(expr)
    for l in layers:
        yield f(l)



