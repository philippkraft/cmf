# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.38
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _cmf_core.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        try:
            fp, pathname, description = imp.find_module('_cmf_core', [dirname(__file__)])
            _mod = imp.load_module('_cmf_core', fp, pathname, description)
        finally:
            if fp is not None: fp.close()
        return _mod
    _cmf_core = swig_import_helper()
    del swig_import_helper
else:
    import _cmf_core
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_SwigPyIterator
    def value(self):
        """value(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _cmf_core.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _cmf_core.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _cmf_core.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _cmf_core.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _cmf_core.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_cmf_core.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_cmf_core.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_cmf_core.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_cmf_core.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_cmf_core.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_cmf_core.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_cmf_core.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_cmf_core.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_cmf_core.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_cmf_core.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_cmf_core.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_cmf_core.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_cmf_core.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_cmf_core.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_cmf_core.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_cmf_core.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _cmf_core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class point(object):
    """
    2D-Point Class.

    Used as location property anywhere in the text Calculation of
    distances

    +,-,-=,*= Operators overloaded

    C++ includes: geometry.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_cmf_core.point_x_get, _cmf_core.point_x_set)
    y = _swig_property(_cmf_core.point_y_get, _cmf_core.point_y_set)
    z = _swig_property(_cmf_core.point_z_get, _cmf_core.point_z_set)
    def Center(self):
        """
        Center(self) -> point

        point Center()
        const 
        """
        return _cmf_core.point_Center(self)

    def __init__(self, *args): 
        """
        __init__(self) -> point
        __init__(self, point p) -> point
        __init__(self, double x_, double y_, double z_ = 0.0) -> point
        __init__(self, double x_, double y_) -> point

        point(double x_,
        double y_, double z_=0.0)

        Creates a point from two doubles. 
        """
        _cmf_core.point_swiginit(self,_cmf_core.new_point(*args))
    def distanceTo(self, *args):
        """
        distanceTo(self, point p) -> double

        double
        distanceTo(point p) const

        Returns the euclidian distance to another point.
        $\\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}$. 
        """
        return _cmf_core.point_distanceTo(self, *args)

    def distance3DTo(self, *args):
        """
        distance3DTo(self, point p) -> double

        double
        distance3DTo(point p) const 
        """
        return _cmf_core.point_distance3DTo(self, *args)

    def distance(*args):
        """distance(point p1, point p2) -> double"""
        return _cmf_core.point_distance(*args)

    distance = staticmethod(distance)
    def distance_max(self, *args):
        """
        distance_max(self, point p) -> double

        double
        distance_max(point p) const

        Returns the distance by the maximum orthogonal offset. 
        """
        return _cmf_core.point_distance_max(self, *args)

    def azimuth(self, *args):
        """
        azimuth(self, point p) -> double

        double
        azimuth(point p) const

        Returns the azimuth angle of the line $ \\overline{this,p} $ to the
        Azimuth in degrees. 
        """
        return _cmf_core.point_azimuth(self, *args)

    def angleToXAxis(self, *args):
        """
        angleToXAxis(self, point p) -> double

        double
        angleToXAxis(point p) const

        Returns the angle between the line $ \\overline{this,p} $ to the
        x-Axis in degrees. 
        """
        return _cmf_core.point_angleToXAxis(self, *args)

    def __add__(self, *args):
        """__add__(self, point p) -> point"""
        return _cmf_core.point___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, point p) -> point"""
        return _cmf_core.point___sub__(self, *args)

    def __mul__(self, *args):
        """__mul__(self, double left) -> point"""
        return _cmf_core.point___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, double left) -> point"""
        return _cmf_core.point___div__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, point p) -> point"""
        return _cmf_core.point___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, point p) -> point"""
        return _cmf_core.point___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, point p) -> bool"""
        return _cmf_core.point___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, point p) -> bool"""
        return _cmf_core.point___ne__(self, *args)

    def __len__(self):
        """__len__(self) -> int"""
        return _cmf_core.point___len__(self)

    def __getitem__(self,index) :
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(p)))]
        if index==0 :
            return self.x
        elif index==1 :
            return self.y
        elif index==2 :
            return self.z
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __setitem__(self,index,value) :
        if index==0 :
            self.x=value
        elif index==1 :
            self.y=value
        elif index==2 :
            self.z=value
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z
    def __repr__(self):
        return 'cmf.point(%g,%g,%g)' % (self.x,self.y,self.z)

    __swig_destroy__ = _cmf_core.delete_point
point.Center = new_instancemethod(_cmf_core.point_Center,None,point)
point.distanceTo = new_instancemethod(_cmf_core.point_distanceTo,None,point)
point.distance3DTo = new_instancemethod(_cmf_core.point_distance3DTo,None,point)
point.distance_max = new_instancemethod(_cmf_core.point_distance_max,None,point)
point.azimuth = new_instancemethod(_cmf_core.point_azimuth,None,point)
point.angleToXAxis = new_instancemethod(_cmf_core.point_angleToXAxis,None,point)
point.__add__ = new_instancemethod(_cmf_core.point___add__,None,point)
point.__sub__ = new_instancemethod(_cmf_core.point___sub__,None,point)
point.__mul__ = new_instancemethod(_cmf_core.point___mul__,None,point)
point.__div__ = new_instancemethod(_cmf_core.point___div__,None,point)
point.__iadd__ = new_instancemethod(_cmf_core.point___iadd__,None,point)
point.__isub__ = new_instancemethod(_cmf_core.point___isub__,None,point)
point.__eq__ = new_instancemethod(_cmf_core.point___eq__,None,point)
point.__ne__ = new_instancemethod(_cmf_core.point___ne__,None,point)
point.__len__ = new_instancemethod(_cmf_core.point___len__,None,point)
point_swigregister = _cmf_core.point_swigregister
point_swigregister(point)
cvar = _cmf_core.cvar
PI = cvar.PI

def point_distance(*args):
  """point_distance(point p1, point p2) -> double"""
  return _cmf_core.point_distance(*args)

class Points(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.Points_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf_core.Points___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf_core.Points___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf_core.Points___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf_core.Points_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> Points"""
        return _cmf_core.Points___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, Points v)"""
        return _cmf_core.Points___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.Points___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.Points___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> Points
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.Points___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, Points v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.Points___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.Points_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf_core.Points_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf_core.Points_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf_core.Points_clear(self)

    def swap(self, *args):
        """swap(self, Points v)"""
        return _cmf_core.Points_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.Points_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf_core.Points_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf_core.Points_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.Points_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.Points_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf_core.Points_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.Points_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Points
        __init__(self, Points arg0) -> Points
        __init__(self, size_type size) -> Points
        __init__(self, size_type size, value_type value) -> Points
        """
        _cmf_core.Points_swiginit(self,_cmf_core.new_Points(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.Points_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf_core.Points_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf_core.Points_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.Points_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.Points_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.Points_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.Points_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf_core.Points_capacity(self)

    __swig_destroy__ = _cmf_core.delete_Points
Points.iterator = new_instancemethod(_cmf_core.Points_iterator,None,Points)
Points.__nonzero__ = new_instancemethod(_cmf_core.Points___nonzero__,None,Points)
Points.__bool__ = new_instancemethod(_cmf_core.Points___bool__,None,Points)
Points.__len__ = new_instancemethod(_cmf_core.Points___len__,None,Points)
Points.pop = new_instancemethod(_cmf_core.Points_pop,None,Points)
Points.__getslice__ = new_instancemethod(_cmf_core.Points___getslice__,None,Points)
Points.__setslice__ = new_instancemethod(_cmf_core.Points___setslice__,None,Points)
Points.__delslice__ = new_instancemethod(_cmf_core.Points___delslice__,None,Points)
Points.__delitem__ = new_instancemethod(_cmf_core.Points___delitem__,None,Points)
Points.__getitem__ = new_instancemethod(_cmf_core.Points___getitem__,None,Points)
Points.__setitem__ = new_instancemethod(_cmf_core.Points___setitem__,None,Points)
Points.append = new_instancemethod(_cmf_core.Points_append,None,Points)
Points.empty = new_instancemethod(_cmf_core.Points_empty,None,Points)
Points.size = new_instancemethod(_cmf_core.Points_size,None,Points)
Points.clear = new_instancemethod(_cmf_core.Points_clear,None,Points)
Points.swap = new_instancemethod(_cmf_core.Points_swap,None,Points)
Points.get_allocator = new_instancemethod(_cmf_core.Points_get_allocator,None,Points)
Points.begin = new_instancemethod(_cmf_core.Points_begin,None,Points)
Points.end = new_instancemethod(_cmf_core.Points_end,None,Points)
Points.rbegin = new_instancemethod(_cmf_core.Points_rbegin,None,Points)
Points.rend = new_instancemethod(_cmf_core.Points_rend,None,Points)
Points.pop_back = new_instancemethod(_cmf_core.Points_pop_back,None,Points)
Points.erase = new_instancemethod(_cmf_core.Points_erase,None,Points)
Points.push_back = new_instancemethod(_cmf_core.Points_push_back,None,Points)
Points.front = new_instancemethod(_cmf_core.Points_front,None,Points)
Points.back = new_instancemethod(_cmf_core.Points_back,None,Points)
Points.assign = new_instancemethod(_cmf_core.Points_assign,None,Points)
Points.resize = new_instancemethod(_cmf_core.Points_resize,None,Points)
Points.insert = new_instancemethod(_cmf_core.Points_insert,None,Points)
Points.reserve = new_instancemethod(_cmf_core.Points_reserve,None,Points)
Points.capacity = new_instancemethod(_cmf_core.Points_capacity,None,Points)
Points_swigregister = _cmf_core.Points_swigregister
Points_swigregister(Points)

import datetime


def minimum(*args):
  """
    minimum(real a, real b) -> real

    real minimum(real a, real b)

    Returns the minimum of two values. 
    """
  return _cmf_core.minimum(*args)

def maximum(*args):
  """
    maximum(real a, real b) -> real

    real maximum(real a, real b) 
    """
  return _cmf_core.maximum(*args)

def minmax(*args):
  """
    minmax(real x, real min, real max) -> real

    real minmax(real x, real min, real
    max) 
    """
  return _cmf_core.minmax(*args)

def mean(*args):
  """mean(real a, real b) -> real"""
  return _cmf_core.mean(*args)

def geo_mean(*args):
  """geo_mean(real a, real b) -> real"""
  return _cmf_core.geo_mean(*args)

def boltzmann(*args):
  """boltzmann(real x, real tau, real x_half) -> real"""
  return _cmf_core.boltzmann(*args)

def sign(*args):
  """sign(real x) -> real"""
  return _cmf_core.sign(*args)

def square(*args):
  """square(real x) -> real"""
  return _cmf_core.square(*args)
JULIANDAY_0_1_1900 = _cmf_core.JULIANDAY_0_1_1900
class Time(object):
    """
    A time class, used to pass around current modelling times.

    Timespans and dates in cmf are used with a special object, called
    Time. The advantage of an extra class has the advantage, that the user
    does not has to rememember, which unit of time he or she uses or what
    time unit is accepted by a specific function of the model. Arithmetic
    and boolean operators are supported by Time. Internally the time
    classes stores the time as integer milliseconds, therefore rounding
    issues will only appear at very small time ranges. Absolute time (like
    dates) are represented as milliseconds gone by from Dec, 31st 1899.
    Microsoft Excel dates are represented as days from that time, using
    floating point numbers, therefore it is very simple to convert Excel
    time representations to cmf time.

    Another object is Date, which is doesn't provide the operators, but
    has a nice printed version and some special date functions, like day
    of year (DOY) and provides access to the current hour of day and so
    on, which only applyto dates and not to time spans. You can convert
    Time to Date an vice versa. The printing is not culture aware and uses
    the European representation. If you use the Python standard library
    datetime, conversion between Python time and cmf time is
    possibleCreating absolute time values (dates)

    import CMFlib as cmf                 # Create the time: Jan, 5th 2001,
    2:30 pm, 20s, 412 ms                 t=cmf.Time(5,1,2001,14,30,20,412)
    print t # Prints: '36896d:14:30:20.412h'                 print
    t.AsDate() # Prints: '05.01.2001 14:30:20.412'Creating time spans

    In principle, there are three ways to create time spans. One is to use
    one of the static functions, another is to multiply an existing time
    span (like one of the build in constants) or to substrate two absolute
    times.Available static functions, the default value is always 1

    Milliseconds(): t=cmf.Time.Milliseconds(4100), create a timespan of
    4.1 seconds

    Seconds(): t=cmf. Time.Seconds(4.1), create a timespan of 4.1 seconds

    Minutes(): t=cmf.Time.Minutes(138), create a timespan of 2.3 hours
    (138 min)

    Hours(): t=cmf. Time.Hours(2.3), create a timespan of 2.3 hours (138
    min)

    Days(): t=cmf. Time.Days(2.5), create a timespan of 60 hours

    Years(): t=cmf. Time.Years(), create a timespan of 365 days Available
    constants

    cmf.sec * 4.1: 4.1 seconds

    cmf.min * 138: 2.3 hours (138 min)

    cmf.h * 2.3: 2.3 hours (138 min)

    cmf.day * 2.5: 60 hours (2.5 days)

    cmf.week: 7 days

    cmf.month: 365/12 days (30.4167 days)

    cmf.year: 365 days Available operators:

    time + time = time, time - time = time

    time * float = time ,time / float = time

    time/time=float

    &gt, &lt, ==, != Conversions

    Converting to python datetime

    import CMFlib as cmf                 pythontime = cmf.year.AsPython()
    cmftime=cmf.AsCMFTime(pythontime)                 print
    type(pythontime) # '<type 'datetime.datetime'>'                 print
    type(cmftime)    # '<class 'CMFLib.Time'>'Converting to numbers

    t.AsMilliseconds()

    t.AsSeconds()

    t.AsMinutes()

    t.AsHours()

    t.AsDays()

    t.AsYears() Creating time ranges

    import CMFLib as cmf                 start=cmf.Time(5,1,2001)
    end=cmf.Time(6,1,2001)                 step=cmf.h * 6 for t in
    cmf.timerange(start,end,step):                     print t.AsDate()
    # Prints:                 # 05.01.2001 # 05.01.2001 06:00
    # 05.01.2001 12:00 # 05.01.2001 18:00

    C++ includes: Time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ms_per_day = _cmf_core.Time_ms_per_day
    def __init__(self, *args): 
        """
        __init__(self, double days) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0, 
            int minute = 0, int second = 0, int ms = 0) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0, 
            int minute = 0, int second = 0) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0, 
            int minute = 0) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0) -> Time
        __init__(self, int day, int month, int year = 2001) -> Time
        __init__(self, int day, int month) -> Time
        __init__(self, Date date) -> Time
        __init__(self, Time t) -> Time
        __init__(self) -> Time

        Time()

        Standard constructor. 
        """
        _cmf_core.Time_swiginit(self,_cmf_core.new_Time(*args))
    def AsDays(self):
        """
        AsDays(self) -> double

        double AsDays() const

        Time in days. 
        """
        return _cmf_core.Time_AsDays(self)

    def AsHours(self):
        """
        AsHours(self) -> double

        double AsHours()
        const

        Time in hours. 
        """
        return _cmf_core.Time_AsHours(self)

    def AsMinutes(self):
        """
        AsMinutes(self) -> double

        double AsMinutes()
        const

        Time in minutes. 
        """
        return _cmf_core.Time_AsMinutes(self)

    def AsSeconds(self):
        """
        AsSeconds(self) -> double

        double AsSeconds()
        const

        Time in seconds. 
        """
        return _cmf_core.Time_AsSeconds(self)

    def AsMilliseconds(self):
        """
        AsMilliseconds(self) -> long long

        long long
        AsMilliseconds() const

        Time in milliseconds. 
        """
        return _cmf_core.Time_AsMilliseconds(self)

    def AsDate(self):
        """
        AsDate(self) -> Date

        Date AsDate() const

        """
        return _cmf_core.Time_AsDate(self)

    def ToString(self, seperator = ':'):
        """
        ToString(self, char seperator = ':') -> string
        ToString(self) -> string

        std::string
        ToString(char seperator=':') 
        """
        return _cmf_core.Time_ToString(self, seperator)

    def __add__(self, *args):
        """__add__(self, Time t1) -> Time"""
        return _cmf_core.Time___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Time t1) -> Time"""
        return _cmf_core.Time___sub__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, Time t1) -> Time"""
        return _cmf_core.Time___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Time t1) -> Time"""
        return _cmf_core.Time___isub__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, double x) -> Time
        __mul__(self, int x) -> Time
        """
        return _cmf_core.Time___mul__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, double x) -> Time
        __imul__(self, int x) -> Time
        """
        return _cmf_core.Time___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, double x) -> Time
        __idiv__(self, int x) -> Time
        """
        return _cmf_core.Time___idiv__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, double x) -> Time
        __div__(self, int x) -> Time
        __div__(self, Time t1) -> double
        """
        return _cmf_core.Time___div__(self, *args)

    def __lt__(self, *args):
        """__lt__(self, Time t1) -> bool"""
        return _cmf_core.Time___lt__(self, *args)

    def __gt__(self, *args):
        """__gt__(self, Time t1) -> bool"""
        return _cmf_core.Time___gt__(self, *args)

    def __le__(self, *args):
        """__le__(self, Time t1) -> bool"""
        return _cmf_core.Time___le__(self, *args)

    def __ge__(self, *args):
        """__ge__(self, Time t1) -> bool"""
        return _cmf_core.Time___ge__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Time t1) -> bool"""
        return _cmf_core.Time___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Time t1) -> bool"""
        return _cmf_core.Time___ne__(self, *args)

    def NextDay(self):
        """
        NextDay(self) -> Time

        Time NextDay() const

        Returns the beginning of the next day. 
        """
        return _cmf_core.Time_NextDay(self)

    def NextFullHour(self):
        """
        NextFullHour(self) -> Time

        Time
        NextFullHour() const

        Returns the next full hour. 
        """
        return _cmf_core.Time_NextFullHour(self)

    def Years(y = 1):
        """
        Years(double y = 1) -> Time
        Years() -> Time
        """
        return _cmf_core.Time_Years(y)

    Years = staticmethod(Years)
    def Days(d = 1):
        """
        Days(double d = 1) -> Time
        Days() -> Time
        """
        return _cmf_core.Time_Days(d)

    Days = staticmethod(Days)
    def Hours(h = 1):
        """
        Hours(double h = 1) -> Time
        Hours() -> Time
        """
        return _cmf_core.Time_Hours(h)

    Hours = staticmethod(Hours)
    def Minutes(min = 1):
        """
        Minutes(double min = 1) -> Time
        Minutes() -> Time
        """
        return _cmf_core.Time_Minutes(min)

    Minutes = staticmethod(Minutes)
    def Seconds(secs = 1):
        """
        Seconds(double secs = 1) -> Time
        Seconds() -> Time
        """
        return _cmf_core.Time_Seconds(secs)

    Seconds = staticmethod(Seconds)
    def Milliseconds(ms = 1):
        """
        Milliseconds(long long ms = 1) -> Time
        Milliseconds() -> Time
        """
        return _cmf_core.Time_Milliseconds(ms)

    Milliseconds = staticmethod(Milliseconds)
    def __repr__(self):
        return self.ToString()
    def AsPython(self):
        d=self.AsDate()
        return datetime.datetime(d.year,d.month,d.day,d.hour,d.minute,d.second,d.ms*1000)

    __swig_destroy__ = _cmf_core.delete_Time
Time.AsDays = new_instancemethod(_cmf_core.Time_AsDays,None,Time)
Time.AsHours = new_instancemethod(_cmf_core.Time_AsHours,None,Time)
Time.AsMinutes = new_instancemethod(_cmf_core.Time_AsMinutes,None,Time)
Time.AsSeconds = new_instancemethod(_cmf_core.Time_AsSeconds,None,Time)
Time.AsMilliseconds = new_instancemethod(_cmf_core.Time_AsMilliseconds,None,Time)
Time.AsDate = new_instancemethod(_cmf_core.Time_AsDate,None,Time)
Time.ToString = new_instancemethod(_cmf_core.Time_ToString,None,Time)
Time.__add__ = new_instancemethod(_cmf_core.Time___add__,None,Time)
Time.__sub__ = new_instancemethod(_cmf_core.Time___sub__,None,Time)
Time.__iadd__ = new_instancemethod(_cmf_core.Time___iadd__,None,Time)
Time.__isub__ = new_instancemethod(_cmf_core.Time___isub__,None,Time)
Time.__mul__ = new_instancemethod(_cmf_core.Time___mul__,None,Time)
Time.__imul__ = new_instancemethod(_cmf_core.Time___imul__,None,Time)
Time.__idiv__ = new_instancemethod(_cmf_core.Time___idiv__,None,Time)
Time.__div__ = new_instancemethod(_cmf_core.Time___div__,None,Time)
Time.__lt__ = new_instancemethod(_cmf_core.Time___lt__,None,Time)
Time.__gt__ = new_instancemethod(_cmf_core.Time___gt__,None,Time)
Time.__le__ = new_instancemethod(_cmf_core.Time___le__,None,Time)
Time.__ge__ = new_instancemethod(_cmf_core.Time___ge__,None,Time)
Time.__eq__ = new_instancemethod(_cmf_core.Time___eq__,None,Time)
Time.__ne__ = new_instancemethod(_cmf_core.Time___ne__,None,Time)
Time.NextDay = new_instancemethod(_cmf_core.Time_NextDay,None,Time)
Time.NextFullHour = new_instancemethod(_cmf_core.Time_NextFullHour,None,Time)
Time_swigregister = _cmf_core.Time_swigregister
Time_swigregister(Time)
Debug = cvar.Debug
CompileDate = cvar.CompileDate

def piecewise_linear(*args):
  """
    piecewise_linear(real x, real xmin, real xmax, real ymin = 0, real ymax = 1) -> real
    piecewise_linear(real x, real xmin, real xmax, real ymin = 0) -> real
    piecewise_linear(real x, real xmin, real xmax) -> real

    real piecewise_linear(real
    x, real xmin, real xmax, real ymin=0, real ymax=1) 
    """
  return _cmf_core.piecewise_linear(*args)
Pi = cvar.Pi

def Time_Years(y = 1):
  """
    Years(double y = 1) -> Time
    Time_Years() -> Time
    """
  return _cmf_core.Time_Years(y)

def Time_Days(d = 1):
  """
    Days(double d = 1) -> Time
    Time_Days() -> Time
    """
  return _cmf_core.Time_Days(d)

def Time_Hours(h = 1):
  """
    Hours(double h = 1) -> Time
    Time_Hours() -> Time
    """
  return _cmf_core.Time_Hours(h)

def Time_Minutes(min = 1):
  """
    Minutes(double min = 1) -> Time
    Time_Minutes() -> Time
    """
  return _cmf_core.Time_Minutes(min)

def Time_Seconds(secs = 1):
  """
    Seconds(double secs = 1) -> Time
    Time_Seconds() -> Time
    """
  return _cmf_core.Time_Seconds(secs)

def Time_Milliseconds(ms = 1):
  """
    Milliseconds(long long ms = 1) -> Time
    Time_Milliseconds() -> Time
    """
  return _cmf_core.Time_Milliseconds(ms)

class Date(object):
    """
    An absolute time, not for calculation. Date and Time are
    interchangable.

    C++ includes: Time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    year = _swig_property(_cmf_core.Date_year_get, _cmf_core.Date_year_set)
    month = _swig_property(_cmf_core.Date_month_get, _cmf_core.Date_month_set)
    day = _swig_property(_cmf_core.Date_day_get, _cmf_core.Date_day_set)
    hour = _swig_property(_cmf_core.Date_hour_get, _cmf_core.Date_hour_set)
    minute = _swig_property(_cmf_core.Date_minute_get, _cmf_core.Date_minute_set)
    second = _swig_property(_cmf_core.Date_second_get, _cmf_core.Date_second_set)
    ms = _swig_property(_cmf_core.Date_ms_get, _cmf_core.Date_ms_set)
    def __init__(self, *args): 
        """
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0, 
            int _minute = 0, int _second = 0, int _ms = 0) -> Date
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0, 
            int _minute = 0, int _second = 0) -> Date
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0, 
            int _minute = 0) -> Date
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0) -> Date
        __init__(self, int _day, int _month, int _year = 2001) -> Date
        __init__(self, int _day, int _month) -> Date
        __init__(self, Time time) -> Date

        Date(const Time &time)

        Creates a new date from time (based on the 31.12.1899, like in
        Excel(TM)). 
        """
        _cmf_core.Date_swiginit(self,_cmf_core.new_Date(*args))
    def ToTime(self):
        """
        ToTime(self) -> Time

        Time ToTime()

        Converts a date to Time (based on the 31.12.1899, like in Excel(TM).

        """
        return _cmf_core.Date_ToTime(self)

    def DOY(self):
        """
        DOY(self) -> int

        int DOY()

        Returns the day of year. 
        """
        return _cmf_core.Date_DOY(self)

    def ToString(self):
        """
        ToString(self) -> string

        std::string
        ToString()

        Returns a string representing the date. 
        """
        return _cmf_core.Date_ToString(self)

    def __repr__(self):
        return self.ToString()
    def AsPython(self):
        return datetime.datetime(self.year,self.month,self.day,self.hour,self.minute,self.second,self.ms*1000)

    __swig_destroy__ = _cmf_core.delete_Date
Date.ToTime = new_instancemethod(_cmf_core.Date_ToTime,None,Date)
Date.DOY = new_instancemethod(_cmf_core.Date_DOY,None,Date)
Date.ToString = new_instancemethod(_cmf_core.Date_ToString,None,Date)
Date_swigregister = _cmf_core.Date_swigregister
Date_swigregister(Date)

class timeseries(object):
    """
    A timeseries is a list of values, equally distributed over time. To
    create one, one have to provide as start date and a step size. The end
    time is calculated from the number of values. Values queried for times
    before the start time are returned as the first item, values after the
    end time equal the last item. A timeseries with only one item reacts
    like a scalar value.

    Creating a time series

    import CMFLib as cmf                 # Start date is the January 5th
    2001 at 2:30 pm start=cmf.Time(5,1,2001,14,30)
    # time step of the timeseries is 20 minutes
    step=cmf.min*20                 # Type of interpolation between values
    # 0 - Nearest neighbor,                 # 1 - Linear,
    # 2 - Squared, # 3 - Cubic, etc.                 interpolation=1 #
    Create timeseries
    timeseries=cmf.timeseries(start,step,interpolation) # Add data
    timeseries.Add(0.1) # Value at 2001/5/1 2:30pm is 0.1
    timeseries.Add(0.2) # Value at 2001/5/1 2:50pm is 0.2
    timeseries.Add(0.1) # Value at 2001/5/1 3:10pm is 0.1

    With this technic it is simple to read files or databases to fill
    timeseries.Using a timeseries

    # Query every minute between 2:15 and 3:14 pm for t in
    cmf.timerange(start,start+cmf.h,cmf.min): print
    "Time:",t.AsDate(),"Value:", timeseries[t]                 # Query
    a specific position of the timeseries                 print
    timeseries[2]

    C++ includes: timeseries.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    begin = _swig_property(_cmf_core.timeseries_begin_get, _cmf_core.timeseries_begin_set)
    step = _swig_property(_cmf_core.timeseries_step_get, _cmf_core.timeseries_step_set)
    def end(self):
        """
        end(self) -> Time

        cmf::math::Time
        end() const

        Last date of measurements. 
        """
        return _cmf_core.timeseries_end(self)

    interpolationpower = _swig_property(_cmf_core.timeseries_interpolationpower_get, _cmf_core.timeseries_interpolationpower_set)
    def Add(self, *args):
        """
        Add(self, double Value)

        void Add(double
        Value)

        Appends a measurement. 
        """
        return _cmf_core.timeseries_Add(self, *args)

    def isempty(self):
        """
        isempty(self) -> bool

        bool isempty()
        const

        returns true if no values are added to the timeseries 
        """
        return _cmf_core.timeseries_isempty(self)

    def clear(self):
        """
        clear(self)

        void clear() 
        """
        return _cmf_core.timeseries_clear(self)

    def size(self):
        """
        size(self) -> int

        int size() const

        """
        return _cmf_core.timeseries_size(self)

    def __iadd__(self, *args):
        """
        __iadd__(self, timeseries arg0) -> timeseries
        __iadd__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, timeseries arg0) -> timeseries
        __isub__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___isub__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, timeseries arg0) -> timeseries
        __imul__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, timeseries arg0) -> timeseries
        __idiv__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___idiv__(self, *args)

    def power(self, *args):
        """
        power(self, double arg0) -> timeseries

        timeseries&
        power(double)

        raises the timeseries to a power 
        """
        return _cmf_core.timeseries_power(self, *args)

    def reduce_min(self, *args):
        """
        reduce_min(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_min(cmf::math::Time begin, cmf::math::Time step) const 
        """
        return _cmf_core.timeseries_reduce_min(self, *args)

    def reduce_max(self, *args):
        """
        reduce_max(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_max(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the minimum.

        """
        return _cmf_core.timeseries_reduce_max(self, *args)

    def reduce_sum(self, *args):
        """
        reduce_sum(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_sum(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the maximum.

        """
        return _cmf_core.timeseries_reduce_sum(self, *args)

    def reduce_avg(self, *args):
        """
        reduce_avg(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_avg(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the sum. 
        """
        return _cmf_core.timeseries_reduce_avg(self, *args)

    def Save(self, *args):
        """
        Save(self, std::ostream file)

        void
        Save(std::ostream &file)

        Save the Meteorology data to an ASCII File with fixed format. 
        """
        return _cmf_core.timeseries_Save(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, Time _begin, Time _step, int _interpolationmethod = 0) -> timeseries
        __init__(self, Time _begin, Time _step) -> timeseries
        __init__(self, Time _begin, Time _step, int size, int _interpolationmethod) -> timeseries
        __init__(self) -> timeseries
        __init__(self, timeseries ts) -> timeseries
        __init__(self, double scalar) -> timeseries
        __init__(self, std::istream file) -> timeseries

        timeseries(const cmf::math::timeseries &ts) 
        """
        _cmf_core.timeseries_swiginit(self,_cmf_core.new_timeseries(*args))
    def __size__(self):
        """__size__(self) -> double"""
        return _cmf_core.timeseries___size__(self)

    def __getitem__(self, *args):
        """
        __getitem__(self, Time t) -> double
        __getitem__(self, int i) -> double
        """
        return _cmf_core.timeseries___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, int i, double value)"""
        return _cmf_core.timeseries___setitem__(self, *args)

    def AddList(list) :
        """ Adds the values of a list to the timeseries"""
        for item in list :
            self.Add(float(item))

    __swig_destroy__ = _cmf_core.delete_timeseries
timeseries.end = new_instancemethod(_cmf_core.timeseries_end,None,timeseries)
timeseries.Add = new_instancemethod(_cmf_core.timeseries_Add,None,timeseries)
timeseries.isempty = new_instancemethod(_cmf_core.timeseries_isempty,None,timeseries)
timeseries.clear = new_instancemethod(_cmf_core.timeseries_clear,None,timeseries)
timeseries.size = new_instancemethod(_cmf_core.timeseries_size,None,timeseries)
timeseries.__iadd__ = new_instancemethod(_cmf_core.timeseries___iadd__,None,timeseries)
timeseries.__isub__ = new_instancemethod(_cmf_core.timeseries___isub__,None,timeseries)
timeseries.__imul__ = new_instancemethod(_cmf_core.timeseries___imul__,None,timeseries)
timeseries.__idiv__ = new_instancemethod(_cmf_core.timeseries___idiv__,None,timeseries)
timeseries.power = new_instancemethod(_cmf_core.timeseries_power,None,timeseries)
timeseries.reduce_min = new_instancemethod(_cmf_core.timeseries_reduce_min,None,timeseries)
timeseries.reduce_max = new_instancemethod(_cmf_core.timeseries_reduce_max,None,timeseries)
timeseries.reduce_sum = new_instancemethod(_cmf_core.timeseries_reduce_sum,None,timeseries)
timeseries.reduce_avg = new_instancemethod(_cmf_core.timeseries_reduce_avg,None,timeseries)
timeseries.Save = new_instancemethod(_cmf_core.timeseries_Save,None,timeseries)
timeseries.__size__ = new_instancemethod(_cmf_core.timeseries___size__,None,timeseries)
timeseries.__getitem__ = new_instancemethod(_cmf_core.timeseries___getitem__,None,timeseries)
timeseries.__setitem__ = new_instancemethod(_cmf_core.timeseries___setitem__,None,timeseries)
timeseries_swigregister = _cmf_core.timeseries_swigregister
timeseries_swigregister(timeseries)
ms = cvar.ms
sec = cvar.sec
min = cvar.min
h = cvar.h
day = cvar.day
week = cvar.week
month = cvar.month
year = cvar.year

class numVector(object):
    """
    A valarray kind of vector implementation with OpenMP capabilities.

    C++ includes: numVector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, int count, real Value = 0) -> numVector
        __init__(self, int count) -> numVector
        __init__(self, size_t count, real Value = 0) -> numVector
        __init__(self, size_t count) -> numVector
        __init__(self) -> numVector
        __init__(self, numVector Vector) -> numVector

        numVector(const std::valarray< real > &Vector)

        Convert from valarray<real>. 
        """
        _cmf_core.numVector_swiginit(self,_cmf_core.new_numVector(*args))
    __swig_destroy__ = _cmf_core.delete_numVector
    def size(self):
        """
        size(self) -> int

        int size() const

        Size of the vector. 
        """
        return _cmf_core.numVector_size(self)

    def resize(self, *args):
        """
        resize(self, int count)
        resize(self, size_t count)

        void
        resize(size_t count) 
        """
        return _cmf_core.numVector_resize(self, *args)

    def __neg__(self):
        """__neg__(self) -> numVector"""
        return _cmf_core.numVector___neg__(self)

    def power(self, *args):
        """
        power(self, numVector arg0) -> numVector
        power(self, real exponent) -> numVector

        numVector
        power(real exponent) const

        Return each element to the power "exponent". 
        """
        return _cmf_core.numVector_power(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, numVector arg0) -> numVector
        __iadd__(self, real arg0) -> numVector
        """
        return _cmf_core.numVector___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, numVector arg0) -> numVector
        __isub__(self, real arg0) -> numVector
        """
        return _cmf_core.numVector___isub__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, numVector arg0) -> numVector
        __imul__(self, real arg0) -> numVector
        """
        return _cmf_core.numVector___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, numVector arg0) -> numVector
        __idiv__(self, real arg0) -> numVector
        """
        return _cmf_core.numVector___idiv__(self, *args)

    def apply(self, *args):
        """
        apply(self, real funct) -> numVector

        numVector
        apply(real funct(real)) const

        Return funct(this).

        Parameters:
        -----------

        funct:  a function of signature real funct(real)

        Example: Return the sinus of each element of vector x 
        """
        return _cmf_core.numVector_apply(self, *args)

    def dot(self, *args):
        """
        dot(self, numVector arg0) -> real

        real dot(const
        numVector &) const

        Return dot product of this and vector. 
        """
        return _cmf_core.numVector_dot(self, *args)

    def sum(self):
        """
        sum(self) -> real

        real sum() const

        Return sum of vector. 
        """
        return _cmf_core.numVector_sum(self)

    def max(self):
        """
        max(self) -> real

        real max() const

        Return max of vector. 
        """
        return _cmf_core.numVector_max(self)

    def min(self):
        """
        min(self) -> real

        real min() const

        Return min of vector. 
        """
        return _cmf_core.numVector_min(self)

    def norm(self, normtype = 0):
        """
        norm(self, int normtype = 0) -> real
        norm(self) -> real

        real norm(int
        normtype=0) const

        Returns a norm of the vector, implemented norms: 1 - sum of abs, 2 -
        Euclidean distance, 0 Maximum of abs.

        Parameters:
        -----------

        normtype:  An integer indicating the type of norm 
        """
        return _cmf_core.numVector_norm(self, normtype)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> double"""
        return _cmf_core.numVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, int index, double value)"""
        return _cmf_core.numVector___setitem__(self, *args)

    def __len__(self):
        """__len__(self) -> int"""
        return _cmf_core.numVector___len__(self)

numVector.size = new_instancemethod(_cmf_core.numVector_size,None,numVector)
numVector.resize = new_instancemethod(_cmf_core.numVector_resize,None,numVector)
numVector.__neg__ = new_instancemethod(_cmf_core.numVector___neg__,None,numVector)
numVector.power = new_instancemethod(_cmf_core.numVector_power,None,numVector)
numVector.__iadd__ = new_instancemethod(_cmf_core.numVector___iadd__,None,numVector)
numVector.__isub__ = new_instancemethod(_cmf_core.numVector___isub__,None,numVector)
numVector.__imul__ = new_instancemethod(_cmf_core.numVector___imul__,None,numVector)
numVector.__idiv__ = new_instancemethod(_cmf_core.numVector___idiv__,None,numVector)
numVector.apply = new_instancemethod(_cmf_core.numVector_apply,None,numVector)
numVector.dot = new_instancemethod(_cmf_core.numVector_dot,None,numVector)
numVector.sum = new_instancemethod(_cmf_core.numVector_sum,None,numVector)
numVector.max = new_instancemethod(_cmf_core.numVector_max,None,numVector)
numVector.min = new_instancemethod(_cmf_core.numVector_min,None,numVector)
numVector.norm = new_instancemethod(_cmf_core.numVector_norm,None,numVector)
numVector.__getitem__ = new_instancemethod(_cmf_core.numVector___getitem__,None,numVector)
numVector.__setitem__ = new_instancemethod(_cmf_core.numVector___setitem__,None,numVector)
numVector.__len__ = new_instancemethod(_cmf_core.numVector___len__,None,numVector)
numVector_swigregister = _cmf_core.numVector_swigregister
numVector_swigregister(numVector)

class svVector(object):
    """Proxy of C++ std::vector<(p.cmf::math::StateVariable)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.svVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf_core.svVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf_core.svVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf_core.svVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf_core.svVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> svVector"""
        return _cmf_core.svVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, svVector v)"""
        return _cmf_core.svVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.svVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.svVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> svVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.svVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, svVector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.svVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.svVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf_core.svVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf_core.svVector_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf_core.svVector_clear(self)

    def swap(self, *args):
        """swap(self, svVector v)"""
        return _cmf_core.svVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.svVector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf_core.svVector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf_core.svVector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.svVector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.svVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf_core.svVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.svVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> svVector
        __init__(self, svVector arg0) -> svVector
        __init__(self, size_type size) -> svVector
        __init__(self, size_type size, value_type value) -> svVector
        """
        _cmf_core.svVector_swiginit(self,_cmf_core.new_svVector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.svVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf_core.svVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf_core.svVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.svVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.svVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.svVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.svVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf_core.svVector_capacity(self)

    __swig_destroy__ = _cmf_core.delete_svVector
svVector.iterator = new_instancemethod(_cmf_core.svVector_iterator,None,svVector)
svVector.__nonzero__ = new_instancemethod(_cmf_core.svVector___nonzero__,None,svVector)
svVector.__bool__ = new_instancemethod(_cmf_core.svVector___bool__,None,svVector)
svVector.__len__ = new_instancemethod(_cmf_core.svVector___len__,None,svVector)
svVector.pop = new_instancemethod(_cmf_core.svVector_pop,None,svVector)
svVector.__getslice__ = new_instancemethod(_cmf_core.svVector___getslice__,None,svVector)
svVector.__setslice__ = new_instancemethod(_cmf_core.svVector___setslice__,None,svVector)
svVector.__delslice__ = new_instancemethod(_cmf_core.svVector___delslice__,None,svVector)
svVector.__delitem__ = new_instancemethod(_cmf_core.svVector___delitem__,None,svVector)
svVector.__getitem__ = new_instancemethod(_cmf_core.svVector___getitem__,None,svVector)
svVector.__setitem__ = new_instancemethod(_cmf_core.svVector___setitem__,None,svVector)
svVector.append = new_instancemethod(_cmf_core.svVector_append,None,svVector)
svVector.empty = new_instancemethod(_cmf_core.svVector_empty,None,svVector)
svVector.size = new_instancemethod(_cmf_core.svVector_size,None,svVector)
svVector.clear = new_instancemethod(_cmf_core.svVector_clear,None,svVector)
svVector.swap = new_instancemethod(_cmf_core.svVector_swap,None,svVector)
svVector.get_allocator = new_instancemethod(_cmf_core.svVector_get_allocator,None,svVector)
svVector.begin = new_instancemethod(_cmf_core.svVector_begin,None,svVector)
svVector.end = new_instancemethod(_cmf_core.svVector_end,None,svVector)
svVector.rbegin = new_instancemethod(_cmf_core.svVector_rbegin,None,svVector)
svVector.rend = new_instancemethod(_cmf_core.svVector_rend,None,svVector)
svVector.pop_back = new_instancemethod(_cmf_core.svVector_pop_back,None,svVector)
svVector.erase = new_instancemethod(_cmf_core.svVector_erase,None,svVector)
svVector.push_back = new_instancemethod(_cmf_core.svVector_push_back,None,svVector)
svVector.front = new_instancemethod(_cmf_core.svVector_front,None,svVector)
svVector.back = new_instancemethod(_cmf_core.svVector_back,None,svVector)
svVector.assign = new_instancemethod(_cmf_core.svVector_assign,None,svVector)
svVector.resize = new_instancemethod(_cmf_core.svVector_resize,None,svVector)
svVector.insert = new_instancemethod(_cmf_core.svVector_insert,None,svVector)
svVector.reserve = new_instancemethod(_cmf_core.svVector_reserve,None,svVector)
svVector.capacity = new_instancemethod(_cmf_core.svVector_capacity,None,svVector)
svVector_swigregister = _cmf_core.svVector_swigregister
svVector_swigregister(svVector)

def __add__(*args):
  """
    __add__(numVector _Left, numVector _Right) -> numVector
    __add__(numVector _Left, real _Right) -> numVector
    __add__(real _Left, numVector _Right) -> numVector
    """
  return _cmf_core.__add__(*args)

def __sub__(*args):
  """
    __sub__(numVector _Left, numVector _Right) -> numVector
    __sub__(numVector _Left, real _Right) -> numVector
    __sub__(real _Left, numVector _Right) -> numVector
    """
  return _cmf_core.__sub__(*args)

def __mul__(*args):
  """
    __mul__(double f, Time t) -> Time
    __mul__(int f, Time t) -> Time
    __mul__(numVector _Left, numVector _Right) -> numVector
    __mul__(numVector _Left, real _Right) -> numVector
    __mul__(real _Left, numVector _Right) -> numVector
    """
  return _cmf_core.__mul__(*args)

def __div__(*args):
  """
    __div__(numVector _Left, numVector _Right) -> numVector
    __div__(numVector _Left, real _Right) -> numVector
    __div__(real _Left, numVector _Right) -> numVector
    """
  return _cmf_core.__div__(*args)

class StateVariable(object):
    """
    Abstract class state variable

    Simple exponential system class header implementing a state variable:

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Derivate(self, *args):
        """
        Derivate(self, Time time) -> real

        virtual
        real Derivate(const cmf::math::Time &time)=0

        Returns the derivate of the state variable at time time. 
        """
        return _cmf_core.StateVariable_Derivate(self, *args)

    def State(self, *args):
        """
        State(self) -> real
        State(self, real newState)

        void
        State(const real &newState)

        Gives access to the state variable. 
        """
        return _cmf_core.StateVariable_State(self, *args)

    def StateIsChanged(self):
        """
        StateIsChanged(self) -> bool

        bool
        StateIsChanged()

        Returns if the state was currently updated. 
        """
        return _cmf_core.StateVariable_StateIsChanged(self)

    state=property(State,None,"Gets the currect state")

    __swig_destroy__ = _cmf_core.delete_StateVariable
StateVariable.Derivate = new_instancemethod(_cmf_core.StateVariable_Derivate,None,StateVariable)
StateVariable.State = new_instancemethod(_cmf_core.StateVariable_State,None,StateVariable)
StateVariable.StateIsChanged = new_instancemethod(_cmf_core.StateVariable_StateIsChanged,None,StateVariable)
StateVariable_swigregister = _cmf_core.StateVariable_swigregister
StateVariable_swigregister(StateVariable)

class StateVariableVector(svVector):
    """
    A vector of state variables, can be solved by RKFIntegrator.

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def CopyStates(self, *args):
        """
        CopyStates(self, numVector destination)
        CopyStates(self, real destination)

        void CopyStates(numVector &destination) const

        Copies the states to a numeric vector using OpenMP. 
        """
        return _cmf_core.StateVariableVector_CopyStates(self, *args)

    def SetStates(self, *args):
        """
        SetStates(self, numVector newStates)
        SetStates(self, real newStates)

        void SetStates(const numVector &newStates)

        Copies the new states to the actual states. 
        """
        return _cmf_core.StateVariableVector_SetStates(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, numVector aVector) -> StateVariableVector"""
        return _cmf_core.StateVariableVector___iadd__(self, *args)

    def CopyDerivs(self, *args):
        """
        CopyDerivs(self, Time time, numVector destination, real factor = 1)
        CopyDerivs(self, Time time, numVector destination)
        CopyDerivs(self, Time time, real destination, real factor = 1)
        CopyDerivs(self, Time time, real destination)

        void CopyDerivs(Time time, numVector &destination, real factor=1)
        const

        Copies the derivatives at time step "time" to a numeric vector using
        OpenMP.

        Parameters:
        -----------

        time:   Time at which the derivatives should be calculated

        destination:  Vector to be overwritten by the results

        factor:  A factor that is multiplied to the derivate (e.g. unit
        conversion or integration length) 
        """
        return _cmf_core.StateVariableVector_CopyDerivs(self, *args)

    def GetStates(self):
        """
        GetStates(self) -> numVector

        numVector GetStates() const

        Returns the states in a numeric vector using :CopyStates, but is
        slower because of additional memory allocation. 
        """
        return _cmf_core.StateVariableVector_GetStates(self)

    def GetDerivs(self, *args):
        """
        GetDerivs(self, Time time) -> numVector

        numVector GetDerivs(Time time) const

        Returns the derivatives at time step "time" in a numeric vector
        using :CopyDerivs, but is slower because of additional memory
        allocation. 
        """
        return _cmf_core.StateVariableVector_GetDerivs(self, *args)

    def __init__(self): 
        """__init__(self) -> StateVariableVector"""
        _cmf_core.StateVariableVector_swiginit(self,_cmf_core.new_StateVariableVector())
    __swig_destroy__ = _cmf_core.delete_StateVariableVector
StateVariableVector.CopyStates = new_instancemethod(_cmf_core.StateVariableVector_CopyStates,None,StateVariableVector)
StateVariableVector.SetStates = new_instancemethod(_cmf_core.StateVariableVector_SetStates,None,StateVariableVector)
StateVariableVector.__iadd__ = new_instancemethod(_cmf_core.StateVariableVector___iadd__,None,StateVariableVector)
StateVariableVector.CopyDerivs = new_instancemethod(_cmf_core.StateVariableVector_CopyDerivs,None,StateVariableVector)
StateVariableVector.GetStates = new_instancemethod(_cmf_core.StateVariableVector_GetStates,None,StateVariableVector)
StateVariableVector.GetDerivs = new_instancemethod(_cmf_core.StateVariableVector_GetDerivs,None,StateVariableVector)
StateVariableVector_swigregister = _cmf_core.StateVariableVector_swigregister
StateVariableVector_swigregister(StateVariableVector)

class StateVariableOwner(object):
    """
    An abstract class, that owns one or more state variables, that can add
    them to a vector of state variables in a certain order.

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def AddStateVariables(self, *args):
        """
        AddStateVariables(self, StateVariableVector vector)

        virtual void
        AddStateVariables(cmf::math::StateVariableVector &vector)=0

        Add the state variables, owned by an object derived from
        StateVariableOwner, to the given vector. 
        """
        return _cmf_core.StateVariableOwner_AddStateVariables(self, *args)

    __swig_destroy__ = _cmf_core.delete_StateVariableOwner
StateVariableOwner.AddStateVariables = new_instancemethod(_cmf_core.StateVariableOwner_AddStateVariables,None,StateVariableOwner)
StateVariableOwner_swigregister = _cmf_core.StateVariableOwner_swigregister
StateVariableOwner_swigregister(StateVariableOwner)

class Integrator(object):
    """
    Base class for any kind of integrator.

    Pure virtual functions: Integrate

    Copy Please provide a custom copy constructorTodo Put the methods of
    StateVariableVector here, and delete StateVariableVector

    C++ includes: Integrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Tag = _swig_property(_cmf_core.Integrator_Tag_get, _cmf_core.Integrator_Tag_set)
    UseEulerAtTmin = _swig_property(_cmf_core.Integrator_UseEulerAtTmin_get, _cmf_core.Integrator_UseEulerAtTmin_set)
    def count(self):
        """
        count(self) -> int

        int count()
        const

        returns the number of state variables 
        """
        return _cmf_core.Integrator_count(self)

    def state(self, *args):
        """
        state(self, int position) -> real
        state(self, int position, real newState)

        void state(int
        position, real newState)

        Simplifies the assessment of state variables. 
        """
        return _cmf_core.Integrator_state(self, *args)

    def AddStatesFromOwner(self, *args):
        """
        AddStatesFromOwner(self, StateVariableOwner stateOwner)

        virtual void AddStatesFromOwner(cmf::math::StateVariableOwner
        &stateOwner)

        Adds the state variables of a StateVariableOwner to the state
        variables of the solver. 
        """
        return _cmf_core.Integrator_AddStatesFromOwner(self, *args)

    def AddState(self, *args):
        """AddState(self, StateVariable statevar)"""
        return _cmf_core.Integrator_AddState(self, *args)

    def ModelTime(self, *args):
        """
        ModelTime(self) -> Time
        ModelTime(self, Time val)

        void
        ModelTime(cmf::math::Time val)

        Sets the current model time. 
        """
        return _cmf_core.Integrator_ModelTime(self, *args)

    def TimeStep(self):
        """
        TimeStep(self) -> Time

        cmf::math::Time TimeStep() const

        Returns the last time step. 
        """
        return _cmf_core.Integrator_TimeStep(self)

    def NextTimeStep(self, *args):
        """
        NextTimeStep(self) -> Time
        NextTimeStep(self, Time val)

        void
        NextTimeStep(cmf::math::Time val)

        Sets the next time step width. 
        """
        return _cmf_core.Integrator_NextTimeStep(self, *args)

    def MinTimestep(self):
        """
        MinTimestep(self) -> Time

        const
        cmf::math::Time MinTimestep() const

        Returns The minimal allowed time step length. 
        """
        return _cmf_core.Integrator_MinTimestep(self)

    def Iterations(self):
        """
        Iterations(self) -> int

        int
        Iterations() const 
        """
        return _cmf_core.Integrator_Iterations(self)

    def ResetIterations(self):
        """
        ResetIterations(self)

        void
        ResetIterations() 
        """
        return _cmf_core.Integrator_ResetIterations(self)

    def Reset(self):
        """Reset(self)"""
        return _cmf_core.Integrator_Reset(self)

    def Copy(self):
        """
        Copy(self) -> Integrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.Integrator_Copy(self)

    def Integrate(self, *args):
        """
        Integrate(self, Time MaxTime, Time TimeStep) -> int
        Integrate(self, Time MaxTime) -> int

        int
        Integrate(cmf::math::Time MaxTime) 
        """
        return _cmf_core.Integrator_Integrate(self, *args)

    def IntegrateUntil(self, *args):
        """
        IntegrateUntil(self, Time MaxTime)
        IntegrateUntil(self, Time MaxTime, Time TimeStep)

        void
        IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

        Integrates the vector of state variables until MaxTime. 
        """
        return _cmf_core.Integrator_IntegrateUntil(self, *args)

    def __call__(self, *args):
        """
        __call__(self, Time t)

        void
        __call__(cmf::math::Time until)

        Calls IntegrateUntil. 
        """
        return _cmf_core.Integrator___call__(self, *args)

    t=property(ModelTime,ModelTime,"Gets or sets the model time of the integrator")
    dt=property(TimeStep,None,"Gets the length of the last internal time step of the integrator")

    __swig_destroy__ = _cmf_core.delete_Integrator
Integrator.count = new_instancemethod(_cmf_core.Integrator_count,None,Integrator)
Integrator.state = new_instancemethod(_cmf_core.Integrator_state,None,Integrator)
Integrator.AddStatesFromOwner = new_instancemethod(_cmf_core.Integrator_AddStatesFromOwner,None,Integrator)
Integrator.AddState = new_instancemethod(_cmf_core.Integrator_AddState,None,Integrator)
Integrator.ModelTime = new_instancemethod(_cmf_core.Integrator_ModelTime,None,Integrator)
Integrator.TimeStep = new_instancemethod(_cmf_core.Integrator_TimeStep,None,Integrator)
Integrator.NextTimeStep = new_instancemethod(_cmf_core.Integrator_NextTimeStep,None,Integrator)
Integrator.MinTimestep = new_instancemethod(_cmf_core.Integrator_MinTimestep,None,Integrator)
Integrator.Iterations = new_instancemethod(_cmf_core.Integrator_Iterations,None,Integrator)
Integrator.ResetIterations = new_instancemethod(_cmf_core.Integrator_ResetIterations,None,Integrator)
Integrator.Reset = new_instancemethod(_cmf_core.Integrator_Reset,None,Integrator)
Integrator.Copy = new_instancemethod(_cmf_core.Integrator_Copy,None,Integrator)
Integrator.Integrate = new_instancemethod(_cmf_core.Integrator_Integrate,None,Integrator)
Integrator.IntegrateUntil = new_instancemethod(_cmf_core.Integrator_IntegrateUntil,None,Integrator)
Integrator.__call__ = new_instancemethod(_cmf_core.Integrator___call__,None,Integrator)
Integrator_swigregister = _cmf_core.Integrator_swigregister
Integrator_swigregister(Integrator)

class BDF2(Integrator):
    """
    An order 2 BDF-Method with fixed-point iteration and variable step
    size.

    Recommended integrator for CMF (so far)

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8 and

    Eckert S., Baaser H., Gross D. and Scherf O. (2004) "A BDF2
    integration method with step size control for elasto-plasticity",
    Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1

    Most important function: Integrate

    C++ includes: BDF2.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get_error_position(self):
        """get_error_position(self) -> int"""
        return _cmf_core.BDF2_get_error_position(self)

    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> BDF2
        __init__(self, StateVariableVector states) -> BDF2
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, real epsilon = 1e-9) -> BDF2
        __init__(self) -> BDF2
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, StateVariableOwner states, real epsilon = 1e-9) -> BDF2
        __init__(self, StateVariableOwner states) -> BDF2
        __init__(self, Integrator templ) -> BDF2

        BDF2(const Integrator
        &templ) 
        """
        _cmf_core.BDF2_swiginit(self,_cmf_core.new_BDF2(*args))
    __swig_destroy__ = _cmf_core.delete_BDF2
BDF2.get_error_position = new_instancemethod(_cmf_core.BDF2_get_error_position,None,BDF2)
BDF2_swigregister = _cmf_core.BDF2_swigregister
BDF2_swigregister(BDF2)

class ExplicitEuler_fixed(Integrator):
    """
    An explicit Euler integrator, with a fixed time step.

    C++ includes: ExplicitEuler_fixed.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> ExplicitEuler_fixed
        __init__(self, StateVariableVector states) -> ExplicitEuler_fixed
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, real epsilon = 1e-9) -> ExplicitEuler_fixed
        __init__(self) -> ExplicitEuler_fixed
        __init__(self, Integrator copy) -> ExplicitEuler_fixed

        ExplicitEuler_fixed(const Integrator &copy)

        Copy constructor. 
        """
        _cmf_core.ExplicitEuler_fixed_swiginit(self,_cmf_core.new_ExplicitEuler_fixed(*args))
    __swig_destroy__ = _cmf_core.delete_ExplicitEuler_fixed
ExplicitEuler_fixed_swigregister = _cmf_core.ExplicitEuler_fixed_swigregister
ExplicitEuler_fixed_swigregister(ExplicitEuler_fixed)

class ExplicitEuler_variable(Integrator):
    """
    An explicit Euler integrator with variable step size.

    C++ includes: ExplicitEuler_variable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    WithStepsizeControl = _swig_property(_cmf_core.ExplicitEuler_variable_WithStepsizeControl_get, _cmf_core.ExplicitEuler_variable_WithStepsizeControl_set)
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_variable
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> ExplicitEuler_variable
        __init__(self, StateVariableVector states) -> ExplicitEuler_variable
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_variable
        __init__(self, real epsilon = 1e-9) -> ExplicitEuler_variable
        __init__(self) -> ExplicitEuler_variable
        __init__(self, Integrator copy) -> ExplicitEuler_variable

        ExplicitEuler_variable(const Integrator &copy)

        Copy constructor. 
        """
        _cmf_core.ExplicitEuler_variable_swiginit(self,_cmf_core.new_ExplicitEuler_variable(*args))
    __swig_destroy__ = _cmf_core.delete_ExplicitEuler_variable
ExplicitEuler_variable_swigregister = _cmf_core.ExplicitEuler_variable_swigregister
ExplicitEuler_variable_swigregister(ExplicitEuler_variable)

class ImplicitEuler(Integrator):
    """
    An implicit (backward) Euler integrator using fixpoint iteration.

    C++ includes: FixpointImplicitEuler.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ImplicitEuler
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> ImplicitEuler
        __init__(self, StateVariableVector states) -> ImplicitEuler
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ImplicitEuler
        __init__(self, real epsilon = 1e-9) -> ImplicitEuler
        __init__(self) -> ImplicitEuler
        __init__(self, Integrator arg0) -> ImplicitEuler

        ImplicitEuler(const Integrator &)

        Copy constructor. 
        """
        _cmf_core.ImplicitEuler_swiginit(self,_cmf_core.new_ImplicitEuler(*args))
    __swig_destroy__ = _cmf_core.delete_ImplicitEuler
ImplicitEuler_swigregister = _cmf_core.ImplicitEuler_swigregister
ImplicitEuler_swigregister(ImplicitEuler)

class RKFIntegrator(Integrator):
    """
    Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
    Fehlberg (RKF54) method.

    C++ includes: RKFIntegrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> RKFIntegrator
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> RKFIntegrator
        __init__(self, StateVariableVector states) -> RKFIntegrator
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> RKFIntegrator
        __init__(self, real epsilon = 1e-9) -> RKFIntegrator
        __init__(self) -> RKFIntegrator
        __init__(self, Integrator forCopy) -> RKFIntegrator

        RKFIntegrator(const Integrator &forCopy)

        Copy constructor, does not copy. 
        """
        _cmf_core.RKFIntegrator_swiginit(self,_cmf_core.new_RKFIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_RKFIntegrator
RKFIntegrator_swigregister = _cmf_core.RKFIntegrator_swigregister
RKFIntegrator_swigregister(RKFIntegrator)

GEAR_MAX_ITER = _cmf_core.GEAR_MAX_ITER
GEAR_RECOVER_AFTER_STEPS = _cmf_core.GEAR_RECOVER_AFTER_STEPS
class Gears_Fixpoint(Integrator):
    """
    An up to 4 step Gears-Method with fixpoint iteration, needs bug
    fixing.

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8

    C++ includes: Gears_Fixpoint.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Time_reduce_stage(self):
        """
        Time_reduce_stage(self) -> int

        int Time_reduce_stage() const

        Returns int Stage oof time reduction. 
        """
        return _cmf_core.Gears_Fixpoint_Time_reduce_stage(self)

    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10), 
            int maxOrder = 4) -> Gears_Fixpoint
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> Gears_Fixpoint
        __init__(self, StateVariableVector states, real epsilon = 1e-9) -> Gears_Fixpoint
        __init__(self, StateVariableVector states) -> Gears_Fixpoint
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10), 
            int maxOrder = 4) -> Gears_Fixpoint
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> Gears_Fixpoint
        __init__(self, real epsilon = 1e-9) -> Gears_Fixpoint
        __init__(self) -> Gears_Fixpoint
        __init__(self, Integrator arg0) -> Gears_Fixpoint

        Gears_Fixpoint(const Integrator &)

        Copy constructor. 
        """
        _cmf_core.Gears_Fixpoint_swiginit(self,_cmf_core.new_Gears_Fixpoint(*args))
    __swig_destroy__ = _cmf_core.delete_Gears_Fixpoint
Gears_Fixpoint.Time_reduce_stage = new_instancemethod(_cmf_core.Gears_Fixpoint_Time_reduce_stage,None,Gears_Fixpoint)
Gears_Fixpoint_swigregister = _cmf_core.Gears_Fixpoint_swigregister
Gears_Fixpoint_swigregister(Gears_Fixpoint)

class CVodeIntegrator(Integrator):
    """Proxy of C++ cmf::math::CVodeIntegrator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    preconditioner = _swig_property(_cmf_core.CVodeIntegrator_preconditioner_get, _cmf_core.CVodeIntegrator_preconditioner_set)
    MaxNonLinearIterations = _swig_property(_cmf_core.CVodeIntegrator_MaxNonLinearIterations_get, _cmf_core.CVodeIntegrator_MaxNonLinearIterations_set)
    MaxConvergenceFailures = _swig_property(_cmf_core.CVodeIntegrator_MaxConvergenceFailures_get, _cmf_core.CVodeIntegrator_MaxConvergenceFailures_set)
    MaxErrorTestFailures = _swig_property(_cmf_core.CVodeIntegrator_MaxErrorTestFailures_get, _cmf_core.CVodeIntegrator_MaxErrorTestFailures_set)
    maxl = _swig_property(_cmf_core.CVodeIntegrator_maxl_get, _cmf_core.CVodeIntegrator_maxl_set)
    LinearSolver = _swig_property(_cmf_core.CVodeIntegrator_LinearSolver_get, _cmf_core.CVodeIntegrator_LinearSolver_set)
    MaxOrder = _swig_property(_cmf_core.CVodeIntegrator_MaxOrder_get, _cmf_core.CVodeIntegrator_MaxOrder_set)
    reinit_always = _swig_property(_cmf_core.CVodeIntegrator_reinit_always_get, _cmf_core.CVodeIntegrator_reinit_always_set)
    def GetOrder(self):
        """GetOrder(self) -> int"""
        return _cmf_core.CVodeIntegrator_GetOrder(self)

    def ReInit(self, *args):
        """
        ReInit(self, Time initdt, real epsilon = 0)
        ReInit(self, Time initdt)
        """
        return _cmf_core.CVodeIntegrator_ReInit(self, *args)

    def Initialize(self, *args):
        """
        Initialize(self, Time max_step = day)
        Initialize(self)
        """
        return _cmf_core.CVodeIntegrator_Initialize(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(50)) -> CVodeIntegrator
        __init__(self, real epsilon = 1e-9) -> CVodeIntegrator
        __init__(self) -> CVodeIntegrator
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(50)) -> CVodeIntegrator
        __init__(self, StateVariableOwner states, real epsilon = 1e-9) -> CVodeIntegrator
        __init__(self, StateVariableOwner states) -> CVodeIntegrator
        __init__(self, CVodeIntegrator templ) -> CVodeIntegrator
        """
        _cmf_core.CVodeIntegrator_swiginit(self,_cmf_core.new_CVodeIntegrator(*args))
    def Copy(self):
        """
        Copy(self) -> CVodeIntegrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.CVodeIntegrator_Copy(self)

    __swig_destroy__ = _cmf_core.delete_CVodeIntegrator
CVodeIntegrator.GetOrder = new_instancemethod(_cmf_core.CVodeIntegrator_GetOrder,None,CVodeIntegrator)
CVodeIntegrator.ReInit = new_instancemethod(_cmf_core.CVodeIntegrator_ReInit,None,CVodeIntegrator)
CVodeIntegrator.Initialize = new_instancemethod(_cmf_core.CVodeIntegrator_Initialize,None,CVodeIntegrator)
CVodeIntegrator.Copy = new_instancemethod(_cmf_core.CVodeIntegrator_Copy,None,CVodeIntegrator)
CVodeIntegrator_swigregister = _cmf_core.CVodeIntegrator_swigregister
CVodeIntegrator_swigregister(CVodeIntegrator)

class Jacobian(object):
    """
    Calculates the jacobian of a system (a vector of state variables).

    Code is inspired by RADAU5 method from Hairer E,Wanner G (1991)
    Solving Ordinary Differential Equations II, Springer-Verlag

    C++ includes: Jacobian.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> Jacobian

        Jacobian() 
        """
        _cmf_core.Jacobian_swiginit(self,_cmf_core.new_Jacobian())
    def Calculate(self, *args):
        """
        Calculate(self, StateVariableVector vector, Time timestep)

        void
        Calculate(StateVariableVector &vector, const cmf::math::Time
        &timestep)

        Calculates the jacobian for a given system at a given time step. 
        """
        return _cmf_core.Jacobian_Calculate(self, *args)

    def __call__(self, *args):
        """__call__(self, int i, int j) -> real"""
        return _cmf_core.Jacobian___call__(self, *args)

    def ToFile(self, *args):
        """
        ToFile(self, string filename)

        void
        ToFile(std::string filename)

        Saves the matrix in an undocumented file. Cols are tab seperated, rows
        are ended with endl. 
        """
        return _cmf_core.Jacobian_ToFile(self, *args)

    __swig_destroy__ = _cmf_core.delete_Jacobian
Jacobian.Calculate = new_instancemethod(_cmf_core.Jacobian_Calculate,None,Jacobian)
Jacobian.__call__ = new_instancemethod(_cmf_core.Jacobian___call__,None,Jacobian)
Jacobian.ToFile = new_instancemethod(_cmf_core.Jacobian_ToFile,None,Jacobian)
Jacobian_swigregister = _cmf_core.Jacobian_swigregister
Jacobian_swigregister(Jacobian)

def AsCMFtime(date):
    """Converts a python datetime to cmf.Time"""
    return Time(date.day,date.month,date.year,date.hour,date.minute,date.second,date.microsecond/1000)
def timerange(start,end,step=day):
    """Creates a list of cmf.Time, similar to the Python range function"""
    return [start+step*x for x in range(0,int((end-start)/step+0.999))]

class Solute(object):
    """
    A structure to identify a solute.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, Solute copy) -> Solute

        Solute(const
        Solute &copy) 
        """
        _cmf_core.Solute_swiginit(self,_cmf_core.new_Solute(*args))
    Name = _swig_property(_cmf_core.Solute_Name_get, _cmf_core.Solute_Name_set)
    Unit = _swig_property(_cmf_core.Solute_Unit_get, _cmf_core.Solute_Unit_set)
    Uptake = _swig_property(_cmf_core.Solute_Uptake_get, _cmf_core.Solute_Uptake_set)
    Id = _swig_property(_cmf_core.Solute_Id_get)
    def create(*args):
        """
        create(string name, string unit = "", double uptake = 1) -> Solute
        create(string name, string unit = "") -> Solute
        create(string name) -> Solute
        """
        return _cmf_core.Solute_create(*args)

    create = staticmethod(create)
    __swig_destroy__ = _cmf_core.delete_Solute
Solute_swigregister = _cmf_core.Solute_swigregister
Solute_swigregister(Solute)

def Solute_create(*args):
  """
    create(string name, string unit = "", double uptake = 1) -> Solute
    create(string name, string unit = "") -> Solute
    Solute_create(string name) -> Solute
    """
  return _cmf_core.Solute_create(*args)

class Solutes(object):
    """
    Manages the solutes of the whole model. The static member All is the
    only instance. Before you are creating any cmf object (like
    UpslopeCell, Reach or IVegetation or Meteorology), make sure you have
    added all solutes you are interest in to Solutes::All Generally you
    are free to add any kind of Solute to the model, but each additional
    will slow down calculations remarkably, and if you intend to use one
    or more ExternalFunctionReaction special requirements apply.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def add(self, *args):
        """
        add(self, string name, string unit = "", double uptake = 1) -> Solute
        add(self, string name, string unit = "") -> Solute
        add(self, string name) -> Solute

        const Solute&
        add(const std::string &name, const std::string &unit="", double
        uptake=1)

        Creates a solute in Solute::All.

        Parameters:
        -----------

        name:  the name of the solute, e.g. 'Tracer', 'NO3'

        unit:  Used unit for amount of solute e.g. 'mol','mmol','g','mg' etc.

        uptake:  Fraction of the available concentration, that is taken up by
        vegetation 
        """
        return _cmf_core.Solutes_add(self, *args)

    def size(self):
        """
        size(self) -> size_t

        size_t size() 
        """
        return _cmf_core.Solutes_size(self)

    def SetInUse(self):
        """
        SetInUse(self)

        void SetInUse()

        If the Solutes of the model are marked as "InUse", no more solutes
        may be added. They get marked as "InUse" as soon as an object
        depending on the number of solutes is created (e.g. an UpslopeCell,
        Reach, IVegetation or Meteorology). 
        """
        return _cmf_core.Solutes_SetInUse(self)

    def all():
        """all() -> Solutes"""
        return _cmf_core.Solutes_all()

    all = staticmethod(all)
    def __getitem__(self, *args):
        """__getitem__(self, int i) -> Solute"""
        return _cmf_core.Solutes___getitem__(self, *args)

    __swig_destroy__ = _cmf_core.delete_Solutes
Solutes.add = new_instancemethod(_cmf_core.Solutes_add,None,Solutes)
Solutes.size = new_instancemethod(_cmf_core.Solutes_size,None,Solutes)
Solutes.SetInUse = new_instancemethod(_cmf_core.Solutes_SetInUse,None,Solutes)
Solutes.__getitem__ = new_instancemethod(_cmf_core.Solutes___getitem__,None,Solutes)
Solutes_swigregister = _cmf_core.Solutes_swigregister
Solutes_swigregister(Solutes)

def Solutes_all():
  """Solutes_all() -> Solutes"""
  return _cmf_core.Solutes_all()

class WaterQuality(object):
    """
    Map of concentrations for different solutes.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def size(self):
        """
        size(self) -> size_t

        size_t size()
        const

        Returns the number of solutes. 
        """
        return _cmf_core.WaterQuality_size(self)

    def tostring(self):
        """
        tostring(self) -> string

        std::string tostring() const 
        """
        return _cmf_core.WaterQuality_tostring(self)

    def clear(self):
        """
        clear(self)

        void clear()

        Clears the water. 
        """
        return _cmf_core.WaterQuality_clear(self)

    def __init__(self, *args): 
        """
        __init__(self) -> WaterQuality
        __init__(self, WaterQuality wq) -> WaterQuality

        WaterQuality(const cmf::water::WaterQuality &wq) 
        """
        _cmf_core.WaterQuality_swiginit(self,_cmf_core.new_WaterQuality(*args))
    def __getitem__(self, *args):
        """__getitem__(self, Solute solute) -> double"""
        return _cmf_core.WaterQuality___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, Solute solute, double concentration)"""
        return _cmf_core.WaterQuality___setitem__(self, *args)

    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf_core.WaterQuality___len__(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _cmf_core.WaterQuality___str__(self)

    __swig_destroy__ = _cmf_core.delete_WaterQuality
WaterQuality.size = new_instancemethod(_cmf_core.WaterQuality_size,None,WaterQuality)
WaterQuality.tostring = new_instancemethod(_cmf_core.WaterQuality_tostring,None,WaterQuality)
WaterQuality.clear = new_instancemethod(_cmf_core.WaterQuality_clear,None,WaterQuality)
WaterQuality.__getitem__ = new_instancemethod(_cmf_core.WaterQuality___getitem__,None,WaterQuality)
WaterQuality.__setitem__ = new_instancemethod(_cmf_core.WaterQuality___setitem__,None,WaterQuality)
WaterQuality.__len__ = new_instancemethod(_cmf_core.WaterQuality___len__,None,WaterQuality)
WaterQuality.__str__ = new_instancemethod(_cmf_core.WaterQuality___str__,None,WaterQuality)
WaterQuality_swigregister = _cmf_core.WaterQuality_swigregister
WaterQuality_swigregister(WaterQuality)

class SoluteTimeseries(object):
    """
    A map of concentration time series for solutes.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def conc(self, *args):
        """
        conc(self, Time t) -> WaterQuality

        WaterQuality conc(cmf::math::Time t) 
        """
        return _cmf_core.SoluteTimeseries_conc(self, *args)

    def size(self):
        """
        size(self) -> size_t

        size_t
        size() const

        Returns the number of solutes in the solution. 
        """
        return _cmf_core.SoluteTimeseries_size(self)

    def __init__(self, *args): 
        """
        __init__(self) -> SoluteTimeseries
        __init__(self, Time begin, Time step) -> SoluteTimeseries
        __init__(self, SoluteTimeseries sts) -> SoluteTimeseries

        SoluteTimeseries(const cmf::water::SoluteTimeseries &sts) 
        """
        _cmf_core.SoluteTimeseries_swiginit(self,_cmf_core.new_SoluteTimeseries(*args))
    def __getitem__(self, *args):
        """__getitem__(self, Solute solute) -> timeseries"""
        return _cmf_core.SoluteTimeseries___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, Solute solute, timeseries concentration)"""
        return _cmf_core.SoluteTimeseries___setitem__(self, *args)

    def __len__(self):
        """__len__(self) -> size_t"""
        return _cmf_core.SoluteTimeseries___len__(self)

    __swig_destroy__ = _cmf_core.delete_SoluteTimeseries
SoluteTimeseries.conc = new_instancemethod(_cmf_core.SoluteTimeseries_conc,None,SoluteTimeseries)
SoluteTimeseries.size = new_instancemethod(_cmf_core.SoluteTimeseries_size,None,SoluteTimeseries)
SoluteTimeseries.__getitem__ = new_instancemethod(_cmf_core.SoluteTimeseries___getitem__,None,SoluteTimeseries)
SoluteTimeseries.__setitem__ = new_instancemethod(_cmf_core.SoluteTimeseries___setitem__,None,SoluteTimeseries)
SoluteTimeseries.__len__ = new_instancemethod(_cmf_core.SoluteTimeseries___len__,None,SoluteTimeseries)
SoluteTimeseries_swigregister = _cmf_core.SoluteTimeseries_swigregister
SoluteTimeseries_swigregister(SoluteTimeseries)

class WaterFlux(object):
    """
    Water fluxes consist of the flux in $\\frac{m^3}{day}$ and a map of
    concentrations (ConcentrationMap).

    C++ includes: WaterFlux.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Update(self, *args):
        """
        Update(self, real waterflux, WaterStorage origin, bool uptake = False) -> WaterFlux
        Update(self, real waterflux, WaterStorage origin) -> WaterFlux

        WaterFlux&
        Update(real waterflux, const cmf::water::WaterStorage &origin, bool
        uptake=false) 
        """
        return _cmf_core.WaterFlux_Update(self, *args)

    c = _swig_property(_cmf_core.WaterFlux_c_get, _cmf_core.WaterFlux_c_set)
    q = _swig_property(_cmf_core.WaterFlux_q_get, _cmf_core.WaterFlux_q_set)
    def __init__(self, *args): 
        """
        __init__(self) -> WaterFlux
        __init__(self, WaterFlux forcopy) -> WaterFlux
        __init__(self, real flux) -> WaterFlux
        __init__(self, real flux, WaterStorage origin, bool uptake = False) -> WaterFlux
        __init__(self, real flux, WaterStorage origin) -> WaterFlux
        __init__(self, real flux, WaterQuality wq) -> WaterFlux

        WaterFlux(real flux, const cmf::water::WaterStorage &origin, bool
        uptake=false) 
        """
        _cmf_core.WaterFlux_swiginit(self,_cmf_core.new_WaterFlux(*args))
    def Add(self, *args):
        """
        Add(self, real flux, WaterStorage origin) -> WaterFlux
        Add(self, real flux, WaterQuality concentrations) -> WaterFlux

        WaterFlux&
        Add(real flux, const cmf::water::WaterQuality &concentrations)

        Adds water of a certain water quality to the flux (mixing) Both fluxes
        may be negative, but mixed signs will throw an error
        \\begin{eqnarray*} q&=& \\mbox{Flux in }\\frac{m^3}{day}
        \\\\ c&=& \\mbox{Vector of concentrations in }
        \\frac{mol}{m^3} \\\\
        c_{this}&=&\\frac{c_{this}q_{this}+c_{other}q_{other}}{q_{this}+q_{other}}
        \\\\ q_{this}&=&q_{this}+q_{other} \\\\ \\end{eqnarray*}. 
        """
        return _cmf_core.WaterFlux_Add(self, *args)

    def Abs(self):
        """
        Abs(self) -> WaterFlux

        WaterFlux& Abs()

        Changes the sign of the flux to positive. 
        """
        return _cmf_core.WaterFlux_Abs(self)

    def matterflux(self, *args):
        """
        matterflux(self, Solute solute) -> real

        real
        matterflux(const cmf::water::Solute &solute)

        Returns the water flux of the given solute in $\\frac{mol}{day}$,
        depending on the unit of the concentration (see cmf::water )
        \\begin{eqnarray*} Q_{Solute} &=&
        q_{H_2O}\\left[\\frac{m^3}{day}\\right] c_{Solute}
        \\left[\\frac{mol}{m^3}\\right] \\end{eqnarray*}. 
        """
        return _cmf_core.WaterFlux_matterflux(self, *args)

    def clear(self):
        """
        clear(self)

        void clear()

        Sets all concentrations and the flux to 0. 
        """
        return _cmf_core.WaterFlux_clear(self)

    def __iadd__(self, *args):
        """__iadd__(self, WaterFlux add) -> WaterFlux"""
        return _cmf_core.WaterFlux___iadd__(self, *args)

    def __imul__(self, *args):
        """__imul__(self, real factor) -> WaterFlux"""
        return _cmf_core.WaterFlux___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, real factor) -> WaterFlux"""
        return _cmf_core.WaterFlux___idiv__(self, *args)

    def __neg__(self):
        """__neg__(self) -> WaterFlux"""
        return _cmf_core.WaterFlux___neg__(self)

    def __call__(self, *args):
        """__call__(self, double waterflux, WaterStorage origin) -> WaterFlux"""
        return _cmf_core.WaterFlux___call__(self, *args)

    __swig_destroy__ = _cmf_core.delete_WaterFlux
WaterFlux.Update = new_instancemethod(_cmf_core.WaterFlux_Update,None,WaterFlux)
WaterFlux.Add = new_instancemethod(_cmf_core.WaterFlux_Add,None,WaterFlux)
WaterFlux.Abs = new_instancemethod(_cmf_core.WaterFlux_Abs,None,WaterFlux)
WaterFlux.matterflux = new_instancemethod(_cmf_core.WaterFlux_matterflux,None,WaterFlux)
WaterFlux.clear = new_instancemethod(_cmf_core.WaterFlux_clear,None,WaterFlux)
WaterFlux.__iadd__ = new_instancemethod(_cmf_core.WaterFlux___iadd__,None,WaterFlux)
WaterFlux.__imul__ = new_instancemethod(_cmf_core.WaterFlux___imul__,None,WaterFlux)
WaterFlux.__idiv__ = new_instancemethod(_cmf_core.WaterFlux___idiv__,None,WaterFlux)
WaterFlux.__neg__ = new_instancemethod(_cmf_core.WaterFlux___neg__,None,WaterFlux)
WaterFlux.__call__ = new_instancemethod(_cmf_core.WaterFlux___call__,None,WaterFlux)
WaterFlux_swigregister = _cmf_core.WaterFlux_swigregister
WaterFlux_swigregister(WaterFlux)

class SoluteStorage(StateVariable):
    """
    A class for the storage of any tracer. The state is the amount (mol,
    kg etc. see cmf::water) of the tracer in the storage
    \\begin{eqnarray*} \\frac{dX}{dt}&=&\\sum_{f=1}^{F}\\left( q_f
    [X]_f\\right) +
    \\sum_{r=1}^R\\left(f_r\\left([A],...,[Z]\\right)\\
    V\\right) \\left[\\frac{mol}{day}\\right]\\\\ F&=&
    \\mbox{Number of fluxes in water storage} \\\\ q_f&=&
    \\mbox{Water flux in } \\frac{m^3}{day} \\\\
    \\left[X\\right]_f &=& \\mbox{Concentration of solute X in flux
    }q_f \\mbox{ in } \\frac{mol}{m^3} \\\\ R&=& \\mbox{Number
    of reactions defined for this solute storage} \\\\
    f_r\\left([A],...,[Z]\\right)&=& \\mbox{Reactive flux of }[X]
    \\mbox{ in environment } [A],...,[Z] \\left[\\frac{mol}{m^3\\
    day}\\right] \\\\ V &=& \\mbox{Volume of water in water
    storage }\\left[m^3\\right] \\end{eqnarray*}.

    C++ includes: SoluteStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    AdditionalFlux = _swig_property(_cmf_core.SoluteStorage_AdditionalFlux_get, _cmf_core.SoluteStorage_AdditionalFlux_set)
    def __iadd__(self, *args):
        """__iadd__(self, real additionalRate) -> SoluteStorage"""
        return _cmf_core.SoluteStorage___iadd__(self, *args)

    Storage = _swig_property(_cmf_core.SoluteStorage_Storage_get)
    Solute = _swig_property(_cmf_core.SoluteStorage_Solute_get)
    def conc(self):
        """
        conc(self) -> real

        real conc()
        const

        Returns the concentration of the solute. 
        """
        return _cmf_core.SoluteStorage_conc(self)

    __swig_destroy__ = _cmf_core.delete_SoluteStorage
SoluteStorage.__iadd__ = new_instancemethod(_cmf_core.SoluteStorage___iadd__,None,SoluteStorage)
SoluteStorage.conc = new_instancemethod(_cmf_core.SoluteStorage_conc,None,SoluteStorage)
SoluteStorage_swigregister = _cmf_core.SoluteStorage_swigregister
SoluteStorage_swigregister(SoluteStorage)

class connection_vector(object):
    """Proxy of C++ std::vector<(p.cmf::water::FluxConnection)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.connection_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf_core.connection_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf_core.connection_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf_core.connection_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf_core.connection_vector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> connection_vector"""
        return _cmf_core.connection_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, connection_vector v)"""
        return _cmf_core.connection_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.connection_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.connection_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> connection_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.connection_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, connection_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.connection_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.connection_vector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf_core.connection_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf_core.connection_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf_core.connection_vector_clear(self)

    def swap(self, *args):
        """swap(self, connection_vector v)"""
        return _cmf_core.connection_vector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.connection_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf_core.connection_vector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf_core.connection_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.connection_vector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.connection_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf_core.connection_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.connection_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> connection_vector
        __init__(self, connection_vector arg0) -> connection_vector
        __init__(self, size_type size) -> connection_vector
        __init__(self, size_type size, value_type value) -> connection_vector
        """
        _cmf_core.connection_vector_swiginit(self,_cmf_core.new_connection_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.connection_vector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf_core.connection_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf_core.connection_vector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.connection_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.connection_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.connection_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.connection_vector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf_core.connection_vector_capacity(self)

    __swig_destroy__ = _cmf_core.delete_connection_vector
connection_vector.iterator = new_instancemethod(_cmf_core.connection_vector_iterator,None,connection_vector)
connection_vector.__nonzero__ = new_instancemethod(_cmf_core.connection_vector___nonzero__,None,connection_vector)
connection_vector.__bool__ = new_instancemethod(_cmf_core.connection_vector___bool__,None,connection_vector)
connection_vector.__len__ = new_instancemethod(_cmf_core.connection_vector___len__,None,connection_vector)
connection_vector.pop = new_instancemethod(_cmf_core.connection_vector_pop,None,connection_vector)
connection_vector.__getslice__ = new_instancemethod(_cmf_core.connection_vector___getslice__,None,connection_vector)
connection_vector.__setslice__ = new_instancemethod(_cmf_core.connection_vector___setslice__,None,connection_vector)
connection_vector.__delslice__ = new_instancemethod(_cmf_core.connection_vector___delslice__,None,connection_vector)
connection_vector.__delitem__ = new_instancemethod(_cmf_core.connection_vector___delitem__,None,connection_vector)
connection_vector.__getitem__ = new_instancemethod(_cmf_core.connection_vector___getitem__,None,connection_vector)
connection_vector.__setitem__ = new_instancemethod(_cmf_core.connection_vector___setitem__,None,connection_vector)
connection_vector.append = new_instancemethod(_cmf_core.connection_vector_append,None,connection_vector)
connection_vector.empty = new_instancemethod(_cmf_core.connection_vector_empty,None,connection_vector)
connection_vector.size = new_instancemethod(_cmf_core.connection_vector_size,None,connection_vector)
connection_vector.clear = new_instancemethod(_cmf_core.connection_vector_clear,None,connection_vector)
connection_vector.swap = new_instancemethod(_cmf_core.connection_vector_swap,None,connection_vector)
connection_vector.get_allocator = new_instancemethod(_cmf_core.connection_vector_get_allocator,None,connection_vector)
connection_vector.begin = new_instancemethod(_cmf_core.connection_vector_begin,None,connection_vector)
connection_vector.end = new_instancemethod(_cmf_core.connection_vector_end,None,connection_vector)
connection_vector.rbegin = new_instancemethod(_cmf_core.connection_vector_rbegin,None,connection_vector)
connection_vector.rend = new_instancemethod(_cmf_core.connection_vector_rend,None,connection_vector)
connection_vector.pop_back = new_instancemethod(_cmf_core.connection_vector_pop_back,None,connection_vector)
connection_vector.erase = new_instancemethod(_cmf_core.connection_vector_erase,None,connection_vector)
connection_vector.push_back = new_instancemethod(_cmf_core.connection_vector_push_back,None,connection_vector)
connection_vector.front = new_instancemethod(_cmf_core.connection_vector_front,None,connection_vector)
connection_vector.back = new_instancemethod(_cmf_core.connection_vector_back,None,connection_vector)
connection_vector.assign = new_instancemethod(_cmf_core.connection_vector_assign,None,connection_vector)
connection_vector.resize = new_instancemethod(_cmf_core.connection_vector_resize,None,connection_vector)
connection_vector.insert = new_instancemethod(_cmf_core.connection_vector_insert,None,connection_vector)
connection_vector.reserve = new_instancemethod(_cmf_core.connection_vector_reserve,None,connection_vector)
connection_vector.capacity = new_instancemethod(_cmf_core.connection_vector_capacity,None,connection_vector)
connection_vector_swigregister = _cmf_core.connection_vector_swigregister
connection_vector_swigregister(connection_vector)

class connection_set(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.connection_set_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf_core.connection_set___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf_core.connection_set___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf_core.connection_set___len__(self)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.connection_set_append(self, *args)

    def __contains__(self, *args):
        """__contains__(self, value_type x) -> bool"""
        return _cmf_core.connection_set___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _cmf_core.connection_set___getitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(p.cmf::water::FluxConnection)> arg0) -> connection_set
        __init__(self) -> connection_set
        __init__(self, connection_set arg0) -> connection_set
        """
        _cmf_core.connection_set_swiginit(self,_cmf_core.new_connection_set(*args))
    def empty(self):
        """empty(self) -> bool"""
        return _cmf_core.connection_set_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf_core.connection_set_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf_core.connection_set_clear(self)

    def swap(self, *args):
        """swap(self, connection_set v)"""
        return _cmf_core.connection_set_swap(self, *args)

    def count(self, *args):
        """count(self, key_type x) -> size_type"""
        return _cmf_core.connection_set_count(self, *args)

    def begin(self):
        """begin(self) -> iterator"""
        return _cmf_core.connection_set_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _cmf_core.connection_set_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _cmf_core.connection_set_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _cmf_core.connection_set_rend(self)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator pos)
        erase(self, iterator first, iterator last)
        """
        return _cmf_core.connection_set_erase(self, *args)

    def find(self, *args):
        """find(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(self, key_type x) -> std::pair<(std::set<(p.cmf::water::FluxConnection)>::iterator,std::set<(p.cmf::water::FluxConnection)>::iterator)>"""
        return _cmf_core.connection_set_equal_range(self, *args)

    def insert(self, *args):
        """insert(self, value_type __x) -> std::pair<(std::set<(p.cmf::water::FluxConnection)>::iterator,bool)>"""
        return _cmf_core.connection_set_insert(self, *args)

    __swig_destroy__ = _cmf_core.delete_connection_set
connection_set.iterator = new_instancemethod(_cmf_core.connection_set_iterator,None,connection_set)
connection_set.__nonzero__ = new_instancemethod(_cmf_core.connection_set___nonzero__,None,connection_set)
connection_set.__bool__ = new_instancemethod(_cmf_core.connection_set___bool__,None,connection_set)
connection_set.__len__ = new_instancemethod(_cmf_core.connection_set___len__,None,connection_set)
connection_set.append = new_instancemethod(_cmf_core.connection_set_append,None,connection_set)
connection_set.__contains__ = new_instancemethod(_cmf_core.connection_set___contains__,None,connection_set)
connection_set.__getitem__ = new_instancemethod(_cmf_core.connection_set___getitem__,None,connection_set)
connection_set.empty = new_instancemethod(_cmf_core.connection_set_empty,None,connection_set)
connection_set.size = new_instancemethod(_cmf_core.connection_set_size,None,connection_set)
connection_set.clear = new_instancemethod(_cmf_core.connection_set_clear,None,connection_set)
connection_set.swap = new_instancemethod(_cmf_core.connection_set_swap,None,connection_set)
connection_set.count = new_instancemethod(_cmf_core.connection_set_count,None,connection_set)
connection_set.begin = new_instancemethod(_cmf_core.connection_set_begin,None,connection_set)
connection_set.end = new_instancemethod(_cmf_core.connection_set_end,None,connection_set)
connection_set.rbegin = new_instancemethod(_cmf_core.connection_set_rbegin,None,connection_set)
connection_set.rend = new_instancemethod(_cmf_core.connection_set_rend,None,connection_set)
connection_set.erase = new_instancemethod(_cmf_core.connection_set_erase,None,connection_set)
connection_set.find = new_instancemethod(_cmf_core.connection_set_find,None,connection_set)
connection_set.lower_bound = new_instancemethod(_cmf_core.connection_set_lower_bound,None,connection_set)
connection_set.upper_bound = new_instancemethod(_cmf_core.connection_set_upper_bound,None,connection_set)
connection_set.equal_range = new_instancemethod(_cmf_core.connection_set_equal_range,None,connection_set)
connection_set.insert = new_instancemethod(_cmf_core.connection_set_insert,None,connection_set)
connection_set_swigregister = _cmf_core.connection_set_swigregister
connection_set_swigregister(connection_set)

class node_vector(object):
    """Proxy of C++ std::vector<(p.cmf::water::FluxNode)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.node_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf_core.node_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf_core.node_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf_core.node_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf_core.node_vector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> node_vector"""
        return _cmf_core.node_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, node_vector v)"""
        return _cmf_core.node_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.node_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.node_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> node_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.node_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, node_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.node_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.node_vector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf_core.node_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf_core.node_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf_core.node_vector_clear(self)

    def swap(self, *args):
        """swap(self, node_vector v)"""
        return _cmf_core.node_vector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.node_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf_core.node_vector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf_core.node_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.node_vector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.node_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf_core.node_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.node_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> node_vector
        __init__(self, node_vector arg0) -> node_vector
        __init__(self, size_type size) -> node_vector
        __init__(self, size_type size, value_type value) -> node_vector
        """
        _cmf_core.node_vector_swiginit(self,_cmf_core.new_node_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.node_vector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf_core.node_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf_core.node_vector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.node_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.node_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.node_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.node_vector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf_core.node_vector_capacity(self)

    __swig_destroy__ = _cmf_core.delete_node_vector
node_vector.iterator = new_instancemethod(_cmf_core.node_vector_iterator,None,node_vector)
node_vector.__nonzero__ = new_instancemethod(_cmf_core.node_vector___nonzero__,None,node_vector)
node_vector.__bool__ = new_instancemethod(_cmf_core.node_vector___bool__,None,node_vector)
node_vector.__len__ = new_instancemethod(_cmf_core.node_vector___len__,None,node_vector)
node_vector.pop = new_instancemethod(_cmf_core.node_vector_pop,None,node_vector)
node_vector.__getslice__ = new_instancemethod(_cmf_core.node_vector___getslice__,None,node_vector)
node_vector.__setslice__ = new_instancemethod(_cmf_core.node_vector___setslice__,None,node_vector)
node_vector.__delslice__ = new_instancemethod(_cmf_core.node_vector___delslice__,None,node_vector)
node_vector.__delitem__ = new_instancemethod(_cmf_core.node_vector___delitem__,None,node_vector)
node_vector.__getitem__ = new_instancemethod(_cmf_core.node_vector___getitem__,None,node_vector)
node_vector.__setitem__ = new_instancemethod(_cmf_core.node_vector___setitem__,None,node_vector)
node_vector.append = new_instancemethod(_cmf_core.node_vector_append,None,node_vector)
node_vector.empty = new_instancemethod(_cmf_core.node_vector_empty,None,node_vector)
node_vector.size = new_instancemethod(_cmf_core.node_vector_size,None,node_vector)
node_vector.clear = new_instancemethod(_cmf_core.node_vector_clear,None,node_vector)
node_vector.swap = new_instancemethod(_cmf_core.node_vector_swap,None,node_vector)
node_vector.get_allocator = new_instancemethod(_cmf_core.node_vector_get_allocator,None,node_vector)
node_vector.begin = new_instancemethod(_cmf_core.node_vector_begin,None,node_vector)
node_vector.end = new_instancemethod(_cmf_core.node_vector_end,None,node_vector)
node_vector.rbegin = new_instancemethod(_cmf_core.node_vector_rbegin,None,node_vector)
node_vector.rend = new_instancemethod(_cmf_core.node_vector_rend,None,node_vector)
node_vector.pop_back = new_instancemethod(_cmf_core.node_vector_pop_back,None,node_vector)
node_vector.erase = new_instancemethod(_cmf_core.node_vector_erase,None,node_vector)
node_vector.push_back = new_instancemethod(_cmf_core.node_vector_push_back,None,node_vector)
node_vector.front = new_instancemethod(_cmf_core.node_vector_front,None,node_vector)
node_vector.back = new_instancemethod(_cmf_core.node_vector_back,None,node_vector)
node_vector.assign = new_instancemethod(_cmf_core.node_vector_assign,None,node_vector)
node_vector.resize = new_instancemethod(_cmf_core.node_vector_resize,None,node_vector)
node_vector.insert = new_instancemethod(_cmf_core.node_vector_insert,None,node_vector)
node_vector.reserve = new_instancemethod(_cmf_core.node_vector_reserve,None,node_vector)
node_vector.capacity = new_instancemethod(_cmf_core.node_vector_capacity,None,node_vector)
node_vector_swigregister = _cmf_core.node_vector_swigregister
node_vector_swigregister(node_vector)

class FluxNode(object):
    """
    Base class for everything that can be connected by fluxes. Flux nodes
    can be WaterStorages, flux end points, sinks, sources and bridges to
    other model domains (e.g. Ponded water to river system). The base
    class can be used where a simple routing, potentially with mixing, is
    needed.

    C++ includes: FluxConnection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def project(self):
        """project(self) -> project"""
        return _cmf_core.FluxNode_project(self)

    node_id = _swig_property(_cmf_core.FluxNode_node_id_get)
    def IsStorage(self):
        """IsStorage(self) -> bool"""
        return _cmf_core.FluxNode_IsStorage(self)

    Name = _swig_property(_cmf_core.FluxNode_Name_get, _cmf_core.FluxNode_Name_set)
    def Connections(self):
        """Connections(self) -> connection_vector"""
        return _cmf_core.FluxNode_Connections(self)

    __swig_destroy__ = _cmf_core.delete_FluxNode
    def __eq__(self, *args):
        """__eq__(self, FluxNode other) -> bool"""
        return _cmf_core.FluxNode___eq__(self, *args)

    def RecalcFluxes(self, *args):
        """
        RecalcFluxes(self, Time t) -> bool

        virtual
        bool RecalcFluxes(cmf::math::Time t)

        Pure FluxNodes do not influence fluxes, therefore no recalculation of
        fluxes is required by fluxnode. WaterStorage overrides this, since
        state changes require an update of the fluxes. 
        """
        return _cmf_core.FluxNode_RecalcFluxes(self, *args)

    def Connection(self, *args):
        """Connection(self, FluxNode target) -> FluxConnection"""
        return _cmf_core.FluxNode_Connection(self, *args)

    def RemoveConnection(self, *args):
        """RemoveConnection(self, FluxNode To)"""
        return _cmf_core.FluxNode_RemoveConnection(self, *args)

    def FluxTo(self, *args):
        """
        FluxTo(self, FluxNode target, Time t) -> real

        real
        FluxTo(const FluxNode &target, cmf::math::Time t)

        Returns the actual flux between this and target (positive sign means
        "from target into this"). 
        """
        return _cmf_core.FluxNode_FluxTo(self, *args)

    def Waterbalance(self, *args):
        """
        Waterbalance(self, Time t, FluxConnection Without = None) -> real
        Waterbalance(self, Time t) -> real

        real
        Waterbalance(cmf::math::Time t, const FluxConnection *except=0)

        Returns the sum of all fluxes (positive and negative) at time t.
        Single fluxes can be excluded from the calculation.

        Parameters:
        -----------

        t:  Time of the query

        except:  A FluxConnection that is excluded from the Waterbalance (e.g.
        to prevent closed circuits) 
        """
        return _cmf_core.FluxNode_Waterbalance(self, *args)

    def conc(self, *args):
        """
        conc(self, Time t) -> WaterQuality

        virtual
        cmf::water::WaterQuality conc(cmf::math::Time t)

        Returns the water quality of the FluxNode, if it is not overridden
        this is the mix of the incoming fluxes. 
        """
        return _cmf_core.FluxNode_conc(self, *args)

    Location = _swig_property(_cmf_core.FluxNode_Location_get, _cmf_core.FluxNode_Location_set)
    def Potential(self):
        """
        Potential(self) -> real

        virtual real
        Potential()

        Returns the water potential of the node in m waterhead The base class
        water storage always returns the height of the location. 
        """
        return _cmf_core.FluxNode_Potential(self)

    def Empty(self):
        """
        Empty(self) -> bool

        virtual bool
        Empty() 
        """
        return _cmf_core.FluxNode_Empty(self)

    def __init__(self, *args): 
        """
        __init__(self, project _project, point location = cmf::geometry::point()) -> FluxNode
        __init__(self, project _project) -> FluxNode
        """
        _cmf_core.FluxNode_swiginit(self,_cmf_core.new_FluxNode(*args))
    def copy(self):
        """
        copy(self) -> FluxNode

        virtual FluxNode*
        copy() const 
        """
        return _cmf_core.FluxNode_copy(self)

    def __repr__(self):
        return self.Name
    def fluxes(self,t):
        for con in self.Connections():
            yield (con.q(self,t),con.Target(self))
    def connections(self):
        for con in self.Connections():
            yield con.Target(self)

    def AsStorage(self):
        """AsStorage(self) -> WaterStorage"""
        return _cmf_core.FluxNode_AsStorage(self)

FluxNode.project = new_instancemethod(_cmf_core.FluxNode_project,None,FluxNode)
FluxNode.IsStorage = new_instancemethod(_cmf_core.FluxNode_IsStorage,None,FluxNode)
FluxNode.Connections = new_instancemethod(_cmf_core.FluxNode_Connections,None,FluxNode)
FluxNode.__eq__ = new_instancemethod(_cmf_core.FluxNode___eq__,None,FluxNode)
FluxNode.RecalcFluxes = new_instancemethod(_cmf_core.FluxNode_RecalcFluxes,None,FluxNode)
FluxNode.Connection = new_instancemethod(_cmf_core.FluxNode_Connection,None,FluxNode)
FluxNode.RemoveConnection = new_instancemethod(_cmf_core.FluxNode_RemoveConnection,None,FluxNode)
FluxNode.FluxTo = new_instancemethod(_cmf_core.FluxNode_FluxTo,None,FluxNode)
FluxNode.Waterbalance = new_instancemethod(_cmf_core.FluxNode_Waterbalance,None,FluxNode)
FluxNode.conc = new_instancemethod(_cmf_core.FluxNode_conc,None,FluxNode)
FluxNode.Potential = new_instancemethod(_cmf_core.FluxNode_Potential,None,FluxNode)
FluxNode.Empty = new_instancemethod(_cmf_core.FluxNode_Empty,None,FluxNode)
FluxNode.copy = new_instancemethod(_cmf_core.FluxNode_copy,None,FluxNode)
FluxNode.AsStorage = new_instancemethod(_cmf_core.FluxNode_AsStorage,None,FluxNode)
FluxNode_swigregister = _cmf_core.FluxNode_swigregister
FluxNode_swigregister(FluxNode)


def replace_node(*args):
  """replace_node(FluxNode oldnode, FluxNode newnode)"""
  return _cmf_core.replace_node(*args)
class FluxConnection(object):
    """
    Represents a connection between FluxNodes, where water fluxes occur.

    C++ includes: FluxConnection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    connection_id = _swig_property(_cmf_core.FluxConnection_connection_id_get)
    def __eq__(self, *args):
        """__eq__(self, FluxConnection other) -> bool"""
        return _cmf_core.FluxConnection___eq__(self, *args)

    def ExchangeTarget(self, *args):
        """ExchangeTarget(self, FluxNode oldtarget, FluxNode newTarget)"""
        return _cmf_core.FluxConnection_ExchangeTarget(self, *args)

    def Target(self, *args):
        """
        Target(self, FluxNode inquirer) -> FluxNode
        Target(self, int index) -> FluxNode
        Target(self, FluxNode inquirer) -> FluxNode

        const
        FluxNode& Target(const FluxNode &inquirer) const

        Returns the other end of a connection than the asking end (const). 
        """
        return _cmf_core.FluxConnection_Target(self, *args)

    def q(self, *args):
        """
        q(self, FluxNode inquirer, Time t) -> real

        real q(const
        FluxNode &inquirer, cmf::math::Time t)

        Returns the current flux through a connection. Negative signs mean out
        of the inquirer, positive are inflows to the inquirer. 
        """
        return _cmf_core.FluxConnection_q(self, *args)

    def conc(self, *args):
        """
        conc(self, FluxNode inquirer, Time t) -> WaterQuality

        WaterQuality
        conc(const FluxNode &inquirer, cmf::math::Time t)

        Returns the concentration of the flux. If not overridden, it returns
        the concentration of the source of the flux (direction depending). 
        """
        return _cmf_core.FluxConnection_conc(self, *args)

    type = _swig_property(_cmf_core.FluxConnection_type_get)
    def ToString(self):
        """ToString(self) -> string"""
        return _cmf_core.FluxConnection_ToString(self)

    __swig_destroy__ = _cmf_core.delete_FluxConnection
    def __repr__(self):
        return self.ToString()
    def __getitem__(self,index):
        return self.Target(index)
    def __iter__(self):
        yield self.Target(0)
        yield self.Target(1)
    def __contains__(self,cmp):
        return cmp==self[0] or cmp==self[1]

FluxConnection.__eq__ = new_instancemethod(_cmf_core.FluxConnection___eq__,None,FluxConnection)
FluxConnection.ExchangeTarget = new_instancemethod(_cmf_core.FluxConnection_ExchangeTarget,None,FluxConnection)
FluxConnection.Target = new_instancemethod(_cmf_core.FluxConnection_Target,None,FluxConnection)
FluxConnection.q = new_instancemethod(_cmf_core.FluxConnection_q,None,FluxConnection)
FluxConnection.conc = new_instancemethod(_cmf_core.FluxConnection_conc,None,FluxConnection)
FluxConnection.ToString = new_instancemethod(_cmf_core.FluxConnection_ToString,None,FluxConnection)
FluxConnection_swigregister = _cmf_core.FluxConnection_swigregister
FluxConnection_swigregister(FluxConnection)

class WaterStorage(StateVariable,StateVariableOwner,FluxNode):
    """
    A state variable for the storage of water A class for the storage of
    any tracer. The state is the amount (mol, kg etc. see cmf::water) of
    the tracer in the storage \\begin{eqnarray*}
    \\frac{dV}{dt}&=&\\sum_{f=1}^{F} q_f \\\\ F&=& \\mbox{Number
    of fluxes in water storage} \\\\ q_f&=& \\mbox{Water flux in }
    \\frac{m^3}{day} \\\\ \\end{eqnarray*} The vector fluxes is
    used used by concentration to get the amount of water mixing.

    C++ includes: WaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args): 
        """
        __init__(self, project _project, double InitialState = 0) -> WaterStorage
        __init__(self, project _project) -> WaterStorage
        __init__(self, WaterStorage forcopy) -> WaterStorage

        WaterStorage(const WaterStorage &forcopy) 
        """
        _cmf_core.WaterStorage_swiginit(self,_cmf_core.new_WaterStorage(*args))
    def FromNode(*args):
        """FromNode(FluxNode node) -> WaterStorage"""
        return _cmf_core.WaterStorage_FromNode(*args)

    FromNode = staticmethod(FromNode)
    def Solute(self, *args):
        """
        Solute(self, Solute solute) -> SoluteStorage
        Solute(self, Solute solute) -> SoluteStorage

        const
        SoluteStorage& Solute(const cmf::water::Solute &solute) const 
        """
        return _cmf_core.WaterStorage_Solute(self, *args)

    def conc(self, *args):
        """
        conc(self, Solute solute) -> real
        conc(self, Time t) -> WaterQuality
        conc(self, Solute solute, real NewConcetration)

        void
        conc(const cmf::water::Solute &solute, real NewConcetration)

        Sets a new concentration. 
        """
        return _cmf_core.WaterStorage_conc(self, *args)

    def water(self, *args):
        """
        water(self) -> real
        water(self, real newwatercontent)

        void
        water(real newwatercontent)

        Sets the volume of water in this storage in m3. 
        """
        return _cmf_core.WaterStorage_water(self, *args)

    def ToString(self):
        """
        ToString(self) -> string

        virtual
        std::string ToString() const 
        """
        return _cmf_core.WaterStorage_ToString(self)

    def copy(self):
        """
        copy(self) -> WaterStorage

        virtual
        WaterStorage* copy() const 
        """
        return _cmf_core.WaterStorage_copy(self)

    def __repr__(self):
        """__repr__(self) -> string"""
        return _cmf_core.WaterStorage___repr__(self)

    __swig_destroy__ = _cmf_core.delete_WaterStorage
WaterStorage.Solute = new_instancemethod(_cmf_core.WaterStorage_Solute,None,WaterStorage)
WaterStorage.conc = new_instancemethod(_cmf_core.WaterStorage_conc,None,WaterStorage)
WaterStorage.water = new_instancemethod(_cmf_core.WaterStorage_water,None,WaterStorage)
WaterStorage.ToString = new_instancemethod(_cmf_core.WaterStorage_ToString,None,WaterStorage)
WaterStorage.copy = new_instancemethod(_cmf_core.WaterStorage_copy,None,WaterStorage)
WaterStorage.__repr__ = new_instancemethod(_cmf_core.WaterStorage___repr__,None,WaterStorage)
WaterStorage_swigregister = _cmf_core.WaterStorage_swigregister
WaterStorage_swigregister(WaterStorage)

def WaterStorage_FromNode(*args):
  """WaterStorage_FromNode(FluxNode node) -> WaterStorage"""
  return _cmf_core.WaterStorage_FromNode(*args)


def vapour_pressure(*args):
  """vapour_pressure(double T) -> double"""
  return _cmf_core.vapour_pressure(*args)

def Pressure(*args):
  """Pressure(double height) -> double"""
  return _cmf_core.Pressure(*args)
class Weather(object):
    """
    A structure to return all parts of the incoming radiation, all values
    in $\\frac{MJ}{m^2 day}$.

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    T = _swig_property(_cmf_core.Weather_T_get, _cmf_core.Weather_T_set)
    Tmax = _swig_property(_cmf_core.Weather_Tmax_get, _cmf_core.Weather_Tmax_set)
    Tmin = _swig_property(_cmf_core.Weather_Tmin_get, _cmf_core.Weather_Tmin_set)
    Tground = _swig_property(_cmf_core.Weather_Tground_get, _cmf_core.Weather_Tground_set)
    Prec = _swig_property(_cmf_core.Weather_Prec_get, _cmf_core.Weather_Prec_set)
    Windspeed = _swig_property(_cmf_core.Weather_Windspeed_get, _cmf_core.Weather_Windspeed_set)
    e_a = _swig_property(_cmf_core.Weather_e_a_get, _cmf_core.Weather_e_a_set)
    e_s = _swig_property(_cmf_core.Weather_e_s_get, _cmf_core.Weather_e_s_set)
    sunshine = _swig_property(_cmf_core.Weather_sunshine_get, _cmf_core.Weather_sunshine_set)
    Rs = _swig_property(_cmf_core.Weather_Rs_get, _cmf_core.Weather_Rs_set)
    def Rn(self, *args):
        """
        Rn(self, double albedo, bool daily = False) -> double
        Rn(self, double albedo) -> double

        double Rn(double
        albedo, bool daily=false)

        Calculates the net radiation flux $R_n \\left[\\frac{MJ}{m^2
        day}\\right]$.

        \\begin{eqnarray*} R_{n} &=& R_{ns} - R_{nl} \\\\ \\mbox{ Net
        short wave radiation: }R_{ns} &=& (1-\\alpha) R_s \\\\ \\mbox{
        Net long wave radiation: }R_{nl} &=& R_{black}\\ \\beta_{v}\\
        \\beta_{c} \\\\ \\mbox{Black body radiation: } R_{black} &=&
        \\left\\{\\begin{array}{cl} \\sigma T^4 & \\mbox{for less
        than daily time steps} \\\\ \\sigma \\frac {T_{max}^4 +
        T_{min}^4} 2 & \\mbox{for daily time steps} \\end{array}
        \\right. \\\\ T &=& \\mbox{Temperature }[K] \\\\ \\sigma
        &=& 4.903\\ 10^{-9} \\frac{MJ}{K^4 m^2 day} \\mbox{ Stefan-
        Boltzmann constant } \\\\ \\mbox{Long wave reflectance: }
        \\\\ \\mbox{by water vapor: }\\beta_{v} &=& 0.34 - 0.14
        \\sqrt{e_a} \\\\ \\mbox{ by clouds: }\\beta_{c} &=& 0.1 +
        0.9 \\frac n N \\end{eqnarray*}

        Parameters:
        -----------

        albedo:  the albedo $\\alpha$ of the surface

        daily:  If true, the net radiation for daily averages will be
        calculated 
        """
        return _cmf_core.Weather_Rn(self, *args)

    def __init__(self): 
        """__init__(self) -> Weather"""
        _cmf_core.Weather_swiginit(self,_cmf_core.new_Weather())
    def ToString(self):
        """ToString(self) -> string"""
        return _cmf_core.Weather_ToString(self)

    __swig_destroy__ = _cmf_core.delete_Weather
Weather.Rn = new_instancemethod(_cmf_core.Weather_Rn,None,Weather)
Weather.ToString = new_instancemethod(_cmf_core.Weather_ToString,None,Weather)
Weather_swigregister = _cmf_core.Weather_swigregister
Weather_swigregister(Weather)

def AsWaterStorage(*args):
  """
    AsWaterStorage(StateVariable state) -> WaterStorage
    AsWaterStorage(FluxNode node) -> WaterStorage
    """
  return _cmf_core.AsWaterStorage(*args)

def global_radiation(*args):
  """
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8, 
        double latitude = 51, int time_zone = 1, 
        bool daily = 0) -> double
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8, 
        double latitude = 51, int time_zone = 1) -> double
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8, 
        double latitude = 51) -> double
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8) -> double
    global_radiation(Time t, double height, double sunshine_fraction) -> double
    """
  return _cmf_core.global_radiation(*args)

class Meteorology(object):
    """
    In order to calculate ETpot with cmf a big amount of meteorological
    data is needed, more data than usually available. The Meteorology
    class can estimate missing data from a minimal set. As more data, as
    one provides, the better the calculation of ETpot becomes. The minimal
    data needed is Tmin and Tmax (daily) and precipitation. To calculate
    the global radiation (although measured global radiation could be
    inserted), the position of meteorological station in geographic
    coordinates has to be set.

    There are two modes for the meteorology: daily=true and daily=false.
    If daily=true, Radiation is given as a daily mean value. If
    daily=false, Radiation is given as an hourly mean value, which shows
    the dial ETpot variation but results in erronous results if the
    timestep is daily.

    In the following, we will assume a meteorological station with given
    Tmin, Tmax, precipitation and daily mean relative humidity. To use
    other meteorological data, please consult the description of the
    Meteorology class in the API documentationCreating a meteorological
    station

    import CMFlib as cmf                  latitude=51.2 # Latitude of
    station in decimal degrees                  longitude=8.1 # Longitude
    of station in decimal degrees (only needed for daily=false) timezone=1
    # Timezone, pos. values mean east of GMT, negative west (Germany=1,
    Pacific time=-8, only needed for daily=false) start=cmf.Time(1,1,2001)
    # Creates all timeseries with this start time, one can change them
    later                  step=cmf.day # s. start
    name="Giessen"           # A name for the station (optional)
    meteo=cmf.Meteorology(latitude,longitude,timezone,start,step,name)

    The daily flag is automatically set to true, since the step width is
    &ge cmf.dayLoading data into the meteorological station

    # MeteoData.txt is tab seperated file containing # Tmin [deg C],Tmax
    [deg C],rHmean [%] and precipitation [mm/day] values for every day
    f=file('MeteoData.txt') for line in file:
    meteo.Tmin.Add(float(line.split('\\t')[0]))
    meteo.Tmax.Add(float(line.split('\\t')[1]))
    meteo.rHmean.Add(float(line.split('\\t')[2]))
    meteo.Prec.Add(float(line.split('\\t')[3]))Using a meteorological
    station

    weather=meteo.GetData(cmf.Time(3,2,2001,14)) # Weather at Feb. 3rd,
    2001, 2pm                  print 'Global Radiation: ',weather.Rs
    # Daily mean Rs, since daily=true print 'Temperature:',weather.T
    # Daily mean T, since nothing else in known

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def GetData(self, *args):
        """
        GetData(self, Time t, double x, double y, double z) -> Weather

        Weather
        GetData(cmf::math::Time t, double height) const

        Returns the current Atmosphere state. Uses default values for missing
        timeseries. 
        """
        return _cmf_core.Meteorology_GetData(self, *args)

    SnowThresholdTemperature = _swig_property(_cmf_core.Meteorology_SnowThresholdTemperature_get, _cmf_core.Meteorology_SnowThresholdTemperature_set)
    def copy(self):
        """copy(self) -> Meteorology"""
        return _cmf_core.Meteorology_copy(self)

    Name = _swig_property(_cmf_core.Meteorology_Name_get, _cmf_core.Meteorology_Name_set)
    __swig_destroy__ = _cmf_core.delete_Meteorology
Meteorology.GetData = new_instancemethod(_cmf_core.Meteorology_GetData,None,Meteorology)
Meteorology.copy = new_instancemethod(_cmf_core.Meteorology_copy,None,Meteorology)
Meteorology_swigregister = _cmf_core.Meteorology_swigregister
Meteorology_swigregister(Meteorology)

class ConstantMeteorology(Meteorology):
    """Proxy of C++ cmf::atmosphere::ConstantMeteorology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    weather = _swig_property(_cmf_core.ConstantMeteorology_weather_get, _cmf_core.ConstantMeteorology_weather_set)
    def __init__(self, *args): 
        """
        __init__(self) -> ConstantMeteorology
        __init__(self, Weather w) -> ConstantMeteorology
        __init__(self, ConstantMeteorology other) -> ConstantMeteorology
        """
        _cmf_core.ConstantMeteorology_swiginit(self,_cmf_core.new_ConstantMeteorology(*args))
    def copy(self):
        """copy(self) -> ConstantMeteorology"""
        return _cmf_core.ConstantMeteorology_copy(self)

    __swig_destroy__ = _cmf_core.delete_ConstantMeteorology
ConstantMeteorology.copy = new_instancemethod(_cmf_core.ConstantMeteorology_copy,None,ConstantMeteorology)
ConstantMeteorology_swigregister = _cmf_core.ConstantMeteorology_swigregister
ConstantMeteorology_swigregister(ConstantMeteorology)

class SingleMeteorology(Meteorology):
    """Proxy of C++ cmf::atmosphere::SingleMeteorology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Latitude = _swig_property(_cmf_core.SingleMeteorology_Latitude_get, _cmf_core.SingleMeteorology_Latitude_set)
    Longitude = _swig_property(_cmf_core.SingleMeteorology_Longitude_get, _cmf_core.SingleMeteorology_Longitude_set)
    Timezone = _swig_property(_cmf_core.SingleMeteorology_Timezone_get, _cmf_core.SingleMeteorology_Timezone_set)
    Elevation = _swig_property(_cmf_core.SingleMeteorology_Elevation_get, _cmf_core.SingleMeteorology_Elevation_set)
    daily = _swig_property(_cmf_core.SingleMeteorology_daily_get, _cmf_core.SingleMeteorology_daily_set)
    def copy(self):
        """copy(self) -> SingleMeteorology"""
        return _cmf_core.SingleMeteorology_copy(self)

    def GetData(self, *args):
        """
        GetData(self, Time t, double height) -> Weather
        GetData(self, Time t, double x, double y, double z) -> Weather

        Weather
        GetData(cmf::math::Time t, double height) const

        Returns the current Atmosphere state. Uses default values for missing
        timeseries. 
        """
        return _cmf_core.SingleMeteorology_GetData(self, *args)

    def GetRs(self, *args):
        """
        GetRs(self, Time t, double height, double sunshine_fraction) -> double

        double
        GetRs(cmf::math::Time t, double height, double sunshine_fraction)
        const

        Returns the global radiation at a given time step $ R_s
        \\frac{MJ}{m^2day}$,
        seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
        \\begin{eqnarray*} \\phi &=& \\frac{(\\mbox{geogr.
        Latitude})^\\circ \\pi}{180^\\circ} \\mbox{ Latitude in }rad
        \\\\ \\delta &=& 0.409 \\sin\\left(\\frac{2\\pi}{365}DOY
        - 1.39\\right) \\mbox{ Declination, DOY is day of year}\\\\
        \\omega_s &=& \\arccos(-\\tan\\phi\\tan\\delta) \\mbox{
        Sunset angle} \\\\ G_{sc} &=& 0.0802 \\frac{MJ}{m^2min}
        \\mbox{Solar constant} \\\\ d_r &=& 1+0.033
        \\cos\\left(\\frac{2\\pi}{365}DOY\\right) \\mbox{Inverse
        relative distance Earth-Sun} \\\\ b &=&
        \\frac{2\\pi(DOY-81)}{364}\\\\ S_c &=&
        0.1645\\sin(2b)-0.1255\\cos(b)-0.025\\sin(b) \\mbox{ Seasonal
        correction for solar time} \\\\ \\omega &=& \\frac {\\pi}
        {12} \\left(t_h+\\frac{(\\mbox{geogr.
        Longitude})^\\circ}{15}-\\mbox{Timezone}+S_c-12\\right)
        \\mbox{ solar time in }rad \\\\ \\mbox{If daily} \\\\ R_a
        &=& \\frac{24\\ 60}{\\pi}G_{sc}\\ d_r \\left(\\omega_s
        \\sin\\phi \\sin\\delta + \\cos\\phi \\cos\\delta
        \\sin\\omega_s\\right) \\mbox{Extraterrestrial radiation }
        \\frac{MJ}{m^2 day} \\\\ \\mbox{If hourly} \\\\ R_a &=&
        \\frac{12\\ 24\\ 60}{\\pi}G_{sc}\\ d_r
        \\left(\\left(\\omega^+ -\\omega^-\\right) \\sin\\phi
        \\sin\\delta + \\cos\\phi \\cos\\delta
        \\left(\\sin\\omega^+ - \\sin\\omega^-\\right)\\right)
        \\\\ && \\omega^+,\\omega^- = \\omega
        \\pm\\frac{\\pi}{24} \\\\ \\frac n N &=&
        \\mbox{Fractional sunshine duration} \\\\ R_s &=&
        \\left(0.25+\\left(0.5+2\\
        10^{-5}z\\right)\\frac{n}{N}\\right)R_a \\mbox{Global
        radiation in }\\frac{MJ}{m^2 day} \\\\ && z=\\mbox{Height
        a.s.l. in }m \\\\ \\end{eqnarray*}. 
        """
        return _cmf_core.SingleMeteorology_GetRs(self, *args)

    def SetSunshineFraction(self, *args):
        """
        SetSunshineFraction(self, timeseries sunshine_duration)

        void
        SetSunshineFraction(cmf::math::timeseries sunshine_duration) const

        Calculates a timeseries of the sunshine fraction (to put into
        Sunshine) from a timeseries of absolute sunshine duration, using the
        potential sunshine duration in hours,
        seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
        \\begin{eqnarray*} \\phi &=& \\frac{(\\mbox{geogr.
        Latitude})^\\circ \\pi}{180^\\circ} \\mbox{ Latitude in }rad
        \\\\ \\delta &=& 0.409 \\sin\\left(\\frac{2\\pi}{365}DOY
        - 1.39\\right) \\mbox{ Declination, DOY is day of year}\\\\
        \\omega_s &=& \\arccos(-\\tan\\phi\\tan\\delta) \\mbox{
        Sunset angle} \\\\ N &=& \\frac{24}{\\pi}\\omega_s \\mbox{
        potential duration of sunshine in }h \\\\ \\frac n N &&
        n\\mbox{Absolute sunshine duration} \\end{eqnarray*}. 
        """
        return _cmf_core.SingleMeteorology_SetSunshineFraction(self, *args)

    temp_height_slope = _swig_property(_cmf_core.SingleMeteorology_temp_height_slope_get, _cmf_core.SingleMeteorology_temp_height_slope_set)
    Prec = _swig_property(_cmf_core.SingleMeteorology_Prec_get, _cmf_core.SingleMeteorology_Prec_set)
    T = _swig_property(_cmf_core.SingleMeteorology_T_get, _cmf_core.SingleMeteorology_T_set)
    Tmax = _swig_property(_cmf_core.SingleMeteorology_Tmax_get, _cmf_core.SingleMeteorology_Tmax_set)
    Tmin = _swig_property(_cmf_core.SingleMeteorology_Tmin_get, _cmf_core.SingleMeteorology_Tmin_set)
    Tground = _swig_property(_cmf_core.SingleMeteorology_Tground_get, _cmf_core.SingleMeteorology_Tground_set)
    Windspeed = _swig_property(_cmf_core.SingleMeteorology_Windspeed_get, _cmf_core.SingleMeteorology_Windspeed_set)
    rHmean = _swig_property(_cmf_core.SingleMeteorology_rHmean_get, _cmf_core.SingleMeteorology_rHmean_set)
    rHmin = _swig_property(_cmf_core.SingleMeteorology_rHmin_get, _cmf_core.SingleMeteorology_rHmin_set)
    rHmax = _swig_property(_cmf_core.SingleMeteorology_rHmax_get, _cmf_core.SingleMeteorology_rHmax_set)
    Tdew = _swig_property(_cmf_core.SingleMeteorology_Tdew_get, _cmf_core.SingleMeteorology_Tdew_set)
    Sunshine = _swig_property(_cmf_core.SingleMeteorology_Sunshine_get, _cmf_core.SingleMeteorology_Sunshine_set)
    Rs = _swig_property(_cmf_core.SingleMeteorology_Rs_get, _cmf_core.SingleMeteorology_Rs_set)
    Deposition = _swig_property(_cmf_core.SingleMeteorology_Deposition_get, _cmf_core.SingleMeteorology_Deposition_set)
    def GetDeposition(self, *args):
        """
        GetDeposition(self, Time t) -> WaterFlux

        cmf::water::WaterFlux GetDeposition(cmf::math::Time t)

        Returns the rainfall with its current concentration. The concentration
        is derived from Deposition. 
        """
        return _cmf_core.SingleMeteorology_GetDeposition(self, *args)

    def Save(self, *args):
        """
        Save(self, string filename)

        void
        Save(const std::string &filename)

        Save the Meteorology data to an ASCII File with fixed format(
        uses cmf::math::timeseries::Save ). 
        """
        return _cmf_core.SingleMeteorology_Save(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1, 
            double elevation = 0, Time startTime = cmf::math::Time(1,1,2001), 
            Time timestep = day, 
            string name = "") -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1, 
            double elevation = 0, Time startTime = cmf::math::Time(1,1,2001), 
            Time timestep = day) -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1, 
            double elevation = 0, Time startTime = cmf::math::Time(1,1,2001)) -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1, 
            double elevation = 0) -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8, double timezone = 1) -> SingleMeteorology
        __init__(self, double latitude = 51, double longitude = 8) -> SingleMeteorology
        __init__(self, double latitude = 51) -> SingleMeteorology
        __init__(self) -> SingleMeteorology
        __init__(self, SingleMeteorology other) -> SingleMeteorology
        __init__(self, string filename) -> SingleMeteorology
        """
        _cmf_core.SingleMeteorology_swiginit(self,_cmf_core.new_SingleMeteorology(*args))
    def TimeseriesDictionary(self):
        return {"Tmin":self.Tmin,
                "Tmax":self.Tmax,
                "Tdew":self.Tdew,
                "T":self.T,
                "Prec":self.Prec,
                "rHmean":self.rHmean,
                "rHmax":self.rHmax,
                "rHmin":self.rHmin,
                "Sunshine":self.Sunshine,
                "Windspeed":self.Windspeed,
    				"Rs" : self.Rs}

    __swig_destroy__ = _cmf_core.delete_SingleMeteorology
SingleMeteorology.copy = new_instancemethod(_cmf_core.SingleMeteorology_copy,None,SingleMeteorology)
SingleMeteorology.GetData = new_instancemethod(_cmf_core.SingleMeteorology_GetData,None,SingleMeteorology)
SingleMeteorology.GetRs = new_instancemethod(_cmf_core.SingleMeteorology_GetRs,None,SingleMeteorology)
SingleMeteorology.SetSunshineFraction = new_instancemethod(_cmf_core.SingleMeteorology_SetSunshineFraction,None,SingleMeteorology)
SingleMeteorology.GetDeposition = new_instancemethod(_cmf_core.SingleMeteorology_GetDeposition,None,SingleMeteorology)
SingleMeteorology.Save = new_instancemethod(_cmf_core.SingleMeteorology_Save,None,SingleMeteorology)
SingleMeteorology_swigregister = _cmf_core.SingleMeteorology_swigregister
SingleMeteorology_swigregister(SingleMeteorology)

class PrecipitationData(object):
    """
    Holds the precipitation and concentration timeseries.

    C++ includes: Precipitation.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def q(self, *args):
        """
        q(self, Time t, double x, double y, double z) -> real
        q(self, Time t, point p) -> real
        """
        return _cmf_core.PrecipitationData_q(self, *args)

    def copy(self):
        """
        copy(self) -> PrecipitationData

        virtual FluxNode* copy() const 
        """
        return _cmf_core.PrecipitationData_copy(self)

    def conc(self, *args):
        """
        conc(self, Time t, double x, double y, double z) -> WaterQuality

        virtual cmf::water::WaterQuality conc(cmf::math::Time t)

        Returns the concentration of the rainfall at time t. 
        """
        return _cmf_core.PrecipitationData_conc(self, *args)

    __swig_destroy__ = _cmf_core.delete_PrecipitationData
PrecipitationData.q = new_instancemethod(_cmf_core.PrecipitationData_q,None,PrecipitationData)
PrecipitationData.copy = new_instancemethod(_cmf_core.PrecipitationData_copy,None,PrecipitationData)
PrecipitationData.conc = new_instancemethod(_cmf_core.PrecipitationData_conc,None,PrecipitationData)
PrecipitationData_swigregister = _cmf_core.PrecipitationData_swigregister
PrecipitationData_swigregister(PrecipitationData)

class RainfallNode(FluxNode):
    """Proxy of C++ cmf::atmosphere::RainfallNode class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetSource(self, *args):
        """SetSource(self, PrecipitationData other)"""
        return _cmf_core.RainfallNode_SetSource(self, *args)

    def q(self, *args):
        """q(self, Time t, double x, double y, double z) -> real"""
        return _cmf_core.RainfallNode_q(self, *args)

    def conc(self, *args):
        """
        conc(self, Time t, double x, double y, double z) -> WaterQuality

        virtual
        cmf::water::WaterQuality conc(cmf::math::Time t)

        Returns the water quality of the FluxNode, if it is not overridden
        this is the mix of the incoming fluxes. 
        """
        return _cmf_core.RainfallNode_conc(self, *args)

    def __init__(self, *args): 
        """__init__(self, project _project) -> RainfallNode"""
        _cmf_core.RainfallNode_swiginit(self,_cmf_core.new_RainfallNode(*args))
    def copy(self):
        """
        copy(self) -> RainfallNode

        virtual FluxNode*
        copy() const 
        """
        return _cmf_core.RainfallNode_copy(self)

    __swig_destroy__ = _cmf_core.delete_RainfallNode
RainfallNode.SetSource = new_instancemethod(_cmf_core.RainfallNode_SetSource,None,RainfallNode)
RainfallNode.q = new_instancemethod(_cmf_core.RainfallNode_q,None,RainfallNode)
RainfallNode.conc = new_instancemethod(_cmf_core.RainfallNode_conc,None,RainfallNode)
RainfallNode.copy = new_instancemethod(_cmf_core.RainfallNode_copy,None,RainfallNode)
RainfallNode_swigregister = _cmf_core.RainfallNode_swigregister
RainfallNode_swigregister(RainfallNode)

class SinglePrecipitationTimeseries(PrecipitationData):
    """Proxy of C++ cmf::atmosphere::SinglePrecipitationTimeseries class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Data = _swig_property(_cmf_core.SinglePrecipitationTimeseries_Data_get, _cmf_core.SinglePrecipitationTimeseries_Data_set)
    RainFallConcentration = _swig_property(_cmf_core.SinglePrecipitationTimeseries_RainFallConcentration_get, _cmf_core.SinglePrecipitationTimeseries_RainFallConcentration_set)
    def __init__(self, *args): 
        """
        __init__(self, timeseries data) -> SinglePrecipitationTimeseries
        __init__(self, timeseries data, SoluteTimeseries concentration) -> SinglePrecipitationTimeseries
        __init__(self, double constantPrecipitation) -> SinglePrecipitationTimeseries
        """
        _cmf_core.SinglePrecipitationTimeseries_swiginit(self,_cmf_core.new_SinglePrecipitationTimeseries(*args))
    def copy(self):
        """
        copy(self) -> SinglePrecipitationTimeseries

        virtual FluxNode* copy() const 
        """
        return _cmf_core.SinglePrecipitationTimeseries_copy(self)

    __swig_destroy__ = _cmf_core.delete_SinglePrecipitationTimeseries
SinglePrecipitationTimeseries.copy = new_instancemethod(_cmf_core.SinglePrecipitationTimeseries_copy,None,SinglePrecipitationTimeseries)
SinglePrecipitationTimeseries_swigregister = _cmf_core.SinglePrecipitationTimeseries_swigregister
SinglePrecipitationTimeseries_swigregister(SinglePrecipitationTimeseries)


def pressure_to_waterhead(*args):
  """pressure_to_waterhead(double Pressure) -> double"""
  return _cmf_core.pressure_to_waterhead(*args)

def waterhead_to_pressure(*args):
  """waterhead_to_pressure(double waterhead) -> double"""
  return _cmf_core.waterhead_to_pressure(*args)

def pF_to_waterhead(*args):
  """pF_to_waterhead(double pF) -> double"""
  return _cmf_core.pF_to_waterhead(*args)

def waterhead_to_pF(*args):
  """waterhead_to_pF(double waterhead) -> double"""
  return _cmf_core.waterhead_to_pF(*args)
class RetentionCurve(object):
    """
    Abstract base class for different types of retention curves.

    This class, and its children uses wetness instead of volumetric water
    content. The wetness of a soil is defined as water content per void
    volume

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def K(self, *args):
        """
        K(self, real wetness, real depth) -> real

        virtual real
        K(real wetness, real depth) const =0

        Returns the conductivity in m/day at a certain depth and water
        content. 
        """
        return _cmf_core.RetentionCurve_K(self, *args)

    def Porosity(self, *args):
        """
        Porosity(self, real depth) -> real

        virtual real Porosity(real depth) const =0

        Returns the porosity at a certain depth. 
        """
        return _cmf_core.RetentionCurve_Porosity(self, *args)

    def VoidVolume(self, *args):
        """
        VoidVolume(self, real upperDepth, real lowerDepth, real Area) -> real

        virtual real VoidVolume(real upperDepth, real lowerDepth, real Area)
        const =0

        Returns the void volume of a soil column. 
        """
        return _cmf_core.RetentionCurve_VoidVolume(self, *args)

    def FillHeight(self, *args):
        """
        FillHeight(self, real lowerDepth, real Area, real Volume) -> real

        virtual real FillHeight(real lowerDepth, real Area, real Volume) const
        =0

        Returns the thickness of a soil column with a certain pore volume. 
        """
        return _cmf_core.RetentionCurve_FillHeight(self, *args)

    def Transmissivity(self, *args):
        """
        Transmissivity(self, real upperDepth, real lowerDepth, real wetness) -> real

        virtual real Transmissivity(real upperDepth, real lowerDepth, real
        theta) const =0

        Returns the transmissivity of a part of a soil column. 
        """
        return _cmf_core.RetentionCurve_Transmissivity(self, *args)

    def Wetness(self, *args):
        """
        Wetness(self, real suction) -> real

        virtual
        real Wetness(real suction) const =0

        returns the wetness (volumetric water content per pore space) at a
        given suction pressure 
        """
        return _cmf_core.RetentionCurve_Wetness(self, *args)

    def Wetness_pF(self, *args):
        """
        Wetness_pF(self, real pF) -> real

        real
        Wetness_pF(real pF) const

        returns the volumetric water content at a given pF value 
        """
        return _cmf_core.RetentionCurve_Wetness_pF(self, *args)

    def MatricPotential(self, *args):
        """
        MatricPotential(self, real wetness) -> real

        virtual real MatricPotential(real wetness) const =0

        returns the wetness of the soil at given water content 
        """
        return _cmf_core.RetentionCurve_MatricPotential(self, *args)

    def copy(self):
        """
        copy(self) -> RetentionCurve

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf_core.RetentionCurve_copy(self)

    __swig_destroy__ = _cmf_core.delete_RetentionCurve
RetentionCurve.K = new_instancemethod(_cmf_core.RetentionCurve_K,None,RetentionCurve)
RetentionCurve.Porosity = new_instancemethod(_cmf_core.RetentionCurve_Porosity,None,RetentionCurve)
RetentionCurve.VoidVolume = new_instancemethod(_cmf_core.RetentionCurve_VoidVolume,None,RetentionCurve)
RetentionCurve.FillHeight = new_instancemethod(_cmf_core.RetentionCurve_FillHeight,None,RetentionCurve)
RetentionCurve.Transmissivity = new_instancemethod(_cmf_core.RetentionCurve_Transmissivity,None,RetentionCurve)
RetentionCurve.Wetness = new_instancemethod(_cmf_core.RetentionCurve_Wetness,None,RetentionCurve)
RetentionCurve.Wetness_pF = new_instancemethod(_cmf_core.RetentionCurve_Wetness_pF,None,RetentionCurve)
RetentionCurve.MatricPotential = new_instancemethod(_cmf_core.RetentionCurve_MatricPotential,None,RetentionCurve)
RetentionCurve.copy = new_instancemethod(_cmf_core.RetentionCurve_copy,None,RetentionCurve)
RetentionCurve_swigregister = _cmf_core.RetentionCurve_swigregister
RetentionCurve_swigregister(RetentionCurve)
rho_wg = cvar.rho_wg

class BrooksCoreyRetentionCurve(RetentionCurve):
    """
    Provides the use of the Brooks-Corey retention curve
    \\begin{eqnarray*} K(W) &=& K_{sat} W^{2+3b} \\\\ \\Psi(W) &=&
    \\Psi_X \\left(\\frac{W}{W_X}\\right)^{-b} \\\\ W &=&
    {\\left( \\frac{\\Psi_X}{\\Psi}\\right)
    }^{\\frac{1}{b}}\\ W_X \\end{eqnarray*} where:  $K$ is the
    conductivity in $\\frac m {day}$

    $W$ is the wetness (Volume of soil water per volume of pores)

    $b$ is the shape of the retention curve (usually between 4 (sand) and
    14 (clay))

    $\\Psi(W)$ is the matric potential in $m H_2O$ at wetness W

    $\\Psi_X$ is a matric potential at a known wetness in $m H_2O$

    $\\W_X$ is the wetness with a known matric potential for dynamic
    changes with depth, exponential decays of porosity and saturated
    conductivity are used The decay function is: $ v(d)=v(0) (1+a)^{-d} $,
    where v is the value ( $ K_{sat},\\Phi$), d is the depth in m and a
    is the fractional decay per m. E.g. 0.1 means the value has in 1 m
    depth 90% of the value at the surface.

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetKsat(self, *args):
        """
        SetKsat(self, real ksat, real ksat_decay)

        real SetKsat(real
        ksat, real ksat_decay) 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_SetKsat(self, *args)

    def SetPorosity(self, *args):
        """
        SetPorosity(self, real porosity, real porosity_decay = 0)
        SetPorosity(self, real porosity)

        void
        SetPorosity(real porosity, real porosity_decay=0)

        Sets the porosity (Volume of pores per volume of soil) and the
        exponential porosity decline with depth. 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_SetPorosity(self, *args)

    wetness_X = _swig_property(_cmf_core.BrooksCoreyRetentionCurve_wetness_X_get, _cmf_core.BrooksCoreyRetentionCurve_wetness_X_set)
    Psi_X = _swig_property(_cmf_core.BrooksCoreyRetentionCurve_Psi_X_get, _cmf_core.BrooksCoreyRetentionCurve_Psi_X_set)
    def b(self):
        """b(self) -> real"""
        return _cmf_core.BrooksCoreyRetentionCurve_b(self)

    def Set_b(self, *args):
        """Set_b(self, real new_b)"""
        return _cmf_core.BrooksCoreyRetentionCurve_Set_b(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2, 
            real psi_x = cmf::upslope::pF_to_waterhead(2.5), 
            real ksat_decay = 0, real porosity_decay = 0) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2, 
            real psi_x = cmf::upslope::pF_to_waterhead(2.5), 
            real ksat_decay = 0) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2, 
            real psi_x = cmf::upslope::pF_to_waterhead(2.5)) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15, real porosity = 0.5) -> BrooksCoreyRetentionCurve
        __init__(self, real ksat = 15) -> BrooksCoreyRetentionCurve
        __init__(self) -> BrooksCoreyRetentionCurve

        BrooksCoreyRetentionCurve(real ksat, real porosity, real theta1, real
        theta2, real psi_1=pF_to_waterhead(2.5), real
        psi_2=pF_to_waterhead(4.2))

        Creates a soiltype from two known points of the retention curve (e.g.
        fieldcapacity and wilting point).

        Parameters:
        -----------

        ksat:  Saturated conductivity $\\frac{m}{day}$

        porosity:   $\\frac {m^3 Pores}{m^3 Soil}$

        theta1:   $\\theta_1$ First water content at a specific suction
        pressure (e.g. fieldcapacity)

        theta2:   $\\theta_2$ Second water content at a specific suction
        pressure (e.g. wiltingpoint)

        psi_1:   $ \\Psi_1$ Suction pressure for $\\theta_1$ in m water
        column, use the conversion functions pF_to_waterhead,
        pressure_to_waterhead to convert pressure in to waterhead height
        (default pF=2.5)

        psi_2:   $ \\Psi_2$ Suction pressure for $\\theta_2$ in m water
        column, use the conversion functions pF_to_waterhead,
        pressure_to_waterhead to convert pressure in to waterhead height
        (default pF=4.2)

        The paramter b (shape of the retention curve) is calculated by: \\[
        b =
        \\frac{\\log\\left(\\frac{\\Psi_1}{\\Psi_2}\\right)}{\\log\\left(\\frac{\\theta_2}{\\theta_1}\\right)}
        \\] 
        """
        _cmf_core.BrooksCoreyRetentionCurve_swiginit(self,_cmf_core.new_BrooksCoreyRetentionCurve(*args))
    def CreateFrom2Points(*args):
        """
        CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
            real psi_1 = cmf::upslope::pF_to_waterhead(2.5), 
            real psi_2 = cmf::upslope::pF_to_waterhead(4.2)) -> BrooksCoreyRetentionCurve
        CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
            real psi_1 = cmf::upslope::pF_to_waterhead(2.5)) -> BrooksCoreyRetentionCurve
        CreateFrom2Points(real ksat, real porosity, real theta1, real theta2) -> BrooksCoreyRetentionCurve
        """
        return _cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points(*args)

    CreateFrom2Points = staticmethod(CreateFrom2Points)
    def copy(self):
        """
        copy(self) -> BrooksCoreyRetentionCurve

        virtual BrooksCoreyRetentionCurve* copy() const 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_copy(self)

    __swig_destroy__ = _cmf_core.delete_BrooksCoreyRetentionCurve
BrooksCoreyRetentionCurve.SetKsat = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_SetKsat,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.SetPorosity = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_SetPorosity,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.b = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_b,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.Set_b = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_Set_b,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.copy = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_copy,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve_swigregister = _cmf_core.BrooksCoreyRetentionCurve_swigregister
BrooksCoreyRetentionCurve_swigregister(BrooksCoreyRetentionCurve)

def BrooksCoreyRetentionCurve_CreateFrom2Points(*args):
  """
    CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
        real psi_1 = cmf::upslope::pF_to_waterhead(2.5), 
        real psi_2 = cmf::upslope::pF_to_waterhead(4.2)) -> BrooksCoreyRetentionCurve
    CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
        real psi_1 = cmf::upslope::pF_to_waterhead(2.5)) -> BrooksCoreyRetentionCurve
    BrooksCoreyRetentionCurve_CreateFrom2Points(real ksat, real porosity, real theta1, real theta2) -> BrooksCoreyRetentionCurve
    """
  return _cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points(*args)

class VanGenuchtenMualem(RetentionCurve):
    """Proxy of C++ cmf::upslope::VanGenuchtenMualem class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = _swig_property(_cmf_core.VanGenuchtenMualem_alpha_get, _cmf_core.VanGenuchtenMualem_alpha_set)
    n = _swig_property(_cmf_core.VanGenuchtenMualem_n_get, _cmf_core.VanGenuchtenMualem_n_set)
    Ksat = _swig_property(_cmf_core.VanGenuchtenMualem_Ksat_get, _cmf_core.VanGenuchtenMualem_Ksat_set)
    Phi = _swig_property(_cmf_core.VanGenuchtenMualem_Phi_get, _cmf_core.VanGenuchtenMualem_Phi_set)
    def copy(self):
        """
        copy(self) -> VanGenuchtenMualem

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf_core.VanGenuchtenMualem_copy(self)

    def __init__(self, *args): 
        """
        __init__(self) -> VanGenuchtenMualem
        __init__(self, real _n, real _alpha, real _phi, real _Ksat) -> VanGenuchtenMualem
        """
        _cmf_core.VanGenuchtenMualem_swiginit(self,_cmf_core.new_VanGenuchtenMualem(*args))
    __swig_destroy__ = _cmf_core.delete_VanGenuchtenMualem
VanGenuchtenMualem.copy = new_instancemethod(_cmf_core.VanGenuchtenMualem_copy,None,VanGenuchtenMualem)
VanGenuchtenMualem_swigregister = _cmf_core.VanGenuchtenMualem_swigregister
VanGenuchtenMualem_swigregister(VanGenuchtenMualem)

class RCurve(object):
    """Proxy of C++ cmf::upslope::RCurve class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Wetness(self, *args):
        """Wetness(self, real suction) -> real"""
        return _cmf_core.RCurve_Wetness(self, *args)

    def MatricPotential(self, *args):
        """MatricPotential(self, real wetness) -> real"""
        return _cmf_core.RCurve_MatricPotential(self, *args)

    def K(self, *args):
        """K(self, real wetness, real depth) -> real"""
        return _cmf_core.RCurve_K(self, *args)

    def VoidVolume(self, *args):
        """VoidVolume(self, real upperDepth, real lowerDepth, real Area) -> real"""
        return _cmf_core.RCurve_VoidVolume(self, *args)

    def Transmissivity(self, *args):
        """Transmissivity(self, real upperDepth, real lowerDepth, real wetness) -> real"""
        return _cmf_core.RCurve_Transmissivity(self, *args)

    def Porosity(self, *args):
        """Porosity(self, real depth) -> real"""
        return _cmf_core.RCurve_Porosity(self, *args)

    def FillHeight(self, *args):
        """FillHeight(self, real lowerDepth, real Area, real Volume) -> real"""
        return _cmf_core.RCurve_FillHeight(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, RetentionCurve forcopy, bool Shared = False) -> RCurve
        __init__(self, RetentionCurve forcopy) -> RCurve
        __init__(self, RCurve forcopy) -> RCurve
        __init__(self, bool Shared = False) -> RCurve
        __init__(self) -> RCurve
        """
        _cmf_core.RCurve_swiginit(self,_cmf_core.new_RCurve(*args))
    def AsVanGenuchten(self):
        """AsVanGenuchten(self) -> VanGenuchtenMualem"""
        return _cmf_core.RCurve_AsVanGenuchten(self)

    def AsBrooksCorey(self):
        """AsBrooksCorey(self) -> BrooksCoreyRetentionCurve"""
        return _cmf_core.RCurve_AsBrooksCorey(self)

    shared = _swig_property(_cmf_core.RCurve_shared_get, _cmf_core.RCurve_shared_set)
    __swig_destroy__ = _cmf_core.delete_RCurve
RCurve.Wetness = new_instancemethod(_cmf_core.RCurve_Wetness,None,RCurve)
RCurve.MatricPotential = new_instancemethod(_cmf_core.RCurve_MatricPotential,None,RCurve)
RCurve.K = new_instancemethod(_cmf_core.RCurve_K,None,RCurve)
RCurve.VoidVolume = new_instancemethod(_cmf_core.RCurve_VoidVolume,None,RCurve)
RCurve.Transmissivity = new_instancemethod(_cmf_core.RCurve_Transmissivity,None,RCurve)
RCurve.Porosity = new_instancemethod(_cmf_core.RCurve_Porosity,None,RCurve)
RCurve.FillHeight = new_instancemethod(_cmf_core.RCurve_FillHeight,None,RCurve)
RCurve.AsVanGenuchten = new_instancemethod(_cmf_core.RCurve_AsVanGenuchten,None,RCurve)
RCurve.AsBrooksCorey = new_instancemethod(_cmf_core.RCurve_AsBrooksCorey,None,RCurve)
RCurve_swigregister = _cmf_core.RCurve_swigregister
RCurve_swigregister(RCurve)

class SoilWaterStorage(WaterStorage):
    """
    A representation of a Layer.

    C++ includes: SoilWaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Position = _swig_property(_cmf_core.SoilWaterStorage_Position_get)
    cell = _swig_property(_cmf_core.SoilWaterStorage_cell_get)
    def UpperBoundary(self):
        """
        UpperBoundary(self) -> double

        virtual double UpperBoundary() const

        Returns the upper boundary of the water storage below ground in m. 
        """
        return _cmf_core.SoilWaterStorage_UpperBoundary(self)

    def LowerBoundary(self):
        """
        LowerBoundary(self) -> double

        virtual double LowerBoundary() const

        Returns the lower boundary of the water storage below ground in m. 
        """
        return _cmf_core.SoilWaterStorage_LowerBoundary(self)

    def Thickness(self):
        """
        Thickness(self) -> double

        double Thickness() const 
        """
        return _cmf_core.SoilWaterStorage_Thickness(self)

    def Soil(self, *args):
        """
        Soil(self) -> RCurve
        Soil(self) -> RCurve

        virtual
        RetentionCurve& Soil() 
        """
        return _cmf_core.SoilWaterStorage_Soil(self, *args)

    def theta(self, *args):
        """
        theta(self) -> real
        theta(self, real Value)

        virtual
        void theta(real Value) 
        """
        return _cmf_core.SoilWaterStorage_theta(self, *args)

    def K(self):
        """
        K(self) -> double

        double K()
        const

        Returns the actual conductivity $\\frac{m}{day}$. 
        """
        return _cmf_core.SoilWaterStorage_K(self)

    def Ksat(self):
        """Ksat(self) -> double"""
        return _cmf_core.SoilWaterStorage_Ksat(self)

    def Wetness(self, *args):
        """
        Wetness(self) -> double
        Wetness(self, double wetness)

        virtual double Wetness() const

        Returns the wetness of the soil $ \\frac{V_{H_2O}}{V_{pores}} $. 
        """
        return _cmf_core.SoilWaterStorage_Wetness(self, *args)

    def MatrixPotential(self):
        """
        MatrixPotential(self) -> real

        virtual real MatrixPotential() const

        Calls RetentionCurve::Matrixpotential. 
        """
        return _cmf_core.SoilWaterStorage_MatrixPotential(self)

    def GravitationalPotential(self):
        """
        GravitationalPotential(self) -> real

        real
        GravitationalPotential() const

        Gravitational Potential in m, reference height is sea level \\[
        \\Psi_G=h \\]. 
        """
        return _cmf_core.SoilWaterStorage_GravitationalPotential(self)

    def Capacity(self):
        """
        Capacity(self) -> real

        virtual real Capacity()

        Returns the capacity of the water storage in m3. 
        """
        return _cmf_core.SoilWaterStorage_Capacity(self)

    def SetPotential(self, *args):
        """
        SetPotential(self, real waterhead)

        void SetPotential(real waterhead)

        Sets the potential of this soil water storage. 
        """
        return _cmf_core.SoilWaterStorage_SetPotential(self, *args)

    def SaturatedDepth(self):
        """SaturatedDepth(self) -> real"""
        return _cmf_core.SoilWaterStorage_SaturatedDepth(self)

    def GetFlowCrosssection(self, *args):
        """
        GetFlowCrosssection(self, SoilWaterStorage target, bool HorizontalLayers = False) -> real
        GetFlowCrosssection(self, SoilWaterStorage target) -> real
        """
        return _cmf_core.SoilWaterStorage_GetFlowCrosssection(self, *args)

    def copy(self):
        """
        copy(self) -> SoilWaterStorage

        SoilWaterStorage* copy() 
        """
        return _cmf_core.SoilWaterStorage_copy(self)

    def Create(*args):
        """
        Create(Cell _cell, real lowerboundary, RCurve r_curve, real saturateddepth = -10) -> SoilWaterStorage
        Create(Cell _cell, real lowerboundary, RCurve r_curve) -> SoilWaterStorage
        """
        return _cmf_core.SoilWaterStorage_Create(*args)

    Create = staticmethod(Create)
    boundary=property(lambda self:(self.LowerBoundary(),self.UpperBoundary()),None,"Returns the upper and lower boundary of the layer")
    def __repr__(self):
        return self.Name

    __swig_destroy__ = _cmf_core.delete_SoilWaterStorage
SoilWaterStorage.UpperBoundary = new_instancemethod(_cmf_core.SoilWaterStorage_UpperBoundary,None,SoilWaterStorage)
SoilWaterStorage.LowerBoundary = new_instancemethod(_cmf_core.SoilWaterStorage_LowerBoundary,None,SoilWaterStorage)
SoilWaterStorage.Thickness = new_instancemethod(_cmf_core.SoilWaterStorage_Thickness,None,SoilWaterStorage)
SoilWaterStorage.Soil = new_instancemethod(_cmf_core.SoilWaterStorage_Soil,None,SoilWaterStorage)
SoilWaterStorage.theta = new_instancemethod(_cmf_core.SoilWaterStorage_theta,None,SoilWaterStorage)
SoilWaterStorage.K = new_instancemethod(_cmf_core.SoilWaterStorage_K,None,SoilWaterStorage)
SoilWaterStorage.Ksat = new_instancemethod(_cmf_core.SoilWaterStorage_Ksat,None,SoilWaterStorage)
SoilWaterStorage.Wetness = new_instancemethod(_cmf_core.SoilWaterStorage_Wetness,None,SoilWaterStorage)
SoilWaterStorage.MatrixPotential = new_instancemethod(_cmf_core.SoilWaterStorage_MatrixPotential,None,SoilWaterStorage)
SoilWaterStorage.GravitationalPotential = new_instancemethod(_cmf_core.SoilWaterStorage_GravitationalPotential,None,SoilWaterStorage)
SoilWaterStorage.Capacity = new_instancemethod(_cmf_core.SoilWaterStorage_Capacity,None,SoilWaterStorage)
SoilWaterStorage.SetPotential = new_instancemethod(_cmf_core.SoilWaterStorage_SetPotential,None,SoilWaterStorage)
SoilWaterStorage.SaturatedDepth = new_instancemethod(_cmf_core.SoilWaterStorage_SaturatedDepth,None,SoilWaterStorage)
SoilWaterStorage.GetFlowCrosssection = new_instancemethod(_cmf_core.SoilWaterStorage_GetFlowCrosssection,None,SoilWaterStorage)
SoilWaterStorage.copy = new_instancemethod(_cmf_core.SoilWaterStorage_copy,None,SoilWaterStorage)
SoilWaterStorage_swigregister = _cmf_core.SoilWaterStorage_swigregister
SoilWaterStorage_swigregister(SoilWaterStorage)

def SoilWaterStorage_Create(*args):
  """
    Create(Cell _cell, real lowerboundary, RCurve r_curve, real saturateddepth = -10) -> SoilWaterStorage
    SoilWaterStorage_Create(Cell _cell, real lowerboundary, RCurve r_curve) -> SoilWaterStorage
    """
  return _cmf_core.SoilWaterStorage_Create(*args)

class FlexibleSizeSaturatedZone(SoilWaterStorage):
    """
    A soil water storage with a flexible (non constant) upper boundary,
    according to its fill state. This soil water storage is always
    saturated.

    C++ includes: SoilWaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Create(*args):
        """Create(Cell cell, real lowerboundary, RCurve r_curve) -> FlexibleSizeSaturatedZone"""
        return _cmf_core.FlexibleSizeSaturatedZone_Create(*args)

    Create = staticmethod(Create)
    __swig_destroy__ = _cmf_core.delete_FlexibleSizeSaturatedZone
FlexibleSizeSaturatedZone_swigregister = _cmf_core.FlexibleSizeSaturatedZone_swigregister
FlexibleSizeSaturatedZone_swigregister(FlexibleSizeSaturatedZone)

def FlexibleSizeSaturatedZone_Create(*args):
  """FlexibleSizeSaturatedZone_Create(Cell cell, real lowerboundary, RCurve r_curve) -> FlexibleSizeSaturatedZone"""
  return _cmf_core.FlexibleSizeSaturatedZone_Create(*args)

class FlexibleSizeLayer(SoilWaterStorage):
    """
    A soil water storage above a FlexibleSizeSaturatedLayer, can only be
    created by FlexibleSaturatedLayer.

    C++ includes: SoilWaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_FlexibleSizeLayer
FlexibleSizeLayer_swigregister = _cmf_core.FlexibleSizeLayer_swigregister
FlexibleSizeLayer_swigregister(FlexibleSizeLayer)


def AsSoilWater(*args):
  """AsSoilWater(FluxNode node) -> SoilWaterStorage"""
  return _cmf_core.AsSoilWater(*args)
class Vegetation(object):
    """Proxy of C++ cmf::upslope::vegetation::Vegetation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LAI = _swig_property(_cmf_core.Vegetation_LAI_get, _cmf_core.Vegetation_LAI_set)
    Height = _swig_property(_cmf_core.Vegetation_Height_get, _cmf_core.Vegetation_Height_set)
    albedo = _swig_property(_cmf_core.Vegetation_albedo_get, _cmf_core.Vegetation_albedo_set)
    CanopyCapacityPerLAI = _swig_property(_cmf_core.Vegetation_CanopyCapacityPerLAI_get, _cmf_core.Vegetation_CanopyCapacityPerLAI_set)
    RootDepth = _swig_property(_cmf_core.Vegetation_RootDepth_get, _cmf_core.Vegetation_RootDepth_set)
    fraction_at_rootdepth = _swig_property(_cmf_core.Vegetation_fraction_at_rootdepth_get, _cmf_core.Vegetation_fraction_at_rootdepth_set)
    StomatalResistance = _swig_property(_cmf_core.Vegetation_StomatalResistance_get, _cmf_core.Vegetation_StomatalResistance_set)
    CanopyClosure = _swig_property(_cmf_core.Vegetation_CanopyClosure_get, _cmf_core.Vegetation_CanopyClosure_set)
    LeafWidth = _swig_property(_cmf_core.Vegetation_LeafWidth_get, _cmf_core.Vegetation_LeafWidth_set)
    def RootFraction(self, *args):
        """
        RootFraction(self, double upperBoundary, double lowerBoundary) -> double

        virtual double
        RootFraction(double upperBoundary, double lowerBoundary) const 
        """
        return _cmf_core.Vegetation_RootFraction(self, *args)

    def __init__(self, _LAI = 12, _Height = 0.12, _RootDepth = 0.25, _StomatalResistance = 100, 
    _albedo = 0.23, _CanopyClosure = 1, 
    _CanopyCapacityPerLAI = 0.1, _fraction_at_rootdepth = 1.0): 
        """
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23, double _CanopyClosure = 1, 
            double _CanopyCapacityPerLAI = 0.1, 
            double _fraction_at_rootdepth = 1.0) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23, double _CanopyClosure = 1, 
            double _CanopyCapacityPerLAI = 0.1) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23, double _CanopyClosure = 1) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12, double _RootDepth = 0.25) -> Vegetation
        __init__(self, double _LAI = 12, double _Height = 0.12) -> Vegetation
        __init__(self, double _LAI = 12) -> Vegetation
        __init__(self) -> Vegetation

        Vegetation(double
        _LAI=12, double _Height=0.12, double _RootDepth=0.25, double
        _StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
        double _CanopyCapacityPerLAI=0.01) 
        """
        _cmf_core.Vegetation_swiginit(self,_cmf_core.new_Vegetation(_LAI, _Height, _RootDepth, _StomatalResistance, _albedo, 
    _CanopyClosure, _CanopyCapacityPerLAI, 
    _fraction_at_rootdepth))
    __swig_destroy__ = _cmf_core.delete_Vegetation
Vegetation.RootFraction = new_instancemethod(_cmf_core.Vegetation_RootFraction,None,Vegetation)
Vegetation_swigregister = _cmf_core.Vegetation_swigregister
Vegetation_swigregister(Vegetation)

class CellConnector(object):
    """Proxy of C++ cmf::upslope::CellConnector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def connect(self, *args):
        """
        connect(self, Cell cell1, Cell cell2, int start_at_layer = 0)
        connect(self, Cell cell1, Cell cell2)
        """
        return _cmf_core.CellConnector_connect(self, *args)

    __swig_destroy__ = _cmf_core.delete_CellConnector
CellConnector.connect = new_instancemethod(_cmf_core.CellConnector_connect,None,CellConnector)
CellConnector_swigregister = _cmf_core.CellConnector_swigregister
CellConnector_swigregister(CellConnector)

class Cell(StateVariableOwner):
    """Proxy of C++ cmf::upslope::Cell class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_cmf_core.Cell_x_get, _cmf_core.Cell_x_set)
    y = _swig_property(_cmf_core.Cell_y_get, _cmf_core.Cell_y_set)
    z = _swig_property(_cmf_core.Cell_z_get, _cmf_core.Cell_z_set)
    def Center(self):
        """
        Center(self) -> point

        cmf::geometry::point Center() const

        Returns the location of the cell. 
        """
        return _cmf_core.Cell_Center(self)

    def Area(self):
        """
        Area(self) -> double

        double Area() const

        Returns the area of the cell. 
        """
        return _cmf_core.Cell_Area(self)

    def InvalidateSatDepth(self):
        """InvalidateSatDepth(self)"""
        return _cmf_core.Cell_InvalidateSatDepth(self)

    def SaturatedDepth(self):
        """
        SaturatedDepth(self) -> real

        real
        SaturatedDepth() 
        """
        return _cmf_core.Cell_SaturatedDepth(self)

    def SetSaturatedDepth(self, *args):
        """SetSaturatedDepth(self, real depth)"""
        return _cmf_core.Cell_SetSaturatedDepth(self, *args)

    def Evaporation(self):
        """Evaporation(self) -> FluxNode"""
        return _cmf_core.Cell_Evaporation(self)

    def Transpiration(self):
        """Transpiration(self) -> FluxNode"""
        return _cmf_core.Cell_Transpiration(self)

    def SurfaceWater(self):
        """
        SurfaceWater(self) -> FluxNode

        cmf::water::FluxNode& SurfaceWater()

        returns the surface water of this cell 
        """
        return _cmf_core.Cell_SurfaceWater(self)

    def AddStorage(self, *args):
        """
        AddStorage(self, string Name, char storage_role = 'N', bool isopenwater = False) -> WaterStorage
        AddStorage(self, string Name, char storage_role = 'N') -> WaterStorage
        AddStorage(self, string Name) -> WaterStorage
        """
        return _cmf_core.Cell_AddStorage(self, *args)

    def RemoveStorage(self, *args):
        """RemoveStorage(self, WaterStorage storage)"""
        return _cmf_core.Cell_RemoveStorage(self, *args)

    def AddReach(self, *args):
        """
        AddReach(self, double length, char shape = 'T', double depth = 0.25, 
            double width = 1., string Name = "Reach") -> Reach
        AddReach(self, double length, char shape = 'T', double depth = 0.25, 
            double width = 1.) -> Reach
        AddReach(self, double length, char shape = 'T', double depth = 0.25) -> Reach
        AddReach(self, double length, char shape = 'T') -> Reach
        AddReach(self, double length) -> Reach
        """
        return _cmf_core.Cell_AddReach(self, *args)

    def StorageCount(self):
        """StorageCount(self) -> int"""
        return _cmf_core.Cell_StorageCount(self)

    def GetStorage(self, *args):
        """
        GetStorage(self, int index) -> WaterStorage
        GetStorage(self, int index) -> WaterStorage
        """
        return _cmf_core.Cell_GetStorage(self, *args)

    def GetReach(self, index = 0):
        """
        GetReach(self, int index = 0) -> Reach
        GetReach(self) -> Reach
        """
        return _cmf_core.Cell_GetReach(self, index)

    def ReachCount(self):
        """ReachCount(self) -> size_t"""
        return _cmf_core.Cell_ReachCount(self)

    def GetCanopy(self):
        """GetCanopy(self) -> WaterStorage"""
        return _cmf_core.Cell_GetCanopy(self)

    def GetSnow(self):
        """GetSnow(self) -> WaterStorage"""
        return _cmf_core.Cell_GetSnow(self)

    def HasSnowStorage(self):
        """HasSnowStorage(self) -> bool"""
        return _cmf_core.Cell_HasSnowStorage(self)

    def SnowCover(self):
        """SnowCover(self) -> real"""
        return _cmf_core.Cell_SnowCover(self)

    def HasInterceptedWater(self):
        """HasInterceptedWater(self) -> bool"""
        return _cmf_core.Cell_HasInterceptedWater(self)

    def HasSurfaceWater(self):
        """HasSurfaceWater(self) -> bool"""
        return _cmf_core.Cell_HasSurfaceWater(self)

    Vegetation = _swig_property(_cmf_core.Cell_Vegetation_get, _cmf_core.Cell_Vegetation_set)
    def GetVegetation(self):
        """GetVegetation(self) -> Vegetation"""
        return _cmf_core.Cell_GetVegetation(self)

    Id = _swig_property(_cmf_core.Cell_Id_get, _cmf_core.Cell_Id_set)
    def project(self):
        """project(self) -> project"""
        return _cmf_core.Cell_project(self)

    def Weather(self, *args):
        """Weather(self, Time t) -> Weather"""
        return _cmf_core.Cell_Weather(self, *args)

    def Rain(self, *args):
        """Rain(self, Time t) -> real"""
        return _cmf_core.Cell_Rain(self, *args)

    def LayerCount(self):
        """
        LayerCount(self) -> int

        int
        LayerCount() const 
        """
        return _cmf_core.Cell_LayerCount(self)

    def Layer(self, *args):
        """
        Layer(self, int ndx) -> SoilWaterStorage
        Layer(self, int ndx) -> SoilWaterStorage

        const
        cmf::upslope::SoilWaterStorage& Layer(int ndx) const 
        """
        return _cmf_core.Cell_Layer(self, *args)

    def AddLayer(self, *args):
        """
        AddLayer(self, real lowerboundary, RCurve r_curve, real saturateddepth = -10)
        AddLayer(self, real lowerboundary, RCurve r_curve)

        void
        AddLayer(cmf::upslope::SoilWaterStorage *layer)

        Registers a layer at the cell. This function is used by the ctor's of
        the layers and should never be used in other code. 
        """
        return _cmf_core.Cell_AddLayer(self, *args)

    def AddVariableLayerPair(self, *args):
        """AddVariableLayerPair(self, real lowerboundary, RCurve r_curve)"""
        return _cmf_core.Cell_AddVariableLayerPair(self, *args)

    def RemoveLastLayer(self):
        """RemoveLastLayer(self)"""
        return _cmf_core.Cell_RemoveLastLayer(self)

    def RemoveLayers(self):
        """RemoveLayers(self)"""
        return _cmf_core.Cell_RemoveLayers(self)

    __swig_destroy__ = _cmf_core.delete_Cell
    def __init__(self, *args): 
        """
        __init__(self, double x, double y, double z, double area, project _project) -> Cell

        Cell(double x,
        double y, double z, double area) 
        """
        _cmf_core.Cell_swiginit(self,_cmf_core.new_Cell(*args))
    def ToString(self):
        """ToString(self) -> string"""
        return _cmf_core.Cell_ToString(self)

    topology = _swig_property(_cmf_core.Cell_topology_get)
    @property
    def neighbors(self):
        c_iter=NeighborIterator(self)
        while c_iter.valid():
            yield (c_iter.cell(),c_iter.flowwidth())
            c_iter.next()
    storages=property(lambda c:_cell_object_list(c,'A'),None,"Provides access to all storages of the cell (surface storages and layers)")
    surface_storages=property(lambda c:_cell_object_list(c,'S'),None,"Provides access to all surface storages of the cell, like canopy, snow, surface water etc")
    layers=property(lambda c:_cell_object_list(c,'L'),None,"Provides access to all soil water storages (layers) of the cell")
    surface_water=property(SurfaceWater,None,"Gives access to the surface water, which is either a distributing flux node, or the storage for all surface water")
    canopy=property(GetCanopy,None,"The canopy water storage of the cell, if it exists")
    snow=property(GetSnow,None,"The snow pack of the cell, if a storage for the snow exists")
    saturated_depth=property(SaturatedDepth,SetSaturatedDepth,"Gets or sets the saturated depth of a cell, if setting each layer of the cell will get a new water content")
    area=property(Area,None,"The area of the cell in m2")
    soildepth=property(lambda self:0 if self.layercount()==0 else self[-1].boundary[-1],None,"the soildepth in m (lower boundary of lowest layer)")
    reach=property(lambda self:self.GetReach(0),None,"The first reach of the cell, other reaches are accessible via reaches[n]")
    reaches=property(lambda self:[self.GetReach(i) for i in range(self.ReachCount())],None,"The reaches of this cell")
    def connect_soil_with_node(self,node,type,flowwidth,distance,upper_boundary=0,lower_boundary=None):
        """Connects all layers between the boundaries with a node using a flux connection
        node: Target node (FluxNode)
        type: Type of the connection (e.g. cmf.Richards_lateral)
        flowwidth: Width of the connection
        distance: distance of the connection
        upper_boundary: Connect only layers, whose lower depth is greater then this value
        lower_boundary: Connect only  layers, whose upper depth is smaller then this value
        """
        if lower_boundary is None:
            lower_boundary=self.soildepth
        for l in self:
            if l.boundary[0]<lower_boundary and l.boundary[1]>upper_boundary:
                type(l,node,flowwidth,distance).thisown=0
    def __hash__(self):
        return hash((self.x,self.y,self.z,self.area,self.Id))
    def __eq__(self,cmp):
        return hash(self)==hash(cmp)
    def __repr__(self):
        return "cell #%i(%g,%g,%g)" % (self.Id,self.x,self.y,self.z)

Cell.Center = new_instancemethod(_cmf_core.Cell_Center,None,Cell)
Cell.Area = new_instancemethod(_cmf_core.Cell_Area,None,Cell)
Cell.InvalidateSatDepth = new_instancemethod(_cmf_core.Cell_InvalidateSatDepth,None,Cell)
Cell.SaturatedDepth = new_instancemethod(_cmf_core.Cell_SaturatedDepth,None,Cell)
Cell.SetSaturatedDepth = new_instancemethod(_cmf_core.Cell_SetSaturatedDepth,None,Cell)
Cell.Evaporation = new_instancemethod(_cmf_core.Cell_Evaporation,None,Cell)
Cell.Transpiration = new_instancemethod(_cmf_core.Cell_Transpiration,None,Cell)
Cell.SurfaceWater = new_instancemethod(_cmf_core.Cell_SurfaceWater,None,Cell)
Cell.AddStorage = new_instancemethod(_cmf_core.Cell_AddStorage,None,Cell)
Cell.RemoveStorage = new_instancemethod(_cmf_core.Cell_RemoveStorage,None,Cell)
Cell.AddReach = new_instancemethod(_cmf_core.Cell_AddReach,None,Cell)
Cell.StorageCount = new_instancemethod(_cmf_core.Cell_StorageCount,None,Cell)
Cell.GetStorage = new_instancemethod(_cmf_core.Cell_GetStorage,None,Cell)
Cell.GetReach = new_instancemethod(_cmf_core.Cell_GetReach,None,Cell)
Cell.ReachCount = new_instancemethod(_cmf_core.Cell_ReachCount,None,Cell)
Cell.GetCanopy = new_instancemethod(_cmf_core.Cell_GetCanopy,None,Cell)
Cell.GetSnow = new_instancemethod(_cmf_core.Cell_GetSnow,None,Cell)
Cell.HasSnowStorage = new_instancemethod(_cmf_core.Cell_HasSnowStorage,None,Cell)
Cell.SnowCover = new_instancemethod(_cmf_core.Cell_SnowCover,None,Cell)
Cell.HasInterceptedWater = new_instancemethod(_cmf_core.Cell_HasInterceptedWater,None,Cell)
Cell.HasSurfaceWater = new_instancemethod(_cmf_core.Cell_HasSurfaceWater,None,Cell)
Cell.GetVegetation = new_instancemethod(_cmf_core.Cell_GetVegetation,None,Cell)
Cell.project = new_instancemethod(_cmf_core.Cell_project,None,Cell)
Cell.Weather = new_instancemethod(_cmf_core.Cell_Weather,None,Cell)
Cell.Rain = new_instancemethod(_cmf_core.Cell_Rain,None,Cell)
Cell.LayerCount = new_instancemethod(_cmf_core.Cell_LayerCount,None,Cell)
Cell.Layer = new_instancemethod(_cmf_core.Cell_Layer,None,Cell)
Cell.AddLayer = new_instancemethod(_cmf_core.Cell_AddLayer,None,Cell)
Cell.AddVariableLayerPair = new_instancemethod(_cmf_core.Cell_AddVariableLayerPair,None,Cell)
Cell.RemoveLastLayer = new_instancemethod(_cmf_core.Cell_RemoveLastLayer,None,Cell)
Cell.RemoveLayers = new_instancemethod(_cmf_core.Cell_RemoveLayers,None,Cell)
Cell.ToString = new_instancemethod(_cmf_core.Cell_ToString,None,Cell)
Cell_swigregister = _cmf_core.Cell_swigregister
Cell_swigregister(Cell)

class _cell_object_list:
    def __init__(self,c,kind):
        self.c=c
        self.kind=kind
    def get(self,index):
        if self.kind=="L":
            return self.c.Layer(index)
        elif self.kind=="S":
            return self.c.GetStorage(index)
        else:
             ndx=index if index>=0 else self.c.StorageCount()+self.c.LayerCount()+index
             lndx=index-self.c.StorageCount()
             if lndx<0:
                 return self.c.GetStorage(ndx)
             else:
                 return self.c.Layer(lndx)
    def __getitem__(self,index):
        if (type(index)==slice):
             return list(map(self.get,range(*index.indices(len(self)))))
        try:
             gen=iter(index)
             return list(map(self.get,gen))
        except TypeError:
             return self.get(index)
    def find_by_name(self,name):
        for s in self:
            if s.Name==name:
                return s
        raise IndexError("No storage %s in %s of %s" % (name,"layers" if self.kind=='L' else "non layer storages" if self.kind=='S' else "storages",self.c))
    def __len__(self):
        return self.c.LayerCount() if self.kind=='L' else (self.c.StorageCount() if self.kind=='S' else self.c.LayerCount()+self.c.StorageCount())
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

class Topology(object):
    """Proxy of C++ cmf::upslope::Topology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    cell = _swig_property(_cmf_core.Topology_cell_get)
    x = _swig_property(_cmf_core.Topology_x_get, _cmf_core.Topology_x_set)
    y = _swig_property(_cmf_core.Topology_y_get, _cmf_core.Topology_y_set)
    z = _swig_property(_cmf_core.Topology_z_get, _cmf_core.Topology_z_set)
    def Center(self):
        """Center(self) -> point"""
        return _cmf_core.Topology_Center(self)

    def flowwidth(self, *args):
        """
        flowwidth(self, Cell target) -> double
        flowwidth(self, Topology target) -> double
        """
        return _cmf_core.Topology_flowwidth(self, *args)

    def AddNeighbor(self, *args):
        """
        AddNeighbor(self, Cell target, double flowwidth)
        AddNeighbor(self, Topology target, double flowwidth)
        """
        return _cmf_core.Topology_AddNeighbor(self, *args)

    def RemoveNeighbor(self, *args):
        """RemoveNeighbor(self, Topology target)"""
        return _cmf_core.Topology_RemoveNeighbor(self, *args)

    def neighbor_count(self):
        """neighbor_count(self) -> size_t"""
        return _cmf_core.Topology_neighbor_count(self)

    def MainOutlet(self, forceRecalc = False):
        """
        MainOutlet(self, bool forceRecalc = False) -> Cell
        MainOutlet(self) -> Cell
        """
        return _cmf_core.Topology_MainOutlet(self, forceRecalc)

    def ContributingArea(self, forceRecalc = False):
        """
        ContributingArea(self, bool forceRecalc = False) -> double
        ContributingArea(self) -> double
        """
        return _cmf_core.Topology_ContributingArea(self, forceRecalc)

    def __eq__(self, *args):
        """__eq__(self, Topology cmp) -> bool"""
        return _cmf_core.Topology___eq__(self, *args)

    __swig_destroy__ = _cmf_core.delete_Topology
Topology.Center = new_instancemethod(_cmf_core.Topology_Center,None,Topology)
Topology.flowwidth = new_instancemethod(_cmf_core.Topology_flowwidth,None,Topology)
Topology.AddNeighbor = new_instancemethod(_cmf_core.Topology_AddNeighbor,None,Topology)
Topology.RemoveNeighbor = new_instancemethod(_cmf_core.Topology_RemoveNeighbor,None,Topology)
Topology.neighbor_count = new_instancemethod(_cmf_core.Topology_neighbor_count,None,Topology)
Topology.MainOutlet = new_instancemethod(_cmf_core.Topology_MainOutlet,None,Topology)
Topology.ContributingArea = new_instancemethod(_cmf_core.Topology_ContributingArea,None,Topology)
Topology.__eq__ = new_instancemethod(_cmf_core.Topology___eq__,None,Topology)
Topology_swigregister = _cmf_core.Topology_swigregister
Topology_swigregister(Topology)

class NeighborIterator(object):
    """Proxy of C++ cmf::upslope::NeighborIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Cell cell) -> NeighborIterator"""
        _cmf_core.NeighborIterator_swiginit(self,_cmf_core.new_NeighborIterator(*args))
    def cell(self):
        """cell(self) -> Cell"""
        return _cmf_core.NeighborIterator_cell(self)

    def flowwidth(self):
        """flowwidth(self) -> double"""
        return _cmf_core.NeighborIterator_flowwidth(self)

    def valid(self):
        """valid(self) -> bool"""
        return _cmf_core.NeighborIterator_valid(self)

    def next(self):
        """next(self) -> NeighborIterator"""
        return _cmf_core.NeighborIterator_next(self)

    def __eq__(self, *args):
        """__eq__(self, NeighborIterator cmp) -> bool"""
        return _cmf_core.NeighborIterator___eq__(self, *args)

    def __neq__(self, *args):
        """__neq__(self, NeighborIterator cmp) -> bool"""
        return _cmf_core.NeighborIterator___neq__(self, *args)

    __swig_destroy__ = _cmf_core.delete_NeighborIterator
NeighborIterator.cell = new_instancemethod(_cmf_core.NeighborIterator_cell,None,NeighborIterator)
NeighborIterator.flowwidth = new_instancemethod(_cmf_core.NeighborIterator_flowwidth,None,NeighborIterator)
NeighborIterator.valid = new_instancemethod(_cmf_core.NeighborIterator_valid,None,NeighborIterator)
NeighborIterator.next = new_instancemethod(_cmf_core.NeighborIterator_next,None,NeighborIterator)
NeighborIterator.__eq__ = new_instancemethod(_cmf_core.NeighborIterator___eq__,None,NeighborIterator)
NeighborIterator.__neq__ = new_instancemethod(_cmf_core.NeighborIterator___neq__,None,NeighborIterator)
NeighborIterator_swigregister = _cmf_core.NeighborIterator_swigregister
NeighborIterator_swigregister(NeighborIterator)

class cell_vector(object):
    """Proxy of C++ std::vector<(p.cmf::upslope::Cell)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.cell_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _cmf_core.cell_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _cmf_core.cell_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _cmf_core.cell_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _cmf_core.cell_vector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> cell_vector"""
        return _cmf_core.cell_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, cell_vector v)"""
        return _cmf_core.cell_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.cell_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.cell_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> cell_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.cell_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, cell_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.cell_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.cell_vector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _cmf_core.cell_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _cmf_core.cell_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _cmf_core.cell_vector_clear(self)

    def swap(self, *args):
        """swap(self, cell_vector v)"""
        return _cmf_core.cell_vector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.cell_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _cmf_core.cell_vector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _cmf_core.cell_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.cell_vector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.cell_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _cmf_core.cell_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.cell_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> cell_vector
        __init__(self, cell_vector arg0) -> cell_vector
        __init__(self, size_type size) -> cell_vector
        __init__(self, size_type size, value_type value) -> cell_vector
        """
        _cmf_core.cell_vector_swiginit(self,_cmf_core.new_cell_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.cell_vector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _cmf_core.cell_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _cmf_core.cell_vector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.cell_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.cell_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.cell_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.cell_vector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _cmf_core.cell_vector_capacity(self)

    __swig_destroy__ = _cmf_core.delete_cell_vector
cell_vector.iterator = new_instancemethod(_cmf_core.cell_vector_iterator,None,cell_vector)
cell_vector.__nonzero__ = new_instancemethod(_cmf_core.cell_vector___nonzero__,None,cell_vector)
cell_vector.__bool__ = new_instancemethod(_cmf_core.cell_vector___bool__,None,cell_vector)
cell_vector.__len__ = new_instancemethod(_cmf_core.cell_vector___len__,None,cell_vector)
cell_vector.pop = new_instancemethod(_cmf_core.cell_vector_pop,None,cell_vector)
cell_vector.__getslice__ = new_instancemethod(_cmf_core.cell_vector___getslice__,None,cell_vector)
cell_vector.__setslice__ = new_instancemethod(_cmf_core.cell_vector___setslice__,None,cell_vector)
cell_vector.__delslice__ = new_instancemethod(_cmf_core.cell_vector___delslice__,None,cell_vector)
cell_vector.__delitem__ = new_instancemethod(_cmf_core.cell_vector___delitem__,None,cell_vector)
cell_vector.__getitem__ = new_instancemethod(_cmf_core.cell_vector___getitem__,None,cell_vector)
cell_vector.__setitem__ = new_instancemethod(_cmf_core.cell_vector___setitem__,None,cell_vector)
cell_vector.append = new_instancemethod(_cmf_core.cell_vector_append,None,cell_vector)
cell_vector.empty = new_instancemethod(_cmf_core.cell_vector_empty,None,cell_vector)
cell_vector.size = new_instancemethod(_cmf_core.cell_vector_size,None,cell_vector)
cell_vector.clear = new_instancemethod(_cmf_core.cell_vector_clear,None,cell_vector)
cell_vector.swap = new_instancemethod(_cmf_core.cell_vector_swap,None,cell_vector)
cell_vector.get_allocator = new_instancemethod(_cmf_core.cell_vector_get_allocator,None,cell_vector)
cell_vector.begin = new_instancemethod(_cmf_core.cell_vector_begin,None,cell_vector)
cell_vector.end = new_instancemethod(_cmf_core.cell_vector_end,None,cell_vector)
cell_vector.rbegin = new_instancemethod(_cmf_core.cell_vector_rbegin,None,cell_vector)
cell_vector.rend = new_instancemethod(_cmf_core.cell_vector_rend,None,cell_vector)
cell_vector.pop_back = new_instancemethod(_cmf_core.cell_vector_pop_back,None,cell_vector)
cell_vector.erase = new_instancemethod(_cmf_core.cell_vector_erase,None,cell_vector)
cell_vector.push_back = new_instancemethod(_cmf_core.cell_vector_push_back,None,cell_vector)
cell_vector.front = new_instancemethod(_cmf_core.cell_vector_front,None,cell_vector)
cell_vector.back = new_instancemethod(_cmf_core.cell_vector_back,None,cell_vector)
cell_vector.assign = new_instancemethod(_cmf_core.cell_vector_assign,None,cell_vector)
cell_vector.resize = new_instancemethod(_cmf_core.cell_vector_resize,None,cell_vector)
cell_vector.insert = new_instancemethod(_cmf_core.cell_vector_insert,None,cell_vector)
cell_vector.reserve = new_instancemethod(_cmf_core.cell_vector_reserve,None,cell_vector)
cell_vector.capacity = new_instancemethod(_cmf_core.cell_vector_capacity,None,cell_vector)
cell_vector_swigregister = _cmf_core.cell_vector_swigregister
cell_vector_swigregister(cell_vector)


def boundary_cells(*args):
  """boundary_cells(cells_ref cells) -> cell_vector"""
  return _cmf_core.boundary_cells(*args)

def get_connections(*args):
  """get_connections(cells_ref cells) -> connection_set"""
  return _cmf_core.get_connections(*args)

def area(*args):
  """area(cells_ref cells) -> double"""
  return _cmf_core.area(*args)
class UnsatSatPercolation(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::UnsatSatPercolation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, FlexibleSizeLayer unsat, FlexibleSizeSaturatedZone sat) -> UnsatSatPercolation"""
        _cmf_core.UnsatSatPercolation_swiginit(self,_cmf_core.new_UnsatSatPercolation(*args))
    __swig_destroy__ = _cmf_core.delete_UnsatSatPercolation
UnsatSatPercolation_swigregister = _cmf_core.UnsatSatPercolation_swigregister
UnsatSatPercolation_swigregister(UnsatSatPercolation)

def find_cell(*args):
  """
    find_cell(cells_ref arg0, point p, double max_dist = 1e20) -> Cell
    find_cell(cells_ref arg0, point p) -> Cell
    """
  return _cmf_core.find_cell(*args)

def connect_cells_with_flux(*args):
  """
    connect_cells_with_flux(cells_ref cells, CellConnector connect, int start_at_layer = 0)
    connect_cells_with_flux(cells_ref cells, CellConnector connect)
    """
  return _cmf_core.connect_cells_with_flux(*args)

def fill_sinks(*args):
  """
    fill_sinks(cells_ref cells, double min_difference = 0.001) -> int
    fill_sinks(cells_ref cells) -> int
    """
  return _cmf_core.fill_sinks(*args)

class Darcy(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::Darcy class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0, 
            real Distance = 0) -> Darcy
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0) -> Darcy
        __init__(self, SoilWaterStorage left, FluxNode right) -> Darcy
        """
        _cmf_core.Darcy_swiginit(self,_cmf_core.new_Darcy(*args))
    __swig_destroy__ = _cmf_core.delete_Darcy
Darcy_swigregister = _cmf_core.Darcy_swigregister
Darcy_swigregister(Darcy)
Darcy.cell_connector = _cmf_core.cvar.Darcy_cell_connector

class TopographicGradientDarcy(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::TopographicGradientDarcy class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0, 
            real Distance = 0) -> TopographicGradientDarcy
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0) -> TopographicGradientDarcy
        __init__(self, SoilWaterStorage left, FluxNode right) -> TopographicGradientDarcy
        """
        _cmf_core.TopographicGradientDarcy_swiginit(self,_cmf_core.new_TopographicGradientDarcy(*args))
    __swig_destroy__ = _cmf_core.delete_TopographicGradientDarcy
TopographicGradientDarcy_swigregister = _cmf_core.TopographicGradientDarcy_swigregister
TopographicGradientDarcy_swigregister(TopographicGradientDarcy)
TopographicGradientDarcy.cell_connector = _cmf_core.cvar.TopographicGradientDarcy_cell_connector

class SWATPercolation(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::SWATPercolation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def use_for_cell(*args):
        """
        use_for_cell(Cell cell, bool no_override = True)
        use_for_cell(Cell cell)
        """
        return _cmf_core.SWATPercolation_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    def __init__(self, *args): 
        """__init__(self, SoilWaterStorage upperLayer, SoilWaterStorage lowerLayer) -> SWATPercolation"""
        _cmf_core.SWATPercolation_swiginit(self,_cmf_core.new_SWATPercolation(*args))
    __swig_destroy__ = _cmf_core.delete_SWATPercolation
SWATPercolation_swigregister = _cmf_core.SWATPercolation_swigregister
SWATPercolation_swigregister(SWATPercolation)

def SWATPercolation_use_for_cell(*args):
  """
    use_for_cell(Cell cell, bool no_override = True)
    SWATPercolation_use_for_cell(Cell cell)
    """
  return _cmf_core.SWATPercolation_use_for_cell(*args)

class Richards(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::Richards class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowArea = 0, 
            real Distance = 0) -> Richards
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowArea = 0) -> Richards
        __init__(self, SoilWaterStorage left, FluxNode right) -> Richards
        """
        _cmf_core.Richards_swiginit(self,_cmf_core.new_Richards(*args))
    def use_for_cell(*args):
        """
        use_for_cell(Cell cell, bool no_override = True)
        use_for_cell(Cell cell)
        """
        return _cmf_core.Richards_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_Richards
Richards_swigregister = _cmf_core.Richards_swigregister
Richards_swigregister(Richards)
Richards.cell_connector = _cmf_core.cvar.Richards_cell_connector

def Richards_use_for_cell(*args):
  """
    use_for_cell(Cell cell, bool no_override = True)
    Richards_use_for_cell(Cell cell)
    """
  return _cmf_core.Richards_use_for_cell(*args)

class Richards_lateral(Richards):
    """Proxy of C++ cmf::upslope::connections::Richards_lateral class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0, 
            real Distance = 0) -> Richards_lateral
        __init__(self, SoilWaterStorage left, FluxNode right, real FlowWidth = 0) -> Richards_lateral
        __init__(self, SoilWaterStorage left, FluxNode right) -> Richards_lateral
        """
        _cmf_core.Richards_lateral_swiginit(self,_cmf_core.new_Richards_lateral(*args))
    __swig_destroy__ = _cmf_core.delete_Richards_lateral
Richards_lateral_swigregister = _cmf_core.Richards_lateral_swigregister
Richards_lateral_swigregister(Richards_lateral)

class UnsaturatedDarcy(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::UnsaturatedDarcy class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage left, SoilWaterStorage right, real FlowArea = 0, 
            real Distance = 0) -> UnsaturatedDarcy
        __init__(self, SoilWaterStorage left, SoilWaterStorage right, real FlowArea = 0) -> UnsaturatedDarcy
        __init__(self, SoilWaterStorage left, SoilWaterStorage right) -> UnsaturatedDarcy
        """
        _cmf_core.UnsaturatedDarcy_swiginit(self,_cmf_core.new_UnsaturatedDarcy(*args))
    def use_for_cell(*args):
        """
        use_for_cell(Cell cell, bool no_override = True)
        use_for_cell(Cell cell)
        """
        return _cmf_core.UnsaturatedDarcy_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_UnsaturatedDarcy
UnsaturatedDarcy_swigregister = _cmf_core.UnsaturatedDarcy_swigregister
UnsaturatedDarcy_swigregister(UnsaturatedDarcy)

def UnsaturatedDarcy_use_for_cell(*args):
  """
    use_for_cell(Cell cell, bool no_override = True)
    UnsaturatedDarcy_use_for_cell(Cell cell)
    """
  return _cmf_core.UnsaturatedDarcy_use_for_cell(*args)
UnsaturatedDarcy.cell_connector = _cmf_core.cvar.UnsaturatedDarcy_cell_connector

class CanopyOverflow(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::CanopyOverflow class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage Canopy, FluxNode target, Cell cell) -> CanopyOverflow

        CanopyOverflow(cmf::water::WaterStorage &Canopy, cmf::water::FluxNode
        &target, cmf::upslope::Cell &cell) 
        """
        _cmf_core.CanopyOverflow_swiginit(self,_cmf_core.new_CanopyOverflow(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell) -> CanopyOverflow"""
        return _cmf_core.CanopyOverflow_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_CanopyOverflow
CanopyOverflow_swigregister = _cmf_core.CanopyOverflow_swigregister
CanopyOverflow_swigregister(CanopyOverflow)

def CanopyOverflow_use_for_cell(*args):
  """CanopyOverflow_use_for_cell(Cell cell) -> CanopyOverflow"""
  return _cmf_core.CanopyOverflow_use_for_cell(*args)

class SimpleTindexSnowMelt(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::SimpleTindexSnowMelt class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SnowMeltRate = _swig_property(_cmf_core.SimpleTindexSnowMelt_SnowMeltRate_get, _cmf_core.SimpleTindexSnowMelt_SnowMeltRate_set)
    def __init__(self, *args): 
        """__init__(self, WaterStorage snow, FluxNode surface_water, Cell cell) -> SimpleTindexSnowMelt"""
        _cmf_core.SimpleTindexSnowMelt_swiginit(self,_cmf_core.new_SimpleTindexSnowMelt(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.SimpleTindexSnowMelt_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_SimpleTindexSnowMelt
SimpleTindexSnowMelt_swigregister = _cmf_core.SimpleTindexSnowMelt_swigregister
SimpleTindexSnowMelt_swigregister(SimpleTindexSnowMelt)

def SimpleTindexSnowMelt_use_for_cell(*args):
  """SimpleTindexSnowMelt_use_for_cell(Cell cell)"""
  return _cmf_core.SimpleTindexSnowMelt_use_for_cell(*args)

class SnowWaterOverflow(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::SnowWaterOverflow class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    RelCapacity = _swig_property(_cmf_core.SnowWaterOverflow_RelCapacity_get, _cmf_core.SnowWaterOverflow_RelCapacity_set)
    SnowConductivity = _swig_property(_cmf_core.SnowWaterOverflow_SnowConductivity_get, _cmf_core.SnowWaterOverflow_SnowConductivity_set)
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage snow_water, FluxNode surface_water, WaterStorage snow, 
            Cell cell, real relative_capacity = 0.1, 
            real snowConductivity = 864.) -> SnowWaterOverflow
        __init__(self, WaterStorage snow_water, FluxNode surface_water, WaterStorage snow, 
            Cell cell, real relative_capacity = 0.1) -> SnowWaterOverflow
        __init__(self, WaterStorage snow_water, FluxNode surface_water, WaterStorage snow, 
            Cell cell) -> SnowWaterOverflow
        """
        _cmf_core.SnowWaterOverflow_swiginit(self,_cmf_core.new_SnowWaterOverflow(*args))
    __swig_destroy__ = _cmf_core.delete_SnowWaterOverflow
SnowWaterOverflow_swigregister = _cmf_core.SnowWaterOverflow_swigregister
SnowWaterOverflow_swigregister(SnowWaterOverflow)

class HBVSnowMelt(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::HBVSnowMelt class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SnowMeltRate = _swig_property(_cmf_core.HBVSnowMelt_SnowMeltRate_get, _cmf_core.HBVSnowMelt_SnowMeltRate_set)
    RefreezeRate = _swig_property(_cmf_core.HBVSnowMelt_RefreezeRate_get, _cmf_core.HBVSnowMelt_RefreezeRate_set)
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage snow, WaterStorage snow_water, Cell cell, 
            real snowmeltrate = 7, real refreezeRate = 0.05) -> HBVSnowMelt
        __init__(self, WaterStorage snow, WaterStorage snow_water, Cell cell, 
            real snowmeltrate = 7) -> HBVSnowMelt
        __init__(self, WaterStorage snow, WaterStorage snow_water, Cell cell) -> HBVSnowMelt
        """
        _cmf_core.HBVSnowMelt_swiginit(self,_cmf_core.new_HBVSnowMelt(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell) -> HBVSnowMelt"""
        return _cmf_core.HBVSnowMelt_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_HBVSnowMelt
HBVSnowMelt_swigregister = _cmf_core.HBVSnowMelt_swigregister
HBVSnowMelt_swigregister(HBVSnowMelt)

def HBVSnowMelt_use_for_cell(*args):
  """HBVSnowMelt_use_for_cell(Cell cell) -> HBVSnowMelt"""
  return _cmf_core.HBVSnowMelt_use_for_cell(*args)

class Rainfall(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::Rainfall class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Throughfall = _swig_property(_cmf_core.Rainfall_Throughfall_get, _cmf_core.Rainfall_Throughfall_set)
    InterceptedRainfall = _swig_property(_cmf_core.Rainfall_InterceptedRainfall_get, _cmf_core.Rainfall_InterceptedRainfall_set)
    def __init__(self, *args): 
        """
        __init__(self, FluxNode target, Cell cell, bool getthroughfall = True, 
            bool getintercepted = True) -> Rainfall
        __init__(self, FluxNode target, Cell cell, bool getthroughfall = True) -> Rainfall
        __init__(self, FluxNode target, Cell cell) -> Rainfall
        """
        _cmf_core.Rainfall_swiginit(self,_cmf_core.new_Rainfall(*args))
    __swig_destroy__ = _cmf_core.delete_Rainfall
Rainfall_swigregister = _cmf_core.Rainfall_swigregister
Rainfall_swigregister(Rainfall)

class Snowfall(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::Snowfall class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, FluxNode target, Cell cell) -> Snowfall"""
        _cmf_core.Snowfall_swiginit(self,_cmf_core.new_Snowfall(*args))
    __swig_destroy__ = _cmf_core.delete_Snowfall
Snowfall_swigregister = _cmf_core.Snowfall_swigregister
Snowfall_swigregister(Snowfall)

class MatrixInfiltration(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::MatrixInfiltration class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, SoilWaterStorage soilwater, FluxNode surfacewater) -> MatrixInfiltration"""
        _cmf_core.MatrixInfiltration_swiginit(self,_cmf_core.new_MatrixInfiltration(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell c)"""
        return _cmf_core.MatrixInfiltration_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_MatrixInfiltration
MatrixInfiltration_swigregister = _cmf_core.MatrixInfiltration_swigregister
MatrixInfiltration_swigregister(MatrixInfiltration)

def MatrixInfiltration_use_for_cell(*args):
  """MatrixInfiltration_use_for_cell(Cell c)"""
  return _cmf_core.MatrixInfiltration_use_for_cell(*args)

class CompleteInfiltration(FluxConnection):
    """Proxy of C++ cmf::upslope::connections::CompleteInfiltration class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, SoilWaterStorage soilwater, FluxNode surfacewater) -> CompleteInfiltration"""
        _cmf_core.CompleteInfiltration_swiginit(self,_cmf_core.new_CompleteInfiltration(*args))
    __swig_destroy__ = _cmf_core.delete_CompleteInfiltration
CompleteInfiltration_swigregister = _cmf_core.CompleteInfiltration_swigregister
CompleteInfiltration_swigregister(CompleteInfiltration)


def Tact(*args):
  """Tact(real Tpot, SoilWaterStorage sw, Vegetation veg) -> real"""
  return _cmf_core.Tact(*args)
class constantETpot(FluxConnection):
    """Proxy of C++ cmf::upslope::ET::constantETpot class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    ETpot_value = _swig_property(_cmf_core.constantETpot_ETpot_value_get, _cmf_core.constantETpot_ETpot_value_set)
    def GetETpot(self, *args):
        """
        GetETpot(self, Time t) -> real

        real GetETpot(cmf::math::Time t) const =0 
        """
        return _cmf_core.constantETpot_GetETpot(self, *args)

    __swig_destroy__ = _cmf_core.delete_constantETpot
constantETpot.GetETpot = new_instancemethod(_cmf_core.constantETpot_GetETpot,None,constantETpot)
constantETpot_swigregister = _cmf_core.constantETpot_swigregister
constantETpot_swigregister(constantETpot)

def PenmanMonteith(*args):
  """
    PenmanMonteith(real Rn, real ra, real rs, real T, real vap_press_deficit) -> real
    PenmanMonteith(Weather A, Vegetation veg, double h) -> real

    real
    cmf::upslope::ET::PenmanMonteith(cmf::atmosphere::Weather A, const
    cmf::upslope::vegetation::Vegetation &veg, double h) 
    """
  return _cmf_core.PenmanMonteith(*args)

class PenmanMonteithET(FluxConnection):
    """
    Calculates the potential evapotranspiration according to FAO(1998)
    \\begin{eqnarray*} \\lambda ET &=& \\frac{\\Delta\\left(R_n
    - G\\right)+\\rho_a c_p \\frac{e_s - e_a}{r_a}}{\\Delta +
    \\gamma\\left(1+\\frac{r_s}{r_a}\\right)} \\mbox{ FAO 1998,
    Eq. 3} \\\\ \\mbox{With:} \\\\ \\Delta &=& 4098
    \\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\frac{kPa}{^\\circ C}
    \\mbox{ (FAO 1998, Eq. 13): Slope of vapor pressure } \\\\ T &=&
    \\mbox{Actual Temperature in } ^\\circ C \\\\ R_n &=&
    \\mbox{net Radiation (see Atmosphere) in } \\frac{MJ}{m^2day}
    \\\\ G &=& 0 \\ \\frac{MJ}{m^2day} \\mbox{ if daily average
    (FAO 1998, Eq. 42)} \\\\ && 0.1 R_n \\ \\mbox{ if day time
    (FAO 1998, Eq. 45)} \\\\ && 0.5 R_n \\ \\mbox{ if night time
    (FAO 1998, Eq. 46)} \\\\ \\gamma &=& \\frac{c_p P}{\\epsilon
    \\lambda} \\mbox{ (FAO 1998,Eq. 8): Psychrometric constant }
    \\frac{kPa}{^\\circ C} \\\\ c_p &=& 0.001013
    \\frac{MJ}{kg\\ ^\\circ C}\\mbox{ specific heat at constant
    pressure } \\\\ P &=& 101.3
    \\left(\\frac{293-0.0065z}{293}\\right)^{5.26} \\mbox{ (FAO
    1998,Eq. 7): Mean pressure kPa as a function of elevation above sea
    level in m} \\\\ \\epsilon &=& 0.622 \\mbox{ ratio molecular
    weight of water vapour/dry air} \\\\ \\lambda &=& 2.45
    \\frac{MJ}{kg} \\mbox{ (FAO 1998,Eq. 8): latent heat of
    vaporization} \\\\ R &=& 0.287 \\frac{kJ}{kg\\ k}\\mbox{
    Specific gas constant } \\\\ \\rho_a &=&
    \\frac{P}{1.01(T+273)R} \\mbox{ (FAO 1998,Box. 6): Mean air
    density at constant pressure} \\\\ e_s &=& \\mbox{ Saturated
    vapor pressure (see Atmosphere) in } kPa \\\\ e_a &=& \\mbox{
    Actual vapor pressure (see Atmosphere) in } kPa \\\\ r_a &=&
    \\frac{\\ln\\left(\\frac{2-d}{z_{om}}\\right)\\ln\\left(\\frac{2-d}{z_{oh}}\\right)}{k^2
    u_2} \\mbox{ (FAO 1998, Eq. 4/Box 4): Aerodynamic resitance in }
    \\frac s m \\\\ && d=\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1
    z_{om}, k=0.41 \\\\ h &=& \\mbox{ Vegetation height in }m
    \\\\ u_2 &=& \\mbox{ Windspeed in 2m above ground (see
    Atmosphere) } \\frac m s \\\\ r_s &=&
    \\frac{r_l}{LAI_{Active}} \\mbox{ (FAO 1998, Eq. 5/Box 5): bulk
    surface resistance} \\frac s m \\\\ && r_l=100 \\frac s m,
    LAI_{Active}=0.5 LAI \\end{eqnarray*}.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    daily = _swig_property(_cmf_core.PenmanMonteithET_daily_get, _cmf_core.PenmanMonteithET_daily_set)
    def __init__(self, *args): 
        """
        __init__(self, SoilWaterStorage source, FluxNode ET_target) -> PenmanMonteithET

        PenmanMonteithET(cmf::upslope::SoilWaterStorage &source,
        cmf::water::FluxNode &ET_target, cmf::upslope::vegetation::Vegetation
        &VegetationAttributes, cmf::atmosphere::Meteorology &meteo) 
        """
        _cmf_core.PenmanMonteithET_swiginit(self,_cmf_core.new_PenmanMonteithET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.PenmanMonteithET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_PenmanMonteithET
PenmanMonteithET_swigregister = _cmf_core.PenmanMonteithET_swigregister
PenmanMonteithET_swigregister(PenmanMonteithET)

def PenmanMonteithET_use_for_cell(*args):
  """PenmanMonteithET_use_for_cell(Cell cell)"""
  return _cmf_core.PenmanMonteithET_use_for_cell(*args)

class ShuttleworthWallaceET(FluxConnection):
    """
    Calculates the actual transpiration and the soil evaporation from a
    soil layer.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage source, FluxNode ET_target, Cell cell, 
            string Type = "Shuttleworth Wallace Evaporation") -> ShuttleworthWallaceET
        __init__(self, WaterStorage source, FluxNode ET_target, Cell cell) -> ShuttleworthWallaceET

        ShuttleworthWallaceET(cmf::upslope::SoilWaterStorage &source,
        cmf::water::FluxNode &ET_target, cmf::atmosphere::Meteorology &meteo)

        """
        _cmf_core.ShuttleworthWallaceET_swiginit(self,_cmf_core.new_ShuttleworthWallaceET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.ShuttleworthWallaceET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_ShuttleworthWallaceET
ShuttleworthWallaceET_swigregister = _cmf_core.ShuttleworthWallaceET_swigregister
ShuttleworthWallaceET_swigregister(ShuttleworthWallaceET)

def ShuttleworthWallaceET_use_for_cell(*args):
  """ShuttleworthWallaceET_use_for_cell(Cell cell)"""
  return _cmf_core.ShuttleworthWallaceET_use_for_cell(*args)

class HargreaveET(FluxConnection):
    """Proxy of C++ cmf::upslope::ET::HargreaveET class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, SoilWaterStorage source, FluxNode ET_target) -> HargreaveET"""
        _cmf_core.HargreaveET_swiginit(self,_cmf_core.new_HargreaveET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.HargreaveET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_HargreaveET
HargreaveET_swigregister = _cmf_core.HargreaveET_swigregister
HargreaveET_swigregister(HargreaveET)

def HargreaveET_use_for_cell(*args):
  """HargreaveET_use_for_cell(Cell cell)"""
  return _cmf_core.HargreaveET_use_for_cell(*args)

class CanopyStorageEvaporation(FluxConnection):
    """
    Calculates the evaporation from a canopy storage.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage CanopyStorage, FluxNode ET_target, Cell cell) -> CanopyStorageEvaporation

        CanopyStorageEvaporation(cmf::water::FluxNode &CanopyStorage,
        cmf::water::FluxNode &ET_target, const cmf::atmosphere::Meteorology
        &meteo, cmf::upslope::Cell &cell) 
        """
        _cmf_core.CanopyStorageEvaporation_swiginit(self,_cmf_core.new_CanopyStorageEvaporation(*args))
    __swig_destroy__ = _cmf_core.delete_CanopyStorageEvaporation
CanopyStorageEvaporation_swigregister = _cmf_core.CanopyStorageEvaporation_swigregister
CanopyStorageEvaporation_swigregister(CanopyStorageEvaporation)

def connect(type,left_node,right_node,*args):
    connection=type(left_node,right_node,*args)
    connection.thisown=0

class ReachType(object):
    """
    Structure for the description of structural parameters of a reach
    Abstract base class for different channel geometries.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    nManning = _swig_property(_cmf_core.ReachType_nManning_get, _cmf_core.ReachType_nManning_set)
    def Width(self, *args):
        """
        Width(self, double depth) -> double

        virtual double
        Width(double depth) const =0

        Calculates the flow width from a given actual depth [m] using the
        actual channel geometry. 
        """
        return _cmf_core.ReachType_Width(self, *args)

    def Perimeter(self, *args):
        """
        Perimeter(self, double depth) -> double

        virtual
        double Perimeter(double depth) const =0

        Calculates the wetted perimeter from a given actual depth [m] using
        the actual channel geometry. 
        """
        return _cmf_core.ReachType_Perimeter(self, *args)

    def Depth(self, *args):
        """
        Depth(self, double area) -> double

        virtual double
        Depth(double area) const =0

        Calculates the actual depth of the reach using the channel geometry.

        Depth of the reach [m]

        Parameters:
        -----------

        area:  Wetted area of a river cross section [m2], can be obtained by
        V/l, where V is the stored volume and l is the reach length 
        """
        return _cmf_core.ReachType_Depth(self, *args)

    def Area(self, *args):
        """
        Area(self, double depth) -> double

        virtual double
        Area(double depth) const =0

        Calculates the wetted area from a given depth using the channel
        geometry. In most cases use Area=V/l, where V is the stored volume and
        l is the reach length.

        Wetted area of a river cross section [m2]

        Parameters:
        -----------

        depth:  Depth of the reach [m] 
        """
        return _cmf_core.ReachType_Area(self, *args)

    def qManning(self, *args):
        """
        qManning(self, double A, double slope) -> double

        double
        qManning(double A, double slope) const

        Calculates the flow rate from a given water volume in the reach
        \\begin{eqnarray*} q_{Manning}&=& A R^{\\frac 23}
        \\sqrt{\\frac {\\Delta_z} n} \\\\ A &=& \\frac V l
        \\mbox{ Area of the wetted crossection, Volume per length}\\\\
        R&=&\\frac A P(d) \\\\ P(d)&=& \\mbox{ Perimeter of the wetted
        crossection, a function of reach depth} \\\\ d(V)&=& \\mbox{
        Depth of the reach} \\\\ \\Delta_z&=& \\frac{z_{max} -
        z_{min}}{l} \\mbox{ Slope of the reach} \\\\ \\end{eqnarray*}.

        Flow rate [m3/s]

        Parameters:
        -----------

        A:  The area of the cross section [m2]

        slope:  The slope of the reach [m/m] 
        """
        return _cmf_core.ReachType_qManning(self, *args)

    def copy(self):
        """copy(self) -> ReachType"""
        return _cmf_core.ReachType_copy(self)

    def AsChannel(self, *args):
        """AsChannel(self, double length) -> Channel"""
        return _cmf_core.ReachType_AsChannel(self, *args)

    __swig_destroy__ = _cmf_core.delete_ReachType
ReachType.Width = new_instancemethod(_cmf_core.ReachType_Width,None,ReachType)
ReachType.Perimeter = new_instancemethod(_cmf_core.ReachType_Perimeter,None,ReachType)
ReachType.Depth = new_instancemethod(_cmf_core.ReachType_Depth,None,ReachType)
ReachType.Area = new_instancemethod(_cmf_core.ReachType_Area,None,ReachType)
ReachType.qManning = new_instancemethod(_cmf_core.ReachType_qManning,None,ReachType)
ReachType.copy = new_instancemethod(_cmf_core.ReachType_copy,None,ReachType)
ReachType.AsChannel = new_instancemethod(_cmf_core.ReachType_AsChannel,None,ReachType)
ReachType_swigregister = _cmf_core.ReachType_swigregister
ReachType_swigregister(ReachType)

class SWATReachType(ReachType):
    """
    Structure for the description of structural parameters of a reach.

    Uses the SWAT channel geometry (see SWAT Theoretical Documentation,
    Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
    referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
    plain is not plain, but has a small slope=0.5%, but has an infinite
    width

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BottomWidth = _swig_property(_cmf_core.SWATReachType_BottomWidth_get, _cmf_core.SWATReachType_BottomWidth_set)
    ChannelDepth = _swig_property(_cmf_core.SWATReachType_ChannelDepth_get, _cmf_core.SWATReachType_ChannelDepth_set)
    BankSlope = _swig_property(_cmf_core.SWATReachType_BankSlope_get, _cmf_core.SWATReachType_BankSlope_set)
    FloodPlainSlope = _swig_property(_cmf_core.SWATReachType_FloodPlainSlope_get, _cmf_core.SWATReachType_FloodPlainSlope_set)
    def __init__(self, *args): 
        """
        __init__(self) -> SWATReachType
        __init__(self, double BankWidth, double Depth) -> SWATReachType

        SWATReachType(double BankWidth, double Depth)

        Creates a new reach structure from a give width and depth.

        Parameters:
        -----------

        BankWidth:  Width of the reach from bank to bank [m]

        Depth:  Depth of the reach [m] 
        """
        _cmf_core.SWATReachType_swiginit(self,_cmf_core.new_SWATReachType(*args))
    def copy(self):
        """copy(self) -> SWATReachType"""
        return _cmf_core.SWATReachType_copy(self)

    __swig_destroy__ = _cmf_core.delete_SWATReachType
SWATReachType.copy = new_instancemethod(_cmf_core.SWATReachType_copy,None,SWATReachType)
SWATReachType_swigregister = _cmf_core.SWATReachType_swigregister
SWATReachType_swigregister(SWATReachType)

class TriangularReach(ReachType):
    """
    Structure for the description of reaches with a triangular cross
    section.

    Although real triangular cross section reach are rarely met, a
    triangular reach does scale with its water load, and is therefore
    preferable in case where nothing about channel geometry is known

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BankSlope = _swig_property(_cmf_core.TriangularReach_BankSlope_get, _cmf_core.TriangularReach_BankSlope_set)
    def __init__(self, bankSlope = 2): 
        """
        __init__(self, double bankSlope = 2) -> TriangularReach
        __init__(self) -> TriangularReach

        TriangularReach(double bankSlope=2)

        Creates a new triangular reach type. 
        """
        _cmf_core.TriangularReach_swiginit(self,_cmf_core.new_TriangularReach(bankSlope))
    def copy(self):
        """copy(self) -> TriangularReach"""
        return _cmf_core.TriangularReach_copy(self)

    __swig_destroy__ = _cmf_core.delete_TriangularReach
TriangularReach.copy = new_instancemethod(_cmf_core.TriangularReach_copy,None,TriangularReach)
TriangularReach_swigregister = _cmf_core.TriangularReach_swigregister
TriangularReach_swigregister(TriangularReach)

class RectangularReach(ReachType):
    """Proxy of C++ cmf::river::RectangularReach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double width) -> RectangularReach"""
        _cmf_core.RectangularReach_swiginit(self,_cmf_core.new_RectangularReach(*args))
    def copy(self):
        """copy(self) -> RectangularReach"""
        return _cmf_core.RectangularReach_copy(self)

    __swig_destroy__ = _cmf_core.delete_RectangularReach
RectangularReach.copy = new_instancemethod(_cmf_core.RectangularReach_copy,None,RectangularReach)
RectangularReach_swigregister = _cmf_core.RectangularReach_swigregister
RectangularReach_swigregister(RectangularReach)

class PipeReach(ReachType):
    """Proxy of C++ cmf::river::PipeReach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double diameter) -> PipeReach"""
        _cmf_core.PipeReach_swiginit(self,_cmf_core.new_PipeReach(*args))
    def copy(self):
        """copy(self) -> PipeReach"""
        return _cmf_core.PipeReach_copy(self)

    __swig_destroy__ = _cmf_core.delete_PipeReach
PipeReach.copy = new_instancemethod(_cmf_core.PipeReach_copy,None,PipeReach)
PipeReach_swigregister = _cmf_core.PipeReach_swigregister
PipeReach_swigregister(PipeReach)

class VolumeHeightRelation(object):
    """Proxy of C++ cmf::river::VolumeHeightRelation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def h(self, *args):
        """h(self, real V) -> real"""
        return _cmf_core.VolumeHeightRelation_h(self, *args)

    def A(self, *args):
        """A(self, real V) -> real"""
        return _cmf_core.VolumeHeightRelation_A(self, *args)

    def copy(self):
        """copy(self) -> VolumeHeightRelation"""
        return _cmf_core.VolumeHeightRelation_copy(self)

    def __call__(self, *args):
        """__call__(self, real V) -> real"""
        return _cmf_core.VolumeHeightRelation___call__(self, *args)

    __swig_destroy__ = _cmf_core.delete_VolumeHeightRelation
VolumeHeightRelation.h = new_instancemethod(_cmf_core.VolumeHeightRelation_h,None,VolumeHeightRelation)
VolumeHeightRelation.A = new_instancemethod(_cmf_core.VolumeHeightRelation_A,None,VolumeHeightRelation)
VolumeHeightRelation.copy = new_instancemethod(_cmf_core.VolumeHeightRelation_copy,None,VolumeHeightRelation)
VolumeHeightRelation.__call__ = new_instancemethod(_cmf_core.VolumeHeightRelation___call__,None,VolumeHeightRelation)
VolumeHeightRelation_swigregister = _cmf_core.VolumeHeightRelation_swigregister
VolumeHeightRelation_swigregister(VolumeHeightRelation)

def create_reachtype(*args):
  """
    create_reachtype(char shortcut, double width = 1., double depth = 0.25) -> ReachType
    create_reachtype(char shortcut, double width = 1.) -> ReachType
    create_reachtype(char shortcut) -> ReachType
    """
  return _cmf_core.create_reachtype(*args)

class cuboid(VolumeHeightRelation):
    """Proxy of C++ cmf::river::cuboid class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Area = _swig_property(_cmf_core.cuboid_Area_get, _cmf_core.cuboid_Area_set)
    def __init__(self, *args): 
        """__init__(self, real base_area) -> cuboid"""
        _cmf_core.cuboid_swiginit(self,_cmf_core.new_cuboid(*args))
    def copy(self):
        """copy(self) -> cuboid"""
        return _cmf_core.cuboid_copy(self)

    __swig_destroy__ = _cmf_core.delete_cuboid
cuboid.copy = new_instancemethod(_cmf_core.cuboid_copy,None,cuboid)
cuboid_swigregister = _cmf_core.cuboid_swigregister
cuboid_swigregister(cuboid)

class exponential_area_decline(VolumeHeightRelation):
    """Proxy of C++ cmf::river::exponential_area_decline class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Area = _swig_property(_cmf_core.exponential_area_decline_Area_get, _cmf_core.exponential_area_decline_Area_set)
    half_area_depth = _swig_property(_cmf_core.exponential_area_decline_half_area_depth_get, _cmf_core.exponential_area_decline_half_area_depth_set)
    def A_d(self, *args):
        """A_d(self, real h) -> real"""
        return _cmf_core.exponential_area_decline_A_d(self, *args)

    def copy(self):
        """copy(self) -> exponential_area_decline"""
        return _cmf_core.exponential_area_decline_copy(self)

    def __init__(self, *args): 
        """__init__(self, real area, real _half_area_depth) -> exponential_area_decline"""
        _cmf_core.exponential_area_decline_swiginit(self,_cmf_core.new_exponential_area_decline(*args))
    __swig_destroy__ = _cmf_core.delete_exponential_area_decline
exponential_area_decline.A_d = new_instancemethod(_cmf_core.exponential_area_decline_A_d,None,exponential_area_decline)
exponential_area_decline.copy = new_instancemethod(_cmf_core.exponential_area_decline_copy,None,exponential_area_decline)
exponential_area_decline_swigregister = _cmf_core.exponential_area_decline_swigregister
exponential_area_decline_swigregister(exponential_area_decline)

class Channel(VolumeHeightRelation):
    """Proxy of C++ cmf::river::Channel class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Length = _swig_property(_cmf_core.Channel_Length_get, _cmf_core.Channel_Length_set)
    def __init__(self, *args): 
        """
        __init__(self, ReachType _type, real l) -> Channel
        __init__(self, char reach_type_shortcut, real l, real d = 0.25, real w = 1.) -> Channel
        __init__(self, char reach_type_shortcut, real l, real d = 0.25) -> Channel
        __init__(self, char reach_type_shortcut, real l) -> Channel
        """
        _cmf_core.Channel_swiginit(self,_cmf_core.new_Channel(*args))
    def copy(self):
        """copy(self) -> Channel"""
        return _cmf_core.Channel_copy(self)

    __swig_destroy__ = _cmf_core.delete_Channel
Channel.copy = new_instancemethod(_cmf_core.Channel_copy,None,Channel)
Channel_swigregister = _cmf_core.Channel_swigregister
Channel_swigregister(Channel)

class OpenWaterStorage(WaterStorage):
    """Proxy of C++ cmf::river::OpenWaterStorage class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetBaseTopography(self, *args):
        """SetBaseTopography(self, VolumeHeightRelation new_base_topo)"""
        return _cmf_core.OpenWaterStorage_SetBaseTopography(self, *args)

    def BaseTopography(self):
        """BaseTopography(self) -> VolumeHeightRelation"""
        return _cmf_core.OpenWaterStorage_BaseTopography(self)

    def h(self):
        """h(self) -> real"""
        return _cmf_core.OpenWaterStorage_h(self)

    def wet_area(self):
        """wet_area(self) -> real"""
        return _cmf_core.OpenWaterStorage_wet_area(self)

    def __init__(self, *args): 
        """
        __init__(self, project _project, real Area) -> OpenWaterStorage
        __init__(self, project _project, VolumeHeightRelation base_geo) -> OpenWaterStorage
        """
        _cmf_core.OpenWaterStorage_swiginit(self,_cmf_core.new_OpenWaterStorage(*args))
    def FromNode(*args):
        """FromNode(FluxNode node, real Area) -> OpenWaterStorage"""
        return _cmf_core.OpenWaterStorage_FromNode(*args)

    FromNode = staticmethod(FromNode)
    def cast(*args):
        """cast(FluxNode node) -> OpenWaterStorage"""
        return _cmf_core.OpenWaterStorage_cast(*args)

    cast = staticmethod(cast)
    __swig_destroy__ = _cmf_core.delete_OpenWaterStorage
OpenWaterStorage.SetBaseTopography = new_instancemethod(_cmf_core.OpenWaterStorage_SetBaseTopography,None,OpenWaterStorage)
OpenWaterStorage.BaseTopography = new_instancemethod(_cmf_core.OpenWaterStorage_BaseTopography,None,OpenWaterStorage)
OpenWaterStorage.h = new_instancemethod(_cmf_core.OpenWaterStorage_h,None,OpenWaterStorage)
OpenWaterStorage.wet_area = new_instancemethod(_cmf_core.OpenWaterStorage_wet_area,None,OpenWaterStorage)
OpenWaterStorage_swigregister = _cmf_core.OpenWaterStorage_swigregister
OpenWaterStorage_swigregister(OpenWaterStorage)

def OpenWaterStorage_FromNode(*args):
  """OpenWaterStorage_FromNode(FluxNode node, real Area) -> OpenWaterStorage"""
  return _cmf_core.OpenWaterStorage_FromNode(*args)

def OpenWaterStorage_cast(*args):
  """OpenWaterStorage_cast(FluxNode node) -> OpenWaterStorage"""
  return _cmf_core.OpenWaterStorage_cast(*args)


def AsOpenWater(*args):
  """AsOpenWater(FluxNode node) -> OpenWaterStorage"""
  return _cmf_core.AsOpenWater(*args)
class Manning(FluxConnection):
    """Proxy of C++ cmf::river::Manning class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def ChannelGeometry(self, *args):
        """
        ChannelGeometry(self) -> ReachType
        ChannelGeometry(self) -> ReachType
        """
        return _cmf_core.Manning_ChannelGeometry(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, OpenWaterStorage left, FluxNode right, ReachType ChannelShape, 
            real Distance) -> Manning
        """
        _cmf_core.Manning_swiginit(self,_cmf_core.new_Manning(*args))
    __swig_destroy__ = _cmf_core.delete_Manning
Manning.ChannelGeometry = new_instancemethod(_cmf_core.Manning_ChannelGeometry,None,Manning)
Manning_swigregister = _cmf_core.Manning_swigregister
Manning_swigregister(Manning)
Manning.cell_connector = _cmf_core.cvar.Manning_cell_connector

class TechnicalFlux(FluxConnection):
    """Proxy of C++ cmf::river::TechnicalFlux class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    MaxFlux = _swig_property(_cmf_core.TechnicalFlux_MaxFlux_get, _cmf_core.TechnicalFlux_MaxFlux_set)
    MinState = _swig_property(_cmf_core.TechnicalFlux_MinState_get, _cmf_core.TechnicalFlux_MinState_set)
    FluxDecreaseTime = _swig_property(_cmf_core.TechnicalFlux_FluxDecreaseTime_get, _cmf_core.TechnicalFlux_FluxDecreaseTime_set)
    def __init__(self, *args): 
        """
        __init__(self, WaterStorage source, FluxNode target, real maximum_flux, 
            real minimal_state = 0, Time flux_decrease_time = h) -> TechnicalFlux
        __init__(self, WaterStorage source, FluxNode target, real maximum_flux, 
            real minimal_state = 0) -> TechnicalFlux
        __init__(self, WaterStorage source, FluxNode target, real maximum_flux) -> TechnicalFlux
        """
        _cmf_core.TechnicalFlux_swiginit(self,_cmf_core.new_TechnicalFlux(*args))
    __swig_destroy__ = _cmf_core.delete_TechnicalFlux
TechnicalFlux_swigregister = _cmf_core.TechnicalFlux_swigregister
TechnicalFlux_swigregister(TechnicalFlux)

class Reach(object):
    """Proxy of C++ cmf::river::Reach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_downstream(self, *args):
        """set_downstream(self, Reach downstream_reach)"""
        return _cmf_core.Reach_set_downstream(self, *args)

    def set_outlet(self, *args):
        """set_outlet(self, FluxNode outlet)"""
        return _cmf_core.Reach_set_outlet(self, *args)

    def set_dead_end(self):
        """set_dead_end(self)"""
        return _cmf_core.Reach_set_dead_end(self)

    length = _swig_property(_cmf_core.Reach_length_get, _cmf_core.Reach_length_set)
    def get_upstream(self, *args):
        """get_upstream(self, int index) -> Reach"""
        return _cmf_core.Reach_get_upstream(self, *args)

    def __lt__(self, *args):
        """__lt__(self, Reach cmp) -> bool"""
        return _cmf_core.Reach___lt__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Reach cmp) -> bool"""
        return _cmf_core.Reach___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Reach cmp) -> bool"""
        return _cmf_core.Reach___ne__(self, *args)

    cell = _swig_property(_cmf_core.Reach_cell_get)
    downstream = _swig_property(_cmf_core.Reach_downstream_get)
    root = _swig_property(_cmf_core.Reach_root_get)
    water = _swig_property(_cmf_core.Reach_water_get)
    outlet = _swig_property(_cmf_core.Reach_outlet_get)
    upstream_count = _swig_property(_cmf_core.Reach_upstream_count_get)
    depth = _swig_property(_cmf_core.Reach_depth_get, _cmf_core.Reach_depth_set)
    @property
    def upstream(self):
        """Returns a list containing all reaches flowing into self"""
        return [self.get_upstream(i) for i in range(self.upstream_count)]
    def __hash__(self):
        return hash(self.water.node_id)
    def __repr__(self):
        return "A reach (node #%i) at %s" % (self.water.node_id,self.cell)
       

    __swig_destroy__ = _cmf_core.delete_Reach
Reach.set_downstream = new_instancemethod(_cmf_core.Reach_set_downstream,None,Reach)
Reach.set_outlet = new_instancemethod(_cmf_core.Reach_set_outlet,None,Reach)
Reach.set_dead_end = new_instancemethod(_cmf_core.Reach_set_dead_end,None,Reach)
Reach.get_upstream = new_instancemethod(_cmf_core.Reach_get_upstream,None,Reach)
Reach.__lt__ = new_instancemethod(_cmf_core.Reach___lt__,None,Reach)
Reach.__eq__ = new_instancemethod(_cmf_core.Reach___eq__,None,Reach)
Reach.__ne__ = new_instancemethod(_cmf_core.Reach___ne__,None,Reach)
Reach_swigregister = _cmf_core.Reach_swigregister
Reach_swigregister(Reach)

class ReachIterator(object):
    """Proxy of C++ cmf::river::ReachIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def next(self):
        """next(self) -> Reach"""
        return _cmf_core.ReachIterator_next(self)

    def valid(self):
        """valid(self) -> bool"""
        return _cmf_core.ReachIterator_valid(self)

    def __init__(self, *args): 
        """__init__(self, Reach first) -> ReachIterator"""
        _cmf_core.ReachIterator_swiginit(self,_cmf_core.new_ReachIterator(*args))
    reach = _swig_property(_cmf_core.ReachIterator_reach_get)
    position = _swig_property(_cmf_core.ReachIterator_position_get)
    def __iter__(self):
        while self.valid():
            self.next()
            yield (self.reach,self.position)

    __swig_destroy__ = _cmf_core.delete_ReachIterator
ReachIterator.next = new_instancemethod(_cmf_core.ReachIterator_next,None,ReachIterator)
ReachIterator.valid = new_instancemethod(_cmf_core.ReachIterator_valid,None,ReachIterator)
ReachIterator_swigregister = _cmf_core.ReachIterator_swigregister
ReachIterator_swigregister(ReachIterator)


def make_river_gap(*args):
  """make_river_gap(Reach root_reach) -> double"""
  return _cmf_core.make_river_gap(*args)
class project(object):
    """Proxy of C++ cmf::project class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    debug = _swig_property(_cmf_core.project_debug_get, _cmf_core.project_debug_set)
    def __init__(self): 
        """__init__(self) -> project"""
        _cmf_core.project_swiginit(self,_cmf_core.new_project())
    __swig_destroy__ = _cmf_core.delete_project
    def Meteorology(self):
        """Meteorology(self) -> Meteorology"""
        return _cmf_core.project_Meteorology(self)

    def LoadMeteorology(self, *args):
        """LoadMeteorology(self, string filename)"""
        return _cmf_core.project_LoadMeteorology(self, *args)

    def Weather(self, *args):
        """Weather(self, Time t, double x, double y, double z) -> Weather"""
        return _cmf_core.project_Weather(self, *args)

    def SetMeteorology(self, *args):
        """SetMeteorology(self, Meteorology meteo)"""
        return _cmf_core.project_SetMeteorology(self, *args)

    def Rainfall(self, *args):
        """
        Rainfall(self) -> RainfallNode
        Rainfall(self, Time t, double x, double y, double z) -> real
        """
        return _cmf_core.project_Rainfall(self, *args)

    def SetPrecipitation(self, *args):
        """SetPrecipitation(self, PrecipitationData rainfall)"""
        return _cmf_core.project_SetPrecipitation(self, *args)

    def CellCount(self):
        """CellCount(self) -> int"""
        return _cmf_core.project_CellCount(self)

    def Area(self):
        """Area(self) -> double"""
        return _cmf_core.project_Area(self)

    def Cell(self, *args):
        """
        Cell(self, int ndx) -> Cell
        Cell(self, point p, double max_dist = 1e20) -> Cell
        Cell(self, point p) -> Cell
        """
        return _cmf_core.project_Cell(self, *args)

    def NewCell(self, *args):
        """
        NewCell(self, double x, double y, double z, double Area) -> Cell
        NewCell(self, point p, double Area) -> Cell
        """
        return _cmf_core.project_NewCell(self, *args)

    def add_boundary_condition(self, *args):
        """
        add_boundary_condition(self, string name, point Location = cmf::geometry::point())
        add_boundary_condition(self, string name)
        """
        return _cmf_core.project_add_boundary_condition(self, *args)

    def get_boundary_condition(self, *args):
        """get_boundary_condition(self, string name) -> FluxNode"""
        return _cmf_core.project_get_boundary_condition(self, *args)

    def count_boundary_condition(self):
        """count_boundary_condition(self) -> int"""
        return _cmf_core.project_count_boundary_condition(self)

    def ClearLayers(self):
        """ClearLayers(self)"""
        return _cmf_core.project_ClearLayers(self)

    @property
    def cells(self):
        for i in range(self.CellCount()):
            yield self.Cell(i)
    @property 
    def boundary_conditions(self):
        it=bc_iterator(self)
        while it.valid():
            yield it.next()
    def __iter__(self):
        return self.cells
    def __len__(self):
        return self.CellCount()
    def __getitem__(self,index):
        if isinstance(index,slice):
            return [self.Cell(i) for i in range(*index.indices(len(p)))]
        return self.Cell(index)
    def cell_list(self,expression='True'):
        res=[]
        f=lambda cell:eval(expression)
        for cell in self.cells():
            if f(cell):
                res.append(cell)
        return res

project.Meteorology = new_instancemethod(_cmf_core.project_Meteorology,None,project)
project.LoadMeteorology = new_instancemethod(_cmf_core.project_LoadMeteorology,None,project)
project.Weather = new_instancemethod(_cmf_core.project_Weather,None,project)
project.SetMeteorology = new_instancemethod(_cmf_core.project_SetMeteorology,None,project)
project.Rainfall = new_instancemethod(_cmf_core.project_Rainfall,None,project)
project.SetPrecipitation = new_instancemethod(_cmf_core.project_SetPrecipitation,None,project)
project.CellCount = new_instancemethod(_cmf_core.project_CellCount,None,project)
project.Area = new_instancemethod(_cmf_core.project_Area,None,project)
project.Cell = new_instancemethod(_cmf_core.project_Cell,None,project)
project.NewCell = new_instancemethod(_cmf_core.project_NewCell,None,project)
project.add_boundary_condition = new_instancemethod(_cmf_core.project_add_boundary_condition,None,project)
project.get_boundary_condition = new_instancemethod(_cmf_core.project_get_boundary_condition,None,project)
project.count_boundary_condition = new_instancemethod(_cmf_core.project_count_boundary_condition,None,project)
project.ClearLayers = new_instancemethod(_cmf_core.project_ClearLayers,None,project)
project_swigregister = _cmf_core.project_swigregister
project_swigregister(project)

class bc_iterator(object):
    """Proxy of C++ cmf::bc_iterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """__eq__(self, bc_iterator cmp) -> bool"""
        return _cmf_core.bc_iterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, bc_iterator cmp) -> bool"""
        return _cmf_core.bc_iterator___ne__(self, *args)

    def __init__(self, *args): 
        """__init__(self, project p) -> bc_iterator"""
        _cmf_core.bc_iterator_swiginit(self,_cmf_core.new_bc_iterator(*args))
    def node(self):
        """node(self) -> FluxNode"""
        return _cmf_core.bc_iterator_node(self)

    def valid(self):
        """valid(self) -> bool"""
        return _cmf_core.bc_iterator_valid(self)

    def next(self):
        """next(self) -> FluxNode"""
        return _cmf_core.bc_iterator_next(self)

    __swig_destroy__ = _cmf_core.delete_bc_iterator
bc_iterator.__eq__ = new_instancemethod(_cmf_core.bc_iterator___eq__,None,bc_iterator)
bc_iterator.__ne__ = new_instancemethod(_cmf_core.bc_iterator___ne__,None,bc_iterator)
bc_iterator.node = new_instancemethod(_cmf_core.bc_iterator_node,None,bc_iterator)
bc_iterator.valid = new_instancemethod(_cmf_core.bc_iterator_valid,None,bc_iterator)
bc_iterator.next = new_instancemethod(_cmf_core.bc_iterator_next,None,bc_iterator)
bc_iterator_swigregister = _cmf_core.bc_iterator_swigregister
bc_iterator_swigregister(bc_iterator)

def get_layers(cells):
    for c in cells:
        for l in c:
           yield l
def count_layers(cells):
    res=0
    for c in cells:
        res+=c.LayerCount()
    return res
def query_layers(layers,expr='layer.theta()'):
    f=lambda layer:eval(expr)
    for l in layers:
        yield f(l)



