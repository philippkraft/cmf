# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _cmf_core.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_cmf_core', [dirname(__file__)])
        except ImportError:
            import _cmf_core
            return _cmf_core
        if fp is not None:
            try:
                _mod = imp.load_module('_cmf_core', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _cmf_core = swig_import_helper()
    del swig_import_helper
else:
    import _cmf_core
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_SwigPyIterator
    def value(self, *args):
        """value(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_value(self, *args)

    def incr(self, *args):
        """incr(self, size_t n = 1) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_incr(self, *args)

    def decr(self, *args):
        """decr(self, size_t n = 1) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_decr(self, *args)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _cmf_core.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator_equal(self, *args)

    def copy(self, *args):
        """copy(self) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_copy(self, *args)

    def next(self, *args):
        """next(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_next(self, *args)

    def __next__(self, *args):
        """__next__(self) -> PyObject"""
        return _cmf_core.SwigPyIterator___next__(self, *args)

    def previous(self, *args):
        """previous(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_previous(self, *args)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _cmf_core.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_cmf_core.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_cmf_core.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_cmf_core.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_cmf_core.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_cmf_core.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_cmf_core.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_cmf_core.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_cmf_core.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_cmf_core.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_cmf_core.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_cmf_core.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_cmf_core.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_cmf_core.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_cmf_core.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_cmf_core.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_cmf_core.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _cmf_core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _cmf_core.SHARED_PTR_DISOWN
class point(object):
    """
    2D-Point Class.

    Used as location property anywhere in the text Calculation of
    distances

    +,-,-=,*= Operators overloaded

    C++ includes: geometry.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_cmf_core.point_x_get, _cmf_core.point_x_set)
    y = _swig_property(_cmf_core.point_y_get, _cmf_core.point_y_set)
    z = _swig_property(_cmf_core.point_z_get, _cmf_core.point_z_set)
    def Center(self, *args):
        """
        Center(self) -> point

        point Center()
        const 
        """
        return _cmf_core.point_Center(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> point
        __init__(self, point p) -> point
        __init__(self, double x_, double y_, double z_ = 0.0) -> point

        point(double x_,
        double y_, double z_=0.0)

        Creates a point from two doubles. 
        """
        _cmf_core.point_swiginit(self,_cmf_core.new_point(*args))
    def distanceTo(self, *args):
        """
        distanceTo(self, point p) -> double

        double
        distanceTo(point p) const

        Returns the euclidian distance to another point. (see Formula in C++
        documentation) . 
        """
        return _cmf_core.point_distanceTo(self, *args)

    def distance3DTo(self, *args):
        """
        distance3DTo(self, point p) -> double

        double
        distance3DTo(point p) const 
        """
        return _cmf_core.point_distance3DTo(self, *args)

    def distance(*args):
        """distance(point p1, point p2) -> double"""
        return _cmf_core.point_distance(*args)

    distance = staticmethod(distance)
    def distance_max(self, *args):
        """
        distance_max(self, point p) -> double

        double
        distance_max(point p) const

        Returns the distance by the maximum orthogonal offset. 
        """
        return _cmf_core.point_distance_max(self, *args)

    def azimuth(self, *args):
        """
        azimuth(self, point p) -> double

        double
        azimuth(point p) const

        Returns the azimuth angle of the line (see Formula in C++
        documentation)  to the Azimuth in degrees. 
        """
        return _cmf_core.point_azimuth(self, *args)

    def angleToXAxis(self, *args):
        """
        angleToXAxis(self, point p) -> double

        double
        angleToXAxis(point p) const

        Returns the angle between the line (see Formula in C++ documentation)
        to the x-Axis in degrees. 
        """
        return _cmf_core.point_angleToXAxis(self, *args)

    def __add__(self, *args):
        """__add__(self, point p) -> point"""
        return _cmf_core.point___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, point p) -> point"""
        return _cmf_core.point___sub__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, double left) -> point
        __mul__(self, point p) -> point
        """
        return _cmf_core.point___mul__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, double left) -> point
        __div__(self, point p) -> point
        """
        return _cmf_core.point___div__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, point p) -> point"""
        return _cmf_core.point___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, point p) -> point"""
        return _cmf_core.point___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, point p) -> bool"""
        return _cmf_core.point___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, point p) -> bool"""
        return _cmf_core.point___ne__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> int"""
        return _cmf_core.point___len__(self, *args)

    def __rmul__(self, *args):
        """__rmul__(self, double val) -> point"""
        return _cmf_core.point___rmul__(self, *args)

    def __rdiv__(self, *args):
        """__rdiv__(self, double val) -> point"""
        return _cmf_core.point___rdiv__(self, *args)

    def __getitem__(self,index) :
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(p)))]
        if index==0 :
            return self.x
        elif index==1 :
            return self.y
        elif index==2 :
            return self.z
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __setitem__(self,index,value) :
        if index==0 :
            self.x=value
        elif index==1 :
            self.y=value
        elif index==2 :
            self.z=value
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z
    def __repr__(self):
        return 'cmf.point(%g,%g,%g)' % (self.x,self.y,self.z)

    __swig_destroy__ = _cmf_core.delete_point
point.Center = new_instancemethod(_cmf_core.point_Center,None,point)
point.distanceTo = new_instancemethod(_cmf_core.point_distanceTo,None,point)
point.distance3DTo = new_instancemethod(_cmf_core.point_distance3DTo,None,point)
point.distance_max = new_instancemethod(_cmf_core.point_distance_max,None,point)
point.azimuth = new_instancemethod(_cmf_core.point_azimuth,None,point)
point.angleToXAxis = new_instancemethod(_cmf_core.point_angleToXAxis,None,point)
point.__add__ = new_instancemethod(_cmf_core.point___add__,None,point)
point.__sub__ = new_instancemethod(_cmf_core.point___sub__,None,point)
point.__mul__ = new_instancemethod(_cmf_core.point___mul__,None,point)
point.__div__ = new_instancemethod(_cmf_core.point___div__,None,point)
point.__iadd__ = new_instancemethod(_cmf_core.point___iadd__,None,point)
point.__isub__ = new_instancemethod(_cmf_core.point___isub__,None,point)
point.__eq__ = new_instancemethod(_cmf_core.point___eq__,None,point)
point.__ne__ = new_instancemethod(_cmf_core.point___ne__,None,point)
point.__len__ = new_instancemethod(_cmf_core.point___len__,None,point)
point.__rmul__ = new_instancemethod(_cmf_core.point___rmul__,None,point)
point.__rdiv__ = new_instancemethod(_cmf_core.point___rdiv__,None,point)
point_swigregister = _cmf_core.point_swigregister
point_swigregister(point)
cvar = _cmf_core.cvar
PI = cvar.PI

def point_distance(*args):
  """point_distance(point p1, point p2) -> double"""
  return _cmf_core.point_distance(*args)

class Locatable(object):
    """
    An interface for objects having a location in space.

    C++ includes: geometry.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get_position(self, *args):
        """
        get_position(self) -> point

        virtual cmf::geometry::point get_position() const =0

        Pure virtual function. Should return the position of the locatable. 
        """
        return _cmf_core.Locatable_get_position(self, *args)

    def set_position(self, *args):
        """
        set_position(self, point p)

        virtual void set_position(cmf::geometry::point p)

        Sets the location. If not implemented by the child class, an exception
        is thrown. 
        """
        return _cmf_core.Locatable_set_position(self, *args)

    def get_distance_to(self, *args):
        """
        get_distance_to(self, Locatable cmp) -> double

        double get_distance_to(const Locatable &cmp)

        Returns the distance between two locatable objects. 
        """
        return _cmf_core.Locatable_get_distance_to(self, *args)

    def get_direction_to(self, *args):
        """
        get_direction_to(self, Locatable cmp) -> point

        cmf::geometry::point get_direction_to(const Locatable &cmp)

        Returns a vector with length=1 pointing in the direction of another
        Locatable. 
        """
        return _cmf_core.Locatable_get_direction_to(self, *args)

    position=property(get_position,set_position,"The position ofthe locatabe object")

    __swig_destroy__ = _cmf_core.delete_Locatable
Locatable.get_position = new_instancemethod(_cmf_core.Locatable_get_position,None,Locatable)
Locatable.set_position = new_instancemethod(_cmf_core.Locatable_set_position,None,Locatable)
Locatable.get_distance_to = new_instancemethod(_cmf_core.Locatable_get_distance_to,None,Locatable)
Locatable.get_direction_to = new_instancemethod(_cmf_core.Locatable_get_direction_to,None,Locatable)
Locatable_swigregister = _cmf_core.Locatable_swigregister
Locatable_swigregister(Locatable)

class Location(Locatable):
    """Proxy of C++ cmf::geometry::Location class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, point position) -> Location
        __init__(self, double x, double y, double z) -> Location

        Location(double x, double y, double z) 
        """
        _cmf_core.Location_swiginit(self,_cmf_core.new_Location(*args))
    __swig_destroy__ = _cmf_core.delete_Location
Location_swigregister = _cmf_core.Location_swigregister
Location_swigregister(Location)

class point_vector(object):
    """Proxy of C++ cmf::geometry::point_vector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    X = _swig_property(_cmf_core.point_vector_X_get, _cmf_core.point_vector_X_set)
    Y = _swig_property(_cmf_core.point_vector_Y_get, _cmf_core.point_vector_Y_set)
    Z = _swig_property(_cmf_core.point_vector_Z_get, _cmf_core.point_vector_Z_set)
    def __init__(self, *args): 
        """
        __init__(self, int size) -> point_vector

        point_vector(int size) 
        """
        _cmf_core.point_vector_swiginit(self,_cmf_core.new_point_vector(*args))
    def get(self, *args):
        """
        get(self, int index) -> point

        point
        get(int index) const 
        """
        return _cmf_core.point_vector_get(self, *args)

    def set(self, *args):
        """
        set(self, int index, point p)

        void set(int
        index, cmf::geometry::point p) 
        """
        return _cmf_core.point_vector_set(self, *args)

    def size(self, *args):
        """
        size(self) -> int

        int size()
        const 
        """
        return _cmf_core.point_vector_size(self, *args)

    __swig_destroy__ = _cmf_core.delete_point_vector
point_vector.get = new_instancemethod(_cmf_core.point_vector_get,None,point_vector)
point_vector.set = new_instancemethod(_cmf_core.point_vector_set,None,point_vector)
point_vector.size = new_instancemethod(_cmf_core.point_vector_size,None,point_vector)
point_vector_swigregister = _cmf_core.point_vector_swigregister
point_vector_swigregister(point_vector)

import datetime
import struct


def minimum(*args):
  """
    minimum(real a, real b) -> real

    real minimum(real a, real b)

    Returns the minimum of two values. 
    """
  return _cmf_core.minimum(*args)

def maximum(*args):
  """
    maximum(real a, real b) -> real

    real maximum(real a, real b) 
    """
  return _cmf_core.maximum(*args)

def minmax(*args):
  """
    minmax(real x, real min, real max) -> real

    real minmax(real x, real min, real
    max) 
    """
  return _cmf_core.minmax(*args)

def mean(*args):
  """
    mean(real a, real b) -> real

    real mean(real a, real b) 
    """
  return _cmf_core.mean(*args)

def geo_mean(*args):
  """
    geo_mean(real a, real b) -> real

    real geo_mean(real a, real b) 
    """
  return _cmf_core.geo_mean(*args)

def harmonic_mean(*args):
  """
    harmonic_mean(real a, real b) -> real

    real harmonic_mean(real a, real
    b) 
    """
  return _cmf_core.harmonic_mean(*args)

def piecewise_linear(*args):
  """
    piecewise_linear(real x, real xmin, real xmax, real ymin = 0, real ymax = 1) -> real

    real piecewise_linear(real
    x, real xmin, real xmax, real ymin=0, real ymax=1) 
    """
  return _cmf_core.piecewise_linear(*args)

def boltzmann(*args):
  """
    boltzmann(real x, real tau, real x_half) -> real

    real boltzmann(real x, real tau,
    real x_half) 
    """
  return _cmf_core.boltzmann(*args)

def sign(*args):
  """
    sign(real x) -> real

    real sign(real x) 
    """
  return _cmf_core.sign(*args)

def square(*args):
  """
    square(real x) -> real

    real square(real x) 
    """
  return _cmf_core.square(*args)
JULIANDAY_0_1_1900 = _cmf_core.JULIANDAY_0_1_1900
class Time(object):
    """
    A time class, used to pass around current modelling times.

    Timespans and dates in cmf are used with a special object, called
    Time. The advantage of an extra class has the advantage, that the user
    does not has to rememember, which unit of time he or she uses or what
    time unit is accepted by a specific function of the model. Arithmetic
    and boolean operators are supported by Time. Internally the time
    classes stores the time as integer milliseconds, therefore rounding
    issues will only appear at very small time ranges. Absolute time (like
    dates) are represented as milliseconds gone by from Dec, 31st 1899.
    Microsoft Excel dates are represented as days from that time, using
    floating point numbers, therefore it is very simple to convert Excel
    time representations to cmf time.

    Another object is Date, which is doesn't provide the operators, but
    has a nice printed version and some special date functions, like day
    of year (DOY) and provides access to the current hour of day and so
    on, which only applyto dates and not to time spans. You can convert
    Time to Date an vice versa. The printing is not culture aware and uses
    the European representation. If you use the Python standard library
    datetime, conversion between Python time and cmf time is
    possibleCreating absolute time values (dates)

    import CMFlib as cmf                 # Create the time: Jan, 5th 2001,
    2:30 pm, 20s, 412 ms                 t=cmf.Time(5,1,2001,14,30,20,412)
    print t # Prints: '36896d:14:30:20.412h'                 print
    t.AsDate() # Prints: '05.01.2001 14:30:20.412'Creating time spans

    In principle, there are three ways to create time spans. One is to use
    one of the static functions, another is to multiply an existing time
    span (like one of the build in constants) or to substrate two absolute
    times.Available static functions, the default value is always 1

    Milliseconds(): t=cmf.Time.Milliseconds(4100), create a timespan of
    4.1 seconds

    Seconds(): t=cmf. Time.Seconds(4.1), create a timespan of 4.1 seconds

    Minutes(): t=cmf.Time.Minutes(138), create a timespan of 2.3 hours
    (138 min)

    Hours(): t=cmf. Time.Hours(2.3), create a timespan of 2.3 hours (138
    min)

    Days(): t=cmf. Time.Days(2.5), create a timespan of 60 hours

    Years(): t=cmf. Time.Years(), create a timespan of 365 days Available
    constants

    cmf.sec * 4.1: 4.1 seconds

    cmf.min * 138: 2.3 hours (138 min)

    cmf.h * 2.3: 2.3 hours (138 min)

    cmf.day * 2.5: 60 hours (2.5 days)

    cmf.week: 7 days

    cmf.month: 365/12 days (30.4167 days)

    cmf.year: 365 days Available operators:

    time + time = time, time - time = time

    time * float = time ,time / float = time

    time/time=float

    &gt, &lt, ==, != Conversions

    Converting to python datetime

    import CMFlib as cmf                 pythontime = cmf.year.AsPython()
    cmftime=cmf.AsCMFTime(pythontime)                 print
    type(pythontime) # '<type 'datetime.datetime'>'                 print
    type(cmftime)    # '<class 'CMFLib.Time'>'Converting to numbers

    t.AsMilliseconds()

    t.AsSeconds()

    t.AsMinutes()

    t.AsHours()

    t.AsDays()

    t.AsYears() Creating time ranges

    import CMFLib as cmf                 start=cmf.Time(5,1,2001)
    end=cmf.Time(6,1,2001)                 step=cmf.h * 6 for t in
    cmf.timerange(start,end,step):                     print t.AsDate()
    # Prints:                 # 05.01.2001 # 05.01.2001 06:00
    # 05.01.2001 12:00 # 05.01.2001 18:00

    C++ includes: Time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ms_per_day = _cmf_core.Time_ms_per_day
    def __init__(self, *args): 
        """
        __init__(self, double days) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0, 
            int minute = 0, int second = 0, int ms = 0) -> Time
        __init__(self, Date date) -> Time
        __init__(self, Time t) -> Time
        __init__(self) -> Time

        Time()

        Standard constructor. 
        """
        _cmf_core.Time_swiginit(self,_cmf_core.new_Time(*args))
    def AsDays(self, *args):
        """
        AsDays(self) -> double

        double AsDays() const

        Time in days. 
        """
        return _cmf_core.Time_AsDays(self, *args)

    def AsHours(self, *args):
        """
        AsHours(self) -> double

        double AsHours()
        const

        Time in hours. 
        """
        return _cmf_core.Time_AsHours(self, *args)

    def AsMinutes(self, *args):
        """
        AsMinutes(self) -> double

        double AsMinutes()
        const

        Time in minutes. 
        """
        return _cmf_core.Time_AsMinutes(self, *args)

    def AsSeconds(self, *args):
        """
        AsSeconds(self) -> double

        double AsSeconds()
        const

        Time in seconds. 
        """
        return _cmf_core.Time_AsSeconds(self, *args)

    def AsMilliseconds(self, *args):
        """
        AsMilliseconds(self) -> long long

        long long
        AsMilliseconds() const

        Time in milliseconds. 
        """
        return _cmf_core.Time_AsMilliseconds(self, *args)

    def AsDate(self, *args):
        """
        AsDate(self) -> Date

        Date AsDate() const

        """
        return _cmf_core.Time_AsDate(self, *args)

    def to_string(self, *args):
        """
        to_string(self, char seperator = ':') -> string

        std::string
        to_string(char seperator=':') 
        """
        return _cmf_core.Time_to_string(self, *args)

    def is_not_0(self, *args):
        """
        is_not_0(self) -> bool

        bool is_not_0()
        const 
        """
        return _cmf_core.Time_is_not_0(self, *args)

    def DOY(self, *args):
        """
        DOY(self) -> double

        double DOY() const 
        """
        return _cmf_core.Time_DOY(self, *args)

    def __add__(self, *args):
        """__add__(self, Time t1) -> Time"""
        return _cmf_core.Time___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Time t1) -> Time"""
        return _cmf_core.Time___sub__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, Time t1) -> Time"""
        return _cmf_core.Time___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Time t1) -> Time"""
        return _cmf_core.Time___isub__(self, *args)

    def __mod__(self, *args):
        """__mod__(self, Time t1) -> Time"""
        return _cmf_core.Time___mod__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, double x) -> Time
        __mul__(self, int x) -> Time
        """
        return _cmf_core.Time___mul__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, double x) -> Time
        __imul__(self, int x) -> Time
        """
        return _cmf_core.Time___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, double x) -> Time
        __idiv__(self, int x) -> Time
        """
        return _cmf_core.Time___idiv__(self, *args)

    def __imod__(self, *args):
        """__imod__(self, Time t1) -> Time"""
        return _cmf_core.Time___imod__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, double x) -> Time
        __div__(self, int x) -> Time
        __div__(self, Time t1) -> double
        """
        return _cmf_core.Time___div__(self, *args)

    def times_in(self, *args):
        """
        times_in(self, Time t1) -> long long

        long long
        times_in(const Time &t1) const

        Returns the number of times this is included in t1. 
        """
        return _cmf_core.Time_times_in(self, *args)

    def __lt__(self, *args):
        """__lt__(self, Time t1) -> bool"""
        return _cmf_core.Time___lt__(self, *args)

    def __gt__(self, *args):
        """__gt__(self, Time t1) -> bool"""
        return _cmf_core.Time___gt__(self, *args)

    def __le__(self, *args):
        """__le__(self, Time t1) -> bool"""
        return _cmf_core.Time___le__(self, *args)

    def __ge__(self, *args):
        """__ge__(self, Time t1) -> bool"""
        return _cmf_core.Time___ge__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Time t1) -> bool"""
        return _cmf_core.Time___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Time t1) -> bool"""
        return _cmf_core.Time___ne__(self, *args)

    def Years(*args):
        """Years(double y = 1) -> Time"""
        return _cmf_core.Time_Years(*args)

    Years = staticmethod(Years)
    def Days(*args):
        """Days(double d = 1) -> Time"""
        return _cmf_core.Time_Days(*args)

    Days = staticmethod(Days)
    def Hours(*args):
        """Hours(double h = 1) -> Time"""
        return _cmf_core.Time_Hours(*args)

    Hours = staticmethod(Hours)
    def Minutes(*args):
        """Minutes(double min = 1) -> Time"""
        return _cmf_core.Time_Minutes(*args)

    Minutes = staticmethod(Minutes)
    def Seconds(*args):
        """Seconds(double secs = 1) -> Time"""
        return _cmf_core.Time_Seconds(*args)

    Seconds = staticmethod(Seconds)
    def Milliseconds(*args):
        """Milliseconds(long long ms = 1) -> Time"""
        return _cmf_core.Time_Milliseconds(*args)

    Milliseconds = staticmethod(Milliseconds)
    def __repr__(self):
        if self>year*40:
            return self.AsDate().to_string()
        else:
            return self.to_string()
    def __nonzero__(self):
        return self.is_not_0();
    def __rmul__(self,other):
        return self*other;
    def AsPython(self):
        d=self.AsDate()
        return datetime.datetime(d.year,d.month,d.day,d.hour,d.minute,d.second,d.ms*1000)
    year   = property(lambda self: self.AsDate().year)
    month  = property(lambda self: self.AsDate().month)
    day    = property(lambda self: self.AsDate().day)
    hour   = property(lambda self: self.AsDate().hour)
    minute = property(lambda self: self.AsDate().minute)
    second = property(lambda self: self.AsDate().second)
    ms     = property(lambda self: self.AsDate().ms)

    __swig_destroy__ = _cmf_core.delete_Time
Time.AsDays = new_instancemethod(_cmf_core.Time_AsDays,None,Time)
Time.AsHours = new_instancemethod(_cmf_core.Time_AsHours,None,Time)
Time.AsMinutes = new_instancemethod(_cmf_core.Time_AsMinutes,None,Time)
Time.AsSeconds = new_instancemethod(_cmf_core.Time_AsSeconds,None,Time)
Time.AsMilliseconds = new_instancemethod(_cmf_core.Time_AsMilliseconds,None,Time)
Time.AsDate = new_instancemethod(_cmf_core.Time_AsDate,None,Time)
Time.to_string = new_instancemethod(_cmf_core.Time_to_string,None,Time)
Time.is_not_0 = new_instancemethod(_cmf_core.Time_is_not_0,None,Time)
Time.DOY = new_instancemethod(_cmf_core.Time_DOY,None,Time)
Time.__add__ = new_instancemethod(_cmf_core.Time___add__,None,Time)
Time.__sub__ = new_instancemethod(_cmf_core.Time___sub__,None,Time)
Time.__iadd__ = new_instancemethod(_cmf_core.Time___iadd__,None,Time)
Time.__isub__ = new_instancemethod(_cmf_core.Time___isub__,None,Time)
Time.__mod__ = new_instancemethod(_cmf_core.Time___mod__,None,Time)
Time.__mul__ = new_instancemethod(_cmf_core.Time___mul__,None,Time)
Time.__imul__ = new_instancemethod(_cmf_core.Time___imul__,None,Time)
Time.__idiv__ = new_instancemethod(_cmf_core.Time___idiv__,None,Time)
Time.__imod__ = new_instancemethod(_cmf_core.Time___imod__,None,Time)
Time.__div__ = new_instancemethod(_cmf_core.Time___div__,None,Time)
Time.times_in = new_instancemethod(_cmf_core.Time_times_in,None,Time)
Time.__lt__ = new_instancemethod(_cmf_core.Time___lt__,None,Time)
Time.__gt__ = new_instancemethod(_cmf_core.Time___gt__,None,Time)
Time.__le__ = new_instancemethod(_cmf_core.Time___le__,None,Time)
Time.__ge__ = new_instancemethod(_cmf_core.Time___ge__,None,Time)
Time.__eq__ = new_instancemethod(_cmf_core.Time___eq__,None,Time)
Time.__ne__ = new_instancemethod(_cmf_core.Time___ne__,None,Time)
Time_swigregister = _cmf_core.Time_swigregister
Time_swigregister(Time)
Debug = cvar.Debug
VERSION = cvar.VERSION
Pi = cvar.Pi

def Time_Years(*args):
  """Time_Years(double y = 1) -> Time"""
  return _cmf_core.Time_Years(*args)

def Time_Days(*args):
  """Time_Days(double d = 1) -> Time"""
  return _cmf_core.Time_Days(*args)

def Time_Hours(*args):
  """Time_Hours(double h = 1) -> Time"""
  return _cmf_core.Time_Hours(*args)

def Time_Minutes(*args):
  """Time_Minutes(double min = 1) -> Time"""
  return _cmf_core.Time_Minutes(*args)

def Time_Seconds(*args):
  """Time_Seconds(double secs = 1) -> Time"""
  return _cmf_core.Time_Seconds(*args)

def Time_Milliseconds(*args):
  """Time_Milliseconds(long long ms = 1) -> Time"""
  return _cmf_core.Time_Milliseconds(*args)


def minimum_t(*args):
  """
    minimum_t(Time t1, Time t2) -> Time

    Time
    cmf::math::minimum_t(Time t1, Time t2) 
    """
  return _cmf_core.minimum_t(*args)

def maximum_t(*args):
  """
    maximum_t(Time t1, Time t2) -> Time

    Time
    cmf::math::maximum_t(Time t1, Time t2) 
    """
  return _cmf_core.maximum_t(*args)
class Date(object):
    """
    An absolute time, not for calculation. Date and Time are
    interchangable.

    C++ includes: Time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    year = _swig_property(_cmf_core.Date_year_get, _cmf_core.Date_year_set)
    month = _swig_property(_cmf_core.Date_month_get, _cmf_core.Date_month_set)
    day = _swig_property(_cmf_core.Date_day_get, _cmf_core.Date_day_set)
    hour = _swig_property(_cmf_core.Date_hour_get, _cmf_core.Date_hour_set)
    minute = _swig_property(_cmf_core.Date_minute_get, _cmf_core.Date_minute_set)
    second = _swig_property(_cmf_core.Date_second_get, _cmf_core.Date_second_set)
    ms = _swig_property(_cmf_core.Date_ms_get, _cmf_core.Date_ms_set)
    def __init__(self, *args): 
        """
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0, 
            int _minute = 0, int _second = 0, int _ms = 0) -> Date
        __init__(self, Time time) -> Date

        Date(const Time &time)

        Creates a new date from time (based on the 31.12.1899, like in
        Excel(TM)). 
        """
        _cmf_core.Date_swiginit(self,_cmf_core.new_Date(*args))
    def ToTime(self, *args):
        """
        ToTime(self) -> Time

        Time ToTime()

        Converts a date to Time (based on the 31.12.1899, like in Excel(TM).

        """
        return _cmf_core.Date_ToTime(self, *args)

    def DOY(self, *args):
        """
        DOY(self) -> double

        double DOY()

        Returns the day of year. 
        """
        return _cmf_core.Date_DOY(self, *args)

    def to_string(self, *args):
        """
        to_string(self) -> string

        std::string
        to_string()

        Returns a string representing the date. 
        """
        return _cmf_core.Date_to_string(self, *args)

    def __repr__(self):
        return self.to_string()
    def AsPython(self):
        return datetime.datetime(self.year,self.month,self.day,self.hour,self.minute,self.second,self.ms*1000)

    __swig_destroy__ = _cmf_core.delete_Date
Date.ToTime = new_instancemethod(_cmf_core.Date_ToTime,None,Date)
Date.DOY = new_instancemethod(_cmf_core.Date_DOY,None,Date)
Date.to_string = new_instancemethod(_cmf_core.Date_to_string,None,Date)
Date_swigregister = _cmf_core.Date_swigregister
Date_swigregister(Date)

class timeseries(object):
    """
    A timeseries is a list of values, equally distributed over time. To
    create one, one have to provide as start date and a step size. The end
    time is calculated from the number of values. Values queried for times
    before the start time are returned as the first item, values after the
    end time equal the last item. A timeseries with only one item reacts
    like a scalar value.

    Creating a time series

    import CMFLib as cmf                 # Start date is the January 5th
    2001 at 2:30 pm start=cmf.Time(5,1,2001,14,30)
    # time step of the timeseries is 20 minutes
    step=cmf.min*20                 # Type of interpolation between values
    # 0 - Nearest neighbor,                 # 1 - Linear,
    # 2 - Squared, # 3 - Cubic, etc.                 interpolation=1 #
    Create timeseries
    timeseries=cmf.timeseries(start,step,interpolation) # add data
    timeseries.add(0.1) # Value at 2001/5/1 2:30pm is 0.1
    timeseries.add(0.2) # Value at 2001/5/1 2:50pm is 0.2
    timeseries.add(0.1) # Value at 2001/5/1 3:10pm is 0.1

    With this technic it is simple to read files or databases to fill
    timeseries.Using a timeseries

    # Query every minute between 2:15 and 3:14 pm for t in
    cmf.timerange(start,start+cmf.h,cmf.min): print
    "Time:",t.AsDate(),"Value:", timeseries[t]                 # Query
    a specific position of the timeseries                 print
    timeseries[2]

    C++ includes: timeseries.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def interpolationpower(self, *args):
        """
        interpolationpower(self) -> int

        double interpolationpower() const

        Method for the interpolation (0 - Nearest neighbor, 1- linear, 2 -
        cubic spline (not implemented yet). 
        """
        return _cmf_core.timeseries_interpolationpower(self, *args)

    def add(self, *args):
        """
        add(self, double Value)

        void add(double
        Value)

        Appends a measurement. 
        """
        return _cmf_core.timeseries_add(self, *args)

    def is_empty(self, *args):
        """
        is_empty(self) -> bool

        bool
        is_empty() const

        returns true if no values are added to the timeseries 
        """
        return _cmf_core.timeseries_is_empty(self, *args)

    def clear(self, *args):
        """
        clear(self)

        void clear() 
        """
        return _cmf_core.timeseries_clear(self, *args)

    def adress(self, *args):
        """
        adress(self) -> size_t

        size_t adress()
        const 
        """
        return _cmf_core.timeseries_adress(self, *args)

    def copy(self, *args):
        """
        copy(self) -> timeseries

        timeseries copy()
        const 
        """
        return _cmf_core.timeseries_copy(self, *args)

    def size(self, *args):
        """
        size(self) -> int

        int size() const

        """
        return _cmf_core.timeseries_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, Time _begin, Time _step, int _interpolationmethod = 1) -> timeseries
        __init__(self) -> timeseries
        __init__(self, timeseries ts) -> timeseries
        __init__(self, double scalar) -> timeseries

        timeseries(double scalar) 
        """
        _cmf_core.timeseries_swiginit(self,_cmf_core.new_timeseries(*args))
    def get_t(self, *args):
        """
        get_t(self, Time t) -> double

        double
        get_t(cmf::math::Time t) const 
        """
        return _cmf_core.timeseries_get_t(self, *args)

    def get_i(self, *args):
        """
        get_i(self, int i) -> double

        double get_i(int
        i) const 
        """
        return _cmf_core.timeseries_get_i(self, *args)

    def set_t(self, *args):
        """
        set_t(self, Time t, double value)

        void
        set_t(cmf::math::Time t, double value) 
        """
        return _cmf_core.timeseries_set_t(self, *args)

    def set_i(self, *args):
        """
        set_i(self, int i, double value)

        void set_i(int
        i, double value) 
        """
        return _cmf_core.timeseries_set_i(self, *args)

    def get_slice(self, *args):
        """
        get_slice(self, Time _begin, Time _end, Time _step = cmf::math::Time()) -> timeseries
        get_slice(self, int _begin, int _end, int step = 1) -> timeseries

        cmf::math::timeseries get_slice(int _begin, int _end, int step=1) 
        """
        return _cmf_core.timeseries_get_slice(self, *args)

    def set_slice(self, *args):
        """
        set_slice(self, Time _begin, Time _end, timeseries values)
        set_slice(self, int _begin, int _end, timeseries _values)

        void
        set_slice(int _begin, int _end, cmf::math::timeseries _values) 
        """
        return _cmf_core.timeseries_set_slice(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, timeseries arg0) -> timeseries
        __iadd__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, timeseries arg0) -> timeseries
        __isub__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___isub__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, timeseries arg0) -> timeseries
        __imul__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, timeseries arg0) -> timeseries
        __idiv__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___idiv__(self, *args)

    def __add__(self, *args):
        """
        __add__(self, timeseries arg0) -> timeseries
        __add__(self, double other) -> timeseries
        """
        return _cmf_core.timeseries___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, timeseries other) -> timeseries
        __sub__(self, double other) -> timeseries
        """
        return _cmf_core.timeseries___sub__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, timeseries other) -> timeseries
        __mul__(self, double other) -> timeseries
        """
        return _cmf_core.timeseries___mul__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, timeseries other) -> timeseries
        __div__(self, double other) -> timeseries
        """
        return _cmf_core.timeseries___div__(self, *args)

    def __neg__(self, *args):
        """__neg__(self) -> timeseries"""
        return _cmf_core.timeseries___neg__(self, *args)

    def inv(self, *args):
        """
        inv(self) -> timeseries

        timeseries inv()
        const 
        """
        return _cmf_core.timeseries_inv(self, *args)

    def reduce_min(self, *args):
        """
        reduce_min(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_min(cmf::math::Time begin, cmf::math::Time step) const 
        """
        return _cmf_core.timeseries_reduce_min(self, *args)

    def reduce_max(self, *args):
        """
        reduce_max(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_max(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the minimum.

        """
        return _cmf_core.timeseries_reduce_max(self, *args)

    def reduce_sum(self, *args):
        """
        reduce_sum(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_sum(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the maximum.

        """
        return _cmf_core.timeseries_reduce_sum(self, *args)

    def reduce_avg(self, *args):
        """
        reduce_avg(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_avg(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the sum. 
        """
        return _cmf_core.timeseries_reduce_avg(self, *args)

    def floating_avg(self, *args):
        """
        floating_avg(self, Time window_width) -> timeseries

        timeseries floating_avg(cmf::math::Time window_width) const

        Creates a timeseries with a bigger timestep, containing the average.

        """
        return _cmf_core.timeseries_floating_avg(self, *args)

    def floating_max(self, *args):
        """
        floating_max(self, Time window_width) -> timeseries

        timeseries floating_max(cmf::math::Time window_width) const 
        """
        return _cmf_core.timeseries_floating_max(self, *args)

    def floating_min(self, *args):
        """
        floating_min(self, Time window_width) -> timeseries

        timeseries floating_min(cmf::math::Time window_width) const 
        """
        return _cmf_core.timeseries_floating_min(self, *args)

    def mean(self, *args):
        """
        mean(self) -> double

        double mean()
        const 
        """
        return _cmf_core.timeseries_mean(self, *args)

    def min(self, *args):
        """
        min(self) -> double

        double min() const

        """
        return _cmf_core.timeseries_min(self, *args)

    def max(self, *args):
        """
        max(self) -> double

        double max() const

        """
        return _cmf_core.timeseries_max(self, *args)

    def log(self, *args):
        """
        log(self) -> timeseries

        timeseries log()
        const 
        """
        return _cmf_core.timeseries_log(self, *args)

    def log10(self, *args):
        """
        log10(self) -> timeseries

        timeseries
        log10() const 
        """
        return _cmf_core.timeseries_log10(self, *args)

    def power(self, *args):
        """
        power(self, double exponent) -> timeseries

        timeseries
        power(double exponent) const 
        """
        return _cmf_core.timeseries_power(self, *args)

    def exp(self, *args):
        """
        exp(self) -> timeseries

        timeseries exp()
        const 
        """
        return _cmf_core.timeseries_exp(self, *args)

    begin = _swig_property(_cmf_core.timeseries_begin_get)
    step = _swig_property(_cmf_core.timeseries_step_get)
    end = _swig_property(_cmf_core.timeseries_end_get)
    def __len__(self, *args):
        """__len__(self) -> double"""
        return _cmf_core.timeseries___len__(self, *args)

    def __repr__(self):
       return "cmf.timeseries(%s:%s:%s,count=%i)" % (self.begin,self.end,self.step,self.size())
    def extend(self,list) :
        """ Adds the values of a sequence to the timeseries"""
        for item in list :
            self.add(float(item))
    def __getitem__(self,index):
        if isinstance(index,int):
            return self.get_i(index)
        elif isinstance(index,slice):
            if index.step:
                return self.get_slice(index.start,index.stop,index.step)
            else:
                return self.get_slice(index.start,index.stop)
        else:
            return self.get_t(index)
    def __setitem__(self,index,value):
        if isinstance(index,int):
            self.set_i(index,value)
        if isinstance(index,slice):
            if index.step:
                raise ValueError("Slices must be continous, when used for setting")
            else:
                if not isinstance(value,timeseries):
                    value=timeseries(value)
                self.set_slice(index.start,index.stop,value)
        else:
            self.set_t(index,value)
    def __iter__(self):
        for i in xrange(self.size()):
            yield self.get_i(i)
    def interpolate(self,begin,end,step):
        """ Returns a generator returning the interpolated values at the timesteps """
        if step>self.step():
            ts=self.reduce_avg(begin,step)
        else:
            ts=self
        for t in timerange(step,end,step):
            yield ts[t]
    def __radd__(self,other):
        return self + other;
    def __rmul__(self,other):
        return self + other;
    def __rsub__(self,other):
        res=-self
        res+=other
        return res
    def __rdiv__(self,other):
        res=self.inv() 
        res*=other
        return res
    def iter_time(self, as_float=0):
        """Returns an iterator to iterate over each timestep
        as_float if True, the timesteps will returned as floating point numbers representing the days after 1.1.0001 00:00
        """
        for i in xrange(len(self)):
            if as_float:
                yield ((self.begin + self.step * i) - cmf.Time(1,1,1)).AsDays()
            else:
                yield self.begin + self.step * i
    def to_buffer(self):
        """Returns a binary buffer filled with the data of self"""
        return struct.pack('qqqq%id' % self.size(),self.begin.AsMilliseconds(),self.step.AsMilliseconds(),self.interpolationpower(), *self)
    def to_file(self,f):
        """ Saves a timeseries in a special binary format.
        The format consists of 4 integers with 64 bit, indicating the milliseconds after the 31.12.1899 00:00 of the beginning of the timeseries, the milliseconds of the time step,
        the interpolation power and the number of values. The following 64 bit floats, are the values of the timeseries
        """
        if isinstance(f,str):
            f=file(f,'wb')
        elif not hasattr(f,'write'):
            raise TypeError("The file f must be either an object providing a write method, like a file, or a valid file name")
        f.write(struct.pack('qqqq%id' % self.size(),  self.size(), self.begin.AsMilliseconds(),self.step.AsMilliseconds(),self.interpolationpower(), *self))
        
    @classmethod
    def from_sequence(cls,begin,step,sequence=[],interpolation_mode=1):
        res=cls(begin,step,interpolation_mode)
        res.extend(sequence)
        
    @classmethod
    def from_buffer(cls,buf):
        header_length=struct.calcsize('qqqq') 
        header=struct.unpack('qqqq',buffer[:header_length])
        res=cls(header[1]*ms,header[2]*ms,header[3])
        res.extend(struct.unpack('%id' % header[0],*buffer(buf,header_length,header[0]*8)))
    @classmethod
    def from_file(cls,f):
        """ Loads a timeseries saved with to_file from a file 
        Description of the file layout:
        byte: 
        0   Number of (int64)
        8   Begin of timeseries (in ms since 31.12.1899 00:00) (int64)
        16  Step size of timeseries (in ms) (int64)
        24  Interpolation power (int64)
        32  First value of timeseries (float64)
        """
        if isinstance(f,str):
            f=file(f,'rb')
        elif not hasattr(f,'read'):
            raise TypeError("The file f must either implement a 'read' method, like a file, or must be a vild file name")
        header_length=struct.calcsize('qqqq') 
        header=struct.unpack('qqqq',f.read(header_length))
        res=cls(header[1]*ms,header[2]*ms,header[3])
        res.extend(struct.unpack('%id' % header[0],f.read(-1)))
        return res

    __swig_destroy__ = _cmf_core.delete_timeseries
timeseries.interpolationpower = new_instancemethod(_cmf_core.timeseries_interpolationpower,None,timeseries)
timeseries.add = new_instancemethod(_cmf_core.timeseries_add,None,timeseries)
timeseries.is_empty = new_instancemethod(_cmf_core.timeseries_is_empty,None,timeseries)
timeseries.clear = new_instancemethod(_cmf_core.timeseries_clear,None,timeseries)
timeseries.adress = new_instancemethod(_cmf_core.timeseries_adress,None,timeseries)
timeseries.copy = new_instancemethod(_cmf_core.timeseries_copy,None,timeseries)
timeseries.size = new_instancemethod(_cmf_core.timeseries_size,None,timeseries)
timeseries.get_t = new_instancemethod(_cmf_core.timeseries_get_t,None,timeseries)
timeseries.get_i = new_instancemethod(_cmf_core.timeseries_get_i,None,timeseries)
timeseries.set_t = new_instancemethod(_cmf_core.timeseries_set_t,None,timeseries)
timeseries.set_i = new_instancemethod(_cmf_core.timeseries_set_i,None,timeseries)
timeseries.get_slice = new_instancemethod(_cmf_core.timeseries_get_slice,None,timeseries)
timeseries.set_slice = new_instancemethod(_cmf_core.timeseries_set_slice,None,timeseries)
timeseries.__iadd__ = new_instancemethod(_cmf_core.timeseries___iadd__,None,timeseries)
timeseries.__isub__ = new_instancemethod(_cmf_core.timeseries___isub__,None,timeseries)
timeseries.__imul__ = new_instancemethod(_cmf_core.timeseries___imul__,None,timeseries)
timeseries.__idiv__ = new_instancemethod(_cmf_core.timeseries___idiv__,None,timeseries)
timeseries.__add__ = new_instancemethod(_cmf_core.timeseries___add__,None,timeseries)
timeseries.__sub__ = new_instancemethod(_cmf_core.timeseries___sub__,None,timeseries)
timeseries.__mul__ = new_instancemethod(_cmf_core.timeseries___mul__,None,timeseries)
timeseries.__div__ = new_instancemethod(_cmf_core.timeseries___div__,None,timeseries)
timeseries.__neg__ = new_instancemethod(_cmf_core.timeseries___neg__,None,timeseries)
timeseries.inv = new_instancemethod(_cmf_core.timeseries_inv,None,timeseries)
timeseries.reduce_min = new_instancemethod(_cmf_core.timeseries_reduce_min,None,timeseries)
timeseries.reduce_max = new_instancemethod(_cmf_core.timeseries_reduce_max,None,timeseries)
timeseries.reduce_sum = new_instancemethod(_cmf_core.timeseries_reduce_sum,None,timeseries)
timeseries.reduce_avg = new_instancemethod(_cmf_core.timeseries_reduce_avg,None,timeseries)
timeseries.floating_avg = new_instancemethod(_cmf_core.timeseries_floating_avg,None,timeseries)
timeseries.floating_max = new_instancemethod(_cmf_core.timeseries_floating_max,None,timeseries)
timeseries.floating_min = new_instancemethod(_cmf_core.timeseries_floating_min,None,timeseries)
timeseries.mean = new_instancemethod(_cmf_core.timeseries_mean,None,timeseries)
timeseries.min = new_instancemethod(_cmf_core.timeseries_min,None,timeseries)
timeseries.max = new_instancemethod(_cmf_core.timeseries_max,None,timeseries)
timeseries.log = new_instancemethod(_cmf_core.timeseries_log,None,timeseries)
timeseries.log10 = new_instancemethod(_cmf_core.timeseries_log10,None,timeseries)
timeseries.power = new_instancemethod(_cmf_core.timeseries_power,None,timeseries)
timeseries.exp = new_instancemethod(_cmf_core.timeseries_exp,None,timeseries)
timeseries.__len__ = new_instancemethod(_cmf_core.timeseries___len__,None,timeseries)
timeseries_swigregister = _cmf_core.timeseries_swigregister
timeseries_swigregister(timeseries)
ms = cvar.ms
sec = cvar.sec
min = cvar.min
h = cvar.h
day = cvar.day
week = cvar.week
month = cvar.month
year = cvar.year


def nash_sutcliff(*args):
  """
    nash_sutcliff(timeseries model, timeseries observation) -> double

    double
    cmf::math::nash_sutcliff(const cmf::math::timeseries &model, const
    cmf::math::timeseries &observation) 
    """
  return _cmf_core.nash_sutcliff(*args)

def R2(*args):
  """
    R2(timeseries model, timeseries observation) -> double

    double cmf::math::R2(const
    cmf::math::timeseries &model, const cmf::math::timeseries
    &observation) 
    """
  return _cmf_core.R2(*args)
def AsCMFtime(date):
    """Converts a python datetime to cmf.Time"""
    return Time(date.day,date.month,date.year,date.hour,date.minute,date.second,date.microsecond/1000)
def timerange(start,end,step=day):
    """Creates a generator of cmf.Time, similar to the Python range function"""
    return [start+step*x for x in range(0,int((end-start)/step))]
def xtimerange(start,end,step=day):
    """Creates a generator of cmf.Time, similar to the Python range function"""
    return (start+step*x for x in range(0,int((end-start)/step)))

class num_array(object):
    """
    A valarray kind of vector implementation with OpenMP capabilities.

    C++ includes: num_array.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, int count, real Value = 0) -> num_array
        __init__(self, size_t count, real Value = 0) -> num_array
        __init__(self) -> num_array
        __init__(self, num_array Vector) -> num_array
        __init__(self, double data, int count) -> num_array

        num_array(const std::valarray< real > &Vector)

        Convert from valarray<real>. 
        """
        _cmf_core.num_array_swiginit(self,_cmf_core.new_num_array(*args))
    def __set_data_from_adress(self, *args):
        """
        __set_data_from_adress(self, size_t data_adress, size_t count)

        void set_data_from_adress(size_t data_adress, size_t count) 
        """
        return _cmf_core.num_array___set_data_from_adress(self, *args)

    def adress(self, *args):
        """
        adress(self) -> size_t

        size_t adress()
        const 
        """
        return _cmf_core.num_array_adress(self, *args)

    __swig_destroy__ = _cmf_core.delete_num_array
    def size(self, *args):
        """
        size(self) -> int

        int size() const

        Size of the vector. 
        """
        return _cmf_core.num_array_size(self, *args)

    def resize(self, *args):
        """
        resize(self, int count)
        resize(self, size_t count)

        void
        resize(size_t count) 
        """
        return _cmf_core.num_array_resize(self, *args)

    def __neg__(self, *args):
        """__neg__(self) -> num_array"""
        return _cmf_core.num_array___neg__(self, *args)

    def power(self, *args):
        """
        power(self, num_array arg0) -> num_array
        power(self, real exponent) -> num_array

        num_array
        power(real exponent) const

        Return each element to the power "exponent". 
        """
        return _cmf_core.num_array_power(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, num_array arg0) -> num_array
        __iadd__(self, real arg0) -> num_array
        """
        return _cmf_core.num_array___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, num_array arg0) -> num_array
        __isub__(self, real arg0) -> num_array
        """
        return _cmf_core.num_array___isub__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, num_array arg0) -> num_array
        __imul__(self, real arg0) -> num_array
        """
        return _cmf_core.num_array___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, num_array arg0) -> num_array
        __idiv__(self, real arg0) -> num_array
        """
        return _cmf_core.num_array___idiv__(self, *args)

    def apply(self, *args):
        """
        apply(self, real funct) -> num_array

        num_array
        apply(real funct(real)) const

        Return funct(this).

        Parameters:
        -----------

        funct:  a function of signature real funct(real)

        Example: Return the sinus of each element of vector x 
        """
        return _cmf_core.num_array_apply(self, *args)

    def dot(self, *args):
        """
        dot(self, num_array arg0) -> real

        real dot(const
        num_array &) const

        Return dot product of this and vector. 
        """
        return _cmf_core.num_array_dot(self, *args)

    def sum(self, *args):
        """
        sum(self) -> real

        real sum() const

        Return sum of vector. 
        """
        return _cmf_core.num_array_sum(self, *args)

    def max(self, *args):
        """
        max(self) -> real

        real max() const

        Return max of vector. 
        """
        return _cmf_core.num_array_max(self, *args)

    def min(self, *args):
        """
        min(self) -> real

        real min() const

        Return min of vector. 
        """
        return _cmf_core.num_array_min(self, *args)

    def mean(self, *args):
        """
        mean(self) -> real

        real mean() const

        < Return mean of vector 
        """
        return _cmf_core.num_array_mean(self, *args)

    def norm(self, *args):
        """
        norm(self, int normtype = 0) -> real

        real norm(int
        normtype=0) const

        Returns a norm of the vector, implemented norms: 1 - sum of abs, 2 -
        Euclidean distance, 0 Maximum of abs.

        Parameters:
        -----------

        normtype:  An integer indicating the type of norm 
        """
        return _cmf_core.num_array_norm(self, *args)

    def __add__(self, *args):
        """
        __add__(self, num_array _Right) -> num_array
        __add__(self, real _Right) -> num_array
        """
        return _cmf_core.num_array___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, num_array _Right) -> num_array
        __sub__(self, real _Right) -> num_array
        """
        return _cmf_core.num_array___sub__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, num_array _Right) -> num_array
        __mul__(self, real _Right) -> num_array
        """
        return _cmf_core.num_array___mul__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, num_array _Right) -> num_array
        __div__(self, real _Right) -> num_array
        """
        return _cmf_core.num_array___div__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> double"""
        return _cmf_core.num_array___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, int index, double value)"""
        return _cmf_core.num_array___setitem__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> int"""
        return _cmf_core.num_array___len__(self, *args)

    def __radd__(self, *args):
        """__radd__(self, real other) -> num_array"""
        return _cmf_core.num_array___radd__(self, *args)

    def __rsub__(self, *args):
        """__rsub__(self, real other) -> num_array"""
        return _cmf_core.num_array___rsub__(self, *args)

    def __rmul__(self, *args):
        """__rmul__(self, real other) -> num_array"""
        return _cmf_core.num_array___rmul__(self, *args)

    def __rdiv__(self, *args):
        """__rdiv__(self, real other) -> num_array"""
        return _cmf_core.num_array___rdiv__(self, *args)

    def __iter__(self):
        for i in xrange(len(self)):
            yield self[i]
    @property
    def __array_interface__(self):
        return dict(shape=(len(self),),typestr='|f8',data=(self.adress(),0),version=3)
    def ravel(self,order='C'):
        return self
    def __repr__(self):
        return 'cmf.num_array(%g, ..., %g, size=%i)' % (self[0],self[-1],self.size())

num_array.__set_data_from_adress = new_instancemethod(_cmf_core.num_array___set_data_from_adress,None,num_array)
num_array.adress = new_instancemethod(_cmf_core.num_array_adress,None,num_array)
num_array.size = new_instancemethod(_cmf_core.num_array_size,None,num_array)
num_array.resize = new_instancemethod(_cmf_core.num_array_resize,None,num_array)
num_array.__neg__ = new_instancemethod(_cmf_core.num_array___neg__,None,num_array)
num_array.power = new_instancemethod(_cmf_core.num_array_power,None,num_array)
num_array.__iadd__ = new_instancemethod(_cmf_core.num_array___iadd__,None,num_array)
num_array.__isub__ = new_instancemethod(_cmf_core.num_array___isub__,None,num_array)
num_array.__imul__ = new_instancemethod(_cmf_core.num_array___imul__,None,num_array)
num_array.__idiv__ = new_instancemethod(_cmf_core.num_array___idiv__,None,num_array)
num_array.apply = new_instancemethod(_cmf_core.num_array_apply,None,num_array)
num_array.dot = new_instancemethod(_cmf_core.num_array_dot,None,num_array)
num_array.sum = new_instancemethod(_cmf_core.num_array_sum,None,num_array)
num_array.max = new_instancemethod(_cmf_core.num_array_max,None,num_array)
num_array.min = new_instancemethod(_cmf_core.num_array_min,None,num_array)
num_array.mean = new_instancemethod(_cmf_core.num_array_mean,None,num_array)
num_array.norm = new_instancemethod(_cmf_core.num_array_norm,None,num_array)
num_array.__add__ = new_instancemethod(_cmf_core.num_array___add__,None,num_array)
num_array.__sub__ = new_instancemethod(_cmf_core.num_array___sub__,None,num_array)
num_array.__mul__ = new_instancemethod(_cmf_core.num_array___mul__,None,num_array)
num_array.__div__ = new_instancemethod(_cmf_core.num_array___div__,None,num_array)
num_array.__getitem__ = new_instancemethod(_cmf_core.num_array___getitem__,None,num_array)
num_array.__setitem__ = new_instancemethod(_cmf_core.num_array___setitem__,None,num_array)
num_array.__len__ = new_instancemethod(_cmf_core.num_array___len__,None,num_array)
num_array.__radd__ = new_instancemethod(_cmf_core.num_array___radd__,None,num_array)
num_array.__rsub__ = new_instancemethod(_cmf_core.num_array___rsub__,None,num_array)
num_array.__rmul__ = new_instancemethod(_cmf_core.num_array___rmul__,None,num_array)
num_array.__rdiv__ = new_instancemethod(_cmf_core.num_array___rdiv__,None,num_array)
num_array_swigregister = _cmf_core.num_array_swigregister
num_array_swigregister(num_array)


def __add__(*args):
  """__add__(real _Left, num_array _Right) -> num_array"""
  return _cmf_core.__add__(*args)

def __sub__(*args):
  """__sub__(real _Left, num_array _Right) -> num_array"""
  return _cmf_core.__sub__(*args)

def __div__(*args):
  """__div__(real _Left, num_array _Right) -> num_array"""
  return _cmf_core.__div__(*args)
def to_num_array(arraylike):
    if hasattr(arraylike,'__array_interface__'):
        interface=arraylike.__array_interface__
        if len(interface['shape'])!=1:
            raise RuntimeError('Only 1d arrays are convertible to cmf.num_arrays')
        res=num_array(interface['shape'][0])
        res.__set_data_from_adress(interface['data'][0],interface['shape'][0])    
    else:
        res=num_array(len(arraylike))
        for i,v in enumerate(arraylike):
            res[i]=v
    return res
        

class svVector(object):
    """Proxy of C++ std::vector<(p.cmf::math::StateVariable)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.svVector_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.svVector___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.svVector___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_type"""
        return _cmf_core.svVector___len__(self, *args)

    def pop(self, *args):
        """pop(self) -> value_type"""
        return _cmf_core.svVector_pop(self, *args)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> svVector"""
        return _cmf_core.svVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, svVector v)"""
        return _cmf_core.svVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.svVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.svVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> svVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.svVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, svVector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.svVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.svVector_append(self, *args)

    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.svVector_empty(self, *args)

    def size(self, *args):
        """size(self) -> size_type"""
        return _cmf_core.svVector_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.svVector_clear(self, *args)

    def swap(self, *args):
        """swap(self, svVector v)"""
        return _cmf_core.svVector_swap(self, *args)

    def get_allocator(self, *args):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.svVector_get_allocator(self, *args)

    def begin(self, *args):
        """begin(self) -> const_iterator"""
        return _cmf_core.svVector_begin(self, *args)

    def end(self, *args):
        """end(self) -> const_iterator"""
        return _cmf_core.svVector_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.svVector_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.svVector_rend(self, *args)

    def pop_back(self, *args):
        """pop_back(self)"""
        return _cmf_core.svVector_pop_back(self, *args)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.svVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> svVector
        __init__(self, svVector arg0) -> svVector
        __init__(self, size_type size) -> svVector
        __init__(self, size_type size, value_type value) -> svVector
        """
        _cmf_core.svVector_swiginit(self,_cmf_core.new_svVector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.svVector_push_back(self, *args)

    def front(self, *args):
        """front(self) -> value_type"""
        return _cmf_core.svVector_front(self, *args)

    def back(self, *args):
        """back(self) -> value_type"""
        return _cmf_core.svVector_back(self, *args)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.svVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.svVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.svVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.svVector_reserve(self, *args)

    def capacity(self, *args):
        """capacity(self) -> size_type"""
        return _cmf_core.svVector_capacity(self, *args)

    __swig_destroy__ = _cmf_core.delete_svVector
svVector.iterator = new_instancemethod(_cmf_core.svVector_iterator,None,svVector)
svVector.__nonzero__ = new_instancemethod(_cmf_core.svVector___nonzero__,None,svVector)
svVector.__bool__ = new_instancemethod(_cmf_core.svVector___bool__,None,svVector)
svVector.__len__ = new_instancemethod(_cmf_core.svVector___len__,None,svVector)
svVector.pop = new_instancemethod(_cmf_core.svVector_pop,None,svVector)
svVector.__getslice__ = new_instancemethod(_cmf_core.svVector___getslice__,None,svVector)
svVector.__setslice__ = new_instancemethod(_cmf_core.svVector___setslice__,None,svVector)
svVector.__delslice__ = new_instancemethod(_cmf_core.svVector___delslice__,None,svVector)
svVector.__delitem__ = new_instancemethod(_cmf_core.svVector___delitem__,None,svVector)
svVector.__getitem__ = new_instancemethod(_cmf_core.svVector___getitem__,None,svVector)
svVector.__setitem__ = new_instancemethod(_cmf_core.svVector___setitem__,None,svVector)
svVector.append = new_instancemethod(_cmf_core.svVector_append,None,svVector)
svVector.empty = new_instancemethod(_cmf_core.svVector_empty,None,svVector)
svVector.size = new_instancemethod(_cmf_core.svVector_size,None,svVector)
svVector.clear = new_instancemethod(_cmf_core.svVector_clear,None,svVector)
svVector.swap = new_instancemethod(_cmf_core.svVector_swap,None,svVector)
svVector.get_allocator = new_instancemethod(_cmf_core.svVector_get_allocator,None,svVector)
svVector.begin = new_instancemethod(_cmf_core.svVector_begin,None,svVector)
svVector.end = new_instancemethod(_cmf_core.svVector_end,None,svVector)
svVector.rbegin = new_instancemethod(_cmf_core.svVector_rbegin,None,svVector)
svVector.rend = new_instancemethod(_cmf_core.svVector_rend,None,svVector)
svVector.pop_back = new_instancemethod(_cmf_core.svVector_pop_back,None,svVector)
svVector.erase = new_instancemethod(_cmf_core.svVector_erase,None,svVector)
svVector.push_back = new_instancemethod(_cmf_core.svVector_push_back,None,svVector)
svVector.front = new_instancemethod(_cmf_core.svVector_front,None,svVector)
svVector.back = new_instancemethod(_cmf_core.svVector_back,None,svVector)
svVector.assign = new_instancemethod(_cmf_core.svVector_assign,None,svVector)
svVector.resize = new_instancemethod(_cmf_core.svVector_resize,None,svVector)
svVector.insert = new_instancemethod(_cmf_core.svVector_insert,None,svVector)
svVector.reserve = new_instancemethod(_cmf_core.svVector_reserve,None,svVector)
svVector.capacity = new_instancemethod(_cmf_core.svVector_capacity,None,svVector)
svVector_swigregister = _cmf_core.svVector_swigregister
svVector_swigregister(svVector)

def __mul__(*args):
  """
    __mul__(double f, Time t) -> Time
    __mul__(int f, Time t) -> Time
    __mul__(real _Left, num_array _Right) -> num_array
    """
  return _cmf_core.__mul__(*args)

class StateVariable(object):
    """
    Abstract class state variable.

    Abstract class state variable

    Simple exponential system class header implementing a state variable:

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def Derivate(self, *args):
        """
        Derivate(self, Time time) -> real

        virtual
        real Derivate(const cmf::math::Time &time)=0

        Returns the derivate of the state variable at time time. 
        """
        return _cmf_core.StateVariable_Derivate(self, *args)

    def StateIsChanged(self, *args):
        """
        StateIsChanged(self) -> bool

        bool
        StateIsChanged()

        Returns if the state was currently updated. 
        """
        return _cmf_core.StateVariable_StateIsChanged(self, *args)

    state = _swig_property(_cmf_core.StateVariable_state_get, _cmf_core.StateVariable_state_set)
    __swig_destroy__ = _cmf_core.delete_StateVariable
StateVariable.Derivate = new_instancemethod(_cmf_core.StateVariable_Derivate,None,StateVariable)
StateVariable.StateIsChanged = new_instancemethod(_cmf_core.StateVariable_StateIsChanged,None,StateVariable)
StateVariable_swigregister = _cmf_core.StateVariable_swigregister
StateVariable_swigregister(StateVariable)

class StateVariableVector(svVector):
    """Proxy of C++ cmf::math::StateVariableVector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    use_OpenMP = _swig_property(_cmf_core.StateVariableVector_use_OpenMP_get, _cmf_core.StateVariableVector_use_OpenMP_set)
    def CopyStates(self, *args):
        """
        CopyStates(self, num_array destination)
        CopyStates(self, real destination)

        void CopyStates(real *destination) const 
        """
        return _cmf_core.StateVariableVector_CopyStates(self, *args)

    def SetStates(self, *args):
        """
        SetStates(self, num_array newStates)
        SetStates(self, real newStates)

        void SetStates(real *newStates) 
        """
        return _cmf_core.StateVariableVector_SetStates(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, num_array aVector) -> StateVariableVector"""
        return _cmf_core.StateVariableVector___iadd__(self, *args)

    def CopyDerivs(self, *args):
        """
        CopyDerivs(self, Time time, num_array destination, real factor = 1)
        CopyDerivs(self, Time time, real destination, real factor = 1)

        void CopyDerivs(Time time, real *destination, real factor=1) const

        Copies the derivatives at time step "time" to an preallocated c
        array.

        Parameters:
        -----------

        time:   Time at which the derivatives should be calculated

        destination:  Allocated c array

        factor:  A factor that is multiplied to the derivate (e.g. unit
        conversion or integration length) 
        """
        return _cmf_core.StateVariableVector_CopyDerivs(self, *args)

    def GetStates(self, *args):
        """
        GetStates(self) -> num_array

        num_array GetStates() const

        Returns the states in a numeric vector using :CopyStates, but is
        slower because of additional memory allocation. 
        """
        return _cmf_core.StateVariableVector_GetStates(self, *args)

    def GetDerivs(self, *args):
        """
        GetDerivs(self, Time time) -> num_array

        num_array GetDerivs(Time time) const

        Returns the derivatives at time step "time" in a numeric vector
        using :CopyDerivs, but is slower because of additional memory
        allocation. 
        """
        return _cmf_core.StateVariableVector_GetDerivs(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> StateVariableVector

        StateVariableVector() 
        """
        _cmf_core.StateVariableVector_swiginit(self,_cmf_core.new_StateVariableVector(*args))
    __swig_destroy__ = _cmf_core.delete_StateVariableVector
StateVariableVector.CopyStates = new_instancemethod(_cmf_core.StateVariableVector_CopyStates,None,StateVariableVector)
StateVariableVector.SetStates = new_instancemethod(_cmf_core.StateVariableVector_SetStates,None,StateVariableVector)
StateVariableVector.__iadd__ = new_instancemethod(_cmf_core.StateVariableVector___iadd__,None,StateVariableVector)
StateVariableVector.CopyDerivs = new_instancemethod(_cmf_core.StateVariableVector_CopyDerivs,None,StateVariableVector)
StateVariableVector.GetStates = new_instancemethod(_cmf_core.StateVariableVector_GetStates,None,StateVariableVector)
StateVariableVector.GetDerivs = new_instancemethod(_cmf_core.StateVariableVector_GetDerivs,None,StateVariableVector)
StateVariableVector_swigregister = _cmf_core.StateVariableVector_swigregister
StateVariableVector_swigregister(StateVariableVector)

class StateVariableOwner(object):
    """
    An abstract class, that owns one or more state variables, that can add
    them to a vector of state variables in a certain order.

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def AddStateVariables(self, *args):
        """
        AddStateVariables(self, StateVariableVector vector)

        virtual void
        AddStateVariables(cmf::math::StateVariableVector &vector)=0

        Add the state variables, owned by an object derived from
        StateVariableOwner, to the given vector. 
        """
        return _cmf_core.StateVariableOwner_AddStateVariables(self, *args)

    __swig_destroy__ = _cmf_core.delete_StateVariableOwner
StateVariableOwner.AddStateVariables = new_instancemethod(_cmf_core.StateVariableOwner_AddStateVariables,None,StateVariableOwner)
StateVariableOwner_swigregister = _cmf_core.StateVariableOwner_swigregister
StateVariableOwner_swigregister(StateVariableOwner)

class Integrator(object):
    """
    Base class for any kind of integrator.

    Pure virtual functions: Integrate

    Copy Please provide a custom copy constructorTodo Put the methods of
    StateVariableVector here, and delete StateVariableVector

    C++ includes: Integrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Tag = _swig_property(_cmf_core.Integrator_Tag_get, _cmf_core.Integrator_Tag_set)
    UseEulerAtTmin = _swig_property(_cmf_core.Integrator_UseEulerAtTmin_get, _cmf_core.Integrator_UseEulerAtTmin_set)
    use_OpenMP = _swig_property(_cmf_core.Integrator_use_OpenMP_get, _cmf_core.Integrator_use_OpenMP_set)
    def count(self, *args):
        """
        count(self) -> int

        int count()
        const

        returns the number of state variables 
        """
        return _cmf_core.Integrator_count(self, *args)

    def state(self, *args):
        """
        state(self, int position) -> real
        state(self, int position, real newState)

        void state(int
        position, real newState)

        Simplifies the assessment of state variables. 
        """
        return _cmf_core.Integrator_state(self, *args)

    def AddStatesFromOwner(self, *args):
        """
        AddStatesFromOwner(self, StateVariableOwner stateOwner)

        virtual void AddStatesFromOwner(cmf::math::StateVariableOwner
        &stateOwner)

        Adds the state variables of a StateVariableOwner to the state
        variables of the solver. 
        """
        return _cmf_core.Integrator_AddStatesFromOwner(self, *args)

    def AddState(self, *args):
        """
        AddState(self, StateVariable statevar)

        virtual void
        AddState(cmf::math::StateVariable &statevar) 
        """
        return _cmf_core.Integrator_AddState(self, *args)

    def ModelTime(self, *args):
        """
        ModelTime(self) -> Time
        ModelTime(self, Time val)

        void
        ModelTime(cmf::math::Time val)

        Sets the current model time. 
        """
        return _cmf_core.Integrator_ModelTime(self, *args)

    def TimeStep(self, *args):
        """
        TimeStep(self) -> Time

        cmf::math::Time TimeStep() const

        Returns the last time step. 
        """
        return _cmf_core.Integrator_TimeStep(self, *args)

    def NextTimeStep(self, *args):
        """
        NextTimeStep(self) -> Time
        NextTimeStep(self, Time val)

        void
        NextTimeStep(cmf::math::Time val)

        Sets the next time step width. 
        """
        return _cmf_core.Integrator_NextTimeStep(self, *args)

    def MinTimestep(self, *args):
        """
        MinTimestep(self) -> Time

        const
        cmf::math::Time MinTimestep() const

        Returns The minimal allowed time step length. 
        """
        return _cmf_core.Integrator_MinTimestep(self, *args)

    def Iterations(self, *args):
        """
        Iterations(self) -> int

        int
        Iterations() const 
        """
        return _cmf_core.Integrator_Iterations(self, *args)

    def ResetIterations(self, *args):
        """
        ResetIterations(self)

        void
        ResetIterations() 
        """
        return _cmf_core.Integrator_ResetIterations(self, *args)

    def Reset(self, *args):
        """
        Reset(self)

        virtual void
        Reset() 
        """
        return _cmf_core.Integrator_Reset(self, *args)

    def Copy(self, *args):
        """
        Copy(self) -> Integrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.Integrator_Copy(self, *args)

    def Integrate(self, *args):
        """
        Integrate(self, Time MaxTime, Time TimeStep) -> int
        Integrate(self, Time MaxTime) -> int

        int
        Integrate(cmf::math::Time MaxTime) 
        """
        return _cmf_core.Integrator_Integrate(self, *args)

    def IntegrateUntil(self, *args):
        """
        IntegrateUntil(self, Time MaxTime)
        IntegrateUntil(self, Time MaxTime, Time TimeStep)

        void
        IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

        Integrates the vector of state variables until MaxTime. 
        """
        return _cmf_core.Integrator_IntegrateUntil(self, *args)

    t=property(ModelTime,ModelTime,"Gets or sets the model time of the integrator")
    dt=property(TimeStep,None,"Gets the length of the last internal time step of the integrator")
    def __call__(self,t):
        if t<self.t:
            self.IntegrateUntil(self.t+t)
        else:
            self.IntegrateUntil(t)
    def run(self,start=day*0,end=day*1,step=day*1):
        self.t=start
        while self.t<end:
            self(self.t+step)
            yield self.t

    __swig_destroy__ = _cmf_core.delete_Integrator
Integrator.count = new_instancemethod(_cmf_core.Integrator_count,None,Integrator)
Integrator.state = new_instancemethod(_cmf_core.Integrator_state,None,Integrator)
Integrator.AddStatesFromOwner = new_instancemethod(_cmf_core.Integrator_AddStatesFromOwner,None,Integrator)
Integrator.AddState = new_instancemethod(_cmf_core.Integrator_AddState,None,Integrator)
Integrator.ModelTime = new_instancemethod(_cmf_core.Integrator_ModelTime,None,Integrator)
Integrator.TimeStep = new_instancemethod(_cmf_core.Integrator_TimeStep,None,Integrator)
Integrator.NextTimeStep = new_instancemethod(_cmf_core.Integrator_NextTimeStep,None,Integrator)
Integrator.MinTimestep = new_instancemethod(_cmf_core.Integrator_MinTimestep,None,Integrator)
Integrator.Iterations = new_instancemethod(_cmf_core.Integrator_Iterations,None,Integrator)
Integrator.ResetIterations = new_instancemethod(_cmf_core.Integrator_ResetIterations,None,Integrator)
Integrator.Reset = new_instancemethod(_cmf_core.Integrator_Reset,None,Integrator)
Integrator.Copy = new_instancemethod(_cmf_core.Integrator_Copy,None,Integrator)
Integrator.Integrate = new_instancemethod(_cmf_core.Integrator_Integrate,None,Integrator)
Integrator.IntegrateUntil = new_instancemethod(_cmf_core.Integrator_IntegrateUntil,None,Integrator)
Integrator_swigregister = _cmf_core.Integrator_swigregister
Integrator_swigregister(Integrator)

class BDF2(Integrator):
    """
    An order 2 BDF-Method with fixed-point iteration and variable step
    size.

    Recommended integrator for CMF (so far)

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8 and

    Eckert S., Baaser H., Gross D. and Scherf O. (2004) "A BDF2
    integration method with step size control for elasto-plasticity",
    Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1

    Most important function: Integrate

    C++ includes: BDF2.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get_error_position(self, *args):
        """
        get_error_position(self) -> int

        int
        get_error_position() const 
        """
        return _cmf_core.BDF2_get_error_position(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, Integrator templ) -> BDF2

        BDF2(const Integrator
        &templ) 
        """
        _cmf_core.BDF2_swiginit(self,_cmf_core.new_BDF2(*args))
    __swig_destroy__ = _cmf_core.delete_BDF2
BDF2.get_error_position = new_instancemethod(_cmf_core.BDF2_get_error_position,None,BDF2)
BDF2_swigregister = _cmf_core.BDF2_swigregister
BDF2_swigregister(BDF2)

class ExplicitEuler_fixed(Integrator):
    """
    An explicit Euler integrator, with a fixed time step.

    C++ includes: ExplicitEuler_fixed.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, Integrator copy) -> ExplicitEuler_fixed

        ExplicitEuler_fixed(const Integrator &copy)

        Copy constructor. 
        """
        _cmf_core.ExplicitEuler_fixed_swiginit(self,_cmf_core.new_ExplicitEuler_fixed(*args))
    __swig_destroy__ = _cmf_core.delete_ExplicitEuler_fixed
ExplicitEuler_fixed_swigregister = _cmf_core.ExplicitEuler_fixed_swigregister
ExplicitEuler_fixed_swigregister(ExplicitEuler_fixed)

class PredictCorrectSimple(Integrator):
    """
    A simple predictor - corrector solver (see Formula in C++
    documentation) .

    C++ includes: ExplicitEuler_fixed.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = _swig_property(_cmf_core.PredictCorrectSimple_alpha_get, _cmf_core.PredictCorrectSimple_alpha_set)
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real Alpha) -> PredictCorrectSimple
        __init__(self, StateVariableOwner states, real Alpha) -> PredictCorrectSimple
        __init__(self, real Alpha = 0.5) -> PredictCorrectSimple
        __init__(self, Integrator copy) -> PredictCorrectSimple

        PredictCorrectSimple(const Integrator &copy)

        Copy constructor. 
        """
        _cmf_core.PredictCorrectSimple_swiginit(self,_cmf_core.new_PredictCorrectSimple(*args))
    __swig_destroy__ = _cmf_core.delete_PredictCorrectSimple
PredictCorrectSimple_swigregister = _cmf_core.PredictCorrectSimple_swigregister
PredictCorrectSimple_swigregister(PredictCorrectSimple)

class ImplicitEuler(Integrator):
    """
    An implicit (backward) Euler integrator using fixpoint iteration.

    C++ includes: FixpointImplicitEuler.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ImplicitEuler
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ImplicitEuler
        __init__(self, Integrator arg0) -> ImplicitEuler

        ImplicitEuler(const Integrator &)

        Copy constructor. 
        """
        _cmf_core.ImplicitEuler_swiginit(self,_cmf_core.new_ImplicitEuler(*args))
    __swig_destroy__ = _cmf_core.delete_ImplicitEuler
ImplicitEuler_swigregister = _cmf_core.ImplicitEuler_swigregister
ImplicitEuler_swigregister(ImplicitEuler)

class RKFIntegrator(Integrator):
    """
    Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
    Fehlberg (RKF54) method.

    C++ includes: RKFIntegrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> RKFIntegrator
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> RKFIntegrator
        __init__(self, Integrator forCopy) -> RKFIntegrator

        RKFIntegrator(const Integrator &forCopy)

        Copy constructor, does not copy. 
        """
        _cmf_core.RKFIntegrator_swiginit(self,_cmf_core.new_RKFIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_RKFIntegrator
RKFIntegrator_swigregister = _cmf_core.RKFIntegrator_swigregister
RKFIntegrator_swigregister(RKFIntegrator)

class CVodeIntegrator(Integrator):
    """
    A wrapper class for the CVODE integrator from the SUNDIALS library.

    https://computation.llnl.gov/casc/sundials/main.html

    C++ includes: cvodeIntegrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    preconditioner = _swig_property(_cmf_core.CVodeIntegrator_preconditioner_get, _cmf_core.CVodeIntegrator_preconditioner_set)
    MaxNonLinearIterations = _swig_property(_cmf_core.CVodeIntegrator_MaxNonLinearIterations_get, _cmf_core.CVodeIntegrator_MaxNonLinearIterations_set)
    MaxConvergenceFailures = _swig_property(_cmf_core.CVodeIntegrator_MaxConvergenceFailures_get, _cmf_core.CVodeIntegrator_MaxConvergenceFailures_set)
    MaxErrorTestFailures = _swig_property(_cmf_core.CVodeIntegrator_MaxErrorTestFailures_get, _cmf_core.CVodeIntegrator_MaxErrorTestFailures_set)
    maxl = _swig_property(_cmf_core.CVodeIntegrator_maxl_get, _cmf_core.CVodeIntegrator_maxl_set)
    LinearSolver = _swig_property(_cmf_core.CVodeIntegrator_LinearSolver_get, _cmf_core.CVodeIntegrator_LinearSolver_set)
    MaxOrder = _swig_property(_cmf_core.CVodeIntegrator_MaxOrder_get, _cmf_core.CVodeIntegrator_MaxOrder_set)
    reinit_always = _swig_property(_cmf_core.CVodeIntegrator_reinit_always_get, _cmf_core.CVodeIntegrator_reinit_always_set)
    max_step = _swig_property(_cmf_core.CVodeIntegrator_max_step_get, _cmf_core.CVodeIntegrator_max_step_set)
    def GetOrder(self, *args):
        """
        GetOrder(self) -> int

        int
        GetOrder()

        Returns the last order of the solver used, may be smaller than
        MaxOrder due to the number of steps already taken or to fullfill
        stability limit. 
        """
        return _cmf_core.CVodeIntegrator_GetOrder(self, *args)

    def ReInit(self, *args):
        """
        ReInit(self, Time initdt, real epsilon = 0)

        void
        ReInit(Time initdt, real epsilon=0) 
        """
        return _cmf_core.CVodeIntegrator_ReInit(self, *args)

    def Initialize(self, *args):
        """
        Initialize(self)

        void
        Initialize()

        Initializes the solver. Do not add or remove statevariables after
        initialization. 
        """
        return _cmf_core.CVodeIntegrator_Initialize(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(50)) -> CVodeIntegrator
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(50)) -> CVodeIntegrator
        __init__(self, CVodeIntegrator templ) -> CVodeIntegrator

        CVodeIntegrator(const CVodeIntegrator &templ)

        Copy constructor, creates a new CVODE integrator similiar to the
        given, but without statevariables. 
        """
        _cmf_core.CVodeIntegrator_swiginit(self,_cmf_core.new_CVodeIntegrator(*args))
    def Copy(self, *args):
        """
        Copy(self) -> CVodeIntegrator

        CVodeIntegrator* Copy() const

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.CVodeIntegrator_Copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_CVodeIntegrator
CVodeIntegrator.GetOrder = new_instancemethod(_cmf_core.CVodeIntegrator_GetOrder,None,CVodeIntegrator)
CVodeIntegrator.ReInit = new_instancemethod(_cmf_core.CVodeIntegrator_ReInit,None,CVodeIntegrator)
CVodeIntegrator.Initialize = new_instancemethod(_cmf_core.CVodeIntegrator_Initialize,None,CVodeIntegrator)
CVodeIntegrator.Copy = new_instancemethod(_cmf_core.CVodeIntegrator_Copy,None,CVodeIntegrator)
CVodeIntegrator_swigregister = _cmf_core.CVodeIntegrator_swigregister
CVodeIntegrator_swigregister(CVodeIntegrator)

class MultiIntegrator(Integrator):
    """
    The MultiIntegrator is a wrapper for a bunch integrators. The states
    of the integrators should not have direct connections over integrator
    boundaries.

    C++ includes: MultiIntegrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Copy(self, *args):
        """
        Copy(self) -> MultiIntegrator

        virtual
        cmf::math::MultiIntegrator* Copy() const

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.MultiIntegrator_Copy(self, *args)

    def add_states_to_integrator(self, *args):
        """
        add_states_to_integrator(self, StateVariableOwner stateOwner, int integrator_position)

        void
        add_states_to_integrator(cmf::math::StateVariableOwner &stateOwner,
        int integrator_position) 
        """
        return _cmf_core.MultiIntegrator_add_states_to_integrator(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, Integrator template_integrator, int count) -> MultiIntegrator

        MultiIntegrator(const cmf::math::Integrator &template_integrator, int
        count) 
        """
        _cmf_core.MultiIntegrator_swiginit(self,_cmf_core.new_MultiIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_MultiIntegrator
MultiIntegrator.Copy = new_instancemethod(_cmf_core.MultiIntegrator_Copy,None,MultiIntegrator)
MultiIntegrator.add_states_to_integrator = new_instancemethod(_cmf_core.MultiIntegrator_add_states_to_integrator,None,MultiIntegrator)
MultiIntegrator_swigregister = _cmf_core.MultiIntegrator_swigregister
MultiIntegrator_swigregister(MultiIntegrator)

class solute(object):
    """
    A structure to identify a solute.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args): 
        """
        __init__(self, solute copy) -> solute

        solute(const
        solute &copy) 
        """
        _cmf_core.solute_swiginit(self,_cmf_core.new_solute(*args))
    def __eq__(self, *args):
        """__eq__(self, solute cmp) -> bool"""
        return _cmf_core.solute___eq__(self, *args)

    def __lt__(self, *args):
        """__lt__(self, solute cmp) -> bool"""
        return _cmf_core.solute___lt__(self, *args)

    def __gt__(self, *args):
        """__gt__(self, solute cmp) -> bool"""
        return _cmf_core.solute___gt__(self, *args)

    def __le__(self, *args):
        """__le__(self, solute cmp) -> bool"""
        return _cmf_core.solute___le__(self, *args)

    def __ge__(self, *args):
        """__ge__(self, solute cmp) -> bool"""
        return _cmf_core.solute___ge__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, solute cmp) -> bool"""
        return _cmf_core.solute___ne__(self, *args)

    Name = _swig_property(_cmf_core.solute_Name_get, _cmf_core.solute_Name_set)
    Unit = _swig_property(_cmf_core.solute_Unit_get, _cmf_core.solute_Unit_set)
    Uptake = _swig_property(_cmf_core.solute_Uptake_get, _cmf_core.solute_Uptake_set)
    Id = _swig_property(_cmf_core.solute_Id_get)
    def __repr__(self, *args):
        """__repr__(self) -> string"""
        return _cmf_core.solute___repr__(self, *args)

    __swig_destroy__ = _cmf_core.delete_solute
solute.__eq__ = new_instancemethod(_cmf_core.solute___eq__,None,solute)
solute.__lt__ = new_instancemethod(_cmf_core.solute___lt__,None,solute)
solute.__gt__ = new_instancemethod(_cmf_core.solute___gt__,None,solute)
solute.__le__ = new_instancemethod(_cmf_core.solute___le__,None,solute)
solute.__ge__ = new_instancemethod(_cmf_core.solute___ge__,None,solute)
solute.__ne__ = new_instancemethod(_cmf_core.solute___ne__,None,solute)
solute.__repr__ = new_instancemethod(_cmf_core.solute___repr__,None,solute)
solute_swigregister = _cmf_core.solute_swigregister
solute_swigregister(solute)

class solute_vector(object):
    """
    Manages the solutes of the model.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def size(self, *args):
        """
        size(self) -> size_t

        size_t size()
        const 
        """
        return _cmf_core.solute_vector_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, string str) -> solute_vector

        solute_vector(std::string str)

        Creates a solute vector from solute names, separated by whitespace.
        E.g. solutes=solute_vector("dO18 dH2"). 
        """
        _cmf_core.solute_vector_swiginit(self,_cmf_core.new_solute_vector(*args))
    def get_solute(self, *args):
        """
        get_solute(self, int position) -> solute

        cmf::water::solute* get_solute(int position) 
        """
        return _cmf_core.solute_vector_get_solute(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, int i) -> solute"""
        return _cmf_core.solute_vector___getitem__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_t"""
        return _cmf_core.solute_vector___len__(self, *args)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __repr__(self):
        return str([s.Name for s in self])

    __swig_destroy__ = _cmf_core.delete_solute_vector
solute_vector.size = new_instancemethod(_cmf_core.solute_vector_size,None,solute_vector)
solute_vector.get_solute = new_instancemethod(_cmf_core.solute_vector_get_solute,None,solute_vector)
solute_vector.__getitem__ = new_instancemethod(_cmf_core.solute_vector___getitem__,None,solute_vector)
solute_vector.__len__ = new_instancemethod(_cmf_core.solute_vector___len__,None,solute_vector)
solute_vector_swigregister = _cmf_core.solute_vector_swigregister
solute_vector_swigregister(solute_vector)

class SoluteTimeseries(object):
    """
    A map of concentration time series for solutes.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def conc(self, *args):
        """
        conc(self, Time t, solute _Solute) -> real

        real
        conc(cmf::math::Time t, const cmf::water::solute &solute) const 
        """
        return _cmf_core.SoluteTimeseries_conc(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t

        size_t
        size() const

        Returns the number of solutes in the solution. 
        """
        return _cmf_core.SoluteTimeseries_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> SoluteTimeseries
        __init__(self, solute_vector solutes, Time begin, Time step) -> SoluteTimeseries
        __init__(self, SoluteTimeseries sts) -> SoluteTimeseries

        SoluteTimeseries(const cmf::water::SoluteTimeseries &sts) 
        """
        _cmf_core.SoluteTimeseries_swiginit(self,_cmf_core.new_SoluteTimeseries(*args))
    def __getitem__(self, *args):
        """__getitem__(self, solute solute) -> timeseries"""
        return _cmf_core.SoluteTimeseries___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, solute solute, timeseries concentration)"""
        return _cmf_core.SoluteTimeseries___setitem__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_t"""
        return _cmf_core.SoluteTimeseries___len__(self, *args)

    __swig_destroy__ = _cmf_core.delete_SoluteTimeseries
SoluteTimeseries.conc = new_instancemethod(_cmf_core.SoluteTimeseries_conc,None,SoluteTimeseries)
SoluteTimeseries.size = new_instancemethod(_cmf_core.SoluteTimeseries_size,None,SoluteTimeseries)
SoluteTimeseries.__getitem__ = new_instancemethod(_cmf_core.SoluteTimeseries___getitem__,None,SoluteTimeseries)
SoluteTimeseries.__setitem__ = new_instancemethod(_cmf_core.SoluteTimeseries___setitem__,None,SoluteTimeseries)
SoluteTimeseries.__len__ = new_instancemethod(_cmf_core.SoluteTimeseries___len__,None,SoluteTimeseries)
SoluteTimeseries_swigregister = _cmf_core.SoluteTimeseries_swigregister
SoluteTimeseries_swigregister(SoluteTimeseries)

class SoluteStorage(StateVariable):
    """
    A class for the storage of any tracer. The state is the amount (mol,
    kg etc. see cmf::water) of the tracer in the storage.

    The derivative function is given by: (see Formula in C++
    documentation)

    C++ includes: SoluteStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    decay = _swig_property(_cmf_core.SoluteStorage_decay_get, _cmf_core.SoluteStorage_decay_set)
    source = _swig_property(_cmf_core.SoluteStorage_source_get, _cmf_core.SoluteStorage_source_set)
    Solute = _swig_property(_cmf_core.SoluteStorage_Solute_get)
    def conc(self, *args):
        """
        conc(self) -> real

        real conc()
        const

        Returns the concentration of the solute. 
        """
        return _cmf_core.SoluteStorage_conc(self, *args)

    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_2__ swigSharedPtrUpcast) -> __dummy_0__"""
        return _cmf_core.SoluteStorage_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    __swig_destroy__ = _cmf_core.delete_SoluteStorage
SoluteStorage.conc = new_instancemethod(_cmf_core.SoluteStorage_conc,None,SoluteStorage)
SoluteStorage_swigregister = _cmf_core.SoluteStorage_swigregister
SoluteStorage_swigregister(SoluteStorage)

def SoluteStorage_SWIGSharedPtrUpcast(*args):
  """SoluteStorage_SWIGSharedPtrUpcast(__dummy_2__ swigSharedPtrUpcast) -> __dummy_0__"""
  return _cmf_core.SoluteStorage_SWIGSharedPtrUpcast(*args)

class connection_vector(object):
    """Proxy of C++ std::vector<(p.cmf::water::flux_connection)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.connection_vector_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.connection_vector___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.connection_vector___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_type"""
        return _cmf_core.connection_vector___len__(self, *args)

    def pop(self, *args):
        """pop(self) -> value_type"""
        return _cmf_core.connection_vector_pop(self, *args)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> connection_vector"""
        return _cmf_core.connection_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, connection_vector v)"""
        return _cmf_core.connection_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.connection_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.connection_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> connection_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.connection_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, connection_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.connection_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.connection_vector_append(self, *args)

    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.connection_vector_empty(self, *args)

    def size(self, *args):
        """size(self) -> size_type"""
        return _cmf_core.connection_vector_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.connection_vector_clear(self, *args)

    def swap(self, *args):
        """swap(self, connection_vector v)"""
        return _cmf_core.connection_vector_swap(self, *args)

    def get_allocator(self, *args):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.connection_vector_get_allocator(self, *args)

    def begin(self, *args):
        """begin(self) -> const_iterator"""
        return _cmf_core.connection_vector_begin(self, *args)

    def end(self, *args):
        """end(self) -> const_iterator"""
        return _cmf_core.connection_vector_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.connection_vector_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.connection_vector_rend(self, *args)

    def pop_back(self, *args):
        """pop_back(self)"""
        return _cmf_core.connection_vector_pop_back(self, *args)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.connection_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> connection_vector
        __init__(self, connection_vector arg0) -> connection_vector
        __init__(self, size_type size) -> connection_vector
        __init__(self, size_type size, value_type value) -> connection_vector
        """
        _cmf_core.connection_vector_swiginit(self,_cmf_core.new_connection_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.connection_vector_push_back(self, *args)

    def front(self, *args):
        """front(self) -> value_type"""
        return _cmf_core.connection_vector_front(self, *args)

    def back(self, *args):
        """back(self) -> value_type"""
        return _cmf_core.connection_vector_back(self, *args)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.connection_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.connection_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.connection_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.connection_vector_reserve(self, *args)

    def capacity(self, *args):
        """capacity(self) -> size_type"""
        return _cmf_core.connection_vector_capacity(self, *args)

    __swig_destroy__ = _cmf_core.delete_connection_vector
connection_vector.iterator = new_instancemethod(_cmf_core.connection_vector_iterator,None,connection_vector)
connection_vector.__nonzero__ = new_instancemethod(_cmf_core.connection_vector___nonzero__,None,connection_vector)
connection_vector.__bool__ = new_instancemethod(_cmf_core.connection_vector___bool__,None,connection_vector)
connection_vector.__len__ = new_instancemethod(_cmf_core.connection_vector___len__,None,connection_vector)
connection_vector.pop = new_instancemethod(_cmf_core.connection_vector_pop,None,connection_vector)
connection_vector.__getslice__ = new_instancemethod(_cmf_core.connection_vector___getslice__,None,connection_vector)
connection_vector.__setslice__ = new_instancemethod(_cmf_core.connection_vector___setslice__,None,connection_vector)
connection_vector.__delslice__ = new_instancemethod(_cmf_core.connection_vector___delslice__,None,connection_vector)
connection_vector.__delitem__ = new_instancemethod(_cmf_core.connection_vector___delitem__,None,connection_vector)
connection_vector.__getitem__ = new_instancemethod(_cmf_core.connection_vector___getitem__,None,connection_vector)
connection_vector.__setitem__ = new_instancemethod(_cmf_core.connection_vector___setitem__,None,connection_vector)
connection_vector.append = new_instancemethod(_cmf_core.connection_vector_append,None,connection_vector)
connection_vector.empty = new_instancemethod(_cmf_core.connection_vector_empty,None,connection_vector)
connection_vector.size = new_instancemethod(_cmf_core.connection_vector_size,None,connection_vector)
connection_vector.clear = new_instancemethod(_cmf_core.connection_vector_clear,None,connection_vector)
connection_vector.swap = new_instancemethod(_cmf_core.connection_vector_swap,None,connection_vector)
connection_vector.get_allocator = new_instancemethod(_cmf_core.connection_vector_get_allocator,None,connection_vector)
connection_vector.begin = new_instancemethod(_cmf_core.connection_vector_begin,None,connection_vector)
connection_vector.end = new_instancemethod(_cmf_core.connection_vector_end,None,connection_vector)
connection_vector.rbegin = new_instancemethod(_cmf_core.connection_vector_rbegin,None,connection_vector)
connection_vector.rend = new_instancemethod(_cmf_core.connection_vector_rend,None,connection_vector)
connection_vector.pop_back = new_instancemethod(_cmf_core.connection_vector_pop_back,None,connection_vector)
connection_vector.erase = new_instancemethod(_cmf_core.connection_vector_erase,None,connection_vector)
connection_vector.push_back = new_instancemethod(_cmf_core.connection_vector_push_back,None,connection_vector)
connection_vector.front = new_instancemethod(_cmf_core.connection_vector_front,None,connection_vector)
connection_vector.back = new_instancemethod(_cmf_core.connection_vector_back,None,connection_vector)
connection_vector.assign = new_instancemethod(_cmf_core.connection_vector_assign,None,connection_vector)
connection_vector.resize = new_instancemethod(_cmf_core.connection_vector_resize,None,connection_vector)
connection_vector.insert = new_instancemethod(_cmf_core.connection_vector_insert,None,connection_vector)
connection_vector.reserve = new_instancemethod(_cmf_core.connection_vector_reserve,None,connection_vector)
connection_vector.capacity = new_instancemethod(_cmf_core.connection_vector_capacity,None,connection_vector)
connection_vector_swigregister = _cmf_core.connection_vector_swigregister
connection_vector_swigregister(connection_vector)

class connection_set(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.connection_set_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.connection_set___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.connection_set___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_type"""
        return _cmf_core.connection_set___len__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.connection_set_append(self, *args)

    def __contains__(self, *args):
        """__contains__(self, value_type x) -> bool"""
        return _cmf_core.connection_set___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _cmf_core.connection_set___getitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(p.cmf::water::flux_connection)> arg0) -> connection_set
        __init__(self) -> connection_set
        __init__(self, connection_set arg0) -> connection_set
        """
        _cmf_core.connection_set_swiginit(self,_cmf_core.new_connection_set(*args))
    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.connection_set_empty(self, *args)

    def size(self, *args):
        """size(self) -> size_type"""
        return _cmf_core.connection_set_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.connection_set_clear(self, *args)

    def swap(self, *args):
        """swap(self, connection_set v)"""
        return _cmf_core.connection_set_swap(self, *args)

    def count(self, *args):
        """count(self, key_type x) -> size_type"""
        return _cmf_core.connection_set_count(self, *args)

    def begin(self, *args):
        """begin(self) -> iterator"""
        return _cmf_core.connection_set_begin(self, *args)

    def end(self, *args):
        """end(self) -> iterator"""
        return _cmf_core.connection_set_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> reverse_iterator"""
        return _cmf_core.connection_set_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> reverse_iterator"""
        return _cmf_core.connection_set_rend(self, *args)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator pos)
        erase(self, iterator first, iterator last)
        """
        return _cmf_core.connection_set_erase(self, *args)

    def find(self, *args):
        """find(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(self, key_type x) -> std::pair<(std::set<(p.cmf::water::flux_connection)>::iterator,std::set<(p.cmf::water::flux_connection)>::iterator)>"""
        return _cmf_core.connection_set_equal_range(self, *args)

    def insert(self, *args):
        """insert(self, value_type __x) -> std::pair<(std::set<(p.cmf::water::flux_connection)>::iterator,bool)>"""
        return _cmf_core.connection_set_insert(self, *args)

    __swig_destroy__ = _cmf_core.delete_connection_set
connection_set.iterator = new_instancemethod(_cmf_core.connection_set_iterator,None,connection_set)
connection_set.__nonzero__ = new_instancemethod(_cmf_core.connection_set___nonzero__,None,connection_set)
connection_set.__bool__ = new_instancemethod(_cmf_core.connection_set___bool__,None,connection_set)
connection_set.__len__ = new_instancemethod(_cmf_core.connection_set___len__,None,connection_set)
connection_set.append = new_instancemethod(_cmf_core.connection_set_append,None,connection_set)
connection_set.__contains__ = new_instancemethod(_cmf_core.connection_set___contains__,None,connection_set)
connection_set.__getitem__ = new_instancemethod(_cmf_core.connection_set___getitem__,None,connection_set)
connection_set.empty = new_instancemethod(_cmf_core.connection_set_empty,None,connection_set)
connection_set.size = new_instancemethod(_cmf_core.connection_set_size,None,connection_set)
connection_set.clear = new_instancemethod(_cmf_core.connection_set_clear,None,connection_set)
connection_set.swap = new_instancemethod(_cmf_core.connection_set_swap,None,connection_set)
connection_set.count = new_instancemethod(_cmf_core.connection_set_count,None,connection_set)
connection_set.begin = new_instancemethod(_cmf_core.connection_set_begin,None,connection_set)
connection_set.end = new_instancemethod(_cmf_core.connection_set_end,None,connection_set)
connection_set.rbegin = new_instancemethod(_cmf_core.connection_set_rbegin,None,connection_set)
connection_set.rend = new_instancemethod(_cmf_core.connection_set_rend,None,connection_set)
connection_set.erase = new_instancemethod(_cmf_core.connection_set_erase,None,connection_set)
connection_set.find = new_instancemethod(_cmf_core.connection_set_find,None,connection_set)
connection_set.lower_bound = new_instancemethod(_cmf_core.connection_set_lower_bound,None,connection_set)
connection_set.upper_bound = new_instancemethod(_cmf_core.connection_set_upper_bound,None,connection_set)
connection_set.equal_range = new_instancemethod(_cmf_core.connection_set_equal_range,None,connection_set)
connection_set.insert = new_instancemethod(_cmf_core.connection_set_insert,None,connection_set)
connection_set_swigregister = _cmf_core.connection_set_swigregister
connection_set_swigregister(connection_set)

class flux_node(object):
    """
    Base class for everything that can be connected by fluxes. Flux nodes
    can be WaterStorages, flux end points, sinks, sources and bridges to
    other model domains (e.g. Ponded water to river system). The base
    class can be used where a simple routing, potentially with mixing, is
    needed.

    C++ includes: flux_node.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def project(self, *args):
        """
        project(self) -> project

        const
        cmf::project& project() const

        Returns the project, this node is part of. 
        """
        return _cmf_core.flux_node_project(self, *args)

    node_id = _swig_property(_cmf_core.flux_node_node_id_get)
    def is_storage(self, *args):
        """
        is_storage(self) -> bool

        virtual
        bool is_storage() const

        true, if this is a waterstorage 
        """
        return _cmf_core.flux_node_is_storage(self, *args)

    Name = _swig_property(_cmf_core.flux_node_Name_get, _cmf_core.flux_node_Name_set)
    def to_string(self, *args):
        """
        to_string(self) -> string

        virtual
        std::string to_string() const 
        """
        return _cmf_core.flux_node_to_string(self, *args)

    __swig_destroy__ = _cmf_core.delete_flux_node
    def __eq__(self, *args):
        """__eq__(self, flux_node other) -> bool"""
        return _cmf_core.flux_node___eq__(self, *args)

    def RecalcFluxes(self, *args):
        """
        RecalcFluxes(self, Time t) -> bool

        virtual
        bool RecalcFluxes(cmf::math::Time t)

        Pure flux_nodes do not influence fluxes, therefore no recalculation of
        fluxes is required by flux_node. WaterStorage overrides this, since
        state changes require an update of the fluxes. 
        """
        return _cmf_core.flux_node_RecalcFluxes(self, *args)

    def get_connection(self, *args):
        """
        get_connection(self, flux_node target) -> flux_connection

        cmf::water::flux_connection* get_connection(const
        cmf::water::flux_node &target)

        Returns the connection between this and target. 
        """
        return _cmf_core.flux_node_get_connection(self, *args)

    def remove_connection(self, *args):
        """
        remove_connection(self, ptr To) -> bool

        bool
        remove_connection(cmf::water::flux_node::ptr To)

        Remove the connection. 
        """
        return _cmf_core.flux_node_remove_connection(self, *args)

    def flux_to(self, *args):
        """
        flux_to(self, flux_node target, Time t) -> real

        real
        flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

        Returns the actual flux between this and target (positive sign means
        "from target into this"). 
        """
        return _cmf_core.flux_node_flux_to(self, *args)

    def flux3d_to(self, *args):
        """
        flux3d_to(self, flux_node target, Time t) -> point

        cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
        cmf::math::Time t) 
        """
        return _cmf_core.flux_node_flux3d_to(self, *args)

    def get_3d_flux(self, *args):
        """
        get_3d_flux(self, Time t) -> point

        cmf::geometry::point get_3d_flux(cmf::math::Time t) 
        """
        return _cmf_core.flux_node_get_3d_flux(self, *args)

    def water_balance(self, *args):
        """
        water_balance(self, Time t, flux_connection Without = None) -> real

        real
        water_balance(cmf::math::Time t, const flux_connection *Without=0)
        const

        Returns the sum of all fluxes (positive and negative) at time t.
        Single fluxes can be excluded from the calculation.

        Parameters:
        -----------

        t:  Time of the query

        Without:  A flux_connection that is excluded from the water_balance
        (e.g. to prevent closed circuits) 
        """
        return _cmf_core.flux_node_water_balance(self, *args)

    def conc(self, *args):
        """
        conc(self, Time t, solute Solute) -> real

        virtual real
        conc(cmf::math::Time t, const cmf::water::solute &solute) const

        Returns the water quality of the flux_node, if it is not overridden
        this is the mix of the incoming fluxes. 
        """
        return _cmf_core.flux_node_conc(self, *args)

    Location = _swig_property(_cmf_core.flux_node_Location_get, _cmf_core.flux_node_Location_set)
    def is_empty(self, *args):
        """
        is_empty(self) -> bool

        virtual bool
        is_empty() const 
        """
        return _cmf_core.flux_node_is_empty(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, project _project, point location = cmf::geometry::point()) -> flux_node

        flux_node(const cmf::project &_project, cmf::geometry::point
        location=cmf::geometry::point()) 
        """
        _cmf_core.flux_node_swiginit(self,_cmf_core.new_flux_node(*args))
    potential = _swig_property(_cmf_core.flux_node_potential_get, _cmf_core.flux_node_potential_set)
    connections = _swig_property(_cmf_core.flux_node_connections_get)
    def __repr__(self): return self.to_string()
    def fluxes(self,t):
        return [(con.q(self,t),con[self]) for con in self.connections]
    @property
    def connected_nodes(self):
        return [con[self] for con in self.connections]

flux_node.project = new_instancemethod(_cmf_core.flux_node_project,None,flux_node)
flux_node.is_storage = new_instancemethod(_cmf_core.flux_node_is_storage,None,flux_node)
flux_node.to_string = new_instancemethod(_cmf_core.flux_node_to_string,None,flux_node)
flux_node.__eq__ = new_instancemethod(_cmf_core.flux_node___eq__,None,flux_node)
flux_node.RecalcFluxes = new_instancemethod(_cmf_core.flux_node_RecalcFluxes,None,flux_node)
flux_node.get_connection = new_instancemethod(_cmf_core.flux_node_get_connection,None,flux_node)
flux_node.remove_connection = new_instancemethod(_cmf_core.flux_node_remove_connection,None,flux_node)
flux_node.flux_to = new_instancemethod(_cmf_core.flux_node_flux_to,None,flux_node)
flux_node.flux3d_to = new_instancemethod(_cmf_core.flux_node_flux3d_to,None,flux_node)
flux_node.get_3d_flux = new_instancemethod(_cmf_core.flux_node_get_3d_flux,None,flux_node)
flux_node.water_balance = new_instancemethod(_cmf_core.flux_node_water_balance,None,flux_node)
flux_node.conc = new_instancemethod(_cmf_core.flux_node_conc,None,flux_node)
flux_node.is_empty = new_instancemethod(_cmf_core.flux_node_is_empty,None,flux_node)
flux_node_swigregister = _cmf_core.flux_node_swigregister
flux_node_swigregister(flux_node)


def count_node_references(*args):
  """
    count_node_references(ptr node) -> int

    int
    cmf::water::count_node_references(flux_node::ptr node) 
    """
  return _cmf_core.count_node_references(*args)

def get_higher_node(*args):
  """
    get_higher_node(ptr node1, ptr node2) -> ptr

    flux_node::ptr
    cmf::water::get_higher_node(flux_node::ptr node1, flux_node::ptr
    node2) 
    """
  return _cmf_core.get_higher_node(*args)

def get_lower_node(*args):
  """
    get_lower_node(ptr node1, ptr node2) -> ptr

    flux_node::ptr
    cmf::water::get_lower_node(flux_node::ptr node1, flux_node::ptr node2)

    """
  return _cmf_core.get_lower_node(*args)
class flux_connection(object):
    """
    Represents a connection between flux_nodes, where water fluxes occur.

    C++ includes: flux_connection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def left_node(self, *args):
        """
        left_node(self) -> ptr

        flux_node::ptr left_node() const

        Returns the left node of this connection. 
        """
        return _cmf_core.flux_connection_left_node(self, *args)

    def right_node(self, *args):
        """
        right_node(self) -> ptr

        flux_node::ptr right_node() const

        returns the right node of this connection 
        """
        return _cmf_core.flux_connection_right_node(self, *args)

    def kill_me(self, *args):
        """
        kill_me(self) -> bool

        bool
        kill_me()

        Deregisters this connection from its nodes. Returns true if only one
        reference is left. 
        """
        return _cmf_core.flux_connection_kill_me(self, *args)

    connection_id = _swig_property(_cmf_core.flux_connection_connection_id_get)
    def __eq__(self, *args):
        """__eq__(self, flux_connection other) -> bool"""
        return _cmf_core.flux_connection___eq__(self, *args)

    def get_target(self, *args):
        """
        get_target(self, flux_node inquirer) -> ptr
        get_target(self, int index) -> ptr

        flux_node::ptr get_target(int index) const

        With index 0, the left node is returned, with index 1 the right node
        of the connection. 
        """
        return _cmf_core.flux_connection_get_target(self, *args)

    def exchange_target(self, *args):
        """
        exchange_target(self, ptr oldtarget, ptr newTarget)

        void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
        newTarget) 
        """
        return _cmf_core.flux_connection_exchange_target(self, *args)

    def q(self, *args):
        """
        q(self, flux_node inquirer, Time t) -> real

        real q(const
        flux_node &inquirer, cmf::math::Time t)

        Returns the current flux through a connection. Negative signs mean out
        of the inquirer, positive are inflows to the inquirer. 
        """
        return _cmf_core.flux_connection_q(self, *args)

    def conc(self, *args):
        """
        conc(self, Time t, solute _Solute) -> real

        real
        conc(cmf::math::Time t, const cmf::water::solute &solute)

        Returns the concentration of the flux. If not overridden, it returns
        the concentration of the source of the flux (direction depending). 
        """
        return _cmf_core.flux_connection_conc(self, *args)

    type = _swig_property(_cmf_core.flux_connection_type_get)
    def to_string(self, *args):
        """
        to_string(self) -> string

        std::string to_string() const 
        """
        return _cmf_core.flux_connection_to_string(self, *args)

    def short_string(self, *args):
        """
        short_string(self) -> string

        std::string short_string() const 
        """
        return _cmf_core.flux_connection_short_string(self, *args)

    __swig_destroy__ = _cmf_core.delete_flux_connection
    tracer_filter = _swig_property(_cmf_core.flux_connection_tracer_filter_get, _cmf_core.flux_connection_tracer_filter_set)
    def __repr__(self):
        return self.to_string()
    def __getitem__(self,index):
        return self.get_target(index)
    def __iter__(self):
        yield self.get_target(0)
        yield self.get_target(1)
    def __contains__(self,cmp):
        return cmp==self[0] or cmp==self[1]

flux_connection.left_node = new_instancemethod(_cmf_core.flux_connection_left_node,None,flux_connection)
flux_connection.right_node = new_instancemethod(_cmf_core.flux_connection_right_node,None,flux_connection)
flux_connection.kill_me = new_instancemethod(_cmf_core.flux_connection_kill_me,None,flux_connection)
flux_connection.__eq__ = new_instancemethod(_cmf_core.flux_connection___eq__,None,flux_connection)
flux_connection.get_target = new_instancemethod(_cmf_core.flux_connection_get_target,None,flux_connection)
flux_connection.exchange_target = new_instancemethod(_cmf_core.flux_connection_exchange_target,None,flux_connection)
flux_connection.q = new_instancemethod(_cmf_core.flux_connection_q,None,flux_connection)
flux_connection.conc = new_instancemethod(_cmf_core.flux_connection_conc,None,flux_connection)
flux_connection.to_string = new_instancemethod(_cmf_core.flux_connection_to_string,None,flux_connection)
flux_connection.short_string = new_instancemethod(_cmf_core.flux_connection_short_string,None,flux_connection)
flux_connection_swigregister = _cmf_core.flux_connection_swigregister
flux_connection_swigregister(flux_connection)


def replace_node(*args):
  """
    replace_node(ptr oldnode, ptr newnode)

    void
    cmf::water::replace_node(cmf::water::flux_node::ptr oldnode,
    cmf::water::flux_node::ptr newnode) 
    """
  return _cmf_core.replace_node(*args)
class waterbalance_connection(flux_connection):
    """Proxy of C++ cmf::water::waterbalance_connection class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr target) -> waterbalance_connection

        waterbalance_connection(flux_node::ptr source, flux_node::ptr target)

        """
        _cmf_core.waterbalance_connection_swiginit(self,_cmf_core.new_waterbalance_connection(*args))
    __swig_destroy__ = _cmf_core.delete_waterbalance_connection
waterbalance_connection_swigregister = _cmf_core.waterbalance_connection_swigregister
waterbalance_connection_swigregister(waterbalance_connection)

class linear_scale(object):
    """
    A linear scaling functor, with slope and displacement.

    C++ includes: boundary_condition.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    displacement = _swig_property(_cmf_core.linear_scale_displacement_get, _cmf_core.linear_scale_displacement_set)
    slope = _swig_property(_cmf_core.linear_scale_slope_get, _cmf_core.linear_scale_slope_set)
    def __call__(self, *args):
        """__call__(self, real value) -> real"""
        return _cmf_core.linear_scale___call__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real _slope = 1, real _displacement = 0) -> linear_scale

        linear_scale(real _slope=1, real _displacement=0)

        Creates a linear scale (by default it is a unity scale, $a=1; b=0$).

        """
        _cmf_core.linear_scale_swiginit(self,_cmf_core.new_linear_scale(*args))
    __swig_destroy__ = _cmf_core.delete_linear_scale
linear_scale.__call__ = new_instancemethod(_cmf_core.linear_scale___call__,None,linear_scale)
linear_scale_swigregister = _cmf_core.linear_scale_swigregister
linear_scale_swigregister(linear_scale)

class DricheletBoundary(flux_node):
    """
    Drichelet (constant head) boundary condition.

    This boundary condition can be used either as a pure sink boundary
    condition or as a conditional source / sink boundary condition. The
    constant head of the boundary condition is interpreted and handled by
    the connections of the boundary condition. Not head aware connections,
    should not be used, since they are ignoring the constant head.

    C++ includes: boundary_condition.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def set_conc(self, *args):
        """
        set_conc(self, solute _Solute, double value)

        virtual void set_conc(const cmf::water::solute &solute, double value)

        """
        return _cmf_core.DricheletBoundary_set_conc(self, *args)

    is_source = _swig_property(_cmf_core.DricheletBoundary_is_source_get, _cmf_core.DricheletBoundary_is_source_set)
    def RecalcFluxes(self, *args):
        """
        RecalcFluxes(self, Time t) -> bool

        virtual bool RecalcFluxes(cmf::math::Time t)

        Pure flux_nodes do not influence fluxes, therefore no recalculation of
        fluxes is required by flux_node. WaterStorage overrides this, since
        state changes require an update of the fluxes. 
        """
        return _cmf_core.DricheletBoundary_RecalcFluxes(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, project _p, real potential, point Location = cmf::geometry::point()) -> DricheletBoundary

        DricheletBoundary(const cmf::project &_p, real potential,
        cmf::geometry::point Location=cmf::geometry::point()) 
        """
        _cmf_core.DricheletBoundary_swiginit(self,_cmf_core.new_DricheletBoundary(*args))
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_6__ swigSharedPtrUpcast) -> __dummy_4__"""
        return _cmf_core.DricheletBoundary_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_DricheletBoundary
DricheletBoundary.set_conc = new_instancemethod(_cmf_core.DricheletBoundary_set_conc,None,DricheletBoundary)
DricheletBoundary.RecalcFluxes = new_instancemethod(_cmf_core.DricheletBoundary_RecalcFluxes,None,DricheletBoundary)
DricheletBoundary_swigregister = _cmf_core.DricheletBoundary_swigregister
DricheletBoundary_swigregister(DricheletBoundary)

def DricheletBoundary_SWIGSharedPtrUpcast(*args):
  """DricheletBoundary_SWIGSharedPtrUpcast(__dummy_6__ swigSharedPtrUpcast) -> __dummy_4__"""
  return _cmf_core.DricheletBoundary_SWIGSharedPtrUpcast(*args)

class NeumannBoundary(flux_node):
    """
    A Neumann boundary condition (constant flux boundary condition).

    The flux is a timeseries, but can be used as a scalar. To scale the
    timeseries to the specific conditions of this boundary condition the
    linear_scale flux_scale can be used.

    C++ includes: boundary_condition.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flux = _swig_property(_cmf_core.NeumannBoundary_flux_get, _cmf_core.NeumannBoundary_flux_set)
    flux_scale = _swig_property(_cmf_core.NeumannBoundary_flux_scale_get, _cmf_core.NeumannBoundary_flux_scale_set)
    concentration = _swig_property(_cmf_core.NeumannBoundary_concentration_get, _cmf_core.NeumannBoundary_concentration_set)
    def __call__(self, *args):
        """__call__(self, Time t) -> real"""
        return _cmf_core.NeumannBoundary___call__(self, *args)

    def connect_to(self, *args):
        """
        connect_to(self, ptr target)

        void
        connect_to(cmf::water::flux_node::ptr target) 
        """
        return _cmf_core.NeumannBoundary_connect_to(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, project _project, timeseries _flux, SoluteTimeseries _concentration = cmf::water::SoluteTimeseries(), 
            point loc = cmf::geometry::point()) -> NeumannBoundary
        __init__(self, project _project, point loc = cmf::geometry::point()) -> NeumannBoundary

        NeumannBoundary(const cmf::project &_project, cmf::geometry::point
        loc=cmf::geometry::point()) 
        """
        _cmf_core.NeumannBoundary_swiginit(self,_cmf_core.new_NeumannBoundary(*args))
    def create(*args):
        """create(ptr target) -> ptr"""
        return _cmf_core.NeumannBoundary_create(*args)

    create = staticmethod(create)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_8__ swigSharedPtrUpcast) -> __dummy_4__"""
        return _cmf_core.NeumannBoundary_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_NeumannBoundary
NeumannBoundary.__call__ = new_instancemethod(_cmf_core.NeumannBoundary___call__,None,NeumannBoundary)
NeumannBoundary.connect_to = new_instancemethod(_cmf_core.NeumannBoundary_connect_to,None,NeumannBoundary)
NeumannBoundary_swigregister = _cmf_core.NeumannBoundary_swigregister
NeumannBoundary_swigregister(NeumannBoundary)

def NeumannBoundary_create(*args):
  """NeumannBoundary_create(ptr target) -> ptr"""
  return _cmf_core.NeumannBoundary_create(*args)

def NeumannBoundary_SWIGSharedPtrUpcast(*args):
  """NeumannBoundary_SWIGSharedPtrUpcast(__dummy_8__ swigSharedPtrUpcast) -> __dummy_4__"""
  return _cmf_core.NeumannBoundary_SWIGSharedPtrUpcast(*args)

class NeumannFlux(flux_connection):
    """
    This flux_connection is created, when connecting a Neumann boundary
    condition with a state variable using Neumann::connect_to.

    C++ includes: boundary_condition.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, __dummy_8__ left, ptr right) -> NeumannFlux

        NeumannFlux(std::tr1::shared_ptr< NeumannBoundary > left,
        cmf::water::flux_node::ptr right) 
        """
        _cmf_core.NeumannFlux_swiginit(self,_cmf_core.new_NeumannFlux(*args))
    __swig_destroy__ = _cmf_core.delete_NeumannFlux
NeumannFlux_swigregister = _cmf_core.NeumannFlux_swigregister
NeumannFlux_swigregister(NeumannFlux)

class TechnicalFlux(flux_connection):
    """
    Produces a constant but changeable flux from a source to a target, if
    enough water is present in the source.

    (see Formula in C++ documentation)

    C++ includes: boundary_condition.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    MaxFlux = _swig_property(_cmf_core.TechnicalFlux_MaxFlux_get, _cmf_core.TechnicalFlux_MaxFlux_set)
    MinState = _swig_property(_cmf_core.TechnicalFlux_MinState_get, _cmf_core.TechnicalFlux_MinState_set)
    FluxDecreaseTime = _swig_property(_cmf_core.TechnicalFlux_FluxDecreaseTime_get, _cmf_core.TechnicalFlux_FluxDecreaseTime_set)
    def __init__(self, *args): 
        """
        __init__(self, __dummy_12__ source, __dummy_4__ target, real maximum_flux, 
            real minimal_state = 0, Time flux_decrease_time = h) -> TechnicalFlux

        TechnicalFlux(std::tr1::shared_ptr< cmf::water::WaterStorage >
        &source, std::tr1::shared_ptr< cmf::water::flux_node > target, real
        maximum_flux, real minimal_state=0, cmf::math::Time
        flux_decrease_time=cmf::math::h)

        Produces a constant but changeable flux from a source to a target, if
        enough water is present in the source.

        Parameters:
        -----------

        source:  The source of the water

        target:  The target of the water

        maximum_flux:  The requested flux (see Formula in C++ documentation)

        minimal_state:  Minimal volume of stored water in source

        flux_decrease_time:  ( cmf::math::Time) 
        """
        _cmf_core.TechnicalFlux_swiginit(self,_cmf_core.new_TechnicalFlux(*args))
    __swig_destroy__ = _cmf_core.delete_TechnicalFlux
TechnicalFlux_swigregister = _cmf_core.TechnicalFlux_swigregister
TechnicalFlux_swigregister(TechnicalFlux)

class WaterStorage(StateVariable,StateVariableOwner,flux_node):
    """
    A state variable for the storage of water.

    A class for the storage of water. The state is the volume of water
    stored in (see Formula in C++ documentation)  The derivative function
    is given by: (see Formula in C++ documentation)

    C++ includes: WaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, project _project, double InitialState = 0) -> WaterStorage

        WaterStorage(const cmf::project &_project, double InitialState=0)

        creates a water storage (abstract class) o

        Parameters:
        -----------

        _project:  The project the waterstorage belongs to

        InitialState:  Initial water content in m3 
        """
        _cmf_core.WaterStorage_swiginit(self,_cmf_core.new_WaterStorage(*args))
    def from_node(*args):
        """from_node(ptr node) -> __dummy_12__"""
        return _cmf_core.WaterStorage_from_node(*args)

    from_node = staticmethod(from_node)
    def Solute(self, *args):
        """
        Solute(self, solute _Solute) -> SoluteStorage
        Solute(self, solute _Solute) -> SoluteStorage

        const
        SoluteStorage& Solute(const cmf::water::solute &solute) const 
        """
        return _cmf_core.WaterStorage_Solute(self, *args)

    def conc(self, *args):
        """
        conc(self, solute _Solute) -> real
        conc(self, Time t, solute _Solute) -> real
        conc(self, solute _Solute, real NewConcetration)

        void
        conc(const cmf::water::solute &solute, real NewConcetration)

        Sets a new concentration. 
        """
        return _cmf_core.WaterStorage_conc(self, *args)

    def cast(*args):
        """cast(__dummy_4__ node) -> __dummy_12__"""
        return _cmf_core.WaterStorage_cast(*args)

    cast = staticmethod(cast)
    def create(*args):
        """create(project _project, real initial_state = 0.0) -> __dummy_12__"""
        return _cmf_core.WaterStorage_create(*args)

    create = staticmethod(create)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_12__ swigSharedPtrUpcast) -> __dummy_4__"""
        return _cmf_core.WaterStorage_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    volume = _swig_property(_cmf_core.WaterStorage_volume_get, _cmf_core.WaterStorage_volume_set)
    statevariable = _swig_property(_cmf_core.WaterStorage_statevariable_get, _cmf_core.WaterStorage_statevariable_set)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_WaterStorage
WaterStorage.Solute = new_instancemethod(_cmf_core.WaterStorage_Solute,None,WaterStorage)
WaterStorage.conc = new_instancemethod(_cmf_core.WaterStorage_conc,None,WaterStorage)
WaterStorage_swigregister = _cmf_core.WaterStorage_swigregister
WaterStorage_swigregister(WaterStorage)

def WaterStorage_from_node(*args):
  """WaterStorage_from_node(ptr node) -> __dummy_12__"""
  return _cmf_core.WaterStorage_from_node(*args)

def WaterStorage_cast(*args):
  """WaterStorage_cast(__dummy_4__ node) -> __dummy_12__"""
  return _cmf_core.WaterStorage_cast(*args)

def WaterStorage_create(*args):
  """WaterStorage_create(project _project, real initial_state = 0.0) -> __dummy_12__"""
  return _cmf_core.WaterStorage_create(*args)

def WaterStorage_SWIGSharedPtrUpcast(*args):
  """WaterStorage_SWIGSharedPtrUpcast(__dummy_12__ swigSharedPtrUpcast) -> __dummy_4__"""
  return _cmf_core.WaterStorage_SWIGSharedPtrUpcast(*args)

class storage_vector(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.storage_vector_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.storage_vector___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.storage_vector___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type"""
        return _cmf_core.storage_vector___len__(self, *args)

    def pop(self, *args):
        """pop(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type"""
        return _cmf_core.storage_vector_pop(self, *args)

    def __getslice__(self, *args):
        """
        __getslice__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type j) -> storage_vector
        """
        return _cmf_core.storage_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type j, 
            storage_vector v)
        """
        return _cmf_core.storage_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type j)
        """
        return _cmf_core.storage_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.storage_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> storage_vector
        __getitem__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type
        """
        return _cmf_core.storage_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, storage_vector v)
        __setitem__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)
        """
        return _cmf_core.storage_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)"""
        return _cmf_core.storage_vector_append(self, *args)

    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.storage_vector_empty(self, *args)

    def size(self, *args):
        """size(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type"""
        return _cmf_core.storage_vector_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.storage_vector_clear(self, *args)

    def swap(self, *args):
        """swap(self, storage_vector v)"""
        return _cmf_core.storage_vector_swap(self, *args)

    def get_allocator(self, *args):
        """get_allocator(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::allocator_type"""
        return _cmf_core.storage_vector_get_allocator(self, *args)

    def begin(self, *args):
        """begin(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::const_iterator"""
        return _cmf_core.storage_vector_begin(self, *args)

    def end(self, *args):
        """end(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::const_iterator"""
        return _cmf_core.storage_vector_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::const_reverse_iterator"""
        return _cmf_core.storage_vector_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::const_reverse_iterator"""
        return _cmf_core.storage_vector_rend(self, *args)

    def pop_back(self, *args):
        """pop_back(self)"""
        return _cmf_core.storage_vector_pop_back(self, *args)

    def erase(self, *args):
        """
        erase(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator pos) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator
        erase(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator first, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator last) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator
        """
        return _cmf_core.storage_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> storage_vector
        __init__(self, storage_vector arg0) -> storage_vector
        __init__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type size) -> storage_vector
        __init__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type size, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type value) -> storage_vector
        """
        _cmf_core.storage_vector_swiginit(self,_cmf_core.new_storage_vector(*args))
    def push_back(self, *args):
        """push_back(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)"""
        return _cmf_core.storage_vector_push_back(self, *args)

    def front(self, *args):
        """front(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type"""
        return _cmf_core.storage_vector_front(self, *args)

    def back(self, *args):
        """back(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type"""
        return _cmf_core.storage_vector_back(self, *args)

    def assign(self, *args):
        """
        assign(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type n, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)
        """
        return _cmf_core.storage_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type new_size)
        resize(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type new_size, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)
        """
        return _cmf_core.storage_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator pos, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator
        insert(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator pos, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type n, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)
        """
        return _cmf_core.storage_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type n)"""
        return _cmf_core.storage_vector_reserve(self, *args)

    def capacity(self, *args):
        """capacity(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type"""
        return _cmf_core.storage_vector_capacity(self, *args)

    __swig_destroy__ = _cmf_core.delete_storage_vector
storage_vector.iterator = new_instancemethod(_cmf_core.storage_vector_iterator,None,storage_vector)
storage_vector.__nonzero__ = new_instancemethod(_cmf_core.storage_vector___nonzero__,None,storage_vector)
storage_vector.__bool__ = new_instancemethod(_cmf_core.storage_vector___bool__,None,storage_vector)
storage_vector.__len__ = new_instancemethod(_cmf_core.storage_vector___len__,None,storage_vector)
storage_vector.pop = new_instancemethod(_cmf_core.storage_vector_pop,None,storage_vector)
storage_vector.__getslice__ = new_instancemethod(_cmf_core.storage_vector___getslice__,None,storage_vector)
storage_vector.__setslice__ = new_instancemethod(_cmf_core.storage_vector___setslice__,None,storage_vector)
storage_vector.__delslice__ = new_instancemethod(_cmf_core.storage_vector___delslice__,None,storage_vector)
storage_vector.__delitem__ = new_instancemethod(_cmf_core.storage_vector___delitem__,None,storage_vector)
storage_vector.__getitem__ = new_instancemethod(_cmf_core.storage_vector___getitem__,None,storage_vector)
storage_vector.__setitem__ = new_instancemethod(_cmf_core.storage_vector___setitem__,None,storage_vector)
storage_vector.append = new_instancemethod(_cmf_core.storage_vector_append,None,storage_vector)
storage_vector.empty = new_instancemethod(_cmf_core.storage_vector_empty,None,storage_vector)
storage_vector.size = new_instancemethod(_cmf_core.storage_vector_size,None,storage_vector)
storage_vector.clear = new_instancemethod(_cmf_core.storage_vector_clear,None,storage_vector)
storage_vector.swap = new_instancemethod(_cmf_core.storage_vector_swap,None,storage_vector)
storage_vector.get_allocator = new_instancemethod(_cmf_core.storage_vector_get_allocator,None,storage_vector)
storage_vector.begin = new_instancemethod(_cmf_core.storage_vector_begin,None,storage_vector)
storage_vector.end = new_instancemethod(_cmf_core.storage_vector_end,None,storage_vector)
storage_vector.rbegin = new_instancemethod(_cmf_core.storage_vector_rbegin,None,storage_vector)
storage_vector.rend = new_instancemethod(_cmf_core.storage_vector_rend,None,storage_vector)
storage_vector.pop_back = new_instancemethod(_cmf_core.storage_vector_pop_back,None,storage_vector)
storage_vector.erase = new_instancemethod(_cmf_core.storage_vector_erase,None,storage_vector)
storage_vector.push_back = new_instancemethod(_cmf_core.storage_vector_push_back,None,storage_vector)
storage_vector.front = new_instancemethod(_cmf_core.storage_vector_front,None,storage_vector)
storage_vector.back = new_instancemethod(_cmf_core.storage_vector_back,None,storage_vector)
storage_vector.assign = new_instancemethod(_cmf_core.storage_vector_assign,None,storage_vector)
storage_vector.resize = new_instancemethod(_cmf_core.storage_vector_resize,None,storage_vector)
storage_vector.insert = new_instancemethod(_cmf_core.storage_vector_insert,None,storage_vector)
storage_vector.reserve = new_instancemethod(_cmf_core.storage_vector_reserve,None,storage_vector)
storage_vector.capacity = new_instancemethod(_cmf_core.storage_vector_capacity,None,storage_vector)
storage_vector_swigregister = _cmf_core.storage_vector_swigregister
storage_vector_swigregister(storage_vector)

class node_list(StateVariableOwner):
    """
    A collection of nodes for fast access of the waterbalance.

    In setups with many storages and rather fast computations, the speed
    of data access for output generation can take a high portion of the
    total run time. To accelerate data access, one can use the node_list
    object

    C++ includes: collections.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def size(self, *args):
        """
        size(self) -> int

        int size() const

        The number of nodes. 
        """
        return _cmf_core.node_list_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> node_list
        __init__(self, node_list forcopy) -> node_list

        node_list(const node_list &forcopy)

        Copy the node_list. 
        """
        _cmf_core.node_list_swiginit(self,_cmf_core.new_node_list(*args))
    def __iadd__(self, *args):
        """__iadd__(self, node_list right) -> node_list"""
        return _cmf_core.node_list___iadd__(self, *args)

    def __add__(self, *args):
        """__add__(self, node_list right) -> node_list"""
        return _cmf_core.node_list___add__(self, *args)

    def get(self, *args):
        """
        get(self, int index) -> ptr
        get(self, int begin, int end, int step = 1) -> node_list

        node_list get(int
        begin, int end, int step=1) const

        Returns a slice of the node_list. 
        """
        return _cmf_core.node_list_get(self, *args)

    def append(self, *args):
        """
        append(self, ptr node)

        void
        append(flux_node::ptr node)

        Adds a flux node to the list. 
        """
        return _cmf_core.node_list_append(self, *args)

    def global_water_balance(self, *args):
        """
        global_water_balance(self, Time t) -> real

        real global_water_balance(cmf::math::Time t) const

        Returns the sum of the water balances of the nodes (see Formula in C++
        documentation) .

        Replaces slow Python code like: 
        """
        return _cmf_core.node_list_global_water_balance(self, *args)

    def water_balance(self, *args):
        """
        water_balance(self, Time t) -> num_array

        cmf::math::num_array water_balance(cmf::math::Time t) const

        Returns the water balance of each vector as a vector (see Formula in
        C++ documentation) .

        Replaces slow Python code like: 
        """
        return _cmf_core.node_list_water_balance(self, *args)

    def conc(self, *args):
        """
        conc(self, Time t, solute _Solute) -> num_array

        cmf::math::num_array conc(cmf::math::Time t, const cmf::water::solute
        &solute) const

        Returns an array holding the concentration of all the flux nodes for
        the given solute. 
        """
        return _cmf_core.node_list_conc(self, *args)

    def set_solute_source(self, *args):
        """
        set_solute_source(self, solute _Solute, num_array source_fluxes) -> int

        int
        set_solute_source(const cmf::water::solute &solute,
        cmf::math::num_array source_fluxes)

        Sets the source flux of a solute storage associated with a node (node
        has to be a water storage). 
        """
        return _cmf_core.node_list_set_solute_source(self, *args)

    def get_fluxes_to(self, *args):
        """
        get_fluxes_to(self, node_list targets, Time t) -> num_array

        cmf::math::num_array get_fluxes_to(const cmf::water::node_list
        &targets, cmf::math::Time t) const

        A fast method to perform flux queries as a batch. The node lists left
        and right should have the same length.

        The vector containing the flux from left to right at the same position

        Parameters:
        -----------

        targets:  A node_list containing the source nodes

        t:  The time for the fluxes

        Replaces slow Python code like: 
        """
        return _cmf_core.node_list_get_fluxes_to(self, *args)

    def get_fluxes3d_to(self, *args):
        """
        get_fluxes3d_to(self, node_list targets, Time t) -> point_vector

        cmf::geometry::point_vector get_fluxes3d_to(const
        cmf::water::node_list &targets, cmf::math::Time t) const

        Returns the flux vectors to the nodes of a given target node_list. 
        """
        return _cmf_core.node_list_get_fluxes3d_to(self, *args)

    def get_fluxes3d(self, *args):
        """
        get_fluxes3d(self, Time t) -> point_vector

        cmf::geometry::point_vector get_fluxes3d(cmf::math::Time t) const

        Returns the current flow vector for each node. 
        """
        return _cmf_core.node_list_get_fluxes3d(self, *args)

    def get_positions(self, *args):
        """
        get_positions(self) -> point_vector

        cmf::geometry::point_vector get_positions() const

        Returns the positions of the nodes. 
        """
        return _cmf_core.node_list_get_positions(self, *args)

    potentials = _swig_property(_cmf_core.node_list_potentials_get, _cmf_core.node_list_potentials_set)
    def __getitem__(self,index):
        return self.get(index)
    def __getslice__(self,slice):
        indices=slice.indices(self.size())
        return self.get(indices[0],indices[1],indices[2])
    def __len__(self):
        return self.size()       
    def __iter__(self):
        for i in xrange(self.size()):
            yield self[i]
    def extend(self,sequence):
        """Extends the node list with the sequence (any iterable will do) """
        for o in sequence:
            self.append(o)
    @staticmethod
    def from_sequence(sequence):
        """Returns a new node list populated from the sequence (any iterable will do) """
        nl=node_list()
        nl.extend(sequence)
        return nl

    __swig_destroy__ = _cmf_core.delete_node_list
node_list.size = new_instancemethod(_cmf_core.node_list_size,None,node_list)
node_list.__iadd__ = new_instancemethod(_cmf_core.node_list___iadd__,None,node_list)
node_list.__add__ = new_instancemethod(_cmf_core.node_list___add__,None,node_list)
node_list.get = new_instancemethod(_cmf_core.node_list_get,None,node_list)
node_list.append = new_instancemethod(_cmf_core.node_list_append,None,node_list)
node_list.global_water_balance = new_instancemethod(_cmf_core.node_list_global_water_balance,None,node_list)
node_list.water_balance = new_instancemethod(_cmf_core.node_list_water_balance,None,node_list)
node_list.conc = new_instancemethod(_cmf_core.node_list_conc,None,node_list)
node_list.set_solute_source = new_instancemethod(_cmf_core.node_list_set_solute_source,None,node_list)
node_list.get_fluxes_to = new_instancemethod(_cmf_core.node_list_get_fluxes_to,None,node_list)
node_list.get_fluxes3d_to = new_instancemethod(_cmf_core.node_list_get_fluxes3d_to,None,node_list)
node_list.get_fluxes3d = new_instancemethod(_cmf_core.node_list_get_fluxes3d,None,node_list)
node_list.get_positions = new_instancemethod(_cmf_core.node_list_get_positions,None,node_list)
node_list_swigregister = _cmf_core.node_list_swigregister
node_list_swigregister(node_list)

class NeumannBoundary_list(object):
    """
    If many Neumann boundary conditions are present in a project, a fast
    data exchange to update the fluxes might be needed.

    With this specialized list a num_array can be passed to the boundary
    conditions for a fast flux update If a multiple system layout for the
    cmf setup is chosen, we might have a node_list Drichelet boundary
    conditions (dbc), a corresponding NeumannBoundary_list (nbc) of
    Neumann boundaries and a node_list containing the storages connected
    with the NeumannBoundary_list (storages). The fast data exchange is
    written in Python as:

    C++ includes: collections.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get(self, *args):
        """
        get(self, int index) -> NeumannBoundary_ptr

        NeumannBoundary_ptr get(int index) const

        Returns the Neumann boundary condition at position index. 
        """
        return _cmf_core.NeumannBoundary_list_get(self, *args)

    def get_fluxes(self, *args):
        """
        get_fluxes(self, Time t = cmf::math::Time()) -> num_array

        cmf::math::num_array get_fluxes(cmf::math::Time t=cmf::math::Time())
        const

        Returns the fluxes of the items as an array. 
        """
        return _cmf_core.NeumannBoundary_list_get_fluxes(self, *args)

    def append(self, *args):
        """
        append(self, NeumannBoundary_ptr nbc)

        void
        append(NeumannBoundary_ptr nbc) 
        """
        return _cmf_core.NeumannBoundary_list_append(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t

        size_t
        size() const 
        """
        return _cmf_core.NeumannBoundary_list_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> NeumannBoundary_list
        __init__(self, node_list copy) -> NeumannBoundary_list
        __init__(self, NeumannBoundary_list copy) -> NeumannBoundary_list

        NeumannBoundary_list(const NeumannBoundary_list &copy) 
        """
        _cmf_core.NeumannBoundary_list_swiginit(self,_cmf_core.new_NeumannBoundary_list(*args))
    def to_node_list(self, *args):
        """
        to_node_list(self) -> node_list

        cmf::water::node_list to_node_list() const

        Creates a node_list from this NeumannBoundary_list. 
        """
        return _cmf_core.NeumannBoundary_list_to_node_list(self, *args)

    def global_water_balance(self, *args):
        """
        global_water_balance(self, Time t) -> real

        real
        global_water_balance(cmf::math::Time t) const

        Returns the sum of the water balances of the nodes (see Formula in C++
        documentation) .

        Replaces slow Python code like: 
        """
        return _cmf_core.NeumannBoundary_list_global_water_balance(self, *args)

    def water_balance(self, *args):
        """
        water_balance(self, Time t) -> num_array

        cmf::math::num_array water_balance(cmf::math::Time t) const

        Returns the water balance of each vector as a vector (see Formula in
        C++ documentation) .

        Replaces slow Python code like: 
        """
        return _cmf_core.NeumannBoundary_list_water_balance(self, *args)

    fluxes = _swig_property(_cmf_core.NeumannBoundary_list_fluxes_get, _cmf_core.NeumannBoundary_list_fluxes_set)
    def __getitem__(self,index):
        return self.get(index)
    def __len__(self):
        return self.size()       
    def __iter__(self):
        for i in xrange(self.size()):
            yield self[i]
    def extend(self,sequence):
        """Extends the list of Neumann boundaries with the sequence (any iterable will do) """
        for o in sequence:
            self.append(o)
    @staticmethod
    def from_sequence(sequence):
        """Returns a new list of Neumann boundaries populated from the sequence (any iterable will do) """
        nl=NeumannBoundary_list()
        nl.extend(sequence)
        return nl

    __swig_destroy__ = _cmf_core.delete_NeumannBoundary_list
NeumannBoundary_list.get = new_instancemethod(_cmf_core.NeumannBoundary_list_get,None,NeumannBoundary_list)
NeumannBoundary_list.get_fluxes = new_instancemethod(_cmf_core.NeumannBoundary_list_get_fluxes,None,NeumannBoundary_list)
NeumannBoundary_list.append = new_instancemethod(_cmf_core.NeumannBoundary_list_append,None,NeumannBoundary_list)
NeumannBoundary_list.size = new_instancemethod(_cmf_core.NeumannBoundary_list_size,None,NeumannBoundary_list)
NeumannBoundary_list.to_node_list = new_instancemethod(_cmf_core.NeumannBoundary_list_to_node_list,None,NeumannBoundary_list)
NeumannBoundary_list.global_water_balance = new_instancemethod(_cmf_core.NeumannBoundary_list_global_water_balance,None,NeumannBoundary_list)
NeumannBoundary_list.water_balance = new_instancemethod(_cmf_core.NeumannBoundary_list_water_balance,None,NeumannBoundary_list)
NeumannBoundary_list_swigregister = _cmf_core.NeumannBoundary_list_swigregister
NeumannBoundary_list_swigregister(NeumannBoundary_list)


def vapour_pressure(*args):
  """
    vapour_pressure(double T) -> double

    double
    cmf::atmosphere::vapour_pressure(double T) 
    """
  return _cmf_core.vapour_pressure(*args)

def vpd_from_rH(*args):
  """vpd_from_rH(double T, double rH) -> double"""
  return _cmf_core.vpd_from_rH(*args)

def rH_from_vpd(*args):
  """rH_from_vpd(double T, double vpd) -> double"""
  return _cmf_core.rH_from_vpd(*args)

def global_radiation(*args):
  """
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8, 
        double latitude = 51, double time_zone = 1, 
        bool daily = 0) -> double

    double
    cmf::atmosphere::global_radiation(cmf::math::Time t, double height,
    double sunshine_fraction, double longitude=8, double latitude=51, int
    time_zone=1, bool daily=0) 
    """
  return _cmf_core.global_radiation(*args)

def Pressure(*args):
  """
    Pressure(double height) -> double

    double
    cmf::atmosphere::Pressure(double height) 
    """
  return _cmf_core.Pressure(*args)
class Weather(object):
    """
    A structure holding meteorological information, excluding
    precipitation.

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    T = _swig_property(_cmf_core.Weather_T_get, _cmf_core.Weather_T_set)
    Tmax = _swig_property(_cmf_core.Weather_Tmax_get, _cmf_core.Weather_Tmax_set)
    Tmin = _swig_property(_cmf_core.Weather_Tmin_get, _cmf_core.Weather_Tmin_set)
    Tground = _swig_property(_cmf_core.Weather_Tground_get, _cmf_core.Weather_Tground_set)
    Windspeed = _swig_property(_cmf_core.Weather_Windspeed_get, _cmf_core.Weather_Windspeed_set)
    e_a = _swig_property(_cmf_core.Weather_e_a_get, _cmf_core.Weather_e_a_set)
    e_s = _swig_property(_cmf_core.Weather_e_s_get, _cmf_core.Weather_e_s_set)
    sunshine = _swig_property(_cmf_core.Weather_sunshine_get, _cmf_core.Weather_sunshine_set)
    Rs = _swig_property(_cmf_core.Weather_Rs_get, _cmf_core.Weather_Rs_set)
    instument_height = _swig_property(_cmf_core.Weather_instument_height_get, _cmf_core.Weather_instument_height_set)
    def Rn(self, *args):
        """
        Rn(self, double albedo, bool daily = False) -> double

        double Rn(double
        albedo, bool daily=false) const

        Calculates the net radiation flux (see Formula in C++ documentation) .

        (see Formula in C++ documentation)

        Parameters:
        -----------

        albedo:  the albedo (see Formula in C++ documentation)  of the surface

        daily:  If true, the net radiation for daily averages will be
        calculated 
        """
        return _cmf_core.Weather_Rn(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Weather
        __init__(self, double _T, double _Tmax, double _Tmin, double _rH, 
            double _wind = 2, double _sunshine = 0.5, double _Rs = 15) -> Weather

        Weather()

        Calculates the mean pressure for a specific height. 
        """
        _cmf_core.Weather_swiginit(self,_cmf_core.new_Weather(*args))
    def to_string(self, *args):
        """
        to_string(self) -> string

        std::string to_string() const 
        """
        return _cmf_core.Weather_to_string(self, *args)

    snow_threshold = _swig_property(_cmf_core.Weather_snow_threshold_get, _cmf_core.Weather_snow_threshold_set)
    def __repr__(self):
        return "cmf.Weather()"
    def __str__(self):
        return "Weather: T(max/min)=%6.2f(%3.0f/%3.0f), Rs=%7.2f, rH=%3.0f%%" % (self.T,self.Tmin,self.Tmax,self.Rs,100*self.e_a/self.e_s)

    __swig_destroy__ = _cmf_core.delete_Weather
Weather.Rn = new_instancemethod(_cmf_core.Weather_Rn,None,Weather)
Weather.to_string = new_instancemethod(_cmf_core.Weather_to_string,None,Weather)
Weather_swigregister = _cmf_core.Weather_swigregister
Weather_swigregister(Weather)

class Meteorology(object):
    """
    An abstract class, for objects generating Weather records at a
    sepcific time.

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(self, Time t) -> Weather"""
        return _cmf_core.Meteorology___call__(self, *args)

    def get_weather(self, *args):
        """
        get_weather(self, Time t) -> Weather

        virtual cmf::atmosphere::Weather get_weather(cmf::math::Time t) const
        =0

        Returns the Weather at time t. Pure virtual function. Must get
        implemented by child functions. 
        """
        return _cmf_core.Meteorology_get_weather(self, *args)

    def copy(self, *args):
        """
        copy(self) -> Meteorology

        virtual
        Meteorology* copy() const =0

        Returns a copy of the meteorology object. Pure virtual function, needs
        to be implemented. 
        """
        return _cmf_core.Meteorology_copy(self, *args)

    def get_instrument_height(self, *args):
        """
        get_instrument_height(self) -> real

        virtual real
        get_instrument_height() const =0 
        """
        return _cmf_core.Meteorology_get_instrument_height(self, *args)

    __swig_destroy__ = _cmf_core.delete_Meteorology
Meteorology.__call__ = new_instancemethod(_cmf_core.Meteorology___call__,None,Meteorology)
Meteorology.get_weather = new_instancemethod(_cmf_core.Meteorology_get_weather,None,Meteorology)
Meteorology.copy = new_instancemethod(_cmf_core.Meteorology_copy,None,Meteorology)
Meteorology.get_instrument_height = new_instancemethod(_cmf_core.Meteorology_get_instrument_height,None,Meteorology)
Meteorology_swigregister = _cmf_core.Meteorology_swigregister
Meteorology_swigregister(Meteorology)

class ConstantMeteorology(Meteorology):
    """
    A primitive implementation of the Meteorology interface. Holds a
    Weather record and returns it for any date.

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    weather = _swig_property(_cmf_core.ConstantMeteorology_weather_get, _cmf_core.ConstantMeteorology_weather_set)
    def __init__(self, *args): 
        """
        __init__(self) -> ConstantMeteorology
        __init__(self, Weather w) -> ConstantMeteorology
        __init__(self, ConstantMeteorology other) -> ConstantMeteorology

        ConstantMeteorology(const cmf::atmosphere::ConstantMeteorology &other)

        """
        _cmf_core.ConstantMeteorology_swiginit(self,_cmf_core.new_ConstantMeteorology(*args))
    def copy(self, *args):
        """
        copy(self) -> ConstantMeteorology

        ConstantMeteorology* copy() const

        Creates a new instannce of the ConstantMeteorology with the same
        weather. 
        """
        return _cmf_core.ConstantMeteorology_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_ConstantMeteorology
ConstantMeteorology.copy = new_instancemethod(_cmf_core.ConstantMeteorology_copy,None,ConstantMeteorology)
ConstantMeteorology_swigregister = _cmf_core.ConstantMeteorology_swigregister
ConstantMeteorology_swigregister(ConstantMeteorology)

class MeteoStation(Locatable):
    """
    A meteorological station holding timeseries to create Weather records.

    In order to calculate ETpot with cmf a big amount of meteorological
    data is needed, more data than usually available. The MeteoStation
    class can estimate missing data from a minimal set. As more data, as
    one provides, the better the calculation of ETpot becomes. The minimal
    data needed is Tmin and Tmax (daily) and precipitation. To calculate
    the global radiation (although measured global radiation could be
    inserted), the position of meteorological station in geographic
    coordinates has to be set.

    There are two modes for the meteorology: daily=true and daily=false.
    If daily=true, Radiation is given as a daily mean value. If
    daily=false, Radiation is given as an hourly mean value, which shows
    the dial ETpot variation but results in erronous results if the
    timestep is daily.

    In the following, we will assume a meteorological station with given
    Tmin, Tmax, precipitation and daily mean relative humidity. To use
    other meteorological data, please consult the description of the
    MeteoStation class in the API documentationCreating a meteorological
    station

    import CMFlib as cmf                  latitude=51.2 # Latitude of
    station in decimal degrees                  longitude=8.1 # Longitude
    of station in decimal degrees (only needed for daily=false) timezone=1
    # Timezone, pos. values mean east of GMT, negative west (Germany=1,
    Pacific time=-8, only needed for daily=false) start=cmf.Time(1,1,2001)
    # Creates all timeseries with this start time, one can change them
    later                  step=cmf.day # s. start
    name="Giessen"           # A name for the station (optional)
    meteo=cmf.MeteoStation(latitude,longitude,timezone,start,step,name)

    The daily flag is automatically set to true, since the step width is
    &ge cmf.dayLoading data into the meteorological station

    # MeteoData.txt is tab seperated file containing # Tmin [deg C],Tmax
    [deg C],rHmean [%] and precipitation [mm/day] values for every day
    f=file('MeteoData.txt') for line in file:
    meteo.Tmin.Add(float(line.split('\\t')[0]))
    meteo.Tmax.Add(float(line.split('\\t')[1]))
    meteo.rHmean.Add(float(line.split('\\t')[2]))
    meteo.Prec.Add(float(line.split('\\t')[3]))Using a meteorological
    station

    weather=meteo.get_data(cmf.Time(3,2,2009,14)) # Weather at Feb. 3rd,
    2009, 2pm                  print 'Global Radiation: ',weather.Rs
    # Daily mean Rs, since daily=true print 'Temperature:',weather.T
    # Daily mean T, since nothing else in known

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Latitude = _swig_property(_cmf_core.MeteoStation_Latitude_get, _cmf_core.MeteoStation_Latitude_set)
    Longitude = _swig_property(_cmf_core.MeteoStation_Longitude_get, _cmf_core.MeteoStation_Longitude_set)
    Timezone = _swig_property(_cmf_core.MeteoStation_Timezone_get, _cmf_core.MeteoStation_Timezone_set)
    x = _swig_property(_cmf_core.MeteoStation_x_get, _cmf_core.MeteoStation_x_set)
    y = _swig_property(_cmf_core.MeteoStation_y_get, _cmf_core.MeteoStation_y_set)
    z = _swig_property(_cmf_core.MeteoStation_z_get, _cmf_core.MeteoStation_z_set)
    Name = _swig_property(_cmf_core.MeteoStation_Name_get, _cmf_core.MeteoStation_Name_set)
    daily = _swig_property(_cmf_core.MeteoStation_daily_get, _cmf_core.MeteoStation_daily_set)
    InstrumentHeight = _swig_property(_cmf_core.MeteoStation_InstrumentHeight_get, _cmf_core.MeteoStation_InstrumentHeight_set)
    def __init__(self, *args): 
        """
        __init__(self, MeteoStation other) -> MeteoStation

        MeteoStation(const cmf::atmosphere::MeteoStation &other) 
        """
        _cmf_core.MeteoStation_swiginit(self,_cmf_core.new_MeteoStation(*args))
    def get_data(self, *args):
        """
        get_data(self, Time t, double height) -> Weather

        cmf::atmosphere::Weather get_data(cmf::math::Time t, double height)
        const

        Returns the current Atmosphere state. Uses default values for missing
        timeseries. 
        """
        return _cmf_core.MeteoStation_get_data(self, *args)

    def SetSunshineFraction(self, *args):
        """
        SetSunshineFraction(self, timeseries sunshine_duration)

        void
        SetSunshineFraction(cmf::math::timeseries sunshine_duration)

        Returns the global radiation at a given time step (see Formula in C++
        documentation) ,
        seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation (see
        Formula in C++ documentation)  double
        get_global_radiation(cmf::math::Time t,double height,double
        sunshine_fraction) const;.

        Calculates a timeseries of the sunshine fraction (to put into
        Sunshine) from a timeseries of absolute sunshine duration, using the
        potential sunshine duration in hours,
        seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation (see
        Formula in C++ documentation)  
        """
        return _cmf_core.MeteoStation_SetSunshineFraction(self, *args)

    T = _swig_property(_cmf_core.MeteoStation_T_get, _cmf_core.MeteoStation_T_set)
    Tmax = _swig_property(_cmf_core.MeteoStation_Tmax_get, _cmf_core.MeteoStation_Tmax_set)
    Tmin = _swig_property(_cmf_core.MeteoStation_Tmin_get, _cmf_core.MeteoStation_Tmin_set)
    Tground = _swig_property(_cmf_core.MeteoStation_Tground_get, _cmf_core.MeteoStation_Tground_set)
    Windspeed = _swig_property(_cmf_core.MeteoStation_Windspeed_get, _cmf_core.MeteoStation_Windspeed_set)
    rHmean = _swig_property(_cmf_core.MeteoStation_rHmean_get, _cmf_core.MeteoStation_rHmean_set)
    rHmin = _swig_property(_cmf_core.MeteoStation_rHmin_get, _cmf_core.MeteoStation_rHmin_set)
    rHmax = _swig_property(_cmf_core.MeteoStation_rHmax_get, _cmf_core.MeteoStation_rHmax_set)
    Tdew = _swig_property(_cmf_core.MeteoStation_Tdew_get, _cmf_core.MeteoStation_Tdew_set)
    Sunshine = _swig_property(_cmf_core.MeteoStation_Sunshine_get, _cmf_core.MeteoStation_Sunshine_set)
    Rs = _swig_property(_cmf_core.MeteoStation_Rs_get, _cmf_core.MeteoStation_Rs_set)
    T_lapse = _swig_property(_cmf_core.MeteoStation_T_lapse_get, _cmf_core.MeteoStation_T_lapse_set)
    def TimeseriesDictionary(self):
        return {"Tmin":self.Tmin,
                "Tmax":self.Tmax,
                "Tdew":self.Tdew,
                "T":self.T,
                "rHmean":self.rHmean,
                "rHmax":self.rHmax,
                "rHmin":self.rHmin,
                "Sunshine":self.Sunshine,
                "Windspeed":self.Windspeed,
                "Rs" : self.Rs}
    def __repr__(self):
        return "cmf.MeteoStation(%s,lat=%0.5g,lon=%0.5g,z=%6.1f)" % (self.Name,self.Latitude,self.Longitude,self.z)

    __swig_destroy__ = _cmf_core.delete_MeteoStation
MeteoStation.get_data = new_instancemethod(_cmf_core.MeteoStation_get_data,None,MeteoStation)
MeteoStation.SetSunshineFraction = new_instancemethod(_cmf_core.MeteoStation_SetSunshineFraction,None,MeteoStation)
MeteoStation_swigregister = _cmf_core.MeteoStation_swigregister
MeteoStation_swigregister(MeteoStation)

class MeteoStationReference(Meteorology,Locatable):
    """
    A reference to a meteorological station. Returns the weather at a
    given time for its place using MeteoStation::T_lapse.

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get_station(self, *args):
        """
        get_station(self) -> ptr

        meteo_station_pointer get_station() const

        Returns the station referenced. 
        """
        return _cmf_core.MeteoStationReference_get_station(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, ptr station, Locatable location) -> MeteoStationReference
        __init__(self, ptr station, point location) -> MeteoStationReference
        __init__(self, MeteoStationReference copy) -> MeteoStationReference

        MeteoStationReference(const MeteoStationReference &copy) 
        """
        _cmf_core.MeteoStationReference_swiginit(self,_cmf_core.new_MeteoStationReference(*args))
    def copy(self, *args):
        """
        copy(self) -> MeteoStationReference

        MeteoStationReference* copy() const

        Returns a copy of the meteorology object. Pure virtual function, needs
        to be implemented. 
        """
        return _cmf_core.MeteoStationReference_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_MeteoStationReference
MeteoStationReference.get_station = new_instancemethod(_cmf_core.MeteoStationReference_get_station,None,MeteoStationReference)
MeteoStationReference.copy = new_instancemethod(_cmf_core.MeteoStationReference_copy,None,MeteoStationReference)
MeteoStationReference_swigregister = _cmf_core.MeteoStationReference_swigregister
MeteoStationReference_swigregister(MeteoStationReference)

class MeteoStationList(object):
    """
    A list of meteorological stations.

    Can find the nearest station for a position and calculate the
    temperature lapse

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __len__(self, *args):
        """
        __len__(self) -> int

        int
        size() const

        Returns the number of stations. 
        """
        return _cmf_core.MeteoStationList___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, int index) -> ptr
        __getitem__(self, string Name) -> ptr
        """
        return _cmf_core.MeteoStationList___getitem__(self, *args)

    def calculate_Temp_lapse(self, *args):
        """
        calculate_Temp_lapse(self, Time begin, Time step, Time end) -> double

        double
        calculate_Temp_lapse(cmf::math::Time begin, cmf::math::Time step,
        cmf::math::Time end)

        Calculates the temperature lapse from all stations in the list and
        sets the T_lapse attribute of each station.

        Returns the average lapse over the whole period. 
        """
        return _cmf_core.MeteoStationList_calculate_Temp_lapse(self, *args)

    def add_station(self, *args):
        """
        add_station(self, string name, double latitude = 51, double longitude = 8, 
            double timezone = 1, double elevation = 0, 
            Time startTime = cmf::math::Time(1,1,2001), 
            Time timestep = day) -> ptr
        add_station(self, string name, point position, double latitude = 51, 
            double longitude = 8, double timezone = 1, Time startTime = cmf::math::Time(1,1,2001), 
            Time timestep = day) -> ptr

        meteo_station_pointer add_station(std::string name,
        cmf::geometry::point position, double latitude=51, double longitude=8,
        double timezone=1, cmf::math::Time startTime=cmf::math::Time(1, 1,
        2001), cmf::math::Time timestep=cmf::math::day)

        Creates a meteorological station at a certain position and adds it to
        the list.

        Parameters:
        -----------

        name:  Name of the station

        position:  The location of the station in map coordinates

        latitude:  Latitude of the study area (for solar radiation)

        longitude:  Longitude of the study area (for solar time)

        timezone:  Time zone of the study area (e.g Germany +1,U.S. Pacific
        time -8

        startTime:  Date of the beginning of the climatic data (may be changed
        for each time series later)

        timestep:  Frequency of climatic data (may be changed for each time
        series later) 
        """
        return _cmf_core.MeteoStationList_add_station(self, *args)

    def remove_station(self, *args):
        """
        remove_station(self, int index) -> int

        int
        remove_station(int index)

        Removes a station and returns the number of remaining references to
        the removed station. If the station is deleted, 0 is returned. 
        """
        return _cmf_core.MeteoStationList_remove_station(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> MeteoStationList
        __init__(self, MeteoStationList copy) -> MeteoStationList

        MeteoStationList(const MeteoStationList &copy) 
        """
        _cmf_core.MeteoStationList_swiginit(self,_cmf_core.new_MeteoStationList(*args))
    def reference_to_nearest(self, *args):
        """
        reference_to_nearest(self, Locatable position, double z_weight = 0) -> MeteoStationReference

        MeteoStationReference reference_to_nearest(const
        cmf::geometry::Locatable &position, double z_weight=0) const

        Creates a MeteoStationReference from the nearest station to position
        at position.

        The distance is calculated as (see Formula in C++ documentation)
        Where (see Formula in C++ documentation)  is the station and (see
        Formula in C++ documentation)  is the locatable A Meteorology using
        the data of the nearest station to position

        Parameters:
        -----------

        position:  The position (any locatable, like e.g. Cell possible) to
        look for the station. The reference should be owned by the locatable

        z_weight:  The weight of the height difference (see Formula in C++
        documentation)  
        """
        return _cmf_core.MeteoStationList_reference_to_nearest(self, *args)

    def __iter__(self):
        for i in xrange(len(self)):
            yield self[i]
    def __repr__(self):
        return "list of %i cmf meteorological stations" % len(self)

    __swig_destroy__ = _cmf_core.delete_MeteoStationList
MeteoStationList.__len__ = new_instancemethod(_cmf_core.MeteoStationList___len__,None,MeteoStationList)
MeteoStationList.__getitem__ = new_instancemethod(_cmf_core.MeteoStationList___getitem__,None,MeteoStationList)
MeteoStationList.calculate_Temp_lapse = new_instancemethod(_cmf_core.MeteoStationList_calculate_Temp_lapse,None,MeteoStationList)
MeteoStationList.add_station = new_instancemethod(_cmf_core.MeteoStationList_add_station,None,MeteoStationList)
MeteoStationList.remove_station = new_instancemethod(_cmf_core.MeteoStationList_remove_station,None,MeteoStationList)
MeteoStationList.reference_to_nearest = new_instancemethod(_cmf_core.MeteoStationList_reference_to_nearest,None,MeteoStationList)
MeteoStationList_swigregister = _cmf_core.MeteoStationList_swigregister
MeteoStationList_swigregister(MeteoStationList)

class RainCloud(NeumannBoundary):
    """
    RainCloud is a specialization of NeumannBoundary . The only difference
    is a reference to the owning cell and the unit conversion of the flux
    timeseries from mm/day to m3/day.

    C++ includes: Precipitation.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get_cell(self, *args):
        """
        get_cell(self) -> Cell

        const
        cmf::upslope::Cell& get_cell() const 
        """
        return _cmf_core.RainCloud_get_cell(self, *args)

    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_10__ swigSharedPtrUpcast) -> __dummy_8__"""
        return _cmf_core.RainCloud_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_RainCloud
RainCloud.get_cell = new_instancemethod(_cmf_core.RainCloud_get_cell,None,RainCloud)
RainCloud_swigregister = _cmf_core.RainCloud_swigregister
RainCloud_swigregister(RainCloud)

def RainCloud_SWIGSharedPtrUpcast(*args):
  """RainCloud_SWIGSharedPtrUpcast(__dummy_10__ swigSharedPtrUpcast) -> __dummy_8__"""
  return _cmf_core.RainCloud_SWIGSharedPtrUpcast(*args)

class _cell_object_list:
    def __init__(self,c,kind):
        self.c=c
        self.kind=kind
    def __get(self,index):
        if self.kind=="L":
            return self.c.get_layer(index)
        elif self.kind=="S":
            return self.c.get_storage(index)
        else:
             ndx=index if index>=0 else self.c.storage_count()+self.c.layer_count()+index
             lndx=index-self.c.storage_count()
             if lndx<0:
                 return self.c.get_storage(ndx)
             else:
                 return self.c.get_layer(lndx)
    def __getitem__(self,index):
        if (type(index)==slice):
             return [self.__get(i) for i in range(*index.indices(len(self)))]
        try:
             gen=iter(index)
             return [self.__get(it) for it in gen]
        except TypeError:
             return self.__get(index)
    def find_by_name(self,name):
        for s in self:
            if s.Name==name:
                return s
        raise IndexError("No storage %s in %s of %s" % (name,"layers" if self.kind=='L' else "non layer storages" if self.kind=='S' else "storages",self.c))
    def __len__(self):
        return self.c.layer_count() if self.kind=='L' else (self.c.storage_count() if self.kind=='S' else self.c.layer_count()+self.c.storage_count())
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

class Vegetation(object):
    """
    Holds the vegetation parameters for the calculation of ET and
    fractionating rainfall. Not every ET method uses all parameters.

    C++ includes: StructVegetation.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LAI = _swig_property(_cmf_core.Vegetation_LAI_get, _cmf_core.Vegetation_LAI_set)
    Height = _swig_property(_cmf_core.Vegetation_Height_get, _cmf_core.Vegetation_Height_set)
    albedo = _swig_property(_cmf_core.Vegetation_albedo_get, _cmf_core.Vegetation_albedo_set)
    CanopyCapacityPerLAI = _swig_property(_cmf_core.Vegetation_CanopyCapacityPerLAI_get, _cmf_core.Vegetation_CanopyCapacityPerLAI_set)
    RootDepth = _swig_property(_cmf_core.Vegetation_RootDepth_get, _cmf_core.Vegetation_RootDepth_set)
    fraction_at_rootdepth = _swig_property(_cmf_core.Vegetation_fraction_at_rootdepth_get, _cmf_core.Vegetation_fraction_at_rootdepth_set)
    StomatalResistance = _swig_property(_cmf_core.Vegetation_StomatalResistance_get, _cmf_core.Vegetation_StomatalResistance_set)
    CanopyClosure = _swig_property(_cmf_core.Vegetation_CanopyClosure_get, _cmf_core.Vegetation_CanopyClosure_set)
    LeafWidth = _swig_property(_cmf_core.Vegetation_LeafWidth_get, _cmf_core.Vegetation_LeafWidth_set)
    def RootFraction(self, *args):
        """
        RootFraction(self, double upperBoundary, double lowerBoundary) -> double

        virtual double
        RootFraction(double upperBoundary, double lowerBoundary) const 
        """
        return _cmf_core.Vegetation_RootFraction(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double _LAI = 2.88, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23, double _CanopyClosure = 1, 
            double _CanopyCapacityPerLAI = 0.1, 
            double _fraction_at_rootdepth = 1.0) -> Vegetation

        Vegetation(double
        _LAI=2.88, double _Height=0.12, double _RootDepth=0.25, double
        _StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
        double _CanopyCapacityPerLAI=0.1, double _fraction_at_rootdepth=1.0)

        """
        _cmf_core.Vegetation_swiginit(self,_cmf_core.new_Vegetation(*args))
    __swig_destroy__ = _cmf_core.delete_Vegetation
Vegetation.RootFraction = new_instancemethod(_cmf_core.Vegetation_RootFraction,None,Vegetation)
Vegetation_swigregister = _cmf_core.Vegetation_swigregister
Vegetation_swigregister(Vegetation)

class CellConnector(object):
    """
    A helper class to connect cells with flux_connection objects. This is
    generated by flux_connection classes, intended to connect cells.

    C++ includes: cell.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def connect(self, *args):
        """
        connect(self, Cell cell1, Cell cell2, int start_at_layer = 0)

        void
        connect(cmf::upslope::Cell &cell1, cmf::upslope::Cell &cell2, int
        start_at_layer=0) const 
        """
        return _cmf_core.CellConnector_connect(self, *args)

    __swig_destroy__ = _cmf_core.delete_CellConnector
CellConnector.connect = new_instancemethod(_cmf_core.CellConnector_connect,None,CellConnector)
CellConnector_swigregister = _cmf_core.CellConnector_swigregister
CellConnector_swigregister(CellConnector)

class Cell(StateVariableOwner,Locatable):
    """
    This class is the basic landscape object. It is the owner of water
    storages, and the upper and lower boundary conditions of the system
    (rainfall, atmospheric vapor, deep groundwater).

    C++ includes: cell.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_cmf_core.Cell_x_get, _cmf_core.Cell_x_set)
    y = _swig_property(_cmf_core.Cell_y_get, _cmf_core.Cell_y_set)
    z = _swig_property(_cmf_core.Cell_z_get, _cmf_core.Cell_z_set)
    def get_area(self, *args):
        """
        get_area(self) -> double

        double
        get_area() const

        Returns the area of the cell. 
        """
        return _cmf_core.Cell_get_area(self, *args)

    def InvalidateSatDepth(self, *args):
        """
        InvalidateSatDepth(self)

        void
        InvalidateSatDepth()

        Marks the saturated depth as unvalid. 
        """
        return _cmf_core.Cell_InvalidateSatDepth(self, *args)

    def get_saturated_depth(self, *args):
        """
        get_saturated_depth(self) -> real

        real
        get_saturated_depth() 
        """
        return _cmf_core.Cell_get_saturated_depth(self, *args)

    def set_saturated_depth(self, *args):
        """
        set_saturated_depth(self, real depth)

        void
        set_saturated_depth(real depth) 
        """
        return _cmf_core.Cell_set_saturated_depth(self, *args)

    def set_weather(self, *args):
        """set_weather(self, Weather weather)"""
        return _cmf_core.Cell_set_weather(self, *args)

    def set_rainfall(self, *args):
        """set_rainfall(self, double rainfall)"""
        return _cmf_core.Cell_set_rainfall(self, *args)

    def get_surfacewater(self, *args):
        """
        get_surfacewater(self) -> ptr

        cmf::water::flux_node::ptr get_surfacewater()

        returns the surface water of this cell 
        """
        return _cmf_core.Cell_get_surfacewater(self, *args)

    def surfacewater_as_storage(self, *args):
        """
        surfacewater_as_storage(self)

        void surfacewater_as_storage() 
        """
        return _cmf_core.Cell_surfacewater_as_storage(self, *args)

    def add_storage(self, *args):
        """
        add_storage(self, string Name, char storage_role = 'N', bool isopenwater = False) -> ptr

        cmf::water::WaterStorage::ptr add_storage(std::string Name, char
        storage_role='N', bool isopenwater=false) 
        """
        return _cmf_core.Cell_add_storage(self, *args)

    def remove_storage(self, *args):
        """
        remove_storage(self, WaterStorage storage)

        void
        remove_storage(cmf::water::WaterStorage &storage) 
        """
        return _cmf_core.Cell_remove_storage(self, *args)

    def storage_count(self, *args):
        """
        storage_count(self) -> int

        int
        storage_count() const 
        """
        return _cmf_core.Cell_storage_count(self, *args)

    def get_storage(self, *args):
        """
        get_storage(self, int index) -> ptr

        cmf::water::WaterStorage::ptr get_storage(int index) const 
        """
        return _cmf_core.Cell_get_storage(self, *args)

    def get_canopy(self, *args):
        """
        get_canopy(self) -> ptr

        cmf::water::WaterStorage::ptr get_canopy() const 
        """
        return _cmf_core.Cell_get_canopy(self, *args)

    def get_snow(self, *args):
        """
        get_snow(self) -> ptr

        cmf::water::WaterStorage::ptr get_snow() const 
        """
        return _cmf_core.Cell_get_snow(self, *args)

    def snow_coverage(self, *args):
        """
        snow_coverage(self) -> real

        real
        snow_coverage() const 
        """
        return _cmf_core.Cell_snow_coverage(self, *args)

    def has_wet_leaves(self, *args):
        """
        has_wet_leaves(self) -> bool

        bool
        has_wet_leaves() const 
        """
        return _cmf_core.Cell_has_wet_leaves(self, *args)

    def has_surface_water(self, *args):
        """
        has_surface_water(self) -> bool

        bool
        has_surface_water() const 
        """
        return _cmf_core.Cell_has_surface_water(self, *args)

    def get_vegetation(self, *args):
        """
        get_vegetation(self) -> Vegetation

        cmf::upslope::vegetation::Vegetation get_vegetation() const 
        """
        return _cmf_core.Cell_get_vegetation(self, *args)

    def set_vegetation(self, *args):
        """
        set_vegetation(self, Vegetation val)

        void
        set_vegetation(cmf::upslope::vegetation::Vegetation val) 
        """
        return _cmf_core.Cell_set_vegetation(self, *args)

    Id = _swig_property(_cmf_core.Cell_Id_get, _cmf_core.Cell_Id_set)
    def project(self, *args):
        """
        project(self) -> project

        const
        cmf::project& project() const 
        """
        return _cmf_core.Cell_project(self, *args)

    def get_weather(self, *args):
        """
        get_weather(self, Time t) -> Weather

        cmf::atmosphere::Weather get_weather(cmf::math::Time t) const 
        """
        return _cmf_core.Cell_get_weather(self, *args)

    def layer_count(self, *args):
        """
        layer_count(self) -> int

        int
        layer_count() const 
        """
        return _cmf_core.Cell_layer_count(self, *args)

    def get_layer(self, *args):
        """
        get_layer(self, int ndx) -> ptr

        cmf::upslope::layer_ptr get_layer(int ndx) const 
        """
        return _cmf_core.Cell_get_layer(self, *args)

    def add_layer(self, *args):
        """
        add_layer(self, real lowerboundary, RetentionCurve r_curve, real saturateddepth = 10)

        void
        add_layer(real lowerboundary, const cmf::upslope::RetentionCurve
        &r_curve, real saturateddepth=10) 
        """
        return _cmf_core.Cell_add_layer(self, *args)

    def remove_last_layer(self, *args):
        """
        remove_last_layer(self)

        void
        remove_last_layer() 
        """
        return _cmf_core.Cell_remove_last_layer(self, *args)

    def remove_layers(self, *args):
        """
        remove_layers(self)

        void
        remove_layers() 
        """
        return _cmf_core.Cell_remove_layers(self, *args)

    __swig_destroy__ = _cmf_core.delete_Cell
    def __init__(self, *args): 
        """
        __init__(self, double x, double y, double z, double area, project _project) -> Cell

        Cell(double x,
        double y, double z, double area, cmf::project &_project) 
        """
        _cmf_core.Cell_swiginit(self,_cmf_core.new_Cell(*args))
    def to_string(self, *args):
        """
        to_string(self) -> string

        std::string
        to_string() 
        """
        return _cmf_core.Cell_to_string(self, *args)

    topology = _swig_property(_cmf_core.Cell_topology_get)
    evaporation = _swig_property(_cmf_core.Cell_evaporation_get)
    transpiration = _swig_property(_cmf_core.Cell_transpiration_get)
    meteorology = _swig_property(_cmf_core.Cell_meteorology_get, _cmf_core.Cell_meteorology_set)
    rain = _swig_property(_cmf_core.Cell_rain_get)
    layers = _swig_property(_cmf_core.Cell_layers_get)
    @property
    def neighbors(self):
        c_iter=NeighborIterator(self)
        while c_iter.valid():
            yield (c_iter.cell(),c_iter.flowwidth())
            c_iter.next()

    storages=property(lambda c:_cell_object_list(c,'A'),None,"Provides access to all storages of the cell (surface storages and layers)")
    surface_storages=property(lambda c:_cell_object_list(c,'S'),None,"Provides access to all surface storages of the cell, like canopy, snow, surface water etc")
    surfacewater=property(get_surfacewater,None,"Gives access to the surface water, which is either a distributing flux node, or the storage for all surface water")
    canopy=property(get_canopy,None,"The canopy water storage of the cell, if it exists")
    snow=property(get_snow,None,"The snow pack of the cell, if a storage for the snow exists")
    saturated_depth=property(get_saturated_depth,set_saturated_depth,"Gets or sets the saturated depth of a cell, if setting each layer of the cell will get a new water content")
    area=property(get_area,None,"The area of the cell in m2")
    soildepth=property(lambda self:0 if self.layer_count()==0 else self.layers[-1].boundary[-1],None,"the soildepth in m (lower boundary of lowest layer)")
    reach=property(lambda self:self.get_reach(0),None,"The first reach of the cell, other reaches are accessible via reaches[n]")
    reaches=property(lambda self:[self.get_reach(i) for i in range(self.ReachCount())],None,"The reaches of this cell")
    Vegetation=property(get_vegetation,set_vegetation,"The vegetational parameters of the cell")


    contributing_area=property(lambda self:self.topology.ContributingArea(),None,"Contributing area of this cell m2")
    main_outlet=property(lambda self:self.topology.MainOutlet(),None,"The main outlet of the surface water of this cell")

    def connect_soil_with_node(self,node,type,flowwidth,distance,upper_boundary=0,lower_boundary=None):
        """Connects all layers between the boundaries with a node using a flux connection
        node: Target node (flux_node)
        type: Type of the connection (e.g. cmf.Richards_lateral)
        flowwidth: Width of the connection
        distance: distance of the connection
        upper_boundary: Connect only layers, whose lower depth is greater then this value
        lower_boundary: Connect only  layers, whose upper depth is smaller then this value
        """
        if lower_boundary is None:
            lower_boundary=self.soildepth
        for l in self.layers:
            if l.boundary[0]<lower_boundary and l.boundary[1]>upper_boundary:
                type(l,node,flowwidth,distance).thisown=0
        
    def install_connection(self,connection_type):
        if hasattr(connection_type,"use_for_cell"):
            connection_type.use_for_cell(self)
        else:
            raise TypeError("Only connection types implementing a static use_for_cell function can be used")
    def __hash__(self):
        return hash((self.x,self.y,self.Id))
    def __eq__(self,cmp):
        return hash(self)==hash(cmp)
    def __repr__(self):
        return "cell #%i(%g,%g,%g)" % (self.Id,self.x,self.y,self.z)

Cell.get_area = new_instancemethod(_cmf_core.Cell_get_area,None,Cell)
Cell.InvalidateSatDepth = new_instancemethod(_cmf_core.Cell_InvalidateSatDepth,None,Cell)
Cell.get_saturated_depth = new_instancemethod(_cmf_core.Cell_get_saturated_depth,None,Cell)
Cell.set_saturated_depth = new_instancemethod(_cmf_core.Cell_set_saturated_depth,None,Cell)
Cell.set_weather = new_instancemethod(_cmf_core.Cell_set_weather,None,Cell)
Cell.set_rainfall = new_instancemethod(_cmf_core.Cell_set_rainfall,None,Cell)
Cell.get_surfacewater = new_instancemethod(_cmf_core.Cell_get_surfacewater,None,Cell)
Cell.surfacewater_as_storage = new_instancemethod(_cmf_core.Cell_surfacewater_as_storage,None,Cell)
Cell.add_storage = new_instancemethod(_cmf_core.Cell_add_storage,None,Cell)
Cell.remove_storage = new_instancemethod(_cmf_core.Cell_remove_storage,None,Cell)
Cell.storage_count = new_instancemethod(_cmf_core.Cell_storage_count,None,Cell)
Cell.get_storage = new_instancemethod(_cmf_core.Cell_get_storage,None,Cell)
Cell.get_canopy = new_instancemethod(_cmf_core.Cell_get_canopy,None,Cell)
Cell.get_snow = new_instancemethod(_cmf_core.Cell_get_snow,None,Cell)
Cell.snow_coverage = new_instancemethod(_cmf_core.Cell_snow_coverage,None,Cell)
Cell.has_wet_leaves = new_instancemethod(_cmf_core.Cell_has_wet_leaves,None,Cell)
Cell.has_surface_water = new_instancemethod(_cmf_core.Cell_has_surface_water,None,Cell)
Cell.get_vegetation = new_instancemethod(_cmf_core.Cell_get_vegetation,None,Cell)
Cell.set_vegetation = new_instancemethod(_cmf_core.Cell_set_vegetation,None,Cell)
Cell.project = new_instancemethod(_cmf_core.Cell_project,None,Cell)
Cell.get_weather = new_instancemethod(_cmf_core.Cell_get_weather,None,Cell)
Cell.layer_count = new_instancemethod(_cmf_core.Cell_layer_count,None,Cell)
Cell.get_layer = new_instancemethod(_cmf_core.Cell_get_layer,None,Cell)
Cell.add_layer = new_instancemethod(_cmf_core.Cell_add_layer,None,Cell)
Cell.remove_last_layer = new_instancemethod(_cmf_core.Cell_remove_last_layer,None,Cell)
Cell.remove_layers = new_instancemethod(_cmf_core.Cell_remove_layers,None,Cell)
Cell.to_string = new_instancemethod(_cmf_core.Cell_to_string,None,Cell)
Cell_swigregister = _cmf_core.Cell_swigregister
Cell_swigregister(Cell)

class Topology(Locatable):
    """
    represents the connectivity of cells to each other

    C++ includes: Topology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    cell = _swig_property(_cmf_core.Topology_cell_get)
    x = _swig_property(_cmf_core.Topology_x_get, _cmf_core.Topology_x_set)
    y = _swig_property(_cmf_core.Topology_y_get, _cmf_core.Topology_y_set)
    z = _swig_property(_cmf_core.Topology_z_get, _cmf_core.Topology_z_set)
    def flowwidth(self, *args):
        """
        flowwidth(self, Cell target) -> double
        flowwidth(self, Topology target) -> double

        double
        flowwidth(Topology &target) 
        """
        return _cmf_core.Topology_flowwidth(self, *args)

    def AddNeighbor(self, *args):
        """
        AddNeighbor(self, Cell target, double flowwidth)
        AddNeighbor(self, Topology target, double flowwidth)

        void
        AddNeighbor(Topology &target, double flowwidth) 
        """
        return _cmf_core.Topology_AddNeighbor(self, *args)

    def RemoveNeighbor(self, *args):
        """
        RemoveNeighbor(self, Topology target)

        void
        RemoveNeighbor(Topology &target) 
        """
        return _cmf_core.Topology_RemoveNeighbor(self, *args)

    def neighbor_count(self, *args):
        """
        neighbor_count(self) -> size_t

        size_t
        neighbor_count() const 
        """
        return _cmf_core.Topology_neighbor_count(self, *args)

    def MainOutlet(self, *args):
        """
        MainOutlet(self, bool forceRecalc = False) -> Cell

        Cell*
        MainOutlet(bool forceRecalc=false) 
        """
        return _cmf_core.Topology_MainOutlet(self, *args)

    def ContributingArea(self, *args):
        """
        ContributingArea(self) -> double

        double ContributingArea() const 
        """
        return _cmf_core.Topology_ContributingArea(self, *args)

    def calculate_contributing_area(*args):
        """calculate_contributing_area(cell_vector arg0)"""
        return _cmf_core.Topology_calculate_contributing_area(*args)

    calculate_contributing_area = staticmethod(calculate_contributing_area)
    def __eq__(self, *args):
        """__eq__(self, Topology cmp) -> bool"""
        return _cmf_core.Topology___eq__(self, *args)

    __swig_destroy__ = _cmf_core.delete_Topology
Topology.flowwidth = new_instancemethod(_cmf_core.Topology_flowwidth,None,Topology)
Topology.AddNeighbor = new_instancemethod(_cmf_core.Topology_AddNeighbor,None,Topology)
Topology.RemoveNeighbor = new_instancemethod(_cmf_core.Topology_RemoveNeighbor,None,Topology)
Topology.neighbor_count = new_instancemethod(_cmf_core.Topology_neighbor_count,None,Topology)
Topology.MainOutlet = new_instancemethod(_cmf_core.Topology_MainOutlet,None,Topology)
Topology.ContributingArea = new_instancemethod(_cmf_core.Topology_ContributingArea,None,Topology)
Topology.__eq__ = new_instancemethod(_cmf_core.Topology___eq__,None,Topology)
Topology_swigregister = _cmf_core.Topology_swigregister
Topology_swigregister(Topology)

def Topology_calculate_contributing_area(*args):
  """Topology_calculate_contributing_area(cell_vector arg0)"""
  return _cmf_core.Topology_calculate_contributing_area(*args)

class NeighborIterator(object):
    """
    A class to iterate through the neighbors of a cell (const). Not needed
    from the Python side, use the generator cell.neighbors instead.

    C++ includes: Topology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, Cell cell) -> NeighborIterator

        NeighborIterator(cmf::upslope::Cell *cell) 
        """
        _cmf_core.NeighborIterator_swiginit(self,_cmf_core.new_NeighborIterator(*args))
    def cell(self, *args):
        """
        cell(self) -> Cell

        Cell&
        cell() 
        """
        return _cmf_core.NeighborIterator_cell(self, *args)

    def flowwidth(self, *args):
        """
        flowwidth(self) -> double

        double flowwidth() 
        """
        return _cmf_core.NeighborIterator_flowwidth(self, *args)

    def valid(self, *args):
        """
        valid(self) -> bool

        bool
        valid() const 
        """
        return _cmf_core.NeighborIterator_valid(self, *args)

    def next(self, *args):
        """
        next(self) -> NeighborIterator

        NeighborIterator& next()

        Points the iterator to the next neighbor. 
        """
        return _cmf_core.NeighborIterator_next(self, *args)

    def __eq__(self, *args):
        """__eq__(self, NeighborIterator cmp) -> bool"""
        return _cmf_core.NeighborIterator___eq__(self, *args)

    def __neq__(self, *args):
        """__neq__(self, NeighborIterator cmp) -> bool"""
        return _cmf_core.NeighborIterator___neq__(self, *args)

    __swig_destroy__ = _cmf_core.delete_NeighborIterator
NeighborIterator.cell = new_instancemethod(_cmf_core.NeighborIterator_cell,None,NeighborIterator)
NeighborIterator.flowwidth = new_instancemethod(_cmf_core.NeighborIterator_flowwidth,None,NeighborIterator)
NeighborIterator.valid = new_instancemethod(_cmf_core.NeighborIterator_valid,None,NeighborIterator)
NeighborIterator.next = new_instancemethod(_cmf_core.NeighborIterator_next,None,NeighborIterator)
NeighborIterator.__eq__ = new_instancemethod(_cmf_core.NeighborIterator___eq__,None,NeighborIterator)
NeighborIterator.__neq__ = new_instancemethod(_cmf_core.NeighborIterator___neq__,None,NeighborIterator)
NeighborIterator_swigregister = _cmf_core.NeighborIterator_swigregister
NeighborIterator_swigregister(NeighborIterator)

class cell_vector(object):
    """Proxy of C++ std::vector<(p.cmf::upslope::Cell)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.cell_vector_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.cell_vector___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.cell_vector___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_type"""
        return _cmf_core.cell_vector___len__(self, *args)

    def pop(self, *args):
        """pop(self) -> value_type"""
        return _cmf_core.cell_vector_pop(self, *args)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> cell_vector"""
        return _cmf_core.cell_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, cell_vector v)"""
        return _cmf_core.cell_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.cell_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.cell_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> cell_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.cell_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, cell_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.cell_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.cell_vector_append(self, *args)

    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.cell_vector_empty(self, *args)

    def size(self, *args):
        """size(self) -> size_type"""
        return _cmf_core.cell_vector_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.cell_vector_clear(self, *args)

    def swap(self, *args):
        """swap(self, cell_vector v)"""
        return _cmf_core.cell_vector_swap(self, *args)

    def get_allocator(self, *args):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.cell_vector_get_allocator(self, *args)

    def begin(self, *args):
        """begin(self) -> const_iterator"""
        return _cmf_core.cell_vector_begin(self, *args)

    def end(self, *args):
        """end(self) -> const_iterator"""
        return _cmf_core.cell_vector_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.cell_vector_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.cell_vector_rend(self, *args)

    def pop_back(self, *args):
        """pop_back(self)"""
        return _cmf_core.cell_vector_pop_back(self, *args)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.cell_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> cell_vector
        __init__(self, cell_vector arg0) -> cell_vector
        __init__(self, size_type size) -> cell_vector
        __init__(self, size_type size, value_type value) -> cell_vector
        """
        _cmf_core.cell_vector_swiginit(self,_cmf_core.new_cell_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.cell_vector_push_back(self, *args)

    def front(self, *args):
        """front(self) -> value_type"""
        return _cmf_core.cell_vector_front(self, *args)

    def back(self, *args):
        """back(self) -> value_type"""
        return _cmf_core.cell_vector_back(self, *args)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.cell_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.cell_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.cell_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.cell_vector_reserve(self, *args)

    def capacity(self, *args):
        """capacity(self) -> size_type"""
        return _cmf_core.cell_vector_capacity(self, *args)

    __swig_destroy__ = _cmf_core.delete_cell_vector
cell_vector.iterator = new_instancemethod(_cmf_core.cell_vector_iterator,None,cell_vector)
cell_vector.__nonzero__ = new_instancemethod(_cmf_core.cell_vector___nonzero__,None,cell_vector)
cell_vector.__bool__ = new_instancemethod(_cmf_core.cell_vector___bool__,None,cell_vector)
cell_vector.__len__ = new_instancemethod(_cmf_core.cell_vector___len__,None,cell_vector)
cell_vector.pop = new_instancemethod(_cmf_core.cell_vector_pop,None,cell_vector)
cell_vector.__getslice__ = new_instancemethod(_cmf_core.cell_vector___getslice__,None,cell_vector)
cell_vector.__setslice__ = new_instancemethod(_cmf_core.cell_vector___setslice__,None,cell_vector)
cell_vector.__delslice__ = new_instancemethod(_cmf_core.cell_vector___delslice__,None,cell_vector)
cell_vector.__delitem__ = new_instancemethod(_cmf_core.cell_vector___delitem__,None,cell_vector)
cell_vector.__getitem__ = new_instancemethod(_cmf_core.cell_vector___getitem__,None,cell_vector)
cell_vector.__setitem__ = new_instancemethod(_cmf_core.cell_vector___setitem__,None,cell_vector)
cell_vector.append = new_instancemethod(_cmf_core.cell_vector_append,None,cell_vector)
cell_vector.empty = new_instancemethod(_cmf_core.cell_vector_empty,None,cell_vector)
cell_vector.size = new_instancemethod(_cmf_core.cell_vector_size,None,cell_vector)
cell_vector.clear = new_instancemethod(_cmf_core.cell_vector_clear,None,cell_vector)
cell_vector.swap = new_instancemethod(_cmf_core.cell_vector_swap,None,cell_vector)
cell_vector.get_allocator = new_instancemethod(_cmf_core.cell_vector_get_allocator,None,cell_vector)
cell_vector.begin = new_instancemethod(_cmf_core.cell_vector_begin,None,cell_vector)
cell_vector.end = new_instancemethod(_cmf_core.cell_vector_end,None,cell_vector)
cell_vector.rbegin = new_instancemethod(_cmf_core.cell_vector_rbegin,None,cell_vector)
cell_vector.rend = new_instancemethod(_cmf_core.cell_vector_rend,None,cell_vector)
cell_vector.pop_back = new_instancemethod(_cmf_core.cell_vector_pop_back,None,cell_vector)
cell_vector.erase = new_instancemethod(_cmf_core.cell_vector_erase,None,cell_vector)
cell_vector.push_back = new_instancemethod(_cmf_core.cell_vector_push_back,None,cell_vector)
cell_vector.front = new_instancemethod(_cmf_core.cell_vector_front,None,cell_vector)
cell_vector.back = new_instancemethod(_cmf_core.cell_vector_back,None,cell_vector)
cell_vector.assign = new_instancemethod(_cmf_core.cell_vector_assign,None,cell_vector)
cell_vector.resize = new_instancemethod(_cmf_core.cell_vector_resize,None,cell_vector)
cell_vector.insert = new_instancemethod(_cmf_core.cell_vector_insert,None,cell_vector)
cell_vector.reserve = new_instancemethod(_cmf_core.cell_vector_reserve,None,cell_vector)
cell_vector.capacity = new_instancemethod(_cmf_core.cell_vector_capacity,None,cell_vector)
cell_vector_swigregister = _cmf_core.cell_vector_swigregister
cell_vector_swigregister(cell_vector)


def find_cell(*args):
  """find_cell(cells_ref arg0, point p, double max_dist = 1e20) -> Cell"""
  return _cmf_core.find_cell(*args)

def get_boundary_cells(*args):
  """get_boundary_cells(cells_ref cells) -> cell_vector"""
  return _cmf_core.get_boundary_cells(*args)

def get_connections(*args):
  """get_connections(cells_ref cells) -> connection_set"""
  return _cmf_core.get_connections(*args)

def connect_cells_with_flux(*args):
  """connect_cells_with_flux(cells_ref cells, CellConnector connect, int start_at_layer = 0)"""
  return _cmf_core.connect_cells_with_flux(*args)

def fill_sinks(*args):
  """fill_sinks(cells_ref cells, double min_difference = 0.001) -> int"""
  return _cmf_core.fill_sinks(*args)

def area(*args):
  """area(cells_ref cells) -> double"""
  return _cmf_core.area(*args)

def set_meteo_station(*args):
  """set_meteo_station(cells_ref cells, ptr meteo_station)"""
  return _cmf_core.set_meteo_station(*args)

def set_precipitation(*args):
  """set_precipitation(cells_ref cells, timeseries data_in_mm_day)"""
  return _cmf_core.set_precipitation(*args)

def cell_positions(*args):
  """cell_positions(cells_ref cells) -> point_vector"""
  return _cmf_core.cell_positions(*args)

def cell_flux_directions(*args):
  """cell_flux_directions(cells_ref cells, Time arg1) -> point_vector"""
  return _cmf_core.cell_flux_directions(*args)

def pressure_to_waterhead(*args):
  """pressure_to_waterhead(double Pressure) -> double"""
  return _cmf_core.pressure_to_waterhead(*args)

def waterhead_to_pressure(*args):
  """waterhead_to_pressure(double waterhead) -> double"""
  return _cmf_core.waterhead_to_pressure(*args)

def pF_to_waterhead(*args):
  """pF_to_waterhead(double pF) -> double"""
  return _cmf_core.pF_to_waterhead(*args)

def waterhead_to_pF(*args):
  """waterhead_to_pF(double waterhead) -> double"""
  return _cmf_core.waterhead_to_pF(*args)
class RetentionCurve(object):
    """
    Abstract base class for different types of retention curves.

    This class, and its children uses wetness instead of volumetric water
    content. The wetness of a soil is defined as water content per void
    volume

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def K(self, *args):
        """
        K(self, real wetness, real depth) -> real

        virtual real
        K(real wetness, real depth) const =0

        Returns the conductivity in m/day at a certain depth and water
        content. 
        """
        return _cmf_core.RetentionCurve_K(self, *args)

    def Wetness_eff(self, *args):
        """
        Wetness_eff(self, real wetness, real pF_r = 4.2) -> real

        virtual real Wetness_eff(real wetness, real pF_r=4.2) const

        Returns the effective wetness, using a residual pF value (see Formula
        in C++ documentation) . 
        """
        return _cmf_core.RetentionCurve_Wetness_eff(self, *args)

    def Porosity(self, *args):
        """
        Porosity(self, real depth) -> real

        virtual real Porosity(real depth) const =0

        Returns the porosity at a certain depth. 
        """
        return _cmf_core.RetentionCurve_Porosity(self, *args)

    def VoidVolume(self, *args):
        """
        VoidVolume(self, real upperDepth, real lowerDepth, real Area) -> real

        virtual real VoidVolume(real upperDepth, real lowerDepth, real Area)
        const

        Returns the void volume of a soil column. 
        """
        return _cmf_core.RetentionCurve_VoidVolume(self, *args)

    def FillHeight(self, *args):
        """
        FillHeight(self, real lowerDepth, real Area, real Volume) -> real

        virtual real FillHeight(real lowerDepth, real Area, real Volume) const

        Returns the thickness of a soil column with a certain pore volume. 
        """
        return _cmf_core.RetentionCurve_FillHeight(self, *args)

    def Transmissivity(self, *args):
        """
        Transmissivity(self, real upperDepth, real lowerDepth, real wetness) -> real

        virtual real Transmissivity(real upperDepth, real lowerDepth, real
        wetness) const

        Returns the transmissivity of a part of a soil column. 
        """
        return _cmf_core.RetentionCurve_Transmissivity(self, *args)

    def Wetness(self, *args):
        """
        Wetness(self, real suction) -> real

        virtual
        real Wetness(real suction) const

        returns the wetness (volumetric water content per pore space) at a
        given suction pressure 
        """
        return _cmf_core.RetentionCurve_Wetness(self, *args)

    def Wetness_pF(self, *args):
        """
        Wetness_pF(self, real pF) -> real

        real
        Wetness_pF(real pF) const

        returns the volumetric water content at a given pF value 
        """
        return _cmf_core.RetentionCurve_Wetness_pF(self, *args)

    def MatricPotential(self, *args):
        """
        MatricPotential(self, real wetness) -> real

        virtual real MatricPotential(real wetness) const

        returns the wetness of the soil at given water content 
        """
        return _cmf_core.RetentionCurve_MatricPotential(self, *args)

    def copy(self, *args):
        """
        copy(self) -> RetentionCurve

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf_core.RetentionCurve_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_RetentionCurve
RetentionCurve.K = new_instancemethod(_cmf_core.RetentionCurve_K,None,RetentionCurve)
RetentionCurve.Wetness_eff = new_instancemethod(_cmf_core.RetentionCurve_Wetness_eff,None,RetentionCurve)
RetentionCurve.Porosity = new_instancemethod(_cmf_core.RetentionCurve_Porosity,None,RetentionCurve)
RetentionCurve.VoidVolume = new_instancemethod(_cmf_core.RetentionCurve_VoidVolume,None,RetentionCurve)
RetentionCurve.FillHeight = new_instancemethod(_cmf_core.RetentionCurve_FillHeight,None,RetentionCurve)
RetentionCurve.Transmissivity = new_instancemethod(_cmf_core.RetentionCurve_Transmissivity,None,RetentionCurve)
RetentionCurve.Wetness = new_instancemethod(_cmf_core.RetentionCurve_Wetness,None,RetentionCurve)
RetentionCurve.Wetness_pF = new_instancemethod(_cmf_core.RetentionCurve_Wetness_pF,None,RetentionCurve)
RetentionCurve.MatricPotential = new_instancemethod(_cmf_core.RetentionCurve_MatricPotential,None,RetentionCurve)
RetentionCurve.copy = new_instancemethod(_cmf_core.RetentionCurve_copy,None,RetentionCurve)
RetentionCurve_swigregister = _cmf_core.RetentionCurve_swigregister
RetentionCurve_swigregister(RetentionCurve)
rho_wg = cvar.rho_wg

class BrooksCoreyRetentionCurve(RetentionCurve):
    """
    Provides the use of the Brooks-Corey retention curve.

    (see Formula in C++ documentation)  where:  (see Formula in C++
    documentation)  is the conductivity in (see Formula in C++
    documentation)

    (see Formula in C++ documentation)  is the wetness (Volume of soil
    water per volume of pores)

    (see Formula in C++ documentation)  is the shape of the retention
    curve (usually between 4 (sand) and 14 (clay))

    (see Formula in C++ documentation)  is the matric potential in (see
    Formula in C++ documentation)  at wetness W

    (see Formula in C++ documentation)  is a matric potential at a known
    wetness in (see Formula in C++ documentation)

    (see Formula in C++ documentation)  is the wetness with a known matric
    potential for dynamic changes with depth, exponential decays of
    porosity and saturated conductivity are used The decay function is:
    (see Formula in C++ documentation) , where v is the value ( (see
    Formula in C++ documentation) ), d is the depth in m and a is the
    fractional decay per m. E.g. 0.1 means the value has in 1 m depth 90%
    of the value at the surface

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetKsat(self, *args):
        """
        SetKsat(self, real ksat, real ksat_decay)

        void SetKsat(real
        ksat, real ksat_decay) 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_SetKsat(self, *args)

    def SetPorosity(self, *args):
        """
        SetPorosity(self, real porosity, real porosity_decay = 0)

        void
        SetPorosity(real porosity, real porosity_decay=0)

        Sets the porosity (Volume of pores per volume of soil) and the
        exponential porosity decline with depth. 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_SetPorosity(self, *args)

    wetness_X = _swig_property(_cmf_core.BrooksCoreyRetentionCurve_wetness_X_get, _cmf_core.BrooksCoreyRetentionCurve_wetness_X_set)
    Psi_X = _swig_property(_cmf_core.BrooksCoreyRetentionCurve_Psi_X_get, _cmf_core.BrooksCoreyRetentionCurve_Psi_X_set)
    def b(self, *args):
        """
        b(self) -> real

        real b() const

        Retention curve shape parameter. 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_b(self, *args)

    def Set_b(self, *args):
        """
        Set_b(self, real new_b)

        void Set_b(real new_b) 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_Set_b(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2, 
            real psi_x = cmf::upslope::pF_to_waterhead(2.5), 
            real ksat_decay = 0, real porosity_decay = 0) -> BrooksCoreyRetentionCurve

        BrooksCoreyRetentionCurve(real ksat=15, real porosity=0.5, real _b=5,
        real theta_x=0.2, real psi_x=pF_to_waterhead(2.5), real ksat_decay=0,
        real porosity_decay=0)

        Creates a brooks corey retention curve.

        Parameters:
        -----------

        ksat:  Saturated conductivity (see Formula in C++ documentation)

        porosity:   (see Formula in C++ documentation)

        _b:  Shape of the retention curve (if you do not know how to
        parameterize this, take a look at the other constructor)

        theta_x:   (see Formula in C++ documentation)  Water content at a
        specific suction pressure

        psi_x:  Suction pressure for (see Formula in C++ documentation)  in m
        water column, use the conversion functions pF_to_waterhead,
        pressure_to_waterhead to convert pressure in to waterhead height
        (default pF=2.5)

        ksat_decay:  Relative decay of conductivity with depth, e.g. 0.1 means
        conductivity gets 10% smaller per meter

        porosity_decay:  Relative decay of porosity with depth, e.g. 0.1 means
        conductivity gets 10% smaller per meter 
        """
        _cmf_core.BrooksCoreyRetentionCurve_swiginit(self,_cmf_core.new_BrooksCoreyRetentionCurve(*args))
    def CreateFrom2Points(*args):
        """
        CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
            real psi_1 = cmf::upslope::pF_to_waterhead(2.5), 
            real psi_2 = cmf::upslope::pF_to_waterhead(4.2)) -> BrooksCoreyRetentionCurve
        """
        return _cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points(*args)

    CreateFrom2Points = staticmethod(CreateFrom2Points)
    def copy(self, *args):
        """
        copy(self) -> BrooksCoreyRetentionCurve

        virtual BrooksCoreyRetentionCurve* copy() const 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_copy(self, *args)

    def __repr__(self):
        return "Brooks-Corey (Ksat=%g,porosity=%g,b=%g,wetness @ h=%g @ %g)" % (self.K(1,0),self.Porosity(0),self.b(),self.wetness_X,self.Psi_X)

    __swig_destroy__ = _cmf_core.delete_BrooksCoreyRetentionCurve
BrooksCoreyRetentionCurve.SetKsat = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_SetKsat,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.SetPorosity = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_SetPorosity,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.b = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_b,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.Set_b = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_Set_b,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.copy = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_copy,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve_swigregister = _cmf_core.BrooksCoreyRetentionCurve_swigregister
BrooksCoreyRetentionCurve_swigregister(BrooksCoreyRetentionCurve)

def BrooksCoreyRetentionCurve_CreateFrom2Points(*args):
  """
    BrooksCoreyRetentionCurve_CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
        real psi_1 = cmf::upslope::pF_to_waterhead(2.5), 
        real psi_2 = cmf::upslope::pF_to_waterhead(4.2)) -> BrooksCoreyRetentionCurve
    """
  return _cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points(*args)

class VanGenuchtenMualem(RetentionCurve):
    """
    Provides the use of the Van Genuchten - Mualem retention curve (Van
    Genuchten 1980).

    Head - moisture realtionship: (see Formula in C++ documentation)
    where:  (see Formula in C++ documentation)  is the conductivity in
    (see Formula in C++ documentation)

    (see Formula in C++ documentation)  is the wetness (Volume of soil
    water per volume of pores)

    (see Formula in C++ documentation)  is a shape parameter of the
    retention curve

    (see Formula in C++ documentation)  is inverse of the air entry
    potential in (see Formula in C++ documentation)

    (see Formula in C++ documentation)  is the matric potential in (see
    Formula in C++ documentation)  at wetness W

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = _swig_property(_cmf_core.VanGenuchtenMualem_alpha_get, _cmf_core.VanGenuchtenMualem_alpha_set)
    n = _swig_property(_cmf_core.VanGenuchtenMualem_n_get, _cmf_core.VanGenuchtenMualem_n_set)
    Ksat = _swig_property(_cmf_core.VanGenuchtenMualem_Ksat_get, _cmf_core.VanGenuchtenMualem_Ksat_set)
    Phi = _swig_property(_cmf_core.VanGenuchtenMualem_Phi_get, _cmf_core.VanGenuchtenMualem_Phi_set)
    Psi_full = _swig_property(_cmf_core.VanGenuchtenMualem_Psi_full_get, _cmf_core.VanGenuchtenMualem_Psi_full_set)
    m = _swig_property(_cmf_core.VanGenuchtenMualem_m_get, _cmf_core.VanGenuchtenMualem_m_set)
    def copy(self, *args):
        """
        copy(self) -> VanGenuchtenMualem

        VanGenuchtenMualem* copy() const 
        """
        return _cmf_core.VanGenuchtenMualem_copy(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> VanGenuchtenMualem
        __init__(self, real _Ksat, real _phi, real _alpha, real _n, real _m = -1) -> VanGenuchtenMualem

        VanGenuchtenMualem(real _Ksat, real _phi, real _alpha, real _n, real
        _m=-1)

        Creates a van Genuchten-Mualem retention curve.

        Parameters:
        -----------

        _Ksat:  Saturated conductivity in (see Formula in C++ documentation)

        _phi:  Porosity in (see Formula in C++ documentation)

        _alpha:  Van Genuchten (see Formula in C++ documentation)  in (see
        Formula in C++ documentation)

        _n:  Van Genuchten n

        _m:  m parameter, if negative m is calculated as (see Formula in C++
        documentation)  
        """
        _cmf_core.VanGenuchtenMualem_swiginit(self,_cmf_core.new_VanGenuchtenMualem(*args))
    def __repr__(self):
        return "VanGenuchten-Mualem (Ksat=%g,porosity=%g,alpha=%g, n=%g)" % (self.K(1,0),self.Porosity(0),self.alpha,self.n)

    __swig_destroy__ = _cmf_core.delete_VanGenuchtenMualem
VanGenuchtenMualem.copy = new_instancemethod(_cmf_core.VanGenuchtenMualem_copy,None,VanGenuchtenMualem)
VanGenuchtenMualem_swigregister = _cmf_core.VanGenuchtenMualem_swigregister
VanGenuchtenMualem_swigregister(VanGenuchtenMualem)

class LinearRetention(RetentionCurve):
    """
    The linear retention curve provides a simple linear relationship
    between storage and head.

    Head function (head in m, calculated from upper side control volume)
    (see Formula in C++ documentation)  Conductivity function (see Formula
    in C++ documentation)

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Ksat = _swig_property(_cmf_core.LinearRetention_Ksat_get, _cmf_core.LinearRetention_Ksat_set)
    porosity = _swig_property(_cmf_core.LinearRetention_porosity_get, _cmf_core.LinearRetention_porosity_set)
    thickness = _swig_property(_cmf_core.LinearRetention_thickness_get, _cmf_core.LinearRetention_thickness_set)
    residual_wetness = _swig_property(_cmf_core.LinearRetention_residual_wetness_get, _cmf_core.LinearRetention_residual_wetness_set)
    porosity_decay = _swig_property(_cmf_core.LinearRetention_porosity_decay_get, _cmf_core.LinearRetention_porosity_decay_set)
    Ksat_decay = _swig_property(_cmf_core.LinearRetention_Ksat_decay_get, _cmf_core.LinearRetention_Ksat_decay_set)
    beta = _swig_property(_cmf_core.LinearRetention_beta_get, _cmf_core.LinearRetention_beta_set)
    def copy(self, *args):
        """
        copy(self) -> LinearRetention

        LinearRetention* copy() const 
        """
        return _cmf_core.LinearRetention_copy(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real _Ksat, real _Phi, real _thickness, real _beta = 1.0, 
            real Ss = 1e-4, real _residual_wetness = 0.0, 
            real _ksat_decay = 0.0, real _porosity_decay = 0.0) -> LinearRetention

        LinearRetention(real _Ksat, real _Phi, real _thickness, real
        _beta=1.0, real Ss=1e-4, real _residual_wetness=0.0, real
        _ksat_decay=0.0, real _porosity_decay=0.0) 
        """
        _cmf_core.LinearRetention_swiginit(self,_cmf_core.new_LinearRetention(*args))
    __swig_destroy__ = _cmf_core.delete_LinearRetention
LinearRetention.copy = new_instancemethod(_cmf_core.LinearRetention_copy,None,LinearRetention)
LinearRetention_swigregister = _cmf_core.LinearRetention_swigregister
LinearRetention_swigregister(LinearRetention)

class SoilLayer(WaterStorage):
    """
    A representation of a SoilLayer.

    C++ includes: SoilLayer.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Position = _swig_property(_cmf_core.SoilLayer_Position_get)
    cell = _swig_property(_cmf_core.SoilLayer_cell_get)
    def get_soil(self, *args):
        """
        get_soil(self) -> RetentionCurve

        virtual
        cmf::upslope::RetentionCurve& get_soil() const

        Returns the soil properties of the water storage. 
        """
        return _cmf_core.SoilLayer_get_soil(self, *args)

    def set_soil(self, *args):
        """
        set_soil(self, RetentionCurve r_curve)

        virtual
        void set_soil(const cmf::upslope::RetentionCurve &r_curve) 
        """
        return _cmf_core.SoilLayer_set_soil(self, *args)

    def get_capacity(self, *args):
        """
        get_capacity(self) -> real

        virtual
        real get_capacity() const

        Returns the capacity of the water storage in m3. 
        """
        return _cmf_core.SoilLayer_get_capacity(self, *args)

    def get_saturated_depth(self, *args):
        """
        get_saturated_depth(self) -> real

        virtual real get_saturated_depth() const

        Returns the depth for saturation (see Formula in C++ documentation) .

        """
        return _cmf_core.SoilLayer_get_saturated_depth(self, *args)

    def get_flow_crosssection(self, *args):
        """
        get_flow_crosssection(self, SoilLayer target, bool HorizontalLayers = False) -> real

        real get_flow_crosssection(const cmf::upslope::SoilLayer &target,
        bool HorizontalLayers=false) const

        Calculates the shared crosssectional area of this and another soil
        water storage.

        If both layers belong to the same cell, the area of the cell is
        returned, if they belong to different cells the area of the vertical
        shared boundary is returned get_area in m2

        Parameters:
        -----------

        target:  The other soil water storage

        HorizontalLayers:  If true, the layers are assumed to be parallel to
        the gravitational potential, otherwise they are assumed to be parallel
        to the ground topography 
        """
        return _cmf_core.SoilLayer_get_flow_crosssection(self, *args)

    def cast(*args):
        """cast(ptr node) -> ptr"""
        return _cmf_core.SoilLayer_cast(*args)

    cast = staticmethod(cast)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_18__ swigSharedPtrUpcast) -> __dummy_12__"""
        return _cmf_core.SoilLayer_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    gravitational_potential = _swig_property(_cmf_core.SoilLayer_gravitational_potential_get)
    matrix_potential = _swig_property(_cmf_core.SoilLayer_matrix_potential_get)
    wetness = _swig_property(_cmf_core.SoilLayer_wetness_get, _cmf_core.SoilLayer_wetness_set)
    theta = _swig_property(_cmf_core.SoilLayer_theta_get, _cmf_core.SoilLayer_theta_set)
    K = _swig_property(_cmf_core.SoilLayer_K_get)
    Ksat = _swig_property(_cmf_core.SoilLayer_Ksat_get)
    thickness = _swig_property(_cmf_core.SoilLayer_thickness_get)
    lower_boundary = _swig_property(_cmf_core.SoilLayer_lower_boundary_get)
    upper_boundary = _swig_property(_cmf_core.SoilLayer_upper_boundary_get)
    porosity = _swig_property(_cmf_core.SoilLayer_porosity_get)
    upper = _swig_property(_cmf_core.SoilLayer_upper_get)
    lower = _swig_property(_cmf_core.SoilLayer_lower_get)
    boundary=property(lambda self:(self.upper_boundary,self.lower_boundary),None,"Returns the upper and lower boundary of the layer")
    pF=property(lambda self : waterhead_to_pF(self.matrix_potential),None,"The actual pF value")
    soil=property(get_soil,set_soil,"The retention curve of the layer")

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoilLayer
SoilLayer.get_soil = new_instancemethod(_cmf_core.SoilLayer_get_soil,None,SoilLayer)
SoilLayer.set_soil = new_instancemethod(_cmf_core.SoilLayer_set_soil,None,SoilLayer)
SoilLayer.get_capacity = new_instancemethod(_cmf_core.SoilLayer_get_capacity,None,SoilLayer)
SoilLayer.get_saturated_depth = new_instancemethod(_cmf_core.SoilLayer_get_saturated_depth,None,SoilLayer)
SoilLayer.get_flow_crosssection = new_instancemethod(_cmf_core.SoilLayer_get_flow_crosssection,None,SoilLayer)
SoilLayer_swigregister = _cmf_core.SoilLayer_swigregister
SoilLayer_swigregister(SoilLayer)

def SoilLayer_cast(*args):
  """SoilLayer_cast(ptr node) -> ptr"""
  return _cmf_core.SoilLayer_cast(*args)

def SoilLayer_SWIGSharedPtrUpcast(*args):
  """SoilLayer_SWIGSharedPtrUpcast(__dummy_18__ swigSharedPtrUpcast) -> __dummy_12__"""
  return _cmf_core.SoilLayer_SWIGSharedPtrUpcast(*args)

class layer_list(object):
    """Proxy of C++ cmf::upslope::layer_list class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, layer_list for_copy) -> layer_list
        __init__(self) -> layer_list
        __init__(self, node_list for_copy) -> layer_list
        """
        _cmf_core.layer_list_swiginit(self,_cmf_core.new_layer_list(*args))
    def pop(self, *args):
        """pop(self) -> ptr"""
        return _cmf_core.layer_list_pop(self, *args)

    def append(self, *args):
        """
        append(self, ptr l) -> layer_list
        append(self, layer_list ll) -> layer_list
        append(self, node_list nl) -> layer_list
        """
        return _cmf_core.layer_list_append(self, *args)

    def get_slice(self, *args):
        """get_slice(self, size_t first = 0, size_t last = 1000000, size_t step = 1) -> layer_list"""
        return _cmf_core.layer_list_get_slice(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.layer_list_clear(self, *args)

    def size(self, *args):
        """size(self) -> size_t"""
        return _cmf_core.layer_list_size(self, *args)

    def set_potential(self, *args):
        """set_potential(self, num_array Value, size_t offset = 0)"""
        return _cmf_core.layer_list_set_potential(self, *args)

    def set_volume(self, *args):
        """set_volume(self, num_array Value, size_t offset = 0)"""
        return _cmf_core.layer_list_set_volume(self, *args)

    def set_wetness(self, *args):
        """set_wetness(self, num_array Value, size_t offset = 0)"""
        return _cmf_core.layer_list_set_wetness(self, *args)

    gravitational_potential = _swig_property(_cmf_core.layer_list_gravitational_potential_get)
    matrix_potential = _swig_property(_cmf_core.layer_list_matrix_potential_get)
    wetness = _swig_property(_cmf_core.layer_list_wetness_get)
    volume = _swig_property(_cmf_core.layer_list_volume_get)
    potential = _swig_property(_cmf_core.layer_list_potential_get)
    K = _swig_property(_cmf_core.layer_list_K_get)
    Ksat = _swig_property(_cmf_core.layer_list_Ksat_get)
    thickness = _swig_property(_cmf_core.layer_list_thickness_get)
    lower_boundary = _swig_property(_cmf_core.layer_list_lower_boundary_get)
    upper_boundary = _swig_property(_cmf_core.layer_list_upper_boundary_get)
    porosity = _swig_property(_cmf_core.layer_list_porosity_get)
    def __get(self, *args):
        """__get(self, int index) -> ptr"""
        return _cmf_core.layer_list___get(self, *args)

    __repr__=lambda self: repr(list(self))
    __str__ =lambda self: str(list(self))
    __len__=lambda self: self.size()
    def __iadd__(self,other):
        self.append(other)
        return self
    def __add__(self,other):
        res = layer_list(self)
        res.append(other)
        return res
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __getitem__(self,index):
        if (type(index)==slice):
            return self.get_slice(*index.indices(len(self)))
        try:
            gen=iter(index)
            return [self.__get(it) for it in gen]
        except TypeError:
             return self.__get(index)      

    __swig_destroy__ = _cmf_core.delete_layer_list
layer_list.pop = new_instancemethod(_cmf_core.layer_list_pop,None,layer_list)
layer_list.append = new_instancemethod(_cmf_core.layer_list_append,None,layer_list)
layer_list.get_slice = new_instancemethod(_cmf_core.layer_list_get_slice,None,layer_list)
layer_list.clear = new_instancemethod(_cmf_core.layer_list_clear,None,layer_list)
layer_list.size = new_instancemethod(_cmf_core.layer_list_size,None,layer_list)
layer_list.set_potential = new_instancemethod(_cmf_core.layer_list_set_potential,None,layer_list)
layer_list.set_volume = new_instancemethod(_cmf_core.layer_list_set_volume,None,layer_list)
layer_list.set_wetness = new_instancemethod(_cmf_core.layer_list_set_wetness,None,layer_list)
layer_list.__get = new_instancemethod(_cmf_core.layer_list___get,None,layer_list)
layer_list_swigregister = _cmf_core.layer_list_swigregister
layer_list_swigregister(layer_list)

class IVolumeHeightFunction(object):
    """
    Volume height relations are functional objects, which return a height
    and a crosssectional area of a volume for different geometric bodies.
    This is the abstract base class, where the geometries derive from.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def h(self, *args):
        """
        h(self, double V) -> double

        virtual
        double h(double V) const =0

        Returns the depth of a given volume. 
        """
        return _cmf_core.IVolumeHeightFunction_h(self, *args)

    def A(self, *args):
        """
        A(self, double V) -> double

        virtual
        double A(double V) const =0

        Returns the area of the surface for a given volume. 
        """
        return _cmf_core.IVolumeHeightFunction_A(self, *args)

    def V(self, *args):
        """
        V(self, double h) -> double

        virtual
        double V(double h) const =0 
        """
        return _cmf_core.IVolumeHeightFunction_V(self, *args)

    def copy(self, *args):
        """
        copy(self) -> IVolumeHeightFunction

        virtual IVolumeHeightFunction* copy() const =0 
        """
        return _cmf_core.IVolumeHeightFunction_copy(self, *args)

    def __call__(self, *args):
        """__call__(self, double V) -> double"""
        return _cmf_core.IVolumeHeightFunction___call__(self, *args)

    __swig_destroy__ = _cmf_core.delete_IVolumeHeightFunction
IVolumeHeightFunction.h = new_instancemethod(_cmf_core.IVolumeHeightFunction_h,None,IVolumeHeightFunction)
IVolumeHeightFunction.A = new_instancemethod(_cmf_core.IVolumeHeightFunction_A,None,IVolumeHeightFunction)
IVolumeHeightFunction.V = new_instancemethod(_cmf_core.IVolumeHeightFunction_V,None,IVolumeHeightFunction)
IVolumeHeightFunction.copy = new_instancemethod(_cmf_core.IVolumeHeightFunction_copy,None,IVolumeHeightFunction)
IVolumeHeightFunction.__call__ = new_instancemethod(_cmf_core.IVolumeHeightFunction___call__,None,IVolumeHeightFunction)
IVolumeHeightFunction_swigregister = _cmf_core.IVolumeHeightFunction_swigregister
IVolumeHeightFunction_swigregister(IVolumeHeightFunction)

class Prism(IVolumeHeightFunction):
    """
    Returns the height of a volume in a Prism with a defined base area.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Area = _swig_property(_cmf_core.Prism_Area_get, _cmf_core.Prism_Area_set)
    def __init__(self, *args): 
        """
        __init__(self, double base_area) -> Prism

        Prism(double
        base_area) 
        """
        _cmf_core.Prism_swiginit(self,_cmf_core.new_Prism(*args))
    def copy(self, *args):
        """
        copy(self) -> Prism

        Prism* copy() const

        """
        return _cmf_core.Prism_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_Prism
Prism.copy = new_instancemethod(_cmf_core.Prism_copy,None,Prism)
Prism_swigregister = _cmf_core.Prism_swigregister
Prism_swigregister(Prism)

class volume_height_function(IVolumeHeightFunction):
    """
    A wrapper class for volume / height functional relations.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, volume_height_function for_copy) -> volume_height_function
        __init__(self, IVolumeHeightFunction for_copy) -> volume_height_function

        volume_height_function(const IVolumeHeightFunction &for_copy)

        Wrapper for any IVolumeHeightFunction. 
        """
        _cmf_core.volume_height_function_swiginit(self,_cmf_core.new_volume_height_function(*args))
    def copy(self, *args):
        """
        copy(self) -> volume_height_function

        volume_height_function* copy() const 
        """
        return _cmf_core.volume_height_function_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_volume_height_function
volume_height_function.copy = new_instancemethod(_cmf_core.volume_height_function_copy,None,volume_height_function)
volume_height_function_swigregister = _cmf_core.volume_height_function_swigregister
volume_height_function_swigregister(volume_height_function)

class IChannel(IVolumeHeightFunction):
    """
    Structure for the description of structural parameters of a reach
    Abstract base class for different IChannel geometries.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get_nManning(self, *args):
        """
        get_nManning(self) -> double

        virtual
        double get_nManning() const 
        """
        return _cmf_core.IChannel_get_nManning(self, *args)

    def set_nManning(self, *args):
        """
        set_nManning(self, double val)

        virtual
        void set_nManning(double val) 
        """
        return _cmf_core.IChannel_set_nManning(self, *args)

    length = _swig_property(_cmf_core.IChannel_length_get, _cmf_core.IChannel_length_set)
    def typecode(self, *args):
        """
        typecode(self) -> char

        virtual char
        typecode() const =0 
        """
        return _cmf_core.IChannel_typecode(self, *args)

    def get_channel_width(self, *args):
        """
        get_channel_width(self, double depth) -> double

        virtual double get_channel_width(double depth) const =0

        Calculates the flow width from a given actual depth [m] using the
        actual IChannel geometry. 
        """
        return _cmf_core.IChannel_get_channel_width(self, *args)

    def get_wetted_perimeter(self, *args):
        """
        get_wetted_perimeter(self, double depth) -> double

        virtual double get_wetted_perimeter(double depth) const =0

        Calculates the wetted perimeter from a given actual depth [m] using
        the actual IChannel geometry. 
        """
        return _cmf_core.IChannel_get_wetted_perimeter(self, *args)

    def get_depth(self, *args):
        """
        get_depth(self, double area) -> double

        virtual
        double get_depth(double area) const =0

        Calculates the actual depth of the reach using the IChannel geometry.

        get_depth of the reach [m]

        Parameters:
        -----------

        area:  Wetted area of a river cross section [m2], can be obtained by
        V/l, where V is the stored volume and l is the reach length 
        """
        return _cmf_core.IChannel_get_depth(self, *args)

    def get_flux_crossection(self, *args):
        """
        get_flux_crossection(self, double depth) -> double

        virtual double get_flux_crossection(double depth) const =0

        Calculates the wetted area from a given depth using the IChannel
        geometry. In most cases use get_flux_crossection=V/l, where V is the
        stored volume and l is the reach length.

        Wetted area of a river cross section [m2]

        Parameters:
        -----------

        depth:  get_depth of the reach [m] 
        """
        return _cmf_core.IChannel_get_flux_crossection(self, *args)

    def copy(self, *args):
        """
        copy(self) -> IChannel

        virtual IChannel*
        copy() const =0 
        """
        return _cmf_core.IChannel_copy(self, *args)

    def qManning(self, *args):
        """
        qManning(self, double A, double slope) -> double

        double
        qManning(double A, double slope) const

        Calculates the flow rate from a given water volume in the reach (see
        Formula in C++ documentation) .

        Flow rate [m3/s]

        Parameters:
        -----------

        A:  The area of the cross section [m2]

        slope:  The slope of the reach [m/m] 
        """
        return _cmf_core.IChannel_qManning(self, *args)

    __swig_destroy__ = _cmf_core.delete_IChannel
IChannel.get_nManning = new_instancemethod(_cmf_core.IChannel_get_nManning,None,IChannel)
IChannel.set_nManning = new_instancemethod(_cmf_core.IChannel_set_nManning,None,IChannel)
IChannel.typecode = new_instancemethod(_cmf_core.IChannel_typecode,None,IChannel)
IChannel.get_channel_width = new_instancemethod(_cmf_core.IChannel_get_channel_width,None,IChannel)
IChannel.get_wetted_perimeter = new_instancemethod(_cmf_core.IChannel_get_wetted_perimeter,None,IChannel)
IChannel.get_depth = new_instancemethod(_cmf_core.IChannel_get_depth,None,IChannel)
IChannel.get_flux_crossection = new_instancemethod(_cmf_core.IChannel_get_flux_crossection,None,IChannel)
IChannel.copy = new_instancemethod(_cmf_core.IChannel_copy,None,IChannel)
IChannel.qManning = new_instancemethod(_cmf_core.IChannel_qManning,None,IChannel)
IChannel_swigregister = _cmf_core.IChannel_swigregister
IChannel_swigregister(IChannel)

class SWATReachType(IChannel):
    """
    Structure for the description of structural parameters of a reach.

    Uses the SWAT IChannel geometry (see SWAT Theoretical Documentation,
    Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
    referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
    plain is not plain, but has a small slope=0.5%, but has an infinite
    width

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BottomWidth = _swig_property(_cmf_core.SWATReachType_BottomWidth_get, _cmf_core.SWATReachType_BottomWidth_set)
    ChannelDepth = _swig_property(_cmf_core.SWATReachType_ChannelDepth_get, _cmf_core.SWATReachType_ChannelDepth_set)
    BankSlope = _swig_property(_cmf_core.SWATReachType_BankSlope_get, _cmf_core.SWATReachType_BankSlope_set)
    FloodPlainSlope = _swig_property(_cmf_core.SWATReachType_FloodPlainSlope_get, _cmf_core.SWATReachType_FloodPlainSlope_set)
    def __init__(self, *args): 
        """
        __init__(self, double l) -> SWATReachType
        __init__(self, double l, double BankWidth, double Depth) -> SWATReachType

        SWATReachType(double l, double BankWidth, double Depth)

        Creates a new reach structure from a give width and depth.

        Parameters:
        -----------

        l:  length of the channel [m]

        BankWidth:  get_channel_width of the reach from bank to bank [m]

        Depth:  Depth of the reach [m] 
        """
        _cmf_core.SWATReachType_swiginit(self,_cmf_core.new_SWATReachType(*args))
    def copy(self, *args):
        """
        copy(self) -> SWATReachType

        SWATReachType* copy() const 
        """
        return _cmf_core.SWATReachType_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_SWATReachType
SWATReachType.copy = new_instancemethod(_cmf_core.SWATReachType_copy,None,SWATReachType)
SWATReachType_swigregister = _cmf_core.SWATReachType_swigregister
SWATReachType_swigregister(SWATReachType)

class TriangularReach(IChannel):
    """
    Structure for the description of reaches with a triangular cross
    section.

    Although double triangular cross section reach are rarely met, a
    triangular reach does scale with its water load, and is therefore
    preferable in case where nothing about IChannel geometry is known

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BankSlope = _swig_property(_cmf_core.TriangularReach_BankSlope_get, _cmf_core.TriangularReach_BankSlope_set)
    def __init__(self, *args): 
        """
        __init__(self, double l, double bankSlope = 2) -> TriangularReach

        TriangularReach(double l, double bankSlope=2)

        Creates a new triangular reach type. 
        """
        _cmf_core.TriangularReach_swiginit(self,_cmf_core.new_TriangularReach(*args))
    def copy(self, *args):
        """
        copy(self) -> TriangularReach

        TriangularReach* copy() const 
        """
        return _cmf_core.TriangularReach_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_TriangularReach
TriangularReach.copy = new_instancemethod(_cmf_core.TriangularReach_copy,None,TriangularReach)
TriangularReach_swigregister = _cmf_core.TriangularReach_swigregister
TriangularReach_swigregister(TriangularReach)

class RectangularReach(IChannel):
    """
    Describes a IChannel with a rectangular crosssection.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double l, double width) -> RectangularReach

        RectangularReach(double l, double width)

        Creates a new rectangular reach type with width [m]. 
        """
        _cmf_core.RectangularReach_swiginit(self,_cmf_core.new_RectangularReach(*args))
    def copy(self, *args):
        """
        copy(self) -> RectangularReach

        RectangularReach* copy() const 
        """
        return _cmf_core.RectangularReach_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_RectangularReach
RectangularReach.copy = new_instancemethod(_cmf_core.RectangularReach_copy,None,RectangularReach)
RectangularReach_swigregister = _cmf_core.RectangularReach_swigregister
RectangularReach_swigregister(RectangularReach)

class PipeReach(IChannel):
    """Proxy of C++ cmf::river::PipeReach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    radius = _swig_property(_cmf_core.PipeReach_radius_get, _cmf_core.PipeReach_radius_set)
    def __init__(self, *args): 
        """
        __init__(self, double l, double diameter) -> PipeReach

        PipeReach(double l, double diameter)

        Creates a tube IChannel with diameter [m]. 
        """
        _cmf_core.PipeReach_swiginit(self,_cmf_core.new_PipeReach(*args))
    def copy(self, *args):
        """
        copy(self) -> PipeReach

        PipeReach* copy()
        const 
        """
        return _cmf_core.PipeReach_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_PipeReach
PipeReach.copy = new_instancemethod(_cmf_core.PipeReach_copy,None,PipeReach)
PipeReach_swigregister = _cmf_core.PipeReach_swigregister
PipeReach_swigregister(PipeReach)

class Channel(IChannel):
    """
    A wrapper for channel geometries.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double length = 1.0) -> Channel
        __init__(self, IChannel for_wrapping) -> Channel
        __init__(self, IVolumeHeightFunction for_casting) -> Channel
        __init__(self, Channel for_copy) -> Channel
        __init__(self, char typecode, double length, double width = 1., double depth = 0.25) -> Channel

        Channel(char
        typecode, double length, double width=1., double depth=0.25)

        Creates a reachtype using a short cut character. Acceptes one of the
        following characters: 'T' TriangularReach, width and depth are
        ignored.

        'R' RectangularReach, depth is ignored

        'P' PipeReach, depth is ignored, width is the diameter of the pipe

        'S' SWATReachType, a trapezoid flow cross section, as used in the SWAT
        model, width (bank width) and depth are used.

        the reach type

        Parameters:
        -----------

        typecode:  Describes the geometry of the reach cross section.

        length:  The length of the channel in m

        width:  width of the reach cross section in m (ignored for typecode
        'T')

        depth:  depth of the reach (ignored for typecode 'T','R','P','S') 
        """
        _cmf_core.Channel_swiginit(self,_cmf_core.new_Channel(*args))
    def copy(self, *args):
        """
        copy(self) -> Channel

        Channel* copy()
        const 
        """
        return _cmf_core.Channel_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_Channel
Channel.copy = new_instancemethod(_cmf_core.Channel_copy,None,Channel)
Channel_swigregister = _cmf_core.Channel_swigregister
Channel_swigregister(Channel)

class MeanChannel(IChannel):
    """
    A combination of two channel geometries.

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, IChannel channel1, IChannel channel2) -> MeanChannel
        __init__(self, MeanChannel meanChannel) -> MeanChannel

        MeanChannel(const MeanChannel &meanChannel) 
        """
        _cmf_core.MeanChannel_swiginit(self,_cmf_core.new_MeanChannel(*args))
    def copy(self, *args):
        """
        copy(self) -> MeanChannel

        MeanChannel*
        copy() const 
        """
        return _cmf_core.MeanChannel_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_MeanChannel
MeanChannel.copy = new_instancemethod(_cmf_core.MeanChannel_copy,None,MeanChannel)
MeanChannel_swigregister = _cmf_core.MeanChannel_swigregister
MeanChannel_swigregister(MeanChannel)

class OpenWaterStorage(WaterStorage):
    """
    An open water body. The potential is calculated from the stored water
    using a water table function.

    C++ includes: OpenWaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get_height_function(self, *args):
        """
        get_height_function(self) -> IVolumeHeightFunction

        virtual const
        IVolumeHeightFunction& get_height_function() const

        The functional relation between volume, depth and exposed area. 
        """
        return _cmf_core.OpenWaterStorage_get_height_function(self, *args)

    def set_height_function(self, *args):
        """
        set_height_function(self, IVolumeHeightFunction val)

        virtual void
        set_height_function(const IVolumeHeightFunction &val) 
        """
        return _cmf_core.OpenWaterStorage_set_height_function(self, *args)

    def wet_area(self, *args):
        """
        wet_area(self) -> real

        real
        wet_area() const

        Returns the exposed surface area in m2. 
        """
        return _cmf_core.OpenWaterStorage_wet_area(self, *args)

    def create(*args):
        """
        create(project _project, real Area) -> ptr
        create(project _project, IVolumeHeightFunction base_geo) -> ptr
        """
        return _cmf_core.OpenWaterStorage_create(*args)

    create = staticmethod(create)
    def from_node(*args):
        """from_node(ptr node, real Area) -> ptr"""
        return _cmf_core.OpenWaterStorage_from_node(*args)

    from_node = staticmethod(from_node)
    def cast(*args):
        """cast(ptr node) -> ptr"""
        return _cmf_core.OpenWaterStorage_cast(*args)

    cast = staticmethod(cast)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_14__ swigSharedPtrUpcast) -> __dummy_12__"""
        return _cmf_core.OpenWaterStorage_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    depth = _swig_property(_cmf_core.OpenWaterStorage_depth_get, _cmf_core.OpenWaterStorage_depth_set)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_OpenWaterStorage
OpenWaterStorage.get_height_function = new_instancemethod(_cmf_core.OpenWaterStorage_get_height_function,None,OpenWaterStorage)
OpenWaterStorage.set_height_function = new_instancemethod(_cmf_core.OpenWaterStorage_set_height_function,None,OpenWaterStorage)
OpenWaterStorage.wet_area = new_instancemethod(_cmf_core.OpenWaterStorage_wet_area,None,OpenWaterStorage)
OpenWaterStorage_swigregister = _cmf_core.OpenWaterStorage_swigregister
OpenWaterStorage_swigregister(OpenWaterStorage)

def OpenWaterStorage_create(*args):
  """
    create(project _project, real Area) -> ptr
    OpenWaterStorage_create(project _project, IVolumeHeightFunction base_geo) -> ptr
    """
  return _cmf_core.OpenWaterStorage_create(*args)

def OpenWaterStorage_from_node(*args):
  """OpenWaterStorage_from_node(ptr node, real Area) -> ptr"""
  return _cmf_core.OpenWaterStorage_from_node(*args)

def OpenWaterStorage_cast(*args):
  """OpenWaterStorage_cast(ptr node) -> ptr"""
  return _cmf_core.OpenWaterStorage_cast(*args)

def OpenWaterStorage_SWIGSharedPtrUpcast(*args):
  """OpenWaterStorage_SWIGSharedPtrUpcast(__dummy_14__ swigSharedPtrUpcast) -> __dummy_12__"""
  return _cmf_core.OpenWaterStorage_SWIGSharedPtrUpcast(*args)

class Reach(OpenWaterStorage):
    """
    A reach is a specialization of an open water storage.

    The OpenWaterStorage attributes and methods are extended by
    topological features, for the creation of a network of reaches.

    C++ includes: reach.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get_height_function(self, *args):
        """
        get_height_function(self) -> IChannel

        const
        IChannel& get_height_function() const

        Returns the channel shape. 
        """
        return _cmf_core.Reach_get_height_function(self, *args)

    def set_height_function(self, *args):
        """
        set_height_function(self, IChannel val)

        virtual void set_height_function(const IVolumeHeightFunction &val) 
        """
        return _cmf_core.Reach_set_height_function(self, *args)

    def get_length(self, *args):
        """
        get_length(self) -> real

        real
        get_length() const

        Returns the length of the reach. 
        """
        return _cmf_core.Reach_get_length(self, *args)

    def set_outlet(self, *args):
        """
        set_outlet(self, ptr outlet)

        void
        set_outlet(cmf::water::flux_node::ptr outlet)

        Connects the reach to an outlet, e.g. a boundary condition. 
        """
        return _cmf_core.Reach_set_outlet(self, *args)

    def set_dead_end(self, *args):
        """
        set_dead_end(self)

        void
        set_dead_end() 
        """
        return _cmf_core.Reach_set_dead_end(self, *args)

    def set_downstream(self, *args):
        """
        set_downstream(self, Reach_ptr new_downstream)

        void
        set_downstream(Reach_ptr new_downstream)

        Connects the reach to another one downstream. 
        """
        return _cmf_core.Reach_set_downstream(self, *args)

    def get_upstream(self, *args):
        """
        get_upstream(self, int index) -> Reach_ptr

        Reach_ptr
        get_upstream(int index) const

        Returns a reach upstream of this. 
        """
        return _cmf_core.Reach_get_upstream(self, *args)

    def add_cell(self, *args):
        """
        add_cell(self, Cell cell, bool soil_cut, real distance, real width)

        void
        add_cell(cmf::upslope::Cell *cell, bool soil_cut, real distance, real
        width)

        Connects the surfacewater of a cell with this reach.

        Parameters:
        -----------

        cell:  The cell with the surface water to be connected with this reach

        soil_cut:  True, if this reach might have inflow through the bank

        distance:  The average distance from cell to this reach

        width:  The flow width from cell to this reach 
        """
        return _cmf_core.Reach_add_cell(self, *args)

    def cuts_soil_of(self, *args):
        """
        cuts_soil_of(self, Cell cell) -> bool

        bool
        cuts_soil_of(cmf::upslope::Cell *cell) const

        True if bank flow is possible. 
        """
        return _cmf_core.Reach_cuts_soil_of(self, *args)

    def get_distance_to(self, *args):
        """
        get_distance_to(self, Cell cell) -> real

        double
        get_distance_to(const Locatable &cmp)

        Returns the distance between two locatable objects. 
        """
        return _cmf_core.Reach_get_distance_to(self, *args)

    def get_bank_length_with(self, *args):
        """
        get_bank_length_with(self, Cell cell) -> real

        real
        get_bank_length_with(cmf::upslope::Cell *cell) const

        The bank length in the cell. 
        """
        return _cmf_core.Reach_get_bank_length_with(self, *args)

    def get_diffusive(self, *args):
        """
        get_diffusive(self) -> bool

        bool
        get_diffusive() const 
        """
        return _cmf_core.Reach_get_diffusive(self, *args)

    def set_diffusive(self, *args):
        """
        set_diffusive(self, bool use_diffusive_wave)

        void
        set_diffusive(bool use_diffusive_wave)

        Sets all Manning kind connections to either diffusive or kinematic. 
        """
        return _cmf_core.Reach_set_diffusive(self, *args)

    __swig_destroy__ = _cmf_core.delete_Reach
    def create(*args):
        """create(project project, Channel shape, bool diffusive = False) -> ptr"""
        return _cmf_core.Reach_create(*args)

    create = staticmethod(create)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_16__ swigSharedPtrUpcast) -> __dummy_14__"""
        return _cmf_core.Reach_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    cells = _swig_property(_cmf_core.Reach_cells_get)
    downstream = _swig_property(_cmf_core.Reach_downstream_get)
    root = _swig_property(_cmf_core.Reach_root_get)
    upstream_count = _swig_property(_cmf_core.Reach_upstream_count_get)
    def __repr__(self): 
        return self.to_string()

Reach.get_height_function = new_instancemethod(_cmf_core.Reach_get_height_function,None,Reach)
Reach.set_height_function = new_instancemethod(_cmf_core.Reach_set_height_function,None,Reach)
Reach.get_length = new_instancemethod(_cmf_core.Reach_get_length,None,Reach)
Reach.set_outlet = new_instancemethod(_cmf_core.Reach_set_outlet,None,Reach)
Reach.set_dead_end = new_instancemethod(_cmf_core.Reach_set_dead_end,None,Reach)
Reach.set_downstream = new_instancemethod(_cmf_core.Reach_set_downstream,None,Reach)
Reach.get_upstream = new_instancemethod(_cmf_core.Reach_get_upstream,None,Reach)
Reach.add_cell = new_instancemethod(_cmf_core.Reach_add_cell,None,Reach)
Reach.cuts_soil_of = new_instancemethod(_cmf_core.Reach_cuts_soil_of,None,Reach)
Reach.get_distance_to = new_instancemethod(_cmf_core.Reach_get_distance_to,None,Reach)
Reach.get_bank_length_with = new_instancemethod(_cmf_core.Reach_get_bank_length_with,None,Reach)
Reach.get_diffusive = new_instancemethod(_cmf_core.Reach_get_diffusive,None,Reach)
Reach.set_diffusive = new_instancemethod(_cmf_core.Reach_set_diffusive,None,Reach)
Reach_swigregister = _cmf_core.Reach_swigregister
Reach_swigregister(Reach)

def Reach_create(*args):
  """Reach_create(project project, Channel shape, bool diffusive = False) -> ptr"""
  return _cmf_core.Reach_create(*args)

def Reach_SWIGSharedPtrUpcast(*args):
  """Reach_SWIGSharedPtrUpcast(__dummy_16__ swigSharedPtrUpcast) -> __dummy_14__"""
  return _cmf_core.Reach_SWIGSharedPtrUpcast(*args)

class ReachIterator(object):
    """
    An iterator over every upstream reach from a start reach. Implements
    both the Python and the C++ iterator interface Usage C++:.

    Usage Python:

    C++ includes: reach.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def next(self, *args):
        """
        next(self) -> Reach_ptr

        Reach_ptr
        next()

        Returns the next reach in the upstream queue. 
        """
        return _cmf_core.ReachIterator_next(self, *args)

    def valid(self, *args):
        """
        valid(self) -> bool

        bool valid()
        const

        Returns true, if reaches are left to iterate over. 
        """
        return _cmf_core.ReachIterator_valid(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, Reach_ptr first) -> ReachIterator

        ReachIterator(Reach_ptr first)

        Creates a ReachIterator from a first reach. 
        """
        _cmf_core.ReachIterator_swiginit(self,_cmf_core.new_ReachIterator(*args))
    reach = _swig_property(_cmf_core.ReachIterator_reach_get)
    position = _swig_property(_cmf_core.ReachIterator_position_get)
    __swig_destroy__ = _cmf_core.delete_ReachIterator
ReachIterator.next = new_instancemethod(_cmf_core.ReachIterator_next,None,ReachIterator)
ReachIterator.valid = new_instancemethod(_cmf_core.ReachIterator_valid,None,ReachIterator)
ReachIterator_swigregister = _cmf_core.ReachIterator_swigregister
ReachIterator_swigregister(ReachIterator)


def make_river_gap(*args):
  """
    make_river_gap(Reach_ptr root_reach) -> double

    double
    cmf::river::make_river_gap(Reach_ptr root_reach)

    Ensures that rivers have a monotone downward flow direction. Reaches
    with a bottom higher than any upstream reach are lowered to the
    minimum height of any (possibly distant) upstream reach. 
    """
  return _cmf_core.make_river_gap(*args)
class lateral_sub_surface_flux(flux_connection):
    """
    An abstract base class for lateral subsurface fluxes.

    C++ includes: subsurfacefluxes.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_lateral_sub_surface_flux
lateral_sub_surface_flux_swigregister = _cmf_core.lateral_sub_surface_flux_swigregister
lateral_sub_surface_flux_swigregister(lateral_sub_surface_flux)

class Darcy(lateral_sub_surface_flux):
    """
    Calculates the lateral flow using the gravitational potential gradient
    only.

    (see Formula in C++ documentation)  where  (see Formula in C++
    documentation)  is the gravitational potential difference

    (see Formula in C++ documentation)  is the distance from Cell 1 to
    Cell 2

    (see Formula in C++ documentation)  is the transmissivity of cell C,
    calculated by SoilType::Transmissivity

    (see Formula in C++ documentation)  is the width of the connection of
    the cells

    C++ includes: subsurfacefluxes.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right, real FlowWidth, real Distance = 0) -> Darcy

        Darcy(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
        right, real FlowWidth, real Distance=0) 
        """
        _cmf_core.Darcy_swiginit(self,_cmf_core.new_Darcy(*args))
    __swig_destroy__ = _cmf_core.delete_Darcy
Darcy_swigregister = _cmf_core.Darcy_swigregister
Darcy_swigregister(Darcy)
Darcy.cell_connector = _cmf_core.cvar.Darcy_cell_connector

class TopographicGradientDarcy(lateral_sub_surface_flux):
    """
    Calculates the lateral flow using the topographic gradient.

    (see Formula in C++ documentation)  where  (see Formula in C++
    documentation)  is the topographic height difference

    (see Formula in C++ documentation)  is the distance from Cell 1 to
    Cell 2

    (see Formula in C++ documentation)  is the transmissivity of cell C,
    calculated by SoilType::Transmissivity

    (see Formula in C++ documentation)  is the width of the connection of
    the cells

    C++ includes: subsurfacefluxes.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right, real FlowWidth, real Distance = 0) -> TopographicGradientDarcy

        TopographicGradientDarcy(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0) 
        """
        _cmf_core.TopographicGradientDarcy_swiginit(self,_cmf_core.new_TopographicGradientDarcy(*args))
    __swig_destroy__ = _cmf_core.delete_TopographicGradientDarcy
TopographicGradientDarcy_swigregister = _cmf_core.TopographicGradientDarcy_swigregister
TopographicGradientDarcy_swigregister(TopographicGradientDarcy)
TopographicGradientDarcy.cell_connector = _cmf_core.cvar.TopographicGradientDarcy_cell_connector

class OHDISflow(lateral_sub_surface_flux):
    """
    A connection similar to OHDIS-KWMSS (OHymos-based DIStributed model -
    with Kinematic Wave Method for Surface and Subsurface runoff).

    (see Formula in C++ documentation)

    C++ includes: subsurfacefluxes.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right, real FlowWidth, real Distance = 0) -> OHDISflow

        OHDISflow(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0) 
        """
        _cmf_core.OHDISflow_swiginit(self,_cmf_core.new_OHDISflow(*args))
    __swig_destroy__ = _cmf_core.delete_OHDISflow
OHDISflow_swigregister = _cmf_core.OHDISflow_swigregister
OHDISflow_swigregister(OHDISflow)
OHDISflow.cell_connector = _cmf_core.cvar.OHDISflow_cell_connector

class DarcyKinematic(lateral_sub_surface_flux):
    """Proxy of C++ cmf::upslope::connections::DarcyKinematic class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right, real FlowWidth, real Distance = 0) -> DarcyKinematic"""
        _cmf_core.DarcyKinematic_swiginit(self,_cmf_core.new_DarcyKinematic(*args))
    __swig_destroy__ = _cmf_core.delete_DarcyKinematic
DarcyKinematic_swigregister = _cmf_core.DarcyKinematic_swigregister
DarcyKinematic_swigregister(DarcyKinematic)
DarcyKinematic.cell_connector = _cmf_core.cvar.DarcyKinematic_cell_connector

class Richards_lateral(lateral_sub_surface_flux):
    """Proxy of C++ cmf::upslope::connections::Richards_lateral class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right, real FlowWidth = 0, real Distance = 0) -> Richards_lateral

        Richards_lateral(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real FlowWidth=0, real Distance=0)

        """
        _cmf_core.Richards_lateral_swiginit(self,_cmf_core.new_Richards_lateral(*args))
    __swig_destroy__ = _cmf_core.delete_Richards_lateral
Richards_lateral_swigregister = _cmf_core.Richards_lateral_swigregister
Richards_lateral_swigregister(Richards_lateral)
Richards_lateral.cell_connector = _cmf_core.cvar.Richards_lateral_cell_connector

class Manning(flux_connection):
    """
    Calculates the flux between two open water bodies, using Manning's
    equation.

    C++ includes: ManningConnection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    is_diffusive_wave = _swig_property(_cmf_core.Manning_is_diffusive_wave_get, _cmf_core.Manning_is_diffusive_wave_set)
    flux_geometry = _swig_property(_cmf_core.Manning_flux_geometry_get, _cmf_core.Manning_flux_geometry_set)
    __swig_destroy__ = _cmf_core.delete_Manning
Manning_swigregister = _cmf_core.Manning_swigregister
Manning_swigregister(Manning)

class Manning_Diffusive(Manning):
    """Proxy of C++ cmf::river::Manning_Diffusive class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right, Channel reachtype) -> Manning_Diffusive

        Manning_Diffusive(cmf::river::OpenWaterStorage::ptr left,
        cmf::water::flux_node::ptr right, cmf::river::Channel reachtype) 
        """
        _cmf_core.Manning_Diffusive_swiginit(self,_cmf_core.new_Manning_Diffusive(*args))
    __swig_destroy__ = _cmf_core.delete_Manning_Diffusive
Manning_Diffusive_swigregister = _cmf_core.Manning_Diffusive_swigregister
Manning_Diffusive_swigregister(Manning_Diffusive)
Manning_Diffusive.cell_connector = _cmf_core.cvar.Manning_Diffusive_cell_connector

class Manning_Kinematic(Manning):
    """Proxy of C++ cmf::river::Manning_Kinematic class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right, Channel reachtype) -> Manning_Kinematic

        Manning_Kinematic(cmf::river::OpenWaterStorage::ptr left,
        cmf::water::flux_node::ptr right, cmf::river::Channel reachtype) 
        """
        _cmf_core.Manning_Kinematic_swiginit(self,_cmf_core.new_Manning_Kinematic(*args))
    __swig_destroy__ = _cmf_core.delete_Manning_Kinematic
Manning_Kinematic_swigregister = _cmf_core.Manning_Kinematic_swigregister
Manning_Kinematic_swigregister(Manning_Kinematic)
Manning_Kinematic.cell_connector = _cmf_core.cvar.Manning_Kinematic_cell_connector

class CanopyOverflow(flux_connection):
    """
    Calculates the overflow of a canopy storage.

    C++ includes: surfacefluxes.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr Canopy, ptr target, Cell cell) -> CanopyOverflow

        CanopyOverflow(cmf::water::WaterStorage::ptr Canopy,
        cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell) 
        """
        _cmf_core.CanopyOverflow_swiginit(self,_cmf_core.new_CanopyOverflow(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell) -> CanopyOverflow"""
        return _cmf_core.CanopyOverflow_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_CanopyOverflow
CanopyOverflow_swigregister = _cmf_core.CanopyOverflow_swigregister
CanopyOverflow_swigregister(CanopyOverflow)

def CanopyOverflow_use_for_cell(*args):
  """CanopyOverflow_use_for_cell(Cell cell) -> CanopyOverflow"""
  return _cmf_core.CanopyOverflow_use_for_cell(*args)

class SimpleTindexSnowMelt(flux_connection):
    """Proxy of C++ cmf::upslope::connections::SimpleTindexSnowMelt class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SnowMeltRate = _swig_property(_cmf_core.SimpleTindexSnowMelt_SnowMeltRate_get, _cmf_core.SimpleTindexSnowMelt_SnowMeltRate_set)
    def __init__(self, *args): 
        """
        __init__(self, ptr snow, ptr surface_water, Cell cell) -> SimpleTindexSnowMelt

        SimpleTindexSnowMelt(cmf::water::WaterStorage::ptr snow,
        cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell) 
        """
        _cmf_core.SimpleTindexSnowMelt_swiginit(self,_cmf_core.new_SimpleTindexSnowMelt(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.SimpleTindexSnowMelt_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_SimpleTindexSnowMelt
SimpleTindexSnowMelt_swigregister = _cmf_core.SimpleTindexSnowMelt_swigregister
SimpleTindexSnowMelt_swigregister(SimpleTindexSnowMelt)

def SimpleTindexSnowMelt_use_for_cell(*args):
  """SimpleTindexSnowMelt_use_for_cell(Cell cell)"""
  return _cmf_core.SimpleTindexSnowMelt_use_for_cell(*args)

class Rainfall(flux_connection):
    """Proxy of C++ cmf::upslope::connections::Rainfall class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Throughfall = _swig_property(_cmf_core.Rainfall_Throughfall_get, _cmf_core.Rainfall_Throughfall_set)
    InterceptedRainfall = _swig_property(_cmf_core.Rainfall_InterceptedRainfall_get, _cmf_core.Rainfall_InterceptedRainfall_set)
    def __init__(self, *args): 
        """
        __init__(self, ptr target, Cell cell, bool getthroughfall = True, 
            bool getintercepted = True) -> Rainfall

        Rainfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell,
        bool getthroughfall=true, bool getintercepted=true) 
        """
        _cmf_core.Rainfall_swiginit(self,_cmf_core.new_Rainfall(*args))
    __swig_destroy__ = _cmf_core.delete_Rainfall
Rainfall_swigregister = _cmf_core.Rainfall_swigregister
Rainfall_swigregister(Rainfall)

class Snowfall(flux_connection):
    """Proxy of C++ cmf::upslope::connections::Snowfall class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr target, Cell cell) -> Snowfall

        Snowfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell)

        """
        _cmf_core.Snowfall_swiginit(self,_cmf_core.new_Snowfall(*args))
    __swig_destroy__ = _cmf_core.delete_Snowfall
Snowfall_swigregister = _cmf_core.Snowfall_swigregister
Snowfall_swigregister(Snowfall)

class MatrixInfiltration(flux_connection):
    """
    Connects the surfacewater and the most upper layer.

    If UpslopeCell::InfiltrationExcess and Cell is not saturated (see
    Formula in C++ documentation)  else (see Formula in C++ documentation)

    C++ includes: infiltration.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr soilwater, ptr surfacewater) -> MatrixInfiltration

        MatrixInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
        cmf::water::flux_node::ptr surfacewater) 
        """
        _cmf_core.MatrixInfiltration_swiginit(self,_cmf_core.new_MatrixInfiltration(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell c)"""
        return _cmf_core.MatrixInfiltration_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_MatrixInfiltration
MatrixInfiltration_swigregister = _cmf_core.MatrixInfiltration_swigregister
MatrixInfiltration_swigregister(MatrixInfiltration)

def MatrixInfiltration_use_for_cell(*args):
  """MatrixInfiltration_use_for_cell(Cell c)"""
  return _cmf_core.MatrixInfiltration_use_for_cell(*args)

class CompleteInfiltration(flux_connection):
    """Proxy of C++ cmf::upslope::connections::CompleteInfiltration class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr soilwater, ptr surfacewater) -> CompleteInfiltration

        CompleteInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
        cmf::water::flux_node::ptr surfacewater) 
        """
        _cmf_core.CompleteInfiltration_swiginit(self,_cmf_core.new_CompleteInfiltration(*args))
    __swig_destroy__ = _cmf_core.delete_CompleteInfiltration
CompleteInfiltration_swigregister = _cmf_core.CompleteInfiltration_swigregister
CompleteInfiltration_swigregister(CompleteInfiltration)

class SWATPercolation(flux_connection):
    """
    A tipping bucket percolation approach similar to the approach in SWAT.

    (see Formula in C++ documentation)

    C++ includes: Percolation.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def use_for_cell(*args):
        """use_for_cell(Cell cell, bool no_override = True)"""
        return _cmf_core.SWATPercolation_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    def __init__(self, *args): 
        """
        __init__(self, ptr upperLayer, ptr lowerLayer) -> SWATPercolation

        SWATPercolation(cmf::upslope::SoilLayer::ptr upperLayer,
        cmf::upslope::SoilLayer::ptr lowerLayer) 
        """
        _cmf_core.SWATPercolation_swiginit(self,_cmf_core.new_SWATPercolation(*args))
    __swig_destroy__ = _cmf_core.delete_SWATPercolation
SWATPercolation_swigregister = _cmf_core.SWATPercolation_swigregister
SWATPercolation_swigregister(SWATPercolation)

def SWATPercolation_use_for_cell(*args):
  """SWATPercolation_use_for_cell(Cell cell, bool no_override = True)"""
  return _cmf_core.SWATPercolation_use_for_cell(*args)

class Richards(flux_connection):
    """
    Calculates flow according to the Richards equation.

    (see Formula in C++ documentation)  where  (see Formula in C++
    documentation)  is the difference of the total water potentials of the
    two soil layers

    (see Formula in C++ documentation)  is the distance between the two
    soil layers

    (see Formula in C++ documentation)  is the geometric mean conductivity
    (see SoilType::Kunsat)

    (see Formula in C++ documentation)  is the crosssectional area of the
    flux

    (see Formula in C++ documentation)  is the matrix potential (see
    SoilType::MatrixPotential)

    (see Formula in C++ documentation)  is the height of a soil layer
    above sea level

    C++ includes: Percolation.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right) -> Richards

        Richards(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
        right) 
        """
        _cmf_core.Richards_swiginit(self,_cmf_core.new_Richards(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell, bool no_override = True)"""
        return _cmf_core.Richards_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_Richards
Richards_swigregister = _cmf_core.Richards_swigregister
Richards_swigregister(Richards)

def Richards_use_for_cell(*args):
  """Richards_use_for_cell(Cell cell, bool no_override = True)"""
  return _cmf_core.Richards_use_for_cell(*args)

class SimplRichards(flux_connection):
    """Proxy of C++ cmf::upslope::connections::SimplRichards class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right) -> SimplRichards"""
        _cmf_core.SimplRichards_swiginit(self,_cmf_core.new_SimplRichards(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell, bool no_override = True)"""
        return _cmf_core.SimplRichards_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_SimplRichards
SimplRichards_swigregister = _cmf_core.SimplRichards_swigregister
SimplRichards_swigregister(SimplRichards)

def SimplRichards_use_for_cell(*args):
  """SimplRichards_use_for_cell(Cell cell, bool no_override = True)"""
  return _cmf_core.SimplRichards_use_for_cell(*args)

class HBVparameters(RetentionCurve):
    """
    This class holds the properties for all HBV like connections
    Implements the RetentionCurve interface is only partly, therefore it
    is not suitable for other connection types.

    (see Formula in C++ documentation)

    C++ includes: HBVflow.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cfmax = _swig_property(_cmf_core.HBVparameters_cfmax_get, _cmf_core.HBVparameters_cfmax_set)
    sfcf = _swig_property(_cmf_core.HBVparameters_sfcf_get, _cmf_core.HBVparameters_sfcf_set)
    cfr = _swig_property(_cmf_core.HBVparameters_cfr_get, _cmf_core.HBVparameters_cfr_set)
    cwh = _swig_property(_cmf_core.HBVparameters_cwh_get, _cmf_core.HBVparameters_cwh_set)
    k0 = _swig_property(_cmf_core.HBVparameters_k0_get, _cmf_core.HBVparameters_k0_set)
    k1 = _swig_property(_cmf_core.HBVparameters_k1_get, _cmf_core.HBVparameters_k1_set)
    k2 = _swig_property(_cmf_core.HBVparameters_k2_get, _cmf_core.HBVparameters_k2_set)
    perc = _swig_property(_cmf_core.HBVparameters_perc_get, _cmf_core.HBVparameters_perc_set)
    fc = _swig_property(_cmf_core.HBVparameters_fc_get, _cmf_core.HBVparameters_fc_set)
    uplim = _swig_property(_cmf_core.HBVparameters_uplim_get, _cmf_core.HBVparameters_uplim_set)
    lowlim = _swig_property(_cmf_core.HBVparameters_lowlim_get, _cmf_core.HBVparameters_lowlim_set)
    beta = _swig_property(_cmf_core.HBVparameters_beta_get, _cmf_core.HBVparameters_beta_set)
    def __init__(self, *args): 
        """
        __init__(self, double _k0 = 1, double _k1 = 0.25, double _k2 = 0.005, 
            double _perc = 0.05, double _fc = 0.3, double _beta = 4.0, 
            double _uplim = .35, double _lowlim = 1.0, 
            double _cfmax = 2, double _sfcf = 0.6, 
            double _cwh = 0.1, double _cfr = 0.05) -> HBVparameters

        HBVparameters(double _k0=1, double _k1=0.25, double _k2=0.005, double
        _perc=0.05, double _fc=0.3, double _beta=4.0, double _uplim=.35,
        double _lowlim=1.0, double _cfmax=2, double _sfcf=0.6, double
        _cwh=0.1, double _cfr=0.05) 
        """
        _cmf_core.HBVparameters_swiginit(self,_cmf_core.new_HBVparameters(*args))
    def copy(self, *args):
        """
        copy(self) -> HBVparameters

        virtual HBVparameters* copy() const 
        """
        return _cmf_core.HBVparameters_copy(self, *args)

    def cast(*args):
        """cast(RetentionCurve for_cast) -> HBVparameters"""
        return _cmf_core.HBVparameters_cast(*args)

    cast = staticmethod(cast)
    __swig_destroy__ = _cmf_core.delete_HBVparameters
HBVparameters.copy = new_instancemethod(_cmf_core.HBVparameters_copy,None,HBVparameters)
HBVparameters_swigregister = _cmf_core.HBVparameters_swigregister
HBVparameters_swigregister(HBVparameters)

def HBVparameters_cast(*args):
  """HBVparameters_cast(RetentionCurve for_cast) -> HBVparameters"""
  return _cmf_core.HBVparameters_cast(*args)

class HBVpercolation(flux_connection):
    """
    Calculates the percolation as in the HBV model.

    (see Formula in C++ documentation)

    C++ includes: HBVflow.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right) -> HBVpercolation

        HBVpercolation(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right) 
        """
        _cmf_core.HBVpercolation_swiginit(self,_cmf_core.new_HBVpercolation(*args))
    __swig_destroy__ = _cmf_core.delete_HBVpercolation
HBVpercolation_swigregister = _cmf_core.HBVpercolation_swigregister
HBVpercolation_swigregister(HBVpercolation)

class HBVlateral(lateral_sub_surface_flux):
    """
    Lateral flow using a simple linear storage, can be directed to another
    cell (HBV D like) or to a reach (HBV like).

    (see Formula in C++ documentation)

    C++ includes: HBVflow.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr left, ptr right, real width, real dist) -> HBVlateral

        HBVlateral(cmf::upslope::SoilLayer::ptr left,
        cmf::water::flux_node::ptr right, real width, real dist) 
        """
        _cmf_core.HBVlateral_swiginit(self,_cmf_core.new_HBVlateral(*args))
    __swig_destroy__ = _cmf_core.delete_HBVlateral
HBVlateral_swigregister = _cmf_core.HBVlateral_swigregister
HBVlateral_swigregister(HBVlateral)
HBVlateral.cell_connector = _cmf_core.cvar.HBVlateral_cell_connector


def HBVinstall(*args):
  """
    HBVinstall(HBVparameters parameters, Cell cell)

    void
    cmf::upslope::connections::HBVinstall(HBVparameters parameters,
    cmf::upslope::Cell &cell)

    Installs an HBV like model setup at a cell Reference: Bergstroem et al
    1995, in Singh (1995): Computer models of watershed hydrology.

    Removes the layers of a cell and adds three layers with 1m thickness
    and the HBVparameters as retention curve. Installs HBVpercolation
    between the layers

    Parameters:
    -----------

    parameters:  The parameters for the HBV like setup

    cell:   Cell where HBV like percolation is to be calculated 
    """
  return _cmf_core.HBVinstall(*args)

def Tact(*args):
  """
    Tact(real Tpot, SoilLayer sw, Vegetation veg) -> real

    real
    cmf::upslope::ET::Tact(real Tpot, const cmf::upslope::SoilLayer &sw,
    const cmf::upslope::vegetation::Vegetation &veg) 
    """
  return _cmf_core.Tact(*args)
class constantETpot(flux_connection):
    """Proxy of C++ cmf::upslope::ET::constantETpot class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ETpot_value = _swig_property(_cmf_core.constantETpot_ETpot_value_get, _cmf_core.constantETpot_ETpot_value_set)
    def GetETpot(self, *args):
        """
        GetETpot(self, Time t) -> real

        real GetETpot(cmf::math::Time t) const 
        """
        return _cmf_core.constantETpot_GetETpot(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr ET_target, double constantETpot_value) -> constantETpot

        constantETpot(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target, double constantETpot_value) 
        """
        _cmf_core.constantETpot_swiginit(self,_cmf_core.new_constantETpot(*args))
    __swig_destroy__ = _cmf_core.delete_constantETpot
constantETpot.GetETpot = new_instancemethod(_cmf_core.constantETpot_GetETpot,None,constantETpot)
constantETpot_swigregister = _cmf_core.constantETpot_swigregister
constantETpot_swigregister(constantETpot)

def PenmanMonteith(*args):
  """
    PenmanMonteith(real Rn, real ra, real rs, real T, real vap_press_deficit) -> real
    PenmanMonteith(Weather A, Vegetation veg, double h) -> real

    real
    cmf::upslope::ET::PenmanMonteith(cmf::atmosphere::Weather A, const
    cmf::upslope::vegetation::Vegetation &veg, double h) 
    """
  return _cmf_core.PenmanMonteith(*args)

class PenmanMonteithET(flux_connection):
    """
    Calculates the potential evapotranspiration according to FAO(1998).

    Gouverning equations: (see Formula in C++ documentation)

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    daily = _swig_property(_cmf_core.PenmanMonteithET_daily_get, _cmf_core.PenmanMonteithET_daily_set)
    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr ET_target) -> PenmanMonteithET

        PenmanMonteithET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target) 
        """
        _cmf_core.PenmanMonteithET_swiginit(self,_cmf_core.new_PenmanMonteithET(*args))
    def r_s(*args):
        """r_s(Vegetation veg) -> real"""
        return _cmf_core.PenmanMonteithET_r_s(*args)

    r_s = staticmethod(r_s)
    def r_a(*args):
        """r_a(Weather A, real veg_height) -> real"""
        return _cmf_core.PenmanMonteithET_r_a(*args)

    r_a = staticmethod(r_a)
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.PenmanMonteithET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_PenmanMonteithET
PenmanMonteithET_swigregister = _cmf_core.PenmanMonteithET_swigregister
PenmanMonteithET_swigregister(PenmanMonteithET)

def PenmanMonteithET_r_s(*args):
  """PenmanMonteithET_r_s(Vegetation veg) -> real"""
  return _cmf_core.PenmanMonteithET_r_s(*args)

def PenmanMonteithET_r_a(*args):
  """PenmanMonteithET_r_a(Weather A, real veg_height) -> real"""
  return _cmf_core.PenmanMonteithET_r_a(*args)

def PenmanMonteithET_use_for_cell(*args):
  """PenmanMonteithET_use_for_cell(Cell cell)"""
  return _cmf_core.PenmanMonteithET_use_for_cell(*args)

class ShuttleworthWallaceET(flux_connection):
    """
    Calculates the actual transpiration and the soil evaporation from a
    soil layer.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr ET_target, Cell cell, string Type = "Shuttleworth Wallace get_evaporation") -> ShuttleworthWallaceET

        ShuttleworthWallaceET(cmf::water::WaterStorage::ptr source,
        cmf::water::flux_node::ptr ET_target, cmf::upslope::Cell &cell,
        std::string Type="Shuttleworth Wallace get_evaporation") 
        """
        _cmf_core.ShuttleworthWallaceET_swiginit(self,_cmf_core.new_ShuttleworthWallaceET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.ShuttleworthWallaceET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_ShuttleworthWallaceET
ShuttleworthWallaceET_swigregister = _cmf_core.ShuttleworthWallaceET_swigregister
ShuttleworthWallaceET_swigregister(ShuttleworthWallaceET)

def ShuttleworthWallaceET_use_for_cell(*args):
  """ShuttleworthWallaceET_use_for_cell(Cell cell)"""
  return _cmf_core.ShuttleworthWallaceET_use_for_cell(*args)

class HargreaveET(flux_connection):
    """Proxy of C++ cmf::upslope::ET::HargreaveET class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr ET_target) -> HargreaveET

        HargreaveET(cmf::upslope::SoilLayer::ptr source,
        cmf::water::flux_node::ptr ET_target) 
        """
        _cmf_core.HargreaveET_swiginit(self,_cmf_core.new_HargreaveET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.HargreaveET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_HargreaveET
HargreaveET_swigregister = _cmf_core.HargreaveET_swigregister
HargreaveET_swigregister(HargreaveET)

def HargreaveET_use_for_cell(*args):
  """HargreaveET_use_for_cell(Cell cell)"""
  return _cmf_core.HargreaveET_use_for_cell(*args)

class CanopyStorageEvaporation(flux_connection):
    """
    Calculates the evaporation from a canopy storage.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr CanopyStorage, ptr ET_target, Cell cell) -> CanopyStorageEvaporation

        CanopyStorageEvaporation(cmf::water::WaterStorage::ptr CanopyStorage,
        cmf::water::flux_node::ptr ET_target, cmf::upslope::Cell &cell) 
        """
        _cmf_core.CanopyStorageEvaporation_swiginit(self,_cmf_core.new_CanopyStorageEvaporation(*args))
    __swig_destroy__ = _cmf_core.delete_CanopyStorageEvaporation
CanopyStorageEvaporation_swigregister = _cmf_core.CanopyStorageEvaporation_swigregister
CanopyStorageEvaporation_swigregister(CanopyStorageEvaporation)

class PenmanEvaporation(flux_connection):
    """Proxy of C++ cmf::upslope::ET::PenmanEvaporation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr Evap_target, Meteorology meteo) -> PenmanEvaporation

        PenmanEvaporation(cmf::river::OpenWaterStorage::ptr source,
        cmf::water::flux_node::ptr Evap_target, const
        cmf::atmosphere::Meteorology &meteo) 
        """
        _cmf_core.PenmanEvaporation_swiginit(self,_cmf_core.new_PenmanEvaporation(*args))
    __swig_destroy__ = _cmf_core.delete_PenmanEvaporation
PenmanEvaporation_swigregister = _cmf_core.PenmanEvaporation_swigregister
PenmanEvaporation_swigregister(PenmanEvaporation)

def connect(type,left_node,right_node,*args):
    connection=type(left_node,right_node,*args)
    connection.thisown=0

class project(StateVariableOwner):
    """
    The study area, holding all cells and outlets and streams.

    C++ includes: project.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    solutes = _swig_property(_cmf_core.project_solutes_get)
    meteo_stations = _swig_property(_cmf_core.project_meteo_stations_get, _cmf_core.project_meteo_stations_set)
    outlets = _swig_property(_cmf_core.project_outlets_get, _cmf_core.project_outlets_set)
    def get_cell(self, *args):
        """
        get_cell(self, int index) -> Cell

        upslope::Cell&
        get_cell(int index) 
        """
        return _cmf_core.project_get_cell(self, *args)

    def size(self, *args):
        """
        size(self) -> int

        int size() const 
        """
        return _cmf_core.project_size(self, *args)

    debug = _swig_property(_cmf_core.project_debug_get, _cmf_core.project_debug_set)
    def __init__(self, *args): 
        """
        __init__(self, string solute_names = "") -> project

        project(std::string
        solute_names="")

        Creates a new project. 
        """
        _cmf_core.project_swiginit(self,_cmf_core.new_project(*args))
    __swig_destroy__ = _cmf_core.delete_project
    def NewCell(self, *args):
        """
        NewCell(self, double x, double y, double z, double Area) -> Cell
        NewCell(self, point p, double Area) -> Cell

        cmf::upslope::Cell*
        NewCell(cmf::geometry::point p, double Area)

        Creates a new cell. 
        """
        return _cmf_core.project_NewCell(self, *args)

    def NewOutlet(self, *args):
        """NewOutlet(self, string name, point p) -> ptr"""
        return _cmf_core.project_NewOutlet(self, *args)

    def get_reach(self, *args):
        """
        get_reach(self, int index) -> Reach_ptr

        cmf::river::Reach_ptr
        get_reach(int index) 
        """
        return _cmf_core.project_get_reach(self, *args)

    def reach_count(self, *args):
        """
        reach_count(self) -> int

        int reach_count()
        const 
        """
        return _cmf_core.project_reach_count(self, *args)

    def get_storages(self, *args):
        """
        get_storages(self) -> node_list

        cmf::water::node_list get_storages() 
        """
        return _cmf_core.project_get_storages(self, *args)

    def NewReach(self, *args):
        """
        NewReach(self, Channel shape, bool diffusive = False) -> Reach_ptr

        cmf::river::Reach_ptr
        NewReach(cmf::river::Channel shape, bool diffusive=false)

        Creates a new reach. 
        """
        return _cmf_core.project_NewReach(self, *args)

    cells = _swig_property(_cmf_core.project_cells_get)
    def __repr__(self):
        return "cmf.project(%i cells, %i meteo stations, %i outlets)" % (len(self.cells),len(self.meteo_stations),len(self.outlets))
    def __len__(self):
        return self.size()
    def __getitem__(self,index):
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(self)))]
        else:
            return self.get_cell(index)        
    def __iter__(self):
        for i in range(self.size()):
            yield self.get_cell(i)

project.get_cell = new_instancemethod(_cmf_core.project_get_cell,None,project)
project.size = new_instancemethod(_cmf_core.project_size,None,project)
project.NewCell = new_instancemethod(_cmf_core.project_NewCell,None,project)
project.NewOutlet = new_instancemethod(_cmf_core.project_NewOutlet,None,project)
project.get_reach = new_instancemethod(_cmf_core.project_get_reach,None,project)
project.reach_count = new_instancemethod(_cmf_core.project_reach_count,None,project)
project.get_storages = new_instancemethod(_cmf_core.project_get_storages,None,project)
project.NewReach = new_instancemethod(_cmf_core.project_NewReach,None,project)
project_swigregister = _cmf_core.project_swigregister
project_swigregister(project)

class SoluteWaterIntegrator(Integrator):
    """Proxy of C++ cmf::math::SoluteWaterIntegrator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Copy(self, *args):
        """
        Copy(self) -> SoluteWaterIntegrator

        virtual cmf::math::SoluteWaterIntegrator* Copy() const 
        """
        return _cmf_core.SoluteWaterIntegrator_Copy(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, Integrator water_integrator, Integrator solute_integrator) -> SoluteWaterIntegrator
        __init__(self, Integrator water_integrator, Integrator solute_integrator, 
            StateVariableOwner states) -> SoluteWaterIntegrator

        SoluteWaterIntegrator(const cmf::math::Integrator &water_integrator,
        const cmf::math::Integrator &solute_integrator,
        cmf::math::StateVariableOwner &states) 
        """
        _cmf_core.SoluteWaterIntegrator_swiginit(self,_cmf_core.new_SoluteWaterIntegrator(*args))
    solute_integrator = _swig_property(_cmf_core.SoluteWaterIntegrator_solute_integrator_get, _cmf_core.SoluteWaterIntegrator_solute_integrator_set)
    water_integrator = _swig_property(_cmf_core.SoluteWaterIntegrator_water_integrator_get, _cmf_core.SoluteWaterIntegrator_water_integrator_set)
    __swig_destroy__ = _cmf_core.delete_SoluteWaterIntegrator
SoluteWaterIntegrator.Copy = new_instancemethod(_cmf_core.SoluteWaterIntegrator_Copy,None,SoluteWaterIntegrator)
SoluteWaterIntegrator_swigregister = _cmf_core.SoluteWaterIntegrator_swigregister
SoluteWaterIntegrator_swigregister(SoluteWaterIntegrator)

def get_layers(cells):
    for c in cells:
        for l in c.layers:
           yield l
def count_layers(cells):
    res=0
    for c in cells:
        res+=c.layer_count()
    return res
def __doc__(self):
    return "cmf -> Catchment Model Framework, extending Python with hydrological elements " + VERSION
cell_vector.__repr__=lambda cv:"list of %i cells. first:%s, last: %s" % ((cv.size(),cv[0],cv[-1]) if len(cv) else (cv.size(),"None","None"))



