# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _cmf_core.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_cmf_core', [dirname(__file__)])
        except ImportError:
            import _cmf_core
            return _cmf_core
        if fp is not None:
            try:
                _mod = imp.load_module('_cmf_core', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _cmf_core = swig_import_helper()
    del swig_import_helper
else:
    import _cmf_core
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_SwigPyIterator
    def value(self, *args):
        """value(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_value(self, *args)

    def incr(self, *args):
        """incr(self, size_t n = 1) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_incr(self, *args)

    def decr(self, *args):
        """decr(self, size_t n = 1) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_decr(self, *args)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _cmf_core.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator_equal(self, *args)

    def copy(self, *args):
        """copy(self) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_copy(self, *args)

    def next(self, *args):
        """next(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_next(self, *args)

    def __next__(self, *args):
        """__next__(self) -> PyObject"""
        return _cmf_core.SwigPyIterator___next__(self, *args)

    def previous(self, *args):
        """previous(self) -> PyObject"""
        return _cmf_core.SwigPyIterator_previous(self, *args)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _cmf_core.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _cmf_core.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _cmf_core.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_cmf_core.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_cmf_core.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_cmf_core.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_cmf_core.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_cmf_core.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_cmf_core.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_cmf_core.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_cmf_core.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_cmf_core.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_cmf_core.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_cmf_core.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_cmf_core.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_cmf_core.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_cmf_core.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_cmf_core.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_cmf_core.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _cmf_core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _cmf_core.SHARED_PTR_DISOWN
class point(object):
    """
    2D-Point Class.

    Used as location property anywhere in the text Calculation of
    distances

    +,-,-=,*= Operators overloaded

    C++ includes: geometry.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_cmf_core.point_x_get, _cmf_core.point_x_set)
    y = _swig_property(_cmf_core.point_y_get, _cmf_core.point_y_set)
    z = _swig_property(_cmf_core.point_z_get, _cmf_core.point_z_set)
    def Center(self, *args):
        """
        Center(self) -> point

        point Center()
        const 
        """
        return _cmf_core.point_Center(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> point
        __init__(self, point p) -> point
        __init__(self, double x_, double y_, double z_ = 0.0) -> point

        point(double x_,
        double y_, double z_=0.0)

        Creates a point from two doubles. 
        """
        _cmf_core.point_swiginit(self,_cmf_core.new_point(*args))
    def distanceTo(self, *args):
        """
        distanceTo(self, point p) -> double

        double
        distanceTo(point p) const

        Returns the euclidian distance to another point.
        $\\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}$. 
        """
        return _cmf_core.point_distanceTo(self, *args)

    def distance3DTo(self, *args):
        """
        distance3DTo(self, point p) -> double

        double
        distance3DTo(point p) const 
        """
        return _cmf_core.point_distance3DTo(self, *args)

    def distance(*args):
        """distance(point p1, point p2) -> double"""
        return _cmf_core.point_distance(*args)

    distance = staticmethod(distance)
    def distance_max(self, *args):
        """
        distance_max(self, point p) -> double

        double
        distance_max(point p) const

        Returns the distance by the maximum orthogonal offset. 
        """
        return _cmf_core.point_distance_max(self, *args)

    def azimuth(self, *args):
        """
        azimuth(self, point p) -> double

        double
        azimuth(point p) const

        Returns the azimuth angle of the line $ \\overline{this,p} $ to the
        Azimuth in degrees. 
        """
        return _cmf_core.point_azimuth(self, *args)

    def angleToXAxis(self, *args):
        """
        angleToXAxis(self, point p) -> double

        double
        angleToXAxis(point p) const

        Returns the angle between the line $ \\overline{this,p} $ to the
        x-Axis in degrees. 
        """
        return _cmf_core.point_angleToXAxis(self, *args)

    def __add__(self, *args):
        """__add__(self, point p) -> point"""
        return _cmf_core.point___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, point p) -> point"""
        return _cmf_core.point___sub__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, double left) -> point
        __mul__(self, point p) -> point
        """
        return _cmf_core.point___mul__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, double left) -> point
        __div__(self, point p) -> point
        """
        return _cmf_core.point___div__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, point p) -> point"""
        return _cmf_core.point___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, point p) -> point"""
        return _cmf_core.point___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, point p) -> bool"""
        return _cmf_core.point___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, point p) -> bool"""
        return _cmf_core.point___ne__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> int"""
        return _cmf_core.point___len__(self, *args)

    def __rmul__(self, *args):
        """__rmul__(self, double val) -> point"""
        return _cmf_core.point___rmul__(self, *args)

    def __rdiv__(self, *args):
        """__rdiv__(self, double val) -> point"""
        return _cmf_core.point___rdiv__(self, *args)

    def __getitem__(self,index) :
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(p)))]
        if index==0 :
            return self.x
        elif index==1 :
            return self.y
        elif index==2 :
            return self.z
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __setitem__(self,index,value) :
        if index==0 :
            self.x=value
        elif index==1 :
            self.y=value
        elif index==2 :
            self.z=value
        else :
            raise IndexError("Only Index 0 .. 2 are allowed")
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z
    def __repr__(self):
        return 'cmf.point(%g,%g,%g)' % (self.x,self.y,self.z)

    __swig_destroy__ = _cmf_core.delete_point
point.Center = new_instancemethod(_cmf_core.point_Center,None,point)
point.distanceTo = new_instancemethod(_cmf_core.point_distanceTo,None,point)
point.distance3DTo = new_instancemethod(_cmf_core.point_distance3DTo,None,point)
point.distance_max = new_instancemethod(_cmf_core.point_distance_max,None,point)
point.azimuth = new_instancemethod(_cmf_core.point_azimuth,None,point)
point.angleToXAxis = new_instancemethod(_cmf_core.point_angleToXAxis,None,point)
point.__add__ = new_instancemethod(_cmf_core.point___add__,None,point)
point.__sub__ = new_instancemethod(_cmf_core.point___sub__,None,point)
point.__mul__ = new_instancemethod(_cmf_core.point___mul__,None,point)
point.__div__ = new_instancemethod(_cmf_core.point___div__,None,point)
point.__iadd__ = new_instancemethod(_cmf_core.point___iadd__,None,point)
point.__isub__ = new_instancemethod(_cmf_core.point___isub__,None,point)
point.__eq__ = new_instancemethod(_cmf_core.point___eq__,None,point)
point.__ne__ = new_instancemethod(_cmf_core.point___ne__,None,point)
point.__len__ = new_instancemethod(_cmf_core.point___len__,None,point)
point.__rmul__ = new_instancemethod(_cmf_core.point___rmul__,None,point)
point.__rdiv__ = new_instancemethod(_cmf_core.point___rdiv__,None,point)
point_swigregister = _cmf_core.point_swigregister
point_swigregister(point)
cvar = _cmf_core.cvar
PI = cvar.PI

def point_distance(*args):
  """point_distance(point p1, point p2) -> double"""
  return _cmf_core.point_distance(*args)

class Locatable(object):
    """Proxy of C++ cmf::geometry::Locatable class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get_position(self, *args):
        """get_position(self) -> point"""
        return _cmf_core.Locatable_get_position(self, *args)

    def set_position(self, *args):
        """set_position(self, point p)"""
        return _cmf_core.Locatable_set_position(self, *args)

    def get_distance_to(self, *args):
        """get_distance_to(self, Locatable cmp) -> double"""
        return _cmf_core.Locatable_get_distance_to(self, *args)

    def get_direction_to(self, *args):
        """get_direction_to(self, Locatable cmp) -> point"""
        return _cmf_core.Locatable_get_direction_to(self, *args)

    position=property(get_position,set_position,"The position ofthe locatabe object")

    __swig_destroy__ = _cmf_core.delete_Locatable
Locatable.get_position = new_instancemethod(_cmf_core.Locatable_get_position,None,Locatable)
Locatable.set_position = new_instancemethod(_cmf_core.Locatable_set_position,None,Locatable)
Locatable.get_distance_to = new_instancemethod(_cmf_core.Locatable_get_distance_to,None,Locatable)
Locatable.get_direction_to = new_instancemethod(_cmf_core.Locatable_get_direction_to,None,Locatable)
Locatable_swigregister = _cmf_core.Locatable_swigregister
Locatable_swigregister(Locatable)

class Location(Locatable):
    """Proxy of C++ cmf::geometry::Location class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, point position) -> Location
        __init__(self, double x, double y, double z) -> Location
        """
        _cmf_core.Location_swiginit(self,_cmf_core.new_Location(*args))
    __swig_destroy__ = _cmf_core.delete_Location
Location_swigregister = _cmf_core.Location_swigregister
Location_swigregister(Location)

class point_vector(object):
    """Proxy of C++ cmf::geometry::point_vector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    X = _swig_property(_cmf_core.point_vector_X_get, _cmf_core.point_vector_X_set)
    Y = _swig_property(_cmf_core.point_vector_Y_get, _cmf_core.point_vector_Y_set)
    Z = _swig_property(_cmf_core.point_vector_Z_get, _cmf_core.point_vector_Z_set)
    def __init__(self, *args): 
        """__init__(self, int size) -> point_vector"""
        _cmf_core.point_vector_swiginit(self,_cmf_core.new_point_vector(*args))
    def get(self, *args):
        """get(self, int index) -> point"""
        return _cmf_core.point_vector_get(self, *args)

    def set(self, *args):
        """set(self, int index, point p)"""
        return _cmf_core.point_vector_set(self, *args)

    def size(self, *args):
        """size(self) -> int"""
        return _cmf_core.point_vector_size(self, *args)

    __swig_destroy__ = _cmf_core.delete_point_vector
point_vector.get = new_instancemethod(_cmf_core.point_vector_get,None,point_vector)
point_vector.set = new_instancemethod(_cmf_core.point_vector_set,None,point_vector)
point_vector.size = new_instancemethod(_cmf_core.point_vector_size,None,point_vector)
point_vector_swigregister = _cmf_core.point_vector_swigregister
point_vector_swigregister(point_vector)

import datetime
import struct


def minimum(*args):
  """
    minimum(real a, real b) -> real

    real minimum(real a, real b)

    Returns the minimum of two values. 
    """
  return _cmf_core.minimum(*args)

def maximum(*args):
  """
    maximum(real a, real b) -> real

    real maximum(real a, real b) 
    """
  return _cmf_core.maximum(*args)

def minmax(*args):
  """
    minmax(real x, real min, real max) -> real

    real minmax(real x, real min, real
    max) 
    """
  return _cmf_core.minmax(*args)

def mean(*args):
  """mean(real a, real b) -> real"""
  return _cmf_core.mean(*args)

def geo_mean(*args):
  """geo_mean(real a, real b) -> real"""
  return _cmf_core.geo_mean(*args)

def harmonic_mean(*args):
  """harmonic_mean(real a, real b) -> real"""
  return _cmf_core.harmonic_mean(*args)

def piecewise_linear(*args):
  """
    piecewise_linear(real x, real xmin, real xmax, real ymin = 0, real ymax = 1) -> real

    real piecewise_linear(real
    x, real xmin, real xmax, real ymin=0, real ymax=1) 
    """
  return _cmf_core.piecewise_linear(*args)

def boltzmann(*args):
  """boltzmann(real x, real tau, real x_half) -> real"""
  return _cmf_core.boltzmann(*args)

def sign(*args):
  """sign(real x) -> real"""
  return _cmf_core.sign(*args)

def square(*args):
  """square(real x) -> real"""
  return _cmf_core.square(*args)
class hyperbola(object):
    """Proxy of C++ hyperbola class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def f(*args):
        """f(real x, real ymax, real K) -> real"""
        return _cmf_core.hyperbola_f(*args)

    f = staticmethod(f)
    def rounded_linear(*args):
        """
        rounded_linear(real x, real ymax = 1, real slope = 1, real roundness = 1, 
            real y_offset = 0) -> real
        """
        return _cmf_core.hyperbola_rounded_linear(*args)

    rounded_linear = staticmethod(rounded_linear)
    def rounded_linear_inverse(*args):
        """rounded_linear_inverse(real y, real ymax, real slope, real roundness, real y_offset) -> real"""
        return _cmf_core.hyperbola_rounded_linear_inverse(*args)

    rounded_linear_inverse = staticmethod(rounded_linear_inverse)
    def through_point(*args):
        """through_point(real x, real x0, real y0, real slope0, real x1, real y1) -> real"""
        return _cmf_core.hyperbola_through_point(*args)

    through_point = staticmethod(through_point)
    def __init__(self, *args): 
        """__init__(self) -> hyperbola"""
        _cmf_core.hyperbola_swiginit(self,_cmf_core.new_hyperbola(*args))
    __swig_destroy__ = _cmf_core.delete_hyperbola
hyperbola_swigregister = _cmf_core.hyperbola_swigregister
hyperbola_swigregister(hyperbola)
Debug = cvar.Debug
VERSION = cvar.VERSION
Pi = cvar.Pi

def hyperbola_f(*args):
  """hyperbola_f(real x, real ymax, real K) -> real"""
  return _cmf_core.hyperbola_f(*args)

def hyperbola_rounded_linear(*args):
  """
    hyperbola_rounded_linear(real x, real ymax = 1, real slope = 1, real roundness = 1, 
        real y_offset = 0) -> real
    """
  return _cmf_core.hyperbola_rounded_linear(*args)

def hyperbola_rounded_linear_inverse(*args):
  """hyperbola_rounded_linear_inverse(real y, real ymax, real slope, real roundness, real y_offset) -> real"""
  return _cmf_core.hyperbola_rounded_linear_inverse(*args)

def hyperbola_through_point(*args):
  """hyperbola_through_point(real x, real x0, real y0, real slope0, real x1, real y1) -> real"""
  return _cmf_core.hyperbola_through_point(*args)

JULIANDAY_0_1_1900 = _cmf_core.JULIANDAY_0_1_1900
class Time(object):
    """
    A time class, used to pass around current modelling times.

    Timespans and dates in cmf are used with a special object, called
    Time. The advantage of an extra class has the advantage, that the user
    does not has to rememember, which unit of time he or she uses or what
    time unit is accepted by a specific function of the model. Arithmetic
    and boolean operators are supported by Time. Internally the time
    classes stores the time as integer milliseconds, therefore rounding
    issues will only appear at very small time ranges. Absolute time (like
    dates) are represented as milliseconds gone by from Dec, 31st 1899.
    Microsoft Excel dates are represented as days from that time, using
    floating point numbers, therefore it is very simple to convert Excel
    time representations to cmf time.

    Another object is Date, which is doesn't provide the operators, but
    has a nice printed version and some special date functions, like day
    of year (DOY) and provides access to the current hour of day and so
    on, which only applyto dates and not to time spans. You can convert
    Time to Date an vice versa. The printing is not culture aware and uses
    the European representation. If you use the Python standard library
    datetime, conversion between Python time and cmf time is
    possibleCreating absolute time values (dates)

    import CMFlib as cmf                 # Create the time: Jan, 5th 2001,
    2:30 pm, 20s, 412 ms                 t=cmf.Time(5,1,2001,14,30,20,412)
    print t # Prints: '36896d:14:30:20.412h'                 print
    t.AsDate() # Prints: '05.01.2001 14:30:20.412'Creating time spans

    In principle, there are three ways to create time spans. One is to use
    one of the static functions, another is to multiply an existing time
    span (like one of the build in constants) or to substrate two absolute
    times.Available static functions, the default value is always 1

    Milliseconds(): t=cmf.Time.Milliseconds(4100), create a timespan of
    4.1 seconds

    Seconds(): t=cmf. Time.Seconds(4.1), create a timespan of 4.1 seconds

    Minutes(): t=cmf.Time.Minutes(138), create a timespan of 2.3 hours
    (138 min)

    Hours(): t=cmf. Time.Hours(2.3), create a timespan of 2.3 hours (138
    min)

    Days(): t=cmf. Time.Days(2.5), create a timespan of 60 hours

    Years(): t=cmf. Time.Years(), create a timespan of 365 days Available
    constants

    cmf.sec * 4.1: 4.1 seconds

    cmf.min * 138: 2.3 hours (138 min)

    cmf.h * 2.3: 2.3 hours (138 min)

    cmf.day * 2.5: 60 hours (2.5 days)

    cmf.week: 7 days

    cmf.month: 365/12 days (30.4167 days)

    cmf.year: 365 days Available operators:

    time + time = time, time - time = time

    time * float = time ,time / float = time

    time/time=float

    &gt, &lt, ==, != Conversions

    Converting to python datetime

    import CMFlib as cmf                 pythontime = cmf.year.AsPython()
    cmftime=cmf.AsCMFTime(pythontime)                 print
    type(pythontime) # '<type 'datetime.datetime'>'                 print
    type(cmftime)    # '<class 'CMFLib.Time'>'Converting to numbers

    t.AsMilliseconds()

    t.AsSeconds()

    t.AsMinutes()

    t.AsHours()

    t.AsDays()

    t.AsYears() Creating time ranges

    import CMFLib as cmf                 start=cmf.Time(5,1,2001)
    end=cmf.Time(6,1,2001)                 step=cmf.h * 6 for t in
    cmf.timerange(start,end,step):                     print t.AsDate()
    # Prints:                 # 05.01.2001 # 05.01.2001 06:00
    # 05.01.2001 12:00 # 05.01.2001 18:00

    C++ includes: Time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ms_per_day = _cmf_core.Time_ms_per_day
    def __init__(self, *args): 
        """
        __init__(self, double days) -> Time
        __init__(self, int day, int month, int year = 2001, int hour = 0, 
            int minute = 0, int second = 0, int ms = 0) -> Time
        __init__(self, Date date) -> Time
        __init__(self, Time t) -> Time
        __init__(self) -> Time

        Time()

        Standard constructor. 
        """
        _cmf_core.Time_swiginit(self,_cmf_core.new_Time(*args))
    def AsDays(self, *args):
        """
        AsDays(self) -> double

        double AsDays() const

        Time in days. 
        """
        return _cmf_core.Time_AsDays(self, *args)

    def AsHours(self, *args):
        """
        AsHours(self) -> double

        double AsHours()
        const

        Time in hours. 
        """
        return _cmf_core.Time_AsHours(self, *args)

    def AsMinutes(self, *args):
        """
        AsMinutes(self) -> double

        double AsMinutes()
        const

        Time in minutes. 
        """
        return _cmf_core.Time_AsMinutes(self, *args)

    def AsSeconds(self, *args):
        """
        AsSeconds(self) -> double

        double AsSeconds()
        const

        Time in seconds. 
        """
        return _cmf_core.Time_AsSeconds(self, *args)

    def AsMilliseconds(self, *args):
        """
        AsMilliseconds(self) -> long long

        long long
        AsMilliseconds() const

        Time in milliseconds. 
        """
        return _cmf_core.Time_AsMilliseconds(self, *args)

    def AsDate(self, *args):
        """
        AsDate(self) -> Date

        Date AsDate() const

        """
        return _cmf_core.Time_AsDate(self, *args)

    def to_string(self, *args):
        """to_string(self, char seperator = ':') -> string"""
        return _cmf_core.Time_to_string(self, *args)

    def is_not_0(self, *args):
        """is_not_0(self) -> bool"""
        return _cmf_core.Time_is_not_0(self, *args)

    def DOY(self, *args):
        """DOY(self) -> double"""
        return _cmf_core.Time_DOY(self, *args)

    def __add__(self, *args):
        """__add__(self, Time t1) -> Time"""
        return _cmf_core.Time___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Time t1) -> Time"""
        return _cmf_core.Time___sub__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, Time t1) -> Time"""
        return _cmf_core.Time___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Time t1) -> Time"""
        return _cmf_core.Time___isub__(self, *args)

    def __mod__(self, *args):
        """__mod__(self, Time t1) -> Time"""
        return _cmf_core.Time___mod__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, double x) -> Time
        __mul__(self, int x) -> Time
        """
        return _cmf_core.Time___mul__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, double x) -> Time
        __imul__(self, int x) -> Time
        """
        return _cmf_core.Time___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, double x) -> Time
        __idiv__(self, int x) -> Time
        """
        return _cmf_core.Time___idiv__(self, *args)

    def __imod__(self, *args):
        """__imod__(self, Time t1) -> Time"""
        return _cmf_core.Time___imod__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, double x) -> Time
        __div__(self, int x) -> Time
        __div__(self, Time t1) -> double
        """
        return _cmf_core.Time___div__(self, *args)

    def times_in(self, *args):
        """times_in(self, Time t1) -> long long"""
        return _cmf_core.Time_times_in(self, *args)

    def __lt__(self, *args):
        """__lt__(self, Time t1) -> bool"""
        return _cmf_core.Time___lt__(self, *args)

    def __gt__(self, *args):
        """__gt__(self, Time t1) -> bool"""
        return _cmf_core.Time___gt__(self, *args)

    def __le__(self, *args):
        """__le__(self, Time t1) -> bool"""
        return _cmf_core.Time___le__(self, *args)

    def __ge__(self, *args):
        """__ge__(self, Time t1) -> bool"""
        return _cmf_core.Time___ge__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Time t1) -> bool"""
        return _cmf_core.Time___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Time t1) -> bool"""
        return _cmf_core.Time___ne__(self, *args)

    def Years(*args):
        """Years(double y = 1) -> Time"""
        return _cmf_core.Time_Years(*args)

    Years = staticmethod(Years)
    def Days(*args):
        """Days(double d = 1) -> Time"""
        return _cmf_core.Time_Days(*args)

    Days = staticmethod(Days)
    def Hours(*args):
        """Hours(double h = 1) -> Time"""
        return _cmf_core.Time_Hours(*args)

    Hours = staticmethod(Hours)
    def Minutes(*args):
        """Minutes(double min = 1) -> Time"""
        return _cmf_core.Time_Minutes(*args)

    Minutes = staticmethod(Minutes)
    def Seconds(*args):
        """Seconds(double secs = 1) -> Time"""
        return _cmf_core.Time_Seconds(*args)

    Seconds = staticmethod(Seconds)
    def Milliseconds(*args):
        """Milliseconds(long long ms = 1) -> Time"""
        return _cmf_core.Time_Milliseconds(*args)

    Milliseconds = staticmethod(Milliseconds)
    def __repr__(self):
        if self>year*40:
            return self.AsDate().to_string()
        else:
            return self.to_string()
    def __nonzero__(self):
        return self.is_not_0();
    def __rmul__(self,other):
        return self*other;
    def AsPython(self):
        d=self.AsDate()
        return datetime.datetime(d.year,d.month,d.day,d.hour,d.minute,d.second,d.ms*1000)

    __swig_destroy__ = _cmf_core.delete_Time
Time.AsDays = new_instancemethod(_cmf_core.Time_AsDays,None,Time)
Time.AsHours = new_instancemethod(_cmf_core.Time_AsHours,None,Time)
Time.AsMinutes = new_instancemethod(_cmf_core.Time_AsMinutes,None,Time)
Time.AsSeconds = new_instancemethod(_cmf_core.Time_AsSeconds,None,Time)
Time.AsMilliseconds = new_instancemethod(_cmf_core.Time_AsMilliseconds,None,Time)
Time.AsDate = new_instancemethod(_cmf_core.Time_AsDate,None,Time)
Time.to_string = new_instancemethod(_cmf_core.Time_to_string,None,Time)
Time.is_not_0 = new_instancemethod(_cmf_core.Time_is_not_0,None,Time)
Time.DOY = new_instancemethod(_cmf_core.Time_DOY,None,Time)
Time.__add__ = new_instancemethod(_cmf_core.Time___add__,None,Time)
Time.__sub__ = new_instancemethod(_cmf_core.Time___sub__,None,Time)
Time.__iadd__ = new_instancemethod(_cmf_core.Time___iadd__,None,Time)
Time.__isub__ = new_instancemethod(_cmf_core.Time___isub__,None,Time)
Time.__mod__ = new_instancemethod(_cmf_core.Time___mod__,None,Time)
Time.__mul__ = new_instancemethod(_cmf_core.Time___mul__,None,Time)
Time.__imul__ = new_instancemethod(_cmf_core.Time___imul__,None,Time)
Time.__idiv__ = new_instancemethod(_cmf_core.Time___idiv__,None,Time)
Time.__imod__ = new_instancemethod(_cmf_core.Time___imod__,None,Time)
Time.__div__ = new_instancemethod(_cmf_core.Time___div__,None,Time)
Time.times_in = new_instancemethod(_cmf_core.Time_times_in,None,Time)
Time.__lt__ = new_instancemethod(_cmf_core.Time___lt__,None,Time)
Time.__gt__ = new_instancemethod(_cmf_core.Time___gt__,None,Time)
Time.__le__ = new_instancemethod(_cmf_core.Time___le__,None,Time)
Time.__ge__ = new_instancemethod(_cmf_core.Time___ge__,None,Time)
Time.__eq__ = new_instancemethod(_cmf_core.Time___eq__,None,Time)
Time.__ne__ = new_instancemethod(_cmf_core.Time___ne__,None,Time)
Time_swigregister = _cmf_core.Time_swigregister
Time_swigregister(Time)

def Time_Years(*args):
  """Time_Years(double y = 1) -> Time"""
  return _cmf_core.Time_Years(*args)

def Time_Days(*args):
  """Time_Days(double d = 1) -> Time"""
  return _cmf_core.Time_Days(*args)

def Time_Hours(*args):
  """Time_Hours(double h = 1) -> Time"""
  return _cmf_core.Time_Hours(*args)

def Time_Minutes(*args):
  """Time_Minutes(double min = 1) -> Time"""
  return _cmf_core.Time_Minutes(*args)

def Time_Seconds(*args):
  """Time_Seconds(double secs = 1) -> Time"""
  return _cmf_core.Time_Seconds(*args)

def Time_Milliseconds(*args):
  """Time_Milliseconds(long long ms = 1) -> Time"""
  return _cmf_core.Time_Milliseconds(*args)


def minimum_t(*args):
  """minimum_t(Time t1, Time t2) -> Time"""
  return _cmf_core.minimum_t(*args)

def maximum_t(*args):
  """maximum_t(Time t1, Time t2) -> Time"""
  return _cmf_core.maximum_t(*args)
class Date(object):
    """
    An absolute time, not for calculation. Date and Time are
    interchangable.

    C++ includes: Time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    year = _swig_property(_cmf_core.Date_year_get, _cmf_core.Date_year_set)
    month = _swig_property(_cmf_core.Date_month_get, _cmf_core.Date_month_set)
    day = _swig_property(_cmf_core.Date_day_get, _cmf_core.Date_day_set)
    hour = _swig_property(_cmf_core.Date_hour_get, _cmf_core.Date_hour_set)
    minute = _swig_property(_cmf_core.Date_minute_get, _cmf_core.Date_minute_set)
    second = _swig_property(_cmf_core.Date_second_get, _cmf_core.Date_second_set)
    ms = _swig_property(_cmf_core.Date_ms_get, _cmf_core.Date_ms_set)
    def __init__(self, *args): 
        """
        __init__(self, int _day, int _month, int _year = 2001, int _hour = 0, 
            int _minute = 0, int _second = 0, int _ms = 0) -> Date
        __init__(self, Time time) -> Date

        Date(const Time &time)

        Creates a new date from time (based on the 31.12.1899, like in
        Excel(TM)). 
        """
        _cmf_core.Date_swiginit(self,_cmf_core.new_Date(*args))
    def ToTime(self, *args):
        """
        ToTime(self) -> Time

        Time ToTime()

        Converts a date to Time (based on the 31.12.1899, like in Excel(TM).

        """
        return _cmf_core.Date_ToTime(self, *args)

    def DOY(self, *args):
        """
        DOY(self) -> double

        int DOY()

        Returns the day of year. 
        """
        return _cmf_core.Date_DOY(self, *args)

    def to_string(self, *args):
        """to_string(self) -> string"""
        return _cmf_core.Date_to_string(self, *args)

    def __repr__(self):
        return self.to_string()
    def AsPython(self):
        return datetime.datetime(self.year,self.month,self.day,self.hour,self.minute,self.second,self.ms*1000)

    __swig_destroy__ = _cmf_core.delete_Date
Date.ToTime = new_instancemethod(_cmf_core.Date_ToTime,None,Date)
Date.DOY = new_instancemethod(_cmf_core.Date_DOY,None,Date)
Date.to_string = new_instancemethod(_cmf_core.Date_to_string,None,Date)
Date_swigregister = _cmf_core.Date_swigregister
Date_swigregister(Date)

class timeseries(object):
    """
    A timeseries is a list of values, equally distributed over time. To
    create one, one have to provide as start date and a step size. The end
    time is calculated from the number of values. Values queried for times
    before the start time are returned as the first item, values after the
    end time equal the last item. A timeseries with only one item reacts
    like a scalar value.

    Creating a time series

    import CMFLib as cmf                 # Start date is the January 5th
    2001 at 2:30 pm start=cmf.Time(5,1,2001,14,30)
    # time step of the timeseries is 20 minutes
    step=cmf.min*20                 # Type of interpolation between values
    # 0 - Nearest neighbor,                 # 1 - Linear,
    # 2 - Squared, # 3 - Cubic, etc.                 interpolation=1 #
    Create timeseries
    timeseries=cmf.timeseries(start,step,interpolation) # Add data
    timeseries.Add(0.1) # Value at 2001/5/1 2:30pm is 0.1
    timeseries.Add(0.2) # Value at 2001/5/1 2:50pm is 0.2
    timeseries.Add(0.1) # Value at 2001/5/1 3:10pm is 0.1

    With this technic it is simple to read files or databases to fill
    timeseries.Using a timeseries

    # Query every minute between 2:15 and 3:14 pm for t in
    cmf.timerange(start,start+cmf.h,cmf.min): print
    "Time:",t.AsDate(),"Value:", timeseries[t]                 # Query
    a specific position of the timeseries                 print
    timeseries[2]

    C++ includes: timeseries.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def interpolationpower(self, *args):
        """interpolationpower(self) -> double"""
        return _cmf_core.timeseries_interpolationpower(self, *args)

    def add(self, *args):
        """add(self, double Value)"""
        return _cmf_core.timeseries_add(self, *args)

    def is_empty(self, *args):
        """is_empty(self) -> bool"""
        return _cmf_core.timeseries_is_empty(self, *args)

    def clear(self, *args):
        """
        clear(self)

        void clear() 
        """
        return _cmf_core.timeseries_clear(self, *args)

    def adress(self, *args):
        """adress(self) -> size_t"""
        return _cmf_core.timeseries_adress(self, *args)

    def copy(self, *args):
        """copy(self) -> timeseries"""
        return _cmf_core.timeseries_copy(self, *args)

    def size(self, *args):
        """
        size(self) -> int

        int size() const

        """
        return _cmf_core.timeseries_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, Time _begin, Time _step, int _interpolationmethod = 1) -> timeseries
        __init__(self) -> timeseries
        __init__(self, timeseries ts) -> timeseries
        __init__(self, double scalar) -> timeseries

        timeseries(const cmf::math::timeseries &ts) 
        """
        _cmf_core.timeseries_swiginit(self,_cmf_core.new_timeseries(*args))
    def get_t(self, *args):
        """get_t(self, Time t) -> double"""
        return _cmf_core.timeseries_get_t(self, *args)

    def get_i(self, *args):
        """get_i(self, int i) -> double"""
        return _cmf_core.timeseries_get_i(self, *args)

    def set_t(self, *args):
        """set_t(self, Time t, double value)"""
        return _cmf_core.timeseries_set_t(self, *args)

    def set_i(self, *args):
        """set_i(self, int i, double value)"""
        return _cmf_core.timeseries_set_i(self, *args)

    def get_slice(self, *args):
        """
        get_slice(self, Time _begin, Time _end, Time _step = cmf::math::Time()) -> timeseries
        get_slice(self, int _begin, int _end, int step = 1) -> timeseries
        """
        return _cmf_core.timeseries_get_slice(self, *args)

    def set_slice(self, *args):
        """
        set_slice(self, Time _begin, Time _end, timeseries values)
        set_slice(self, int _begin, int _end, timeseries _values)
        """
        return _cmf_core.timeseries_set_slice(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, timeseries arg0) -> timeseries
        __iadd__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, timeseries arg0) -> timeseries
        __isub__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___isub__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, timeseries arg0) -> timeseries
        __imul__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, timeseries arg0) -> timeseries
        __idiv__(self, double arg0) -> timeseries
        """
        return _cmf_core.timeseries___idiv__(self, *args)

    def __add__(self, *args):
        """
        __add__(self, timeseries arg0) -> timeseries
        __add__(self, double other) -> timeseries
        """
        return _cmf_core.timeseries___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, timeseries other) -> timeseries
        __sub__(self, double other) -> timeseries
        """
        return _cmf_core.timeseries___sub__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, timeseries other) -> timeseries
        __mul__(self, double other) -> timeseries
        """
        return _cmf_core.timeseries___mul__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, timeseries other) -> timeseries
        __div__(self, double other) -> timeseries
        """
        return _cmf_core.timeseries___div__(self, *args)

    def __neg__(self, *args):
        """__neg__(self) -> timeseries"""
        return _cmf_core.timeseries___neg__(self, *args)

    def inv(self, *args):
        """inv(self) -> timeseries"""
        return _cmf_core.timeseries_inv(self, *args)

    def reduce_min(self, *args):
        """
        reduce_min(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_min(cmf::math::Time begin, cmf::math::Time step) const 
        """
        return _cmf_core.timeseries_reduce_min(self, *args)

    def reduce_max(self, *args):
        """
        reduce_max(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_max(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the minimum.

        """
        return _cmf_core.timeseries_reduce_max(self, *args)

    def reduce_sum(self, *args):
        """
        reduce_sum(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_sum(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the maximum.

        """
        return _cmf_core.timeseries_reduce_sum(self, *args)

    def reduce_avg(self, *args):
        """
        reduce_avg(self, Time begin, Time step) -> timeseries

        timeseries
        reduce_avg(cmf::math::Time begin, cmf::math::Time step) const

        Creates a timeseries with a bigger timestep, containing the sum. 
        """
        return _cmf_core.timeseries_reduce_avg(self, *args)

    def floating_avg(self, *args):
        """floating_avg(self, Time window_width) -> timeseries"""
        return _cmf_core.timeseries_floating_avg(self, *args)

    def floating_max(self, *args):
        """floating_max(self, Time window_width) -> timeseries"""
        return _cmf_core.timeseries_floating_max(self, *args)

    def floating_min(self, *args):
        """floating_min(self, Time window_width) -> timeseries"""
        return _cmf_core.timeseries_floating_min(self, *args)

    def mean(self, *args):
        """mean(self) -> double"""
        return _cmf_core.timeseries_mean(self, *args)

    def min(self, *args):
        """min(self) -> double"""
        return _cmf_core.timeseries_min(self, *args)

    def max(self, *args):
        """max(self) -> double"""
        return _cmf_core.timeseries_max(self, *args)

    def log(self, *args):
        """log(self) -> timeseries"""
        return _cmf_core.timeseries_log(self, *args)

    def log10(self, *args):
        """log10(self) -> timeseries"""
        return _cmf_core.timeseries_log10(self, *args)

    def power(self, *args):
        """
        power(self, double exponent) -> timeseries

        timeseries&
        power(double)

        raises the timeseries to a power 
        """
        return _cmf_core.timeseries_power(self, *args)

    def exp(self, *args):
        """exp(self) -> timeseries"""
        return _cmf_core.timeseries_exp(self, *args)

    begin = _swig_property(_cmf_core.timeseries_begin_get)
    step = _swig_property(_cmf_core.timeseries_step_get)
    end = _swig_property(_cmf_core.timeseries_end_get)
    def __len__(self, *args):
        """__len__(self) -> double"""
        return _cmf_core.timeseries___len__(self, *args)

    def __repr__(self):
       return "cmf.timeseries(%s:%s:%s,count=%i)" % (self.begin,self.end,self.step,self.size())
    def extend(self,list) :
        """ Adds the values of a sequence to the timeseries"""
        for item in list :
            self.add(float(item))
    def __getitem__(self,index):
        if isinstance(index,int):
            return self.get_i(index)
        elif isinstance(index,slice):
            if index.step:
                return self.get_slice(index.start,index.stop,index.step)
            else:
                return self.get_slice(index.start,index.stop)
        else:
            return self.get_t(index)
    def __setitem__(self,index,value):
        if isinstance(index,int):
            self.set_i(index,value)
        if isinstance(index,slice):
            if index.step:
                raise ValueError("Slices must be continous, when used for setting")
            else:
                if not isinstance(value,timeseries):
                    value=timeseries(value)
                self.set_slice(index.start,index.stop,value)
        else:
            self.set_t(index,value)
    def __iter__(self):
        for i in xrange(self.size()):
            yield self.get_i(i)
    def interpolate(self,begin,end,step):
        """ Returns a generator returning the interpolated values at the timesteps """
        if step>self.step():
            ts=self.reduce_avg(begin,step)
        else:
            ts=self
        for t in timerange(step,end,step):
            yield ts[t]
    def __radd__(self,other):
        return self + other;
    def __rmul__(self,other):
        return self + other;
    def __rsub__(self,other):
        res=-self
        res+=other
        return res
    def __rdiv__(self,other):
        res=self.inv() 
        res*=other
        return res
    def iter_time(self, as_float=0):
        """Returns an iterator to iterate over each timestep
        as_float if True, the timesteps will returned as floating point numbers representing the days after 1.1.0001 00:00
        """
        for i in xrange(len(self)):
            if as_float:
                yield ((self.begin + self.step * i) - cmf.Time(1,1,1)).AsDays()
            else:
                yield self.begin + self.step * i
    def to_buffer(self):
        """Returns a binary buffer filled with the data of self"""
        return struct.pack('qqqq%id' % self.size(),self.begin.AsMilliseconds(),self.step.AsMilliseconds(),self.interpolationpower(), *self)
    def to_file(self,f):
        """ Saves a timeseries in a special binary format.
        The format consists of 4 integers with 64 bit, indicating the milliseconds after the 31.12.1899 00:00 of the beginning of the timeseries, the milliseconds of the time step,
        the interpolation power and the number of values. The following 64 bit floats, are the values of the timeseries
        """
        if isinstance(f,str):
            f=file(f,'wb')
        elif not hasattr(f,'write'):
            raise TypeError("The file f must be either an object providing a write method, like a file, or a valid file name")
        f.write(struct.pack('qqqq%id' % self.size(),  self.size(), self.begin.AsMilliseconds(),self.step.AsMilliseconds(),self.interpolationpower(), *self))
        
    @classmethod
    def from_sequence(cls,begin,step,sequence=[],interpolation_mode=1):
        res=cmf.timeseries(begin,step,interpolation_mode)
        res.extend(sequence)
        
    @classmethod
    def from_buffer(cls,buf):
        header_length=struct.calcsize('qqqq') 
        header=struct.unpack('qqqq',buffer[:header_length])
        res=cls(header[1]*ms,header[2]*ms,header[3])
        res.extend(struct.unpack('%id' % header[0],*buffer(buf,header_length,header[0]*8)))
    @classmethod
    def from_file(cls,f):
        """ Loads a timeseries saved with to_file from a file 
        Description of the file layout:
        byte: 
        0   Number of (int64)
        8   Begin of timeseries (in ms since 31.12.1899 00:00) (int64)
        16  Step size of timeseries (in ms) (int64)
        24  Interpolation power (int64)
        32  First value of timeseries (float64)
        """
        if isinstance(f,str):
            f=file(f,'rb')
        elif not hasattr(f,'read'):
            raise TypeError("The file f must either implement a 'read' method, like a file, or must be a vild file name")
        header_length=struct.calcsize('qqqq') 
        header=struct.unpack('qqqq',f.read(header_length))
        res=cls(header[1]*ms,header[2]*ms,header[3])
        res.extend(struct.unpack('%id' % header[0],f.read(-1)))
        return res

    __swig_destroy__ = _cmf_core.delete_timeseries
timeseries.interpolationpower = new_instancemethod(_cmf_core.timeseries_interpolationpower,None,timeseries)
timeseries.add = new_instancemethod(_cmf_core.timeseries_add,None,timeseries)
timeseries.is_empty = new_instancemethod(_cmf_core.timeseries_is_empty,None,timeseries)
timeseries.clear = new_instancemethod(_cmf_core.timeseries_clear,None,timeseries)
timeseries.adress = new_instancemethod(_cmf_core.timeseries_adress,None,timeseries)
timeseries.copy = new_instancemethod(_cmf_core.timeseries_copy,None,timeseries)
timeseries.size = new_instancemethod(_cmf_core.timeseries_size,None,timeseries)
timeseries.get_t = new_instancemethod(_cmf_core.timeseries_get_t,None,timeseries)
timeseries.get_i = new_instancemethod(_cmf_core.timeseries_get_i,None,timeseries)
timeseries.set_t = new_instancemethod(_cmf_core.timeseries_set_t,None,timeseries)
timeseries.set_i = new_instancemethod(_cmf_core.timeseries_set_i,None,timeseries)
timeseries.get_slice = new_instancemethod(_cmf_core.timeseries_get_slice,None,timeseries)
timeseries.set_slice = new_instancemethod(_cmf_core.timeseries_set_slice,None,timeseries)
timeseries.__iadd__ = new_instancemethod(_cmf_core.timeseries___iadd__,None,timeseries)
timeseries.__isub__ = new_instancemethod(_cmf_core.timeseries___isub__,None,timeseries)
timeseries.__imul__ = new_instancemethod(_cmf_core.timeseries___imul__,None,timeseries)
timeseries.__idiv__ = new_instancemethod(_cmf_core.timeseries___idiv__,None,timeseries)
timeseries.__add__ = new_instancemethod(_cmf_core.timeseries___add__,None,timeseries)
timeseries.__sub__ = new_instancemethod(_cmf_core.timeseries___sub__,None,timeseries)
timeseries.__mul__ = new_instancemethod(_cmf_core.timeseries___mul__,None,timeseries)
timeseries.__div__ = new_instancemethod(_cmf_core.timeseries___div__,None,timeseries)
timeseries.__neg__ = new_instancemethod(_cmf_core.timeseries___neg__,None,timeseries)
timeseries.inv = new_instancemethod(_cmf_core.timeseries_inv,None,timeseries)
timeseries.reduce_min = new_instancemethod(_cmf_core.timeseries_reduce_min,None,timeseries)
timeseries.reduce_max = new_instancemethod(_cmf_core.timeseries_reduce_max,None,timeseries)
timeseries.reduce_sum = new_instancemethod(_cmf_core.timeseries_reduce_sum,None,timeseries)
timeseries.reduce_avg = new_instancemethod(_cmf_core.timeseries_reduce_avg,None,timeseries)
timeseries.floating_avg = new_instancemethod(_cmf_core.timeseries_floating_avg,None,timeseries)
timeseries.floating_max = new_instancemethod(_cmf_core.timeseries_floating_max,None,timeseries)
timeseries.floating_min = new_instancemethod(_cmf_core.timeseries_floating_min,None,timeseries)
timeseries.mean = new_instancemethod(_cmf_core.timeseries_mean,None,timeseries)
timeseries.min = new_instancemethod(_cmf_core.timeseries_min,None,timeseries)
timeseries.max = new_instancemethod(_cmf_core.timeseries_max,None,timeseries)
timeseries.log = new_instancemethod(_cmf_core.timeseries_log,None,timeseries)
timeseries.log10 = new_instancemethod(_cmf_core.timeseries_log10,None,timeseries)
timeseries.power = new_instancemethod(_cmf_core.timeseries_power,None,timeseries)
timeseries.exp = new_instancemethod(_cmf_core.timeseries_exp,None,timeseries)
timeseries.__len__ = new_instancemethod(_cmf_core.timeseries___len__,None,timeseries)
timeseries_swigregister = _cmf_core.timeseries_swigregister
timeseries_swigregister(timeseries)
ms = cvar.ms
sec = cvar.sec
min = cvar.min
h = cvar.h
day = cvar.day
week = cvar.week
month = cvar.month
year = cvar.year


def nash_sutcliff(*args):
  """nash_sutcliff(timeseries model, timeseries observation) -> double"""
  return _cmf_core.nash_sutcliff(*args)

def R2(*args):
  """R2(timeseries model, timeseries observation) -> double"""
  return _cmf_core.R2(*args)
def AsCMFtime(date):
    """Converts a python datetime to cmf.Time"""
    return Time(date.day,date.month,date.year,date.hour,date.minute,date.second,date.microsecond/1000)
def timerange(start,end,step=day):
    """Creates a generator of cmf.Time, similar to the Python range function"""
    return [start+step*x for x in range(0,int((end-start)/step))]
def xtimerange(start,end,step=day):
    """Creates a generator of cmf.Time, similar to the Python range function"""
    return (start+step*x for x in range(0,int((end-start)/step)))

class num_array(object):
    """Proxy of C++ cmf::math::num_array class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, int count, real Value = 0) -> num_array
        __init__(self, size_t count, real Value = 0) -> num_array
        __init__(self) -> num_array
        __init__(self, num_array Vector) -> num_array
        __init__(self, double data, int count) -> num_array
        """
        _cmf_core.num_array_swiginit(self,_cmf_core.new_num_array(*args))
    def __set_data_from_adress(self, *args):
        """__set_data_from_adress(self, size_t data_adress, size_t count)"""
        return _cmf_core.num_array___set_data_from_adress(self, *args)

    def adress(self, *args):
        """adress(self) -> size_t"""
        return _cmf_core.num_array_adress(self, *args)

    __swig_destroy__ = _cmf_core.delete_num_array
    def size(self, *args):
        """size(self) -> int"""
        return _cmf_core.num_array_size(self, *args)

    def resize(self, *args):
        """
        resize(self, int count)
        resize(self, size_t count)
        """
        return _cmf_core.num_array_resize(self, *args)

    def __neg__(self, *args):
        """__neg__(self) -> num_array"""
        return _cmf_core.num_array___neg__(self, *args)

    def power(self, *args):
        """
        power(self, num_array arg0) -> num_array
        power(self, real exponent) -> num_array
        """
        return _cmf_core.num_array_power(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(self, num_array arg0) -> num_array
        __iadd__(self, real arg0) -> num_array
        """
        return _cmf_core.num_array___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(self, num_array arg0) -> num_array
        __isub__(self, real arg0) -> num_array
        """
        return _cmf_core.num_array___isub__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, num_array arg0) -> num_array
        __imul__(self, real arg0) -> num_array
        """
        return _cmf_core.num_array___imul__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(self, num_array arg0) -> num_array
        __idiv__(self, real arg0) -> num_array
        """
        return _cmf_core.num_array___idiv__(self, *args)

    def apply(self, *args):
        """apply(self, real funct) -> num_array"""
        return _cmf_core.num_array_apply(self, *args)

    def dot(self, *args):
        """dot(self, num_array arg0) -> real"""
        return _cmf_core.num_array_dot(self, *args)

    def sum(self, *args):
        """sum(self) -> real"""
        return _cmf_core.num_array_sum(self, *args)

    def max(self, *args):
        """max(self) -> real"""
        return _cmf_core.num_array_max(self, *args)

    def min(self, *args):
        """min(self) -> real"""
        return _cmf_core.num_array_min(self, *args)

    def mean(self, *args):
        """mean(self) -> real"""
        return _cmf_core.num_array_mean(self, *args)

    def norm(self, *args):
        """norm(self, int normtype = 0) -> real"""
        return _cmf_core.num_array_norm(self, *args)

    def __add__(self, *args):
        """
        __add__(self, num_array _Right) -> num_array
        __add__(self, real _Right) -> num_array
        """
        return _cmf_core.num_array___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, num_array _Right) -> num_array
        __sub__(self, real _Right) -> num_array
        """
        return _cmf_core.num_array___sub__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, num_array _Right) -> num_array
        __mul__(self, real _Right) -> num_array
        """
        return _cmf_core.num_array___mul__(self, *args)

    def __div__(self, *args):
        """
        __div__(self, num_array _Right) -> num_array
        __div__(self, real _Right) -> num_array
        """
        return _cmf_core.num_array___div__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, int index) -> double"""
        return _cmf_core.num_array___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, int index, double value)"""
        return _cmf_core.num_array___setitem__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> int"""
        return _cmf_core.num_array___len__(self, *args)

    def __radd__(self, *args):
        """__radd__(self, real other) -> num_array"""
        return _cmf_core.num_array___radd__(self, *args)

    def __rsub__(self, *args):
        """__rsub__(self, real other) -> num_array"""
        return _cmf_core.num_array___rsub__(self, *args)

    def __rmul__(self, *args):
        """__rmul__(self, real other) -> num_array"""
        return _cmf_core.num_array___rmul__(self, *args)

    def __rdiv__(self, *args):
        """__rdiv__(self, real other) -> num_array"""
        return _cmf_core.num_array___rdiv__(self, *args)

    def __iter__(self):
        for i in xrange(len(self)):
            yield self[i]
    @property
    def __array_interface__(self):
        return dict(shape=(len(self),),typestr='|f8',data=(self.adress(),0),version=3)
    def ravel(self,order='C'):
        return self
    def __repr__(self):
        return 'cmf.num_array(%g, ..., %g, size=%i)' % (self[0],self[-1],self.size())

num_array.__set_data_from_adress = new_instancemethod(_cmf_core.num_array___set_data_from_adress,None,num_array)
num_array.adress = new_instancemethod(_cmf_core.num_array_adress,None,num_array)
num_array.size = new_instancemethod(_cmf_core.num_array_size,None,num_array)
num_array.resize = new_instancemethod(_cmf_core.num_array_resize,None,num_array)
num_array.__neg__ = new_instancemethod(_cmf_core.num_array___neg__,None,num_array)
num_array.power = new_instancemethod(_cmf_core.num_array_power,None,num_array)
num_array.__iadd__ = new_instancemethod(_cmf_core.num_array___iadd__,None,num_array)
num_array.__isub__ = new_instancemethod(_cmf_core.num_array___isub__,None,num_array)
num_array.__imul__ = new_instancemethod(_cmf_core.num_array___imul__,None,num_array)
num_array.__idiv__ = new_instancemethod(_cmf_core.num_array___idiv__,None,num_array)
num_array.apply = new_instancemethod(_cmf_core.num_array_apply,None,num_array)
num_array.dot = new_instancemethod(_cmf_core.num_array_dot,None,num_array)
num_array.sum = new_instancemethod(_cmf_core.num_array_sum,None,num_array)
num_array.max = new_instancemethod(_cmf_core.num_array_max,None,num_array)
num_array.min = new_instancemethod(_cmf_core.num_array_min,None,num_array)
num_array.mean = new_instancemethod(_cmf_core.num_array_mean,None,num_array)
num_array.norm = new_instancemethod(_cmf_core.num_array_norm,None,num_array)
num_array.__add__ = new_instancemethod(_cmf_core.num_array___add__,None,num_array)
num_array.__sub__ = new_instancemethod(_cmf_core.num_array___sub__,None,num_array)
num_array.__mul__ = new_instancemethod(_cmf_core.num_array___mul__,None,num_array)
num_array.__div__ = new_instancemethod(_cmf_core.num_array___div__,None,num_array)
num_array.__getitem__ = new_instancemethod(_cmf_core.num_array___getitem__,None,num_array)
num_array.__setitem__ = new_instancemethod(_cmf_core.num_array___setitem__,None,num_array)
num_array.__len__ = new_instancemethod(_cmf_core.num_array___len__,None,num_array)
num_array.__radd__ = new_instancemethod(_cmf_core.num_array___radd__,None,num_array)
num_array.__rsub__ = new_instancemethod(_cmf_core.num_array___rsub__,None,num_array)
num_array.__rmul__ = new_instancemethod(_cmf_core.num_array___rmul__,None,num_array)
num_array.__rdiv__ = new_instancemethod(_cmf_core.num_array___rdiv__,None,num_array)
num_array_swigregister = _cmf_core.num_array_swigregister
num_array_swigregister(num_array)


def __add__(*args):
  """__add__(real _Left, num_array _Right) -> num_array"""
  return _cmf_core.__add__(*args)

def __sub__(*args):
  """__sub__(real _Left, num_array _Right) -> num_array"""
  return _cmf_core.__sub__(*args)

def __div__(*args):
  """__div__(real _Left, num_array _Right) -> num_array"""
  return _cmf_core.__div__(*args)
def to_num_array(arraylike):
    if hasattr(arraylike,'__array_interface__'):
        interface=arraylike.__array_interface__
        if len(interface['shape'])!=1:
            raise RuntimeError('Only 1d arrays are convertible to cmf.num_arrays')
        res=num_array(interface['shape'][0])
        res.__set_data_from_adress(interface['data'][0],interface['shape'][0])    
    else:
        res=num_array(len(arraylike))
        for i,v in enumerate(arraylike):
            res[i]=v
    return res
        

class svVector(object):
    """Proxy of C++ std::vector<(p.cmf::math::StateVariable)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.svVector_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.svVector___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.svVector___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_type"""
        return _cmf_core.svVector___len__(self, *args)

    def pop(self, *args):
        """pop(self) -> value_type"""
        return _cmf_core.svVector_pop(self, *args)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> svVector"""
        return _cmf_core.svVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, svVector v)"""
        return _cmf_core.svVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.svVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.svVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> svVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.svVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, svVector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.svVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.svVector_append(self, *args)

    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.svVector_empty(self, *args)

    def size(self, *args):
        """size(self) -> size_type"""
        return _cmf_core.svVector_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.svVector_clear(self, *args)

    def swap(self, *args):
        """swap(self, svVector v)"""
        return _cmf_core.svVector_swap(self, *args)

    def get_allocator(self, *args):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.svVector_get_allocator(self, *args)

    def begin(self, *args):
        """begin(self) -> const_iterator"""
        return _cmf_core.svVector_begin(self, *args)

    def end(self, *args):
        """end(self) -> const_iterator"""
        return _cmf_core.svVector_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.svVector_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.svVector_rend(self, *args)

    def pop_back(self, *args):
        """pop_back(self)"""
        return _cmf_core.svVector_pop_back(self, *args)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.svVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> svVector
        __init__(self, svVector arg0) -> svVector
        __init__(self, size_type size) -> svVector
        __init__(self, size_type size, value_type value) -> svVector
        """
        _cmf_core.svVector_swiginit(self,_cmf_core.new_svVector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.svVector_push_back(self, *args)

    def front(self, *args):
        """front(self) -> value_type"""
        return _cmf_core.svVector_front(self, *args)

    def back(self, *args):
        """back(self) -> value_type"""
        return _cmf_core.svVector_back(self, *args)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.svVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.svVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.svVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.svVector_reserve(self, *args)

    def capacity(self, *args):
        """capacity(self) -> size_type"""
        return _cmf_core.svVector_capacity(self, *args)

    __swig_destroy__ = _cmf_core.delete_svVector
svVector.iterator = new_instancemethod(_cmf_core.svVector_iterator,None,svVector)
svVector.__nonzero__ = new_instancemethod(_cmf_core.svVector___nonzero__,None,svVector)
svVector.__bool__ = new_instancemethod(_cmf_core.svVector___bool__,None,svVector)
svVector.__len__ = new_instancemethod(_cmf_core.svVector___len__,None,svVector)
svVector.pop = new_instancemethod(_cmf_core.svVector_pop,None,svVector)
svVector.__getslice__ = new_instancemethod(_cmf_core.svVector___getslice__,None,svVector)
svVector.__setslice__ = new_instancemethod(_cmf_core.svVector___setslice__,None,svVector)
svVector.__delslice__ = new_instancemethod(_cmf_core.svVector___delslice__,None,svVector)
svVector.__delitem__ = new_instancemethod(_cmf_core.svVector___delitem__,None,svVector)
svVector.__getitem__ = new_instancemethod(_cmf_core.svVector___getitem__,None,svVector)
svVector.__setitem__ = new_instancemethod(_cmf_core.svVector___setitem__,None,svVector)
svVector.append = new_instancemethod(_cmf_core.svVector_append,None,svVector)
svVector.empty = new_instancemethod(_cmf_core.svVector_empty,None,svVector)
svVector.size = new_instancemethod(_cmf_core.svVector_size,None,svVector)
svVector.clear = new_instancemethod(_cmf_core.svVector_clear,None,svVector)
svVector.swap = new_instancemethod(_cmf_core.svVector_swap,None,svVector)
svVector.get_allocator = new_instancemethod(_cmf_core.svVector_get_allocator,None,svVector)
svVector.begin = new_instancemethod(_cmf_core.svVector_begin,None,svVector)
svVector.end = new_instancemethod(_cmf_core.svVector_end,None,svVector)
svVector.rbegin = new_instancemethod(_cmf_core.svVector_rbegin,None,svVector)
svVector.rend = new_instancemethod(_cmf_core.svVector_rend,None,svVector)
svVector.pop_back = new_instancemethod(_cmf_core.svVector_pop_back,None,svVector)
svVector.erase = new_instancemethod(_cmf_core.svVector_erase,None,svVector)
svVector.push_back = new_instancemethod(_cmf_core.svVector_push_back,None,svVector)
svVector.front = new_instancemethod(_cmf_core.svVector_front,None,svVector)
svVector.back = new_instancemethod(_cmf_core.svVector_back,None,svVector)
svVector.assign = new_instancemethod(_cmf_core.svVector_assign,None,svVector)
svVector.resize = new_instancemethod(_cmf_core.svVector_resize,None,svVector)
svVector.insert = new_instancemethod(_cmf_core.svVector_insert,None,svVector)
svVector.reserve = new_instancemethod(_cmf_core.svVector_reserve,None,svVector)
svVector.capacity = new_instancemethod(_cmf_core.svVector_capacity,None,svVector)
svVector_swigregister = _cmf_core.svVector_swigregister
svVector_swigregister(svVector)

def __mul__(*args):
  """
    __mul__(double f, Time t) -> Time
    __mul__(int f, Time t) -> Time
    __mul__(real _Left, num_array _Right) -> num_array
    """
  return _cmf_core.__mul__(*args)

class StateVariable(object):
    """
    Abstract class state variable

    Simple exponential system class header implementing a state variable:

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def Derivate(self, *args):
        """
        Derivate(self, Time time) -> real

        virtual
        real Derivate(const cmf::math::Time &time)=0

        Returns the derivate of the state variable at time time. 
        """
        return _cmf_core.StateVariable_Derivate(self, *args)

    def StateIsChanged(self, *args):
        """
        StateIsChanged(self) -> bool

        bool
        StateIsChanged()

        Returns if the state was currently updated. 
        """
        return _cmf_core.StateVariable_StateIsChanged(self, *args)

    state = _swig_property(_cmf_core.StateVariable_state_get, _cmf_core.StateVariable_state_set)
    __swig_destroy__ = _cmf_core.delete_StateVariable
StateVariable.Derivate = new_instancemethod(_cmf_core.StateVariable_Derivate,None,StateVariable)
StateVariable.StateIsChanged = new_instancemethod(_cmf_core.StateVariable_StateIsChanged,None,StateVariable)
StateVariable_swigregister = _cmf_core.StateVariable_swigregister
StateVariable_swigregister(StateVariable)

class StateVariableVector(svVector):
    """
    A vector of state variables, can be solved by RKFIntegrator.

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    use_OpenMP = _swig_property(_cmf_core.StateVariableVector_use_OpenMP_get, _cmf_core.StateVariableVector_use_OpenMP_set)
    def CopyStates(self, *args):
        """
        CopyStates(self, num_array destination)
        CopyStates(self, real destination)

        void CopyStates(numVector &destination) const

        Copies the states to a numeric vector using OpenMP. 
        """
        return _cmf_core.StateVariableVector_CopyStates(self, *args)

    def SetStates(self, *args):
        """
        SetStates(self, num_array newStates)
        SetStates(self, real newStates)

        void SetStates(const numVector &newStates)

        Copies the new states to the actual states. 
        """
        return _cmf_core.StateVariableVector_SetStates(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, num_array aVector) -> StateVariableVector"""
        return _cmf_core.StateVariableVector___iadd__(self, *args)

    def CopyDerivs(self, *args):
        """
        CopyDerivs(self, Time time, num_array destination, real factor = 1)
        CopyDerivs(self, Time time, real destination, real factor = 1)

        void CopyDerivs(Time time, numVector &destination, real factor=1)
        const

        Copies the derivatives at time step "time" to a numeric vector using
        OpenMP.

        Parameters:
        -----------

        time:   Time at which the derivatives should be calculated

        destination:  Vector to be overwritten by the results

        factor:  A factor that is multiplied to the derivate (e.g. unit
        conversion or integration length) 
        """
        return _cmf_core.StateVariableVector_CopyDerivs(self, *args)

    def GetStates(self, *args):
        """
        GetStates(self) -> num_array

        numVector GetStates() const

        Returns the states in a numeric vector using :CopyStates, but is
        slower because of additional memory allocation. 
        """
        return _cmf_core.StateVariableVector_GetStates(self, *args)

    def GetDerivs(self, *args):
        """
        GetDerivs(self, Time time) -> num_array

        numVector GetDerivs(Time time) const

        Returns the derivatives at time step "time" in a numeric vector
        using :CopyDerivs, but is slower because of additional memory
        allocation. 
        """
        return _cmf_core.StateVariableVector_GetDerivs(self, *args)

    def __init__(self, *args): 
        """__init__(self) -> StateVariableVector"""
        _cmf_core.StateVariableVector_swiginit(self,_cmf_core.new_StateVariableVector(*args))
    __swig_destroy__ = _cmf_core.delete_StateVariableVector
StateVariableVector.CopyStates = new_instancemethod(_cmf_core.StateVariableVector_CopyStates,None,StateVariableVector)
StateVariableVector.SetStates = new_instancemethod(_cmf_core.StateVariableVector_SetStates,None,StateVariableVector)
StateVariableVector.__iadd__ = new_instancemethod(_cmf_core.StateVariableVector___iadd__,None,StateVariableVector)
StateVariableVector.CopyDerivs = new_instancemethod(_cmf_core.StateVariableVector_CopyDerivs,None,StateVariableVector)
StateVariableVector.GetStates = new_instancemethod(_cmf_core.StateVariableVector_GetStates,None,StateVariableVector)
StateVariableVector.GetDerivs = new_instancemethod(_cmf_core.StateVariableVector_GetDerivs,None,StateVariableVector)
StateVariableVector_swigregister = _cmf_core.StateVariableVector_swigregister
StateVariableVector_swigregister(StateVariableVector)

class StateVariableOwner(object):
    """
    An abstract class, that owns one or more state variables, that can add
    them to a vector of state variables in a certain order.

    C++ includes: StateVariable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def AddStateVariables(self, *args):
        """
        AddStateVariables(self, StateVariableVector vector)

        virtual void
        AddStateVariables(cmf::math::StateVariableVector &vector)=0

        Add the state variables, owned by an object derived from
        StateVariableOwner, to the given vector. 
        """
        return _cmf_core.StateVariableOwner_AddStateVariables(self, *args)

    __swig_destroy__ = _cmf_core.delete_StateVariableOwner
StateVariableOwner.AddStateVariables = new_instancemethod(_cmf_core.StateVariableOwner_AddStateVariables,None,StateVariableOwner)
StateVariableOwner_swigregister = _cmf_core.StateVariableOwner_swigregister
StateVariableOwner_swigregister(StateVariableOwner)

class Integrator(object):
    """
    Base class for any kind of integrator.

    Pure virtual functions: Integrate

    Copy Please provide a custom copy constructorTodo Put the methods of
    StateVariableVector here, and delete StateVariableVector

    C++ includes: Integrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Tag = _swig_property(_cmf_core.Integrator_Tag_get, _cmf_core.Integrator_Tag_set)
    UseEulerAtTmin = _swig_property(_cmf_core.Integrator_UseEulerAtTmin_get, _cmf_core.Integrator_UseEulerAtTmin_set)
    use_OpenMP = _swig_property(_cmf_core.Integrator_use_OpenMP_get, _cmf_core.Integrator_use_OpenMP_set)
    def count(self, *args):
        """
        count(self) -> int

        int count()
        const

        returns the number of state variables 
        """
        return _cmf_core.Integrator_count(self, *args)

    def state(self, *args):
        """
        state(self, int position) -> real
        state(self, int position, real newState)

        void state(int
        position, real newState)

        Simplifies the assessment of state variables. 
        """
        return _cmf_core.Integrator_state(self, *args)

    def AddStatesFromOwner(self, *args):
        """
        AddStatesFromOwner(self, StateVariableOwner stateOwner)

        virtual void AddStatesFromOwner(cmf::math::StateVariableOwner
        &stateOwner)

        Adds the state variables of a StateVariableOwner to the state
        variables of the solver. 
        """
        return _cmf_core.Integrator_AddStatesFromOwner(self, *args)

    def AddState(self, *args):
        """AddState(self, StateVariable statevar)"""
        return _cmf_core.Integrator_AddState(self, *args)

    def ModelTime(self, *args):
        """
        ModelTime(self) -> Time
        ModelTime(self, Time val)

        void
        ModelTime(cmf::math::Time val)

        Sets the current model time. 
        """
        return _cmf_core.Integrator_ModelTime(self, *args)

    def TimeStep(self, *args):
        """
        TimeStep(self) -> Time

        cmf::math::Time TimeStep() const

        Returns the last time step. 
        """
        return _cmf_core.Integrator_TimeStep(self, *args)

    def NextTimeStep(self, *args):
        """
        NextTimeStep(self) -> Time
        NextTimeStep(self, Time val)

        void
        NextTimeStep(cmf::math::Time val)

        Sets the next time step width. 
        """
        return _cmf_core.Integrator_NextTimeStep(self, *args)

    def MinTimestep(self, *args):
        """
        MinTimestep(self) -> Time

        const
        cmf::math::Time MinTimestep() const

        Returns The minimal allowed time step length. 
        """
        return _cmf_core.Integrator_MinTimestep(self, *args)

    def Iterations(self, *args):
        """
        Iterations(self) -> int

        int
        Iterations() const 
        """
        return _cmf_core.Integrator_Iterations(self, *args)

    def ResetIterations(self, *args):
        """
        ResetIterations(self)

        void
        ResetIterations() 
        """
        return _cmf_core.Integrator_ResetIterations(self, *args)

    def Reset(self, *args):
        """Reset(self)"""
        return _cmf_core.Integrator_Reset(self, *args)

    def Copy(self, *args):
        """
        Copy(self) -> Integrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.Integrator_Copy(self, *args)

    def Integrate(self, *args):
        """
        Integrate(self, Time MaxTime, Time TimeStep) -> int
        Integrate(self, Time MaxTime) -> int

        int
        Integrate(cmf::math::Time MaxTime) 
        """
        return _cmf_core.Integrator_Integrate(self, *args)

    def IntegrateUntil(self, *args):
        """
        IntegrateUntil(self, Time MaxTime)
        IntegrateUntil(self, Time MaxTime, Time TimeStep)

        void
        IntegrateUntil(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

        Integrates the vector of state variables until MaxTime. 
        """
        return _cmf_core.Integrator_IntegrateUntil(self, *args)

    t=property(ModelTime,ModelTime,"Gets or sets the model time of the integrator")
    dt=property(TimeStep,None,"Gets the length of the last internal time step of the integrator")
    def __call__(self,t):
        if t<self.t:
            self.IntegrateUntil(self.t+t)
        else:
            self.IntegrateUntil(t)
    def run(self,start=day*0,end=day*1,step=day*1):
        self.t=start
        while self.t<end:
            self(self.t+step)
            yield self.t

    __swig_destroy__ = _cmf_core.delete_Integrator
Integrator.count = new_instancemethod(_cmf_core.Integrator_count,None,Integrator)
Integrator.state = new_instancemethod(_cmf_core.Integrator_state,None,Integrator)
Integrator.AddStatesFromOwner = new_instancemethod(_cmf_core.Integrator_AddStatesFromOwner,None,Integrator)
Integrator.AddState = new_instancemethod(_cmf_core.Integrator_AddState,None,Integrator)
Integrator.ModelTime = new_instancemethod(_cmf_core.Integrator_ModelTime,None,Integrator)
Integrator.TimeStep = new_instancemethod(_cmf_core.Integrator_TimeStep,None,Integrator)
Integrator.NextTimeStep = new_instancemethod(_cmf_core.Integrator_NextTimeStep,None,Integrator)
Integrator.MinTimestep = new_instancemethod(_cmf_core.Integrator_MinTimestep,None,Integrator)
Integrator.Iterations = new_instancemethod(_cmf_core.Integrator_Iterations,None,Integrator)
Integrator.ResetIterations = new_instancemethod(_cmf_core.Integrator_ResetIterations,None,Integrator)
Integrator.Reset = new_instancemethod(_cmf_core.Integrator_Reset,None,Integrator)
Integrator.Copy = new_instancemethod(_cmf_core.Integrator_Copy,None,Integrator)
Integrator.Integrate = new_instancemethod(_cmf_core.Integrator_Integrate,None,Integrator)
Integrator.IntegrateUntil = new_instancemethod(_cmf_core.Integrator_IntegrateUntil,None,Integrator)
Integrator_swigregister = _cmf_core.Integrator_swigregister
Integrator_swigregister(Integrator)

class BDF2(Integrator):
    """
    An order 2 BDF-Method with fixed-point iteration and variable step
    size.

    Recommended integrator for CMF (so far)

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8 and

    Eckert S., Baaser H., Gross D. and Scherf O. (2004) "A BDF2
    integration method with step size control for elasto-plasticity",
    Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1

    Most important function: Integrate

    C++ includes: BDF2.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get_error_position(self, *args):
        """get_error_position(self) -> int"""
        return _cmf_core.BDF2_get_error_position(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(10)) -> BDF2
        __init__(self, Integrator templ) -> BDF2

        BDF2(const Integrator
        &templ) 
        """
        _cmf_core.BDF2_swiginit(self,_cmf_core.new_BDF2(*args))
    __swig_destroy__ = _cmf_core.delete_BDF2
BDF2.get_error_position = new_instancemethod(_cmf_core.BDF2_get_error_position,None,BDF2)
BDF2_swigregister = _cmf_core.BDF2_swigregister
BDF2_swigregister(BDF2)

class ExplicitEuler_fixed(Integrator):
    """
    An explicit Euler integrator, with a fixed time step.

    C++ includes: ExplicitEuler_fixed.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_fixed
        __init__(self, Integrator copy) -> ExplicitEuler_fixed

        ExplicitEuler_fixed(const Integrator &copy)

        Copy constructor. 
        """
        _cmf_core.ExplicitEuler_fixed_swiginit(self,_cmf_core.new_ExplicitEuler_fixed(*args))
    __swig_destroy__ = _cmf_core.delete_ExplicitEuler_fixed
ExplicitEuler_fixed_swigregister = _cmf_core.ExplicitEuler_fixed_swigregister
ExplicitEuler_fixed_swigregister(ExplicitEuler_fixed)

class PredictCorrectSimple(Integrator):
    """Proxy of C++ cmf::math::PredictCorrectSimple class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = _swig_property(_cmf_core.PredictCorrectSimple_alpha_get, _cmf_core.PredictCorrectSimple_alpha_set)
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real Alpha) -> PredictCorrectSimple
        __init__(self, StateVariableOwner states, real Alpha) -> PredictCorrectSimple
        __init__(self, real Alpha = 0.5) -> PredictCorrectSimple
        __init__(self, Integrator copy) -> PredictCorrectSimple
        """
        _cmf_core.PredictCorrectSimple_swiginit(self,_cmf_core.new_PredictCorrectSimple(*args))
    __swig_destroy__ = _cmf_core.delete_PredictCorrectSimple
PredictCorrectSimple_swigregister = _cmf_core.PredictCorrectSimple_swigregister
PredictCorrectSimple_swigregister(PredictCorrectSimple)

class ExplicitEuler_variable(Integrator):
    """
    An explicit Euler integrator with variable step size.

    C++ includes: ExplicitEuler_variable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    WithStepsizeControl = _swig_property(_cmf_core.ExplicitEuler_variable_WithStepsizeControl_get, _cmf_core.ExplicitEuler_variable_WithStepsizeControl_set)
    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_variable
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ExplicitEuler_variable
        __init__(self, Integrator copy) -> ExplicitEuler_variable

        ExplicitEuler_variable(const Integrator &copy)

        Copy constructor. 
        """
        _cmf_core.ExplicitEuler_variable_swiginit(self,_cmf_core.new_ExplicitEuler_variable(*args))
    __swig_destroy__ = _cmf_core.delete_ExplicitEuler_variable
ExplicitEuler_variable_swigregister = _cmf_core.ExplicitEuler_variable_swigregister
ExplicitEuler_variable_swigregister(ExplicitEuler_variable)

class ImplicitEuler(Integrator):
    """
    An implicit (backward) Euler integrator using fixpoint iteration.

    C++ includes: FixpointImplicitEuler.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ImplicitEuler
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> ImplicitEuler
        __init__(self, Integrator arg0) -> ImplicitEuler

        ImplicitEuler(const Integrator &)

        Copy constructor. 
        """
        _cmf_core.ImplicitEuler_swiginit(self,_cmf_core.new_ImplicitEuler(*args))
    __swig_destroy__ = _cmf_core.delete_ImplicitEuler
ImplicitEuler_swigregister = _cmf_core.ImplicitEuler_swigregister
ImplicitEuler_swigregister(ImplicitEuler)

class RKFIntegrator(Integrator):
    """
    Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
    Fehlberg (RKF54) method.

    C++ includes: RKFIntegrator.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> RKFIntegrator
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10)) -> RKFIntegrator
        __init__(self, Integrator forCopy) -> RKFIntegrator

        RKFIntegrator(const Integrator &forCopy)

        Copy constructor, does not copy. 
        """
        _cmf_core.RKFIntegrator_swiginit(self,_cmf_core.new_RKFIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_RKFIntegrator
RKFIntegrator_swigregister = _cmf_core.RKFIntegrator_swigregister
RKFIntegrator_swigregister(RKFIntegrator)

GEAR_MAX_ITER = _cmf_core.GEAR_MAX_ITER
GEAR_RECOVER_AFTER_STEPS = _cmf_core.GEAR_RECOVER_AFTER_STEPS
class Gears_Fixpoint(Integrator):
    """
    An up to 4 step Gears-Method with fixpoint iteration, needs bug
    fixing.

    Derived from Roussel C. and Roussel M. (2003) "Generic Object-
    Oriented Differential Equation Integrators", C/C++ User Journal, Nov.
    2003,http://www.ddj.com/cpp/184401724?pgno=8

    C++ includes: Gears_Fixpoint.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Time_reduce_stage(self, *args):
        """
        Time_reduce_stage(self) -> int

        int Time_reduce_stage() const

        Returns int Stage oof time reduction. 
        """
        return _cmf_core.Gears_Fixpoint_Time_reduce_stage(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, StateVariableVector states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10), 
            int maxOrder = 4) -> Gears_Fixpoint
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Seconds(10), 
            int maxOrder = 4) -> Gears_Fixpoint
        __init__(self, Integrator arg0) -> Gears_Fixpoint

        Gears_Fixpoint(const Integrator &)

        Copy constructor. 
        """
        _cmf_core.Gears_Fixpoint_swiginit(self,_cmf_core.new_Gears_Fixpoint(*args))
    __swig_destroy__ = _cmf_core.delete_Gears_Fixpoint
Gears_Fixpoint.Time_reduce_stage = new_instancemethod(_cmf_core.Gears_Fixpoint_Time_reduce_stage,None,Gears_Fixpoint)
Gears_Fixpoint_swigregister = _cmf_core.Gears_Fixpoint_swigregister
Gears_Fixpoint_swigregister(Gears_Fixpoint)

class CVodeIntegrator(Integrator):
    """Proxy of C++ cmf::math::CVodeIntegrator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    preconditioner = _swig_property(_cmf_core.CVodeIntegrator_preconditioner_get, _cmf_core.CVodeIntegrator_preconditioner_set)
    MaxNonLinearIterations = _swig_property(_cmf_core.CVodeIntegrator_MaxNonLinearIterations_get, _cmf_core.CVodeIntegrator_MaxNonLinearIterations_set)
    MaxConvergenceFailures = _swig_property(_cmf_core.CVodeIntegrator_MaxConvergenceFailures_get, _cmf_core.CVodeIntegrator_MaxConvergenceFailures_set)
    MaxErrorTestFailures = _swig_property(_cmf_core.CVodeIntegrator_MaxErrorTestFailures_get, _cmf_core.CVodeIntegrator_MaxErrorTestFailures_set)
    maxl = _swig_property(_cmf_core.CVodeIntegrator_maxl_get, _cmf_core.CVodeIntegrator_maxl_set)
    LinearSolver = _swig_property(_cmf_core.CVodeIntegrator_LinearSolver_get, _cmf_core.CVodeIntegrator_LinearSolver_set)
    MaxOrder = _swig_property(_cmf_core.CVodeIntegrator_MaxOrder_get, _cmf_core.CVodeIntegrator_MaxOrder_set)
    reinit_always = _swig_property(_cmf_core.CVodeIntegrator_reinit_always_get, _cmf_core.CVodeIntegrator_reinit_always_set)
    max_step = _swig_property(_cmf_core.CVodeIntegrator_max_step_get, _cmf_core.CVodeIntegrator_max_step_set)
    def GetOrder(self, *args):
        """GetOrder(self) -> int"""
        return _cmf_core.CVodeIntegrator_GetOrder(self, *args)

    def ReInit(self, *args):
        """ReInit(self, Time initdt, real epsilon = 0)"""
        return _cmf_core.CVodeIntegrator_ReInit(self, *args)

    def Initialize(self, *args):
        """Initialize(self)"""
        return _cmf_core.CVodeIntegrator_Initialize(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(50)) -> CVodeIntegrator
        __init__(self, StateVariableOwner states, real epsilon = 1e-9, Time tStepMin = cmf::math::Time::Milliseconds(50)) -> CVodeIntegrator
        __init__(self, CVodeIntegrator templ) -> CVodeIntegrator
        """
        _cmf_core.CVodeIntegrator_swiginit(self,_cmf_core.new_CVodeIntegrator(*args))
    def Copy(self, *args):
        """
        Copy(self) -> CVodeIntegrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.CVodeIntegrator_Copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_CVodeIntegrator
CVodeIntegrator.GetOrder = new_instancemethod(_cmf_core.CVodeIntegrator_GetOrder,None,CVodeIntegrator)
CVodeIntegrator.ReInit = new_instancemethod(_cmf_core.CVodeIntegrator_ReInit,None,CVodeIntegrator)
CVodeIntegrator.Initialize = new_instancemethod(_cmf_core.CVodeIntegrator_Initialize,None,CVodeIntegrator)
CVodeIntegrator.Copy = new_instancemethod(_cmf_core.CVodeIntegrator_Copy,None,CVodeIntegrator)
CVodeIntegrator_swigregister = _cmf_core.CVodeIntegrator_swigregister
CVodeIntegrator_swigregister(CVodeIntegrator)

class MultiIntegrator(Integrator):
    """Proxy of C++ cmf::math::MultiIntegrator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Copy(self, *args):
        """
        Copy(self) -> MultiIntegrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.MultiIntegrator_Copy(self, *args)

    def add_states_to_integrator(self, *args):
        """add_states_to_integrator(self, StateVariableOwner stateOwner, int integrator_position)"""
        return _cmf_core.MultiIntegrator_add_states_to_integrator(self, *args)

    def __init__(self, *args): 
        """__init__(self, Integrator template_integrator, int count) -> MultiIntegrator"""
        _cmf_core.MultiIntegrator_swiginit(self,_cmf_core.new_MultiIntegrator(*args))
    __swig_destroy__ = _cmf_core.delete_MultiIntegrator
MultiIntegrator.Copy = new_instancemethod(_cmf_core.MultiIntegrator_Copy,None,MultiIntegrator)
MultiIntegrator.add_states_to_integrator = new_instancemethod(_cmf_core.MultiIntegrator_add_states_to_integrator,None,MultiIntegrator)
MultiIntegrator_swigregister = _cmf_core.MultiIntegrator_swigregister
MultiIntegrator_swigregister(MultiIntegrator)

class Jacobian(object):
    """
    Calculates the jacobian of a system (a vector of state variables).

    Code is inspired by RADAU5 method from Hairer E,Wanner G (1991)
    Solving Ordinary Differential Equations II, Springer-Verlag

    C++ includes: Jacobian.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Jacobian

        Jacobian() 
        """
        _cmf_core.Jacobian_swiginit(self,_cmf_core.new_Jacobian(*args))
    def Calculate(self, *args):
        """
        Calculate(self, StateVariableVector vector, Time timestep)

        void
        Calculate(StateVariableVector &vector, const cmf::math::Time
        &timestep)

        Calculates the jacobian for a given system at a given time step. 
        """
        return _cmf_core.Jacobian_Calculate(self, *args)

    def __call__(self, *args):
        """__call__(self, int i, int j) -> real"""
        return _cmf_core.Jacobian___call__(self, *args)

    def ToFile(self, *args):
        """
        ToFile(self, string filename)

        void
        ToFile(std::string filename)

        Saves the matrix in an undocumented file. Cols are tab seperated, rows
        are ended with endl. 
        """
        return _cmf_core.Jacobian_ToFile(self, *args)

    __swig_destroy__ = _cmf_core.delete_Jacobian
Jacobian.Calculate = new_instancemethod(_cmf_core.Jacobian_Calculate,None,Jacobian)
Jacobian.__call__ = new_instancemethod(_cmf_core.Jacobian___call__,None,Jacobian)
Jacobian.ToFile = new_instancemethod(_cmf_core.Jacobian_ToFile,None,Jacobian)
Jacobian_swigregister = _cmf_core.Jacobian_swigregister
Jacobian_swigregister(Jacobian)

class solute(object):
    """Proxy of C++ cmf::water::solute class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args): 
        """__init__(self, solute copy) -> solute"""
        _cmf_core.solute_swiginit(self,_cmf_core.new_solute(*args))
    def __eq__(self, *args):
        """__eq__(self, solute cmp) -> bool"""
        return _cmf_core.solute___eq__(self, *args)

    def __lt__(self, *args):
        """__lt__(self, solute cmp) -> bool"""
        return _cmf_core.solute___lt__(self, *args)

    def __gt__(self, *args):
        """__gt__(self, solute cmp) -> bool"""
        return _cmf_core.solute___gt__(self, *args)

    def __le__(self, *args):
        """__le__(self, solute cmp) -> bool"""
        return _cmf_core.solute___le__(self, *args)

    def __ge__(self, *args):
        """__ge__(self, solute cmp) -> bool"""
        return _cmf_core.solute___ge__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, solute cmp) -> bool"""
        return _cmf_core.solute___ne__(self, *args)

    Name = _swig_property(_cmf_core.solute_Name_get, _cmf_core.solute_Name_set)
    Unit = _swig_property(_cmf_core.solute_Unit_get, _cmf_core.solute_Unit_set)
    Uptake = _swig_property(_cmf_core.solute_Uptake_get, _cmf_core.solute_Uptake_set)
    Id = _swig_property(_cmf_core.solute_Id_get)
    def __repr__(self, *args):
        """__repr__(self) -> string"""
        return _cmf_core.solute___repr__(self, *args)

    __swig_destroy__ = _cmf_core.delete_solute
solute.__eq__ = new_instancemethod(_cmf_core.solute___eq__,None,solute)
solute.__lt__ = new_instancemethod(_cmf_core.solute___lt__,None,solute)
solute.__gt__ = new_instancemethod(_cmf_core.solute___gt__,None,solute)
solute.__le__ = new_instancemethod(_cmf_core.solute___le__,None,solute)
solute.__ge__ = new_instancemethod(_cmf_core.solute___ge__,None,solute)
solute.__ne__ = new_instancemethod(_cmf_core.solute___ne__,None,solute)
solute.__repr__ = new_instancemethod(_cmf_core.solute___repr__,None,solute)
solute_swigregister = _cmf_core.solute_swigregister
solute_swigregister(solute)

class solute_vector(object):
    """Proxy of C++ cmf::water::solute_vector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def size(self, *args):
        """size(self) -> size_t"""
        return _cmf_core.solute_vector_size(self, *args)

    def __init__(self, *args): 
        """__init__(self, string str) -> solute_vector"""
        _cmf_core.solute_vector_swiginit(self,_cmf_core.new_solute_vector(*args))
    def get_solute(self, *args):
        """get_solute(self, int position) -> solute"""
        return _cmf_core.solute_vector_get_solute(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, int i) -> solute"""
        return _cmf_core.solute_vector___getitem__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_t"""
        return _cmf_core.solute_vector___len__(self, *args)

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]
    def __repr__(self):
        return str([s.Name for s in self])

    __swig_destroy__ = _cmf_core.delete_solute_vector
solute_vector.size = new_instancemethod(_cmf_core.solute_vector_size,None,solute_vector)
solute_vector.get_solute = new_instancemethod(_cmf_core.solute_vector_get_solute,None,solute_vector)
solute_vector.__getitem__ = new_instancemethod(_cmf_core.solute_vector___getitem__,None,solute_vector)
solute_vector.__len__ = new_instancemethod(_cmf_core.solute_vector___len__,None,solute_vector)
solute_vector_swigregister = _cmf_core.solute_vector_swigregister
solute_vector_swigregister(solute_vector)

class SoluteTimeseries(object):
    """
    A map of concentration time series for solutes.

    C++ includes: Solute.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def conc(self, *args):
        """
        conc(self, Time t, solute solute) -> real

        WaterQuality conc(cmf::math::Time t) 
        """
        return _cmf_core.SoluteTimeseries_conc(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t

        size_t
        size() const

        Returns the number of solutes in the solution. 
        """
        return _cmf_core.SoluteTimeseries_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> SoluteTimeseries
        __init__(self, solute_vector solutes, Time begin, Time step) -> SoluteTimeseries
        __init__(self, SoluteTimeseries sts) -> SoluteTimeseries

        SoluteTimeseries(const cmf::water::SoluteTimeseries &sts) 
        """
        _cmf_core.SoluteTimeseries_swiginit(self,_cmf_core.new_SoluteTimeseries(*args))
    def __getitem__(self, *args):
        """__getitem__(self, solute solute) -> timeseries"""
        return _cmf_core.SoluteTimeseries___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(self, solute solute, timeseries concentration)"""
        return _cmf_core.SoluteTimeseries___setitem__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_t"""
        return _cmf_core.SoluteTimeseries___len__(self, *args)

    __swig_destroy__ = _cmf_core.delete_SoluteTimeseries
SoluteTimeseries.conc = new_instancemethod(_cmf_core.SoluteTimeseries_conc,None,SoluteTimeseries)
SoluteTimeseries.size = new_instancemethod(_cmf_core.SoluteTimeseries_size,None,SoluteTimeseries)
SoluteTimeseries.__getitem__ = new_instancemethod(_cmf_core.SoluteTimeseries___getitem__,None,SoluteTimeseries)
SoluteTimeseries.__setitem__ = new_instancemethod(_cmf_core.SoluteTimeseries___setitem__,None,SoluteTimeseries)
SoluteTimeseries.__len__ = new_instancemethod(_cmf_core.SoluteTimeseries___len__,None,SoluteTimeseries)
SoluteTimeseries_swigregister = _cmf_core.SoluteTimeseries_swigregister
SoluteTimeseries_swigregister(SoluteTimeseries)

class SoluteStorage(StateVariable):
    """
    A class for the storage of any tracer. The state is the amount (mol,
    kg etc. see cmf::water) of the tracer in the storage
    \\begin{eqnarray*} \\frac{dX}{dt}&=&\\sum_{f=1}^{F}\\left( q_f
    [X]_f\\right) +
    \\sum_{r=1}^R\\left(f_r\\left([A],...,[Z]\\right)\\
    V\\right) \\left[\\frac{mol}{day}\\right]\\\\ F&=&
    \\mbox{Number of fluxes in water storage} \\\\ q_f&=&
    \\mbox{Water flux in } \\frac{m^3}{day} \\\\
    \\left[X\\right]_f &=& \\mbox{Concentration of solute X in flux
    }q_f \\mbox{ in } \\frac{mol}{m^3} \\\\ R&=& \\mbox{Number
    of reactions defined for this solute storage} \\\\
    f_r\\left([A],...,[Z]\\right)&=& \\mbox{Reactive flux of }[X]
    \\mbox{ in environment } [A],...,[Z] \\left[\\frac{mol}{m^3\\
    day}\\right] \\\\ V &=& \\mbox{Volume of water in water
    storage }\\left[m^3\\right] \\end{eqnarray*}.

    C++ includes: SoluteStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    decay = _swig_property(_cmf_core.SoluteStorage_decay_get, _cmf_core.SoluteStorage_decay_set)
    source = _swig_property(_cmf_core.SoluteStorage_source_get, _cmf_core.SoluteStorage_source_set)
    Solute = _swig_property(_cmf_core.SoluteStorage_Solute_get)
    def conc(self, *args):
        """
        conc(self) -> real

        real conc()
        const

        Returns the concentration of the solute. 
        """
        return _cmf_core.SoluteStorage_conc(self, *args)

    __swig_destroy__ = _cmf_core.delete_SoluteStorage
SoluteStorage.conc = new_instancemethod(_cmf_core.SoluteStorage_conc,None,SoluteStorage)
SoluteStorage_swigregister = _cmf_core.SoluteStorage_swigregister
SoluteStorage_swigregister(SoluteStorage)

class connection_vector(object):
    """Proxy of C++ std::vector<(p.cmf::water::flux_connection)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.connection_vector_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.connection_vector___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.connection_vector___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_type"""
        return _cmf_core.connection_vector___len__(self, *args)

    def pop(self, *args):
        """pop(self) -> value_type"""
        return _cmf_core.connection_vector_pop(self, *args)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> connection_vector"""
        return _cmf_core.connection_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, connection_vector v)"""
        return _cmf_core.connection_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.connection_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.connection_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> connection_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.connection_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, connection_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.connection_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.connection_vector_append(self, *args)

    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.connection_vector_empty(self, *args)

    def size(self, *args):
        """size(self) -> size_type"""
        return _cmf_core.connection_vector_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.connection_vector_clear(self, *args)

    def swap(self, *args):
        """swap(self, connection_vector v)"""
        return _cmf_core.connection_vector_swap(self, *args)

    def get_allocator(self, *args):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.connection_vector_get_allocator(self, *args)

    def begin(self, *args):
        """begin(self) -> const_iterator"""
        return _cmf_core.connection_vector_begin(self, *args)

    def end(self, *args):
        """end(self) -> const_iterator"""
        return _cmf_core.connection_vector_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.connection_vector_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.connection_vector_rend(self, *args)

    def pop_back(self, *args):
        """pop_back(self)"""
        return _cmf_core.connection_vector_pop_back(self, *args)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.connection_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> connection_vector
        __init__(self, connection_vector arg0) -> connection_vector
        __init__(self, size_type size) -> connection_vector
        __init__(self, size_type size, value_type value) -> connection_vector
        """
        _cmf_core.connection_vector_swiginit(self,_cmf_core.new_connection_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.connection_vector_push_back(self, *args)

    def front(self, *args):
        """front(self) -> value_type"""
        return _cmf_core.connection_vector_front(self, *args)

    def back(self, *args):
        """back(self) -> value_type"""
        return _cmf_core.connection_vector_back(self, *args)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.connection_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.connection_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.connection_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.connection_vector_reserve(self, *args)

    def capacity(self, *args):
        """capacity(self) -> size_type"""
        return _cmf_core.connection_vector_capacity(self, *args)

    __swig_destroy__ = _cmf_core.delete_connection_vector
connection_vector.iterator = new_instancemethod(_cmf_core.connection_vector_iterator,None,connection_vector)
connection_vector.__nonzero__ = new_instancemethod(_cmf_core.connection_vector___nonzero__,None,connection_vector)
connection_vector.__bool__ = new_instancemethod(_cmf_core.connection_vector___bool__,None,connection_vector)
connection_vector.__len__ = new_instancemethod(_cmf_core.connection_vector___len__,None,connection_vector)
connection_vector.pop = new_instancemethod(_cmf_core.connection_vector_pop,None,connection_vector)
connection_vector.__getslice__ = new_instancemethod(_cmf_core.connection_vector___getslice__,None,connection_vector)
connection_vector.__setslice__ = new_instancemethod(_cmf_core.connection_vector___setslice__,None,connection_vector)
connection_vector.__delslice__ = new_instancemethod(_cmf_core.connection_vector___delslice__,None,connection_vector)
connection_vector.__delitem__ = new_instancemethod(_cmf_core.connection_vector___delitem__,None,connection_vector)
connection_vector.__getitem__ = new_instancemethod(_cmf_core.connection_vector___getitem__,None,connection_vector)
connection_vector.__setitem__ = new_instancemethod(_cmf_core.connection_vector___setitem__,None,connection_vector)
connection_vector.append = new_instancemethod(_cmf_core.connection_vector_append,None,connection_vector)
connection_vector.empty = new_instancemethod(_cmf_core.connection_vector_empty,None,connection_vector)
connection_vector.size = new_instancemethod(_cmf_core.connection_vector_size,None,connection_vector)
connection_vector.clear = new_instancemethod(_cmf_core.connection_vector_clear,None,connection_vector)
connection_vector.swap = new_instancemethod(_cmf_core.connection_vector_swap,None,connection_vector)
connection_vector.get_allocator = new_instancemethod(_cmf_core.connection_vector_get_allocator,None,connection_vector)
connection_vector.begin = new_instancemethod(_cmf_core.connection_vector_begin,None,connection_vector)
connection_vector.end = new_instancemethod(_cmf_core.connection_vector_end,None,connection_vector)
connection_vector.rbegin = new_instancemethod(_cmf_core.connection_vector_rbegin,None,connection_vector)
connection_vector.rend = new_instancemethod(_cmf_core.connection_vector_rend,None,connection_vector)
connection_vector.pop_back = new_instancemethod(_cmf_core.connection_vector_pop_back,None,connection_vector)
connection_vector.erase = new_instancemethod(_cmf_core.connection_vector_erase,None,connection_vector)
connection_vector.push_back = new_instancemethod(_cmf_core.connection_vector_push_back,None,connection_vector)
connection_vector.front = new_instancemethod(_cmf_core.connection_vector_front,None,connection_vector)
connection_vector.back = new_instancemethod(_cmf_core.connection_vector_back,None,connection_vector)
connection_vector.assign = new_instancemethod(_cmf_core.connection_vector_assign,None,connection_vector)
connection_vector.resize = new_instancemethod(_cmf_core.connection_vector_resize,None,connection_vector)
connection_vector.insert = new_instancemethod(_cmf_core.connection_vector_insert,None,connection_vector)
connection_vector.reserve = new_instancemethod(_cmf_core.connection_vector_reserve,None,connection_vector)
connection_vector.capacity = new_instancemethod(_cmf_core.connection_vector_capacity,None,connection_vector)
connection_vector_swigregister = _cmf_core.connection_vector_swigregister
connection_vector_swigregister(connection_vector)

class connection_set(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.connection_set_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.connection_set___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.connection_set___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_type"""
        return _cmf_core.connection_set___len__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.connection_set_append(self, *args)

    def __contains__(self, *args):
        """__contains__(self, value_type x) -> bool"""
        return _cmf_core.connection_set___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _cmf_core.connection_set___getitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(p.cmf::water::flux_connection)> arg0) -> connection_set
        __init__(self) -> connection_set
        __init__(self, connection_set arg0) -> connection_set
        """
        _cmf_core.connection_set_swiginit(self,_cmf_core.new_connection_set(*args))
    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.connection_set_empty(self, *args)

    def size(self, *args):
        """size(self) -> size_type"""
        return _cmf_core.connection_set_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.connection_set_clear(self, *args)

    def swap(self, *args):
        """swap(self, connection_set v)"""
        return _cmf_core.connection_set_swap(self, *args)

    def count(self, *args):
        """count(self, key_type x) -> size_type"""
        return _cmf_core.connection_set_count(self, *args)

    def begin(self, *args):
        """begin(self) -> iterator"""
        return _cmf_core.connection_set_begin(self, *args)

    def end(self, *args):
        """end(self) -> iterator"""
        return _cmf_core.connection_set_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> reverse_iterator"""
        return _cmf_core.connection_set_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> reverse_iterator"""
        return _cmf_core.connection_set_rend(self, *args)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator pos)
        erase(self, iterator first, iterator last)
        """
        return _cmf_core.connection_set_erase(self, *args)

    def find(self, *args):
        """find(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(self, key_type x) -> iterator"""
        return _cmf_core.connection_set_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(self, key_type x) -> std::pair<(std::set<(p.cmf::water::flux_connection)>::iterator,std::set<(p.cmf::water::flux_connection)>::iterator)>"""
        return _cmf_core.connection_set_equal_range(self, *args)

    def insert(self, *args):
        """insert(self, value_type __x) -> std::pair<(std::set<(p.cmf::water::flux_connection)>::iterator,bool)>"""
        return _cmf_core.connection_set_insert(self, *args)

    __swig_destroy__ = _cmf_core.delete_connection_set
connection_set.iterator = new_instancemethod(_cmf_core.connection_set_iterator,None,connection_set)
connection_set.__nonzero__ = new_instancemethod(_cmf_core.connection_set___nonzero__,None,connection_set)
connection_set.__bool__ = new_instancemethod(_cmf_core.connection_set___bool__,None,connection_set)
connection_set.__len__ = new_instancemethod(_cmf_core.connection_set___len__,None,connection_set)
connection_set.append = new_instancemethod(_cmf_core.connection_set_append,None,connection_set)
connection_set.__contains__ = new_instancemethod(_cmf_core.connection_set___contains__,None,connection_set)
connection_set.__getitem__ = new_instancemethod(_cmf_core.connection_set___getitem__,None,connection_set)
connection_set.empty = new_instancemethod(_cmf_core.connection_set_empty,None,connection_set)
connection_set.size = new_instancemethod(_cmf_core.connection_set_size,None,connection_set)
connection_set.clear = new_instancemethod(_cmf_core.connection_set_clear,None,connection_set)
connection_set.swap = new_instancemethod(_cmf_core.connection_set_swap,None,connection_set)
connection_set.count = new_instancemethod(_cmf_core.connection_set_count,None,connection_set)
connection_set.begin = new_instancemethod(_cmf_core.connection_set_begin,None,connection_set)
connection_set.end = new_instancemethod(_cmf_core.connection_set_end,None,connection_set)
connection_set.rbegin = new_instancemethod(_cmf_core.connection_set_rbegin,None,connection_set)
connection_set.rend = new_instancemethod(_cmf_core.connection_set_rend,None,connection_set)
connection_set.erase = new_instancemethod(_cmf_core.connection_set_erase,None,connection_set)
connection_set.find = new_instancemethod(_cmf_core.connection_set_find,None,connection_set)
connection_set.lower_bound = new_instancemethod(_cmf_core.connection_set_lower_bound,None,connection_set)
connection_set.upper_bound = new_instancemethod(_cmf_core.connection_set_upper_bound,None,connection_set)
connection_set.equal_range = new_instancemethod(_cmf_core.connection_set_equal_range,None,connection_set)
connection_set.insert = new_instancemethod(_cmf_core.connection_set_insert,None,connection_set)
connection_set_swigregister = _cmf_core.connection_set_swigregister
connection_set_swigregister(connection_set)

class flux_node(Locatable):
    """Proxy of C++ cmf::water::flux_node class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def project(self, *args):
        """project(self) -> project"""
        return _cmf_core.flux_node_project(self, *args)

    node_id = _swig_property(_cmf_core.flux_node_node_id_get)
    def is_storage(self, *args):
        """is_storage(self) -> bool"""
        return _cmf_core.flux_node_is_storage(self, *args)

    Name = _swig_property(_cmf_core.flux_node_Name_get, _cmf_core.flux_node_Name_set)
    def to_string(self, *args):
        """to_string(self) -> string"""
        return _cmf_core.flux_node_to_string(self, *args)

    __swig_destroy__ = _cmf_core.delete_flux_node
    def __eq__(self, *args):
        """__eq__(self, flux_node other) -> bool"""
        return _cmf_core.flux_node___eq__(self, *args)

    def RecalcFluxes(self, *args):
        """RecalcFluxes(self, Time t) -> bool"""
        return _cmf_core.flux_node_RecalcFluxes(self, *args)

    def get_connection(self, *args):
        """get_connection(self, flux_node target) -> flux_connection"""
        return _cmf_core.flux_node_get_connection(self, *args)

    def remove_connection(self, *args):
        """remove_connection(self, ptr To) -> bool"""
        return _cmf_core.flux_node_remove_connection(self, *args)

    def flux_to(self, *args):
        """flux_to(self, flux_node target, Time t) -> real"""
        return _cmf_core.flux_node_flux_to(self, *args)

    def flux3d_to(self, *args):
        """flux3d_to(self, flux_node target, Time t) -> point"""
        return _cmf_core.flux_node_flux3d_to(self, *args)

    def get_3d_flux(self, *args):
        """get_3d_flux(self, Time t) -> point"""
        return _cmf_core.flux_node_get_3d_flux(self, *args)

    def water_balance(self, *args):
        """water_balance(self, Time t, flux_connection Without = None) -> real"""
        return _cmf_core.flux_node_water_balance(self, *args)

    def conc(self, *args):
        """conc(self, Time t, solute solute) -> real"""
        return _cmf_core.flux_node_conc(self, *args)

    Location = _swig_property(_cmf_core.flux_node_Location_get, _cmf_core.flux_node_Location_set)
    def is_empty(self, *args):
        """is_empty(self) -> bool"""
        return _cmf_core.flux_node_is_empty(self, *args)

    def __init__(self, *args): 
        """__init__(self, project _project, point location = cmf::geometry::point()) -> flux_node"""
        _cmf_core.flux_node_swiginit(self,_cmf_core.new_flux_node(*args))
    potential = _swig_property(_cmf_core.flux_node_potential_get, _cmf_core.flux_node_potential_set)
    connections = _swig_property(_cmf_core.flux_node_connections_get)
    def __repr__(self): return self.to_string()
    def fluxes(self,t):
        return [(con.q(self,t),con[self]) for con in self.connections]
    @property
    def connected_nodes(self):
        return [con[self] for con in self.connections]

flux_node.project = new_instancemethod(_cmf_core.flux_node_project,None,flux_node)
flux_node.is_storage = new_instancemethod(_cmf_core.flux_node_is_storage,None,flux_node)
flux_node.to_string = new_instancemethod(_cmf_core.flux_node_to_string,None,flux_node)
flux_node.__eq__ = new_instancemethod(_cmf_core.flux_node___eq__,None,flux_node)
flux_node.RecalcFluxes = new_instancemethod(_cmf_core.flux_node_RecalcFluxes,None,flux_node)
flux_node.get_connection = new_instancemethod(_cmf_core.flux_node_get_connection,None,flux_node)
flux_node.remove_connection = new_instancemethod(_cmf_core.flux_node_remove_connection,None,flux_node)
flux_node.flux_to = new_instancemethod(_cmf_core.flux_node_flux_to,None,flux_node)
flux_node.flux3d_to = new_instancemethod(_cmf_core.flux_node_flux3d_to,None,flux_node)
flux_node.get_3d_flux = new_instancemethod(_cmf_core.flux_node_get_3d_flux,None,flux_node)
flux_node.water_balance = new_instancemethod(_cmf_core.flux_node_water_balance,None,flux_node)
flux_node.conc = new_instancemethod(_cmf_core.flux_node_conc,None,flux_node)
flux_node.is_empty = new_instancemethod(_cmf_core.flux_node_is_empty,None,flux_node)
flux_node_swigregister = _cmf_core.flux_node_swigregister
flux_node_swigregister(flux_node)


def count_node_references(*args):
  """count_node_references(ptr node) -> int"""
  return _cmf_core.count_node_references(*args)

def get_higher_node(*args):
  """get_higher_node(ptr node1, ptr node2) -> ptr"""
  return _cmf_core.get_higher_node(*args)

def get_lower_node(*args):
  """get_lower_node(ptr node1, ptr node2) -> ptr"""
  return _cmf_core.get_lower_node(*args)
class flux_connection(object):
    """Proxy of C++ cmf::water::flux_connection class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def left_node(self, *args):
        """left_node(self) -> ptr"""
        return _cmf_core.flux_connection_left_node(self, *args)

    def right_node(self, *args):
        """right_node(self) -> ptr"""
        return _cmf_core.flux_connection_right_node(self, *args)

    def kill_me(self, *args):
        """kill_me(self) -> bool"""
        return _cmf_core.flux_connection_kill_me(self, *args)

    connection_id = _swig_property(_cmf_core.flux_connection_connection_id_get)
    def __eq__(self, *args):
        """__eq__(self, flux_connection other) -> bool"""
        return _cmf_core.flux_connection___eq__(self, *args)

    def get_target(self, *args):
        """
        get_target(self, flux_node inquirer) -> ptr
        get_target(self, int index) -> ptr
        """
        return _cmf_core.flux_connection_get_target(self, *args)

    def exchange_target(self, *args):
        """exchange_target(self, ptr oldtarget, ptr newTarget)"""
        return _cmf_core.flux_connection_exchange_target(self, *args)

    def q(self, *args):
        """q(self, flux_node inquirer, Time t) -> real"""
        return _cmf_core.flux_connection_q(self, *args)

    def conc(self, *args):
        """conc(self, Time t, solute solute) -> real"""
        return _cmf_core.flux_connection_conc(self, *args)

    type = _swig_property(_cmf_core.flux_connection_type_get)
    def to_string(self, *args):
        """to_string(self) -> string"""
        return _cmf_core.flux_connection_to_string(self, *args)

    def short_string(self, *args):
        """short_string(self) -> string"""
        return _cmf_core.flux_connection_short_string(self, *args)

    __swig_destroy__ = _cmf_core.delete_flux_connection
    tracer_filter = _swig_property(_cmf_core.flux_connection_tracer_filter_get, _cmf_core.flux_connection_tracer_filter_set)
    def __repr__(self):
        return self.to_string()
    def __getitem__(self,index):
        return self.get_target(index)
    def __iter__(self):
        yield self.get_target(0)
        yield self.get_target(1)
    def __contains__(self,cmp):
        return cmp==self[0] or cmp==self[1]

flux_connection.left_node = new_instancemethod(_cmf_core.flux_connection_left_node,None,flux_connection)
flux_connection.right_node = new_instancemethod(_cmf_core.flux_connection_right_node,None,flux_connection)
flux_connection.kill_me = new_instancemethod(_cmf_core.flux_connection_kill_me,None,flux_connection)
flux_connection.__eq__ = new_instancemethod(_cmf_core.flux_connection___eq__,None,flux_connection)
flux_connection.get_target = new_instancemethod(_cmf_core.flux_connection_get_target,None,flux_connection)
flux_connection.exchange_target = new_instancemethod(_cmf_core.flux_connection_exchange_target,None,flux_connection)
flux_connection.q = new_instancemethod(_cmf_core.flux_connection_q,None,flux_connection)
flux_connection.conc = new_instancemethod(_cmf_core.flux_connection_conc,None,flux_connection)
flux_connection.to_string = new_instancemethod(_cmf_core.flux_connection_to_string,None,flux_connection)
flux_connection.short_string = new_instancemethod(_cmf_core.flux_connection_short_string,None,flux_connection)
flux_connection_swigregister = _cmf_core.flux_connection_swigregister
flux_connection_swigregister(flux_connection)


def replace_node(*args):
  """replace_node(ptr oldnode, ptr newnode)"""
  return _cmf_core.replace_node(*args)
class waterbalance_connection(flux_connection):
    """Proxy of C++ cmf::water::waterbalance_connection class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr source, ptr target) -> waterbalance_connection"""
        _cmf_core.waterbalance_connection_swiginit(self,_cmf_core.new_waterbalance_connection(*args))
    __swig_destroy__ = _cmf_core.delete_waterbalance_connection
waterbalance_connection_swigregister = _cmf_core.waterbalance_connection_swigregister
waterbalance_connection_swigregister(waterbalance_connection)

class linear_scale(object):
    """Proxy of C++ cmf::water::linear_scale class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    displacement = _swig_property(_cmf_core.linear_scale_displacement_get, _cmf_core.linear_scale_displacement_set)
    slope = _swig_property(_cmf_core.linear_scale_slope_get, _cmf_core.linear_scale_slope_set)
    def __call__(self, *args):
        """__call__(self, real value) -> real"""
        return _cmf_core.linear_scale___call__(self, *args)

    def __init__(self, *args): 
        """__init__(self, real _slope = 1, real _displacement = 0) -> linear_scale"""
        _cmf_core.linear_scale_swiginit(self,_cmf_core.new_linear_scale(*args))
    __swig_destroy__ = _cmf_core.delete_linear_scale
linear_scale.__call__ = new_instancemethod(_cmf_core.linear_scale___call__,None,linear_scale)
linear_scale_swigregister = _cmf_core.linear_scale_swigregister
linear_scale_swigregister(linear_scale)

class DricheletBoundary(flux_node):
    """Proxy of C++ cmf::water::DricheletBoundary class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def set_conc(self, *args):
        """set_conc(self, solute solute, double value)"""
        return _cmf_core.DricheletBoundary_set_conc(self, *args)

    is_source = _swig_property(_cmf_core.DricheletBoundary_is_source_get, _cmf_core.DricheletBoundary_is_source_set)
    def RecalcFluxes(self, *args):
        """RecalcFluxes(self, Time t) -> bool"""
        return _cmf_core.DricheletBoundary_RecalcFluxes(self, *args)

    def __init__(self, *args): 
        """__init__(self, project _p, real potential, point Location = cmf::geometry::point()) -> DricheletBoundary"""
        _cmf_core.DricheletBoundary_swiginit(self,_cmf_core.new_DricheletBoundary(*args))
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_2__ swigSharedPtrUpcast) -> __dummy_0__"""
        return _cmf_core.DricheletBoundary_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_DricheletBoundary
DricheletBoundary.set_conc = new_instancemethod(_cmf_core.DricheletBoundary_set_conc,None,DricheletBoundary)
DricheletBoundary.RecalcFluxes = new_instancemethod(_cmf_core.DricheletBoundary_RecalcFluxes,None,DricheletBoundary)
DricheletBoundary_swigregister = _cmf_core.DricheletBoundary_swigregister
DricheletBoundary_swigregister(DricheletBoundary)

def DricheletBoundary_SWIGSharedPtrUpcast(*args):
  """DricheletBoundary_SWIGSharedPtrUpcast(__dummy_2__ swigSharedPtrUpcast) -> __dummy_0__"""
  return _cmf_core.DricheletBoundary_SWIGSharedPtrUpcast(*args)

class NeumannBoundary(flux_node):
    """Proxy of C++ cmf::water::NeumannBoundary class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flux = _swig_property(_cmf_core.NeumannBoundary_flux_get, _cmf_core.NeumannBoundary_flux_set)
    flux_scale = _swig_property(_cmf_core.NeumannBoundary_flux_scale_get, _cmf_core.NeumannBoundary_flux_scale_set)
    concentration = _swig_property(_cmf_core.NeumannBoundary_concentration_get, _cmf_core.NeumannBoundary_concentration_set)
    def __call__(self, *args):
        """__call__(self, Time t) -> real"""
        return _cmf_core.NeumannBoundary___call__(self, *args)

    def connect_to(self, *args):
        """connect_to(self, ptr target)"""
        return _cmf_core.NeumannBoundary_connect_to(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, project _project, timeseries _flux, SoluteTimeseries _concentration = cmf::water::SoluteTimeseries(), 
            point loc = cmf::geometry::point()) -> NeumannBoundary
        __init__(self, project _project, point loc = cmf::geometry::point()) -> NeumannBoundary
        """
        _cmf_core.NeumannBoundary_swiginit(self,_cmf_core.new_NeumannBoundary(*args))
    def create(*args):
        """create(ptr target) -> ptr"""
        return _cmf_core.NeumannBoundary_create(*args)

    create = staticmethod(create)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_4__ swigSharedPtrUpcast) -> __dummy_0__"""
        return _cmf_core.NeumannBoundary_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_NeumannBoundary
NeumannBoundary.__call__ = new_instancemethod(_cmf_core.NeumannBoundary___call__,None,NeumannBoundary)
NeumannBoundary.connect_to = new_instancemethod(_cmf_core.NeumannBoundary_connect_to,None,NeumannBoundary)
NeumannBoundary_swigregister = _cmf_core.NeumannBoundary_swigregister
NeumannBoundary_swigregister(NeumannBoundary)

def NeumannBoundary_create(*args):
  """NeumannBoundary_create(ptr target) -> ptr"""
  return _cmf_core.NeumannBoundary_create(*args)

def NeumannBoundary_SWIGSharedPtrUpcast(*args):
  """NeumannBoundary_SWIGSharedPtrUpcast(__dummy_4__ swigSharedPtrUpcast) -> __dummy_0__"""
  return _cmf_core.NeumannBoundary_SWIGSharedPtrUpcast(*args)

class NeumannFlux(flux_connection):
    """Proxy of C++ cmf::water::NeumannFlux class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, __dummy_4__ left, ptr right) -> NeumannFlux"""
        _cmf_core.NeumannFlux_swiginit(self,_cmf_core.new_NeumannFlux(*args))
    __swig_destroy__ = _cmf_core.delete_NeumannFlux
NeumannFlux_swigregister = _cmf_core.NeumannFlux_swigregister
NeumannFlux_swigregister(NeumannFlux)

class TechnicalFlux(flux_connection):
    """Proxy of C++ cmf::water::TechnicalFlux class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    MaxFlux = _swig_property(_cmf_core.TechnicalFlux_MaxFlux_get, _cmf_core.TechnicalFlux_MaxFlux_set)
    MinState = _swig_property(_cmf_core.TechnicalFlux_MinState_get, _cmf_core.TechnicalFlux_MinState_set)
    FluxDecreaseTime = _swig_property(_cmf_core.TechnicalFlux_FluxDecreaseTime_get, _cmf_core.TechnicalFlux_FluxDecreaseTime_set)
    def __init__(self, *args): 
        """
        __init__(self, __dummy_8__ source, __dummy_0__ target, real maximum_flux, 
            real minimal_state = 0, Time flux_decrease_time = h) -> TechnicalFlux
        """
        _cmf_core.TechnicalFlux_swiginit(self,_cmf_core.new_TechnicalFlux(*args))
    __swig_destroy__ = _cmf_core.delete_TechnicalFlux
TechnicalFlux_swigregister = _cmf_core.TechnicalFlux_swigregister
TechnicalFlux_swigregister(TechnicalFlux)

class WaterStorage(StateVariable,StateVariableOwner,flux_node):
    """
    A state variable for the storage of water A class for the storage of
    any tracer. The state is the amount (mol, kg etc. see cmf::water) of
    the tracer in the storage \\begin{eqnarray*}
    \\frac{dV}{dt}&=&\\sum_{f=1}^{F} q_f \\\\ F&=& \\mbox{Number
    of fluxes in water storage} \\\\ q_f&=& \\mbox{Water flux in }
    \\frac{m^3}{day} \\\\ \\end{eqnarray*} The vector fluxes is
    used used by concentration to get the amount of water mixing.

    C++ includes: WaterStorage.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, project _project, double InitialState = 0) -> WaterStorage

        WaterStorage(const WaterStorage &forcopy) 
        """
        _cmf_core.WaterStorage_swiginit(self,_cmf_core.new_WaterStorage(*args))
    def from_node(*args):
        """from_node(ptr node) -> __dummy_8__"""
        return _cmf_core.WaterStorage_from_node(*args)

    from_node = staticmethod(from_node)
    def Solute(self, *args):
        """
        Solute(self, solute solute) -> SoluteStorage
        Solute(self, solute solute) -> SoluteStorage

        const
        SoluteStorage& Solute(const cmf::water::Solute &solute) const 
        """
        return _cmf_core.WaterStorage_Solute(self, *args)

    def conc(self, *args):
        """
        conc(self, solute solute) -> real
        conc(self, Time t, solute solute) -> real
        conc(self, solute solute, real NewConcetration)

        void
        conc(const cmf::water::Solute &solute, real NewConcetration)

        Sets a new concentration. 
        """
        return _cmf_core.WaterStorage_conc(self, *args)

    def cast(*args):
        """cast(__dummy_0__ node) -> __dummy_8__"""
        return _cmf_core.WaterStorage_cast(*args)

    cast = staticmethod(cast)
    def create(*args):
        """create(project _project, real initial_state = 0.0) -> __dummy_8__"""
        return _cmf_core.WaterStorage_create(*args)

    create = staticmethod(create)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_8__ swigSharedPtrUpcast) -> __dummy_0__"""
        return _cmf_core.WaterStorage_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    volume = _swig_property(_cmf_core.WaterStorage_volume_get, _cmf_core.WaterStorage_volume_set)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_WaterStorage
WaterStorage.Solute = new_instancemethod(_cmf_core.WaterStorage_Solute,None,WaterStorage)
WaterStorage.conc = new_instancemethod(_cmf_core.WaterStorage_conc,None,WaterStorage)
WaterStorage_swigregister = _cmf_core.WaterStorage_swigregister
WaterStorage_swigregister(WaterStorage)

def WaterStorage_from_node(*args):
  """WaterStorage_from_node(ptr node) -> __dummy_8__"""
  return _cmf_core.WaterStorage_from_node(*args)

def WaterStorage_cast(*args):
  """WaterStorage_cast(__dummy_0__ node) -> __dummy_8__"""
  return _cmf_core.WaterStorage_cast(*args)

def WaterStorage_create(*args):
  """WaterStorage_create(project _project, real initial_state = 0.0) -> __dummy_8__"""
  return _cmf_core.WaterStorage_create(*args)

def WaterStorage_SWIGSharedPtrUpcast(*args):
  """WaterStorage_SWIGSharedPtrUpcast(__dummy_8__ swigSharedPtrUpcast) -> __dummy_0__"""
  return _cmf_core.WaterStorage_SWIGSharedPtrUpcast(*args)

class storage_vector(object):
    """
    STL class. 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.storage_vector_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.storage_vector___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.storage_vector___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type"""
        return _cmf_core.storage_vector___len__(self, *args)

    def pop(self, *args):
        """pop(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type"""
        return _cmf_core.storage_vector_pop(self, *args)

    def __getslice__(self, *args):
        """
        __getslice__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type j) -> storage_vector
        """
        return _cmf_core.storage_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type j, 
            storage_vector v)
        """
        return _cmf_core.storage_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type j)
        """
        return _cmf_core.storage_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.storage_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> storage_vector
        __getitem__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type
        """
        return _cmf_core.storage_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, storage_vector v)
        __setitem__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::difference_type i, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)
        """
        return _cmf_core.storage_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)"""
        return _cmf_core.storage_vector_append(self, *args)

    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.storage_vector_empty(self, *args)

    def size(self, *args):
        """size(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type"""
        return _cmf_core.storage_vector_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.storage_vector_clear(self, *args)

    def swap(self, *args):
        """swap(self, storage_vector v)"""
        return _cmf_core.storage_vector_swap(self, *args)

    def get_allocator(self, *args):
        """get_allocator(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::allocator_type"""
        return _cmf_core.storage_vector_get_allocator(self, *args)

    def begin(self, *args):
        """begin(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::const_iterator"""
        return _cmf_core.storage_vector_begin(self, *args)

    def end(self, *args):
        """end(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::const_iterator"""
        return _cmf_core.storage_vector_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::const_reverse_iterator"""
        return _cmf_core.storage_vector_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::const_reverse_iterator"""
        return _cmf_core.storage_vector_rend(self, *args)

    def pop_back(self, *args):
        """pop_back(self)"""
        return _cmf_core.storage_vector_pop_back(self, *args)

    def erase(self, *args):
        """
        erase(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator pos) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator
        erase(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator first, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator last) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator
        """
        return _cmf_core.storage_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> storage_vector
        __init__(self, storage_vector arg0) -> storage_vector
        __init__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type size) -> storage_vector
        __init__(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type size, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type value) -> storage_vector
        """
        _cmf_core.storage_vector_swiginit(self,_cmf_core.new_storage_vector(*args))
    def push_back(self, *args):
        """push_back(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)"""
        return _cmf_core.storage_vector_push_back(self, *args)

    def front(self, *args):
        """front(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type"""
        return _cmf_core.storage_vector_front(self, *args)

    def back(self, *args):
        """back(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type"""
        return _cmf_core.storage_vector_back(self, *args)

    def assign(self, *args):
        """
        assign(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type n, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)
        """
        return _cmf_core.storage_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type new_size)
        resize(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type new_size, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)
        """
        return _cmf_core.storage_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator pos, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator
        insert(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::iterator pos, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type n, 
            std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::value_type x)
        """
        return _cmf_core.storage_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type n)"""
        return _cmf_core.storage_vector_reserve(self, *args)

    def capacity(self, *args):
        """capacity(self) -> std::vector<(std::tr1::shared_ptr<(cmf::water::WaterStorage)>)>::size_type"""
        return _cmf_core.storage_vector_capacity(self, *args)

    __swig_destroy__ = _cmf_core.delete_storage_vector
storage_vector.iterator = new_instancemethod(_cmf_core.storage_vector_iterator,None,storage_vector)
storage_vector.__nonzero__ = new_instancemethod(_cmf_core.storage_vector___nonzero__,None,storage_vector)
storage_vector.__bool__ = new_instancemethod(_cmf_core.storage_vector___bool__,None,storage_vector)
storage_vector.__len__ = new_instancemethod(_cmf_core.storage_vector___len__,None,storage_vector)
storage_vector.pop = new_instancemethod(_cmf_core.storage_vector_pop,None,storage_vector)
storage_vector.__getslice__ = new_instancemethod(_cmf_core.storage_vector___getslice__,None,storage_vector)
storage_vector.__setslice__ = new_instancemethod(_cmf_core.storage_vector___setslice__,None,storage_vector)
storage_vector.__delslice__ = new_instancemethod(_cmf_core.storage_vector___delslice__,None,storage_vector)
storage_vector.__delitem__ = new_instancemethod(_cmf_core.storage_vector___delitem__,None,storage_vector)
storage_vector.__getitem__ = new_instancemethod(_cmf_core.storage_vector___getitem__,None,storage_vector)
storage_vector.__setitem__ = new_instancemethod(_cmf_core.storage_vector___setitem__,None,storage_vector)
storage_vector.append = new_instancemethod(_cmf_core.storage_vector_append,None,storage_vector)
storage_vector.empty = new_instancemethod(_cmf_core.storage_vector_empty,None,storage_vector)
storage_vector.size = new_instancemethod(_cmf_core.storage_vector_size,None,storage_vector)
storage_vector.clear = new_instancemethod(_cmf_core.storage_vector_clear,None,storage_vector)
storage_vector.swap = new_instancemethod(_cmf_core.storage_vector_swap,None,storage_vector)
storage_vector.get_allocator = new_instancemethod(_cmf_core.storage_vector_get_allocator,None,storage_vector)
storage_vector.begin = new_instancemethod(_cmf_core.storage_vector_begin,None,storage_vector)
storage_vector.end = new_instancemethod(_cmf_core.storage_vector_end,None,storage_vector)
storage_vector.rbegin = new_instancemethod(_cmf_core.storage_vector_rbegin,None,storage_vector)
storage_vector.rend = new_instancemethod(_cmf_core.storage_vector_rend,None,storage_vector)
storage_vector.pop_back = new_instancemethod(_cmf_core.storage_vector_pop_back,None,storage_vector)
storage_vector.erase = new_instancemethod(_cmf_core.storage_vector_erase,None,storage_vector)
storage_vector.push_back = new_instancemethod(_cmf_core.storage_vector_push_back,None,storage_vector)
storage_vector.front = new_instancemethod(_cmf_core.storage_vector_front,None,storage_vector)
storage_vector.back = new_instancemethod(_cmf_core.storage_vector_back,None,storage_vector)
storage_vector.assign = new_instancemethod(_cmf_core.storage_vector_assign,None,storage_vector)
storage_vector.resize = new_instancemethod(_cmf_core.storage_vector_resize,None,storage_vector)
storage_vector.insert = new_instancemethod(_cmf_core.storage_vector_insert,None,storage_vector)
storage_vector.reserve = new_instancemethod(_cmf_core.storage_vector_reserve,None,storage_vector)
storage_vector.capacity = new_instancemethod(_cmf_core.storage_vector_capacity,None,storage_vector)
storage_vector_swigregister = _cmf_core.storage_vector_swigregister
storage_vector_swigregister(storage_vector)

class node_list(StateVariableOwner):
    """Proxy of C++ cmf::water::node_list class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def size(self, *args):
        """size(self) -> int"""
        return _cmf_core.node_list_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> node_list
        __init__(self, node_list forcopy) -> node_list
        """
        _cmf_core.node_list_swiginit(self,_cmf_core.new_node_list(*args))
    def __iadd__(self, *args):
        """__iadd__(self, node_list right) -> node_list"""
        return _cmf_core.node_list___iadd__(self, *args)

    def __add__(self, *args):
        """__add__(self, node_list right) -> node_list"""
        return _cmf_core.node_list___add__(self, *args)

    def get(self, *args):
        """
        get(self, int index) -> ptr
        get(self, int begin, int end, int step = 1) -> node_list
        """
        return _cmf_core.node_list_get(self, *args)

    def append(self, *args):
        """append(self, ptr node)"""
        return _cmf_core.node_list_append(self, *args)

    def global_water_balance(self, *args):
        """global_water_balance(self, Time t) -> real"""
        return _cmf_core.node_list_global_water_balance(self, *args)

    def water_balance(self, *args):
        """water_balance(self, Time t) -> num_array"""
        return _cmf_core.node_list_water_balance(self, *args)

    def conc(self, *args):
        """conc(self, Time t, solute solute) -> num_array"""
        return _cmf_core.node_list_conc(self, *args)

    def set_solute_source(self, *args):
        """set_solute_source(self, solute solute, num_array source_fluxes) -> int"""
        return _cmf_core.node_list_set_solute_source(self, *args)

    def get_fluxes_to(self, *args):
        """get_fluxes_to(self, node_list targets, Time t) -> num_array"""
        return _cmf_core.node_list_get_fluxes_to(self, *args)

    def get_fluxes3d_to(self, *args):
        """get_fluxes3d_to(self, node_list targets, Time t) -> point_vector"""
        return _cmf_core.node_list_get_fluxes3d_to(self, *args)

    def get_fluxes3d(self, *args):
        """get_fluxes3d(self, Time t) -> point_vector"""
        return _cmf_core.node_list_get_fluxes3d(self, *args)

    def get_positions(self, *args):
        """get_positions(self) -> point_vector"""
        return _cmf_core.node_list_get_positions(self, *args)

    potentials = _swig_property(_cmf_core.node_list_potentials_get, _cmf_core.node_list_potentials_set)
    def __getitem__(self,index):
        return self.get(index)
    def __getslice__(self,slice):
        indices=slice.indices(self.size())
        return self.get(indices[0],indices[1],indices[2])
    def __len__(self):
        return self.size()       
    def __iter__(self):
        for i in xrange(self.size()):
            yield self[i]
    def extend(self,sequence):
        """Extends the node list with the sequence (any iterable will do) """
        for o in sequence:
            self.append(o)
    @staticmethod
    def from_sequence(sequence):
        """Returns a new node list populated from the sequence (any iterable will do) """
        nl=node_list()
        nl.extend(sequence)
        return nl

    __swig_destroy__ = _cmf_core.delete_node_list
node_list.size = new_instancemethod(_cmf_core.node_list_size,None,node_list)
node_list.__iadd__ = new_instancemethod(_cmf_core.node_list___iadd__,None,node_list)
node_list.__add__ = new_instancemethod(_cmf_core.node_list___add__,None,node_list)
node_list.get = new_instancemethod(_cmf_core.node_list_get,None,node_list)
node_list.append = new_instancemethod(_cmf_core.node_list_append,None,node_list)
node_list.global_water_balance = new_instancemethod(_cmf_core.node_list_global_water_balance,None,node_list)
node_list.water_balance = new_instancemethod(_cmf_core.node_list_water_balance,None,node_list)
node_list.conc = new_instancemethod(_cmf_core.node_list_conc,None,node_list)
node_list.set_solute_source = new_instancemethod(_cmf_core.node_list_set_solute_source,None,node_list)
node_list.get_fluxes_to = new_instancemethod(_cmf_core.node_list_get_fluxes_to,None,node_list)
node_list.get_fluxes3d_to = new_instancemethod(_cmf_core.node_list_get_fluxes3d_to,None,node_list)
node_list.get_fluxes3d = new_instancemethod(_cmf_core.node_list_get_fluxes3d,None,node_list)
node_list.get_positions = new_instancemethod(_cmf_core.node_list_get_positions,None,node_list)
node_list_swigregister = _cmf_core.node_list_swigregister
node_list_swigregister(node_list)

class NeumannBoundary_list(object):
    """Proxy of C++ cmf::water::NeumannBoundary_list class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get(self, *args):
        """get(self, int index) -> NeumannBoundary_ptr"""
        return _cmf_core.NeumannBoundary_list_get(self, *args)

    def get_fluxes(self, *args):
        """get_fluxes(self, Time t = cmf::math::Time()) -> num_array"""
        return _cmf_core.NeumannBoundary_list_get_fluxes(self, *args)

    def append(self, *args):
        """append(self, NeumannBoundary_ptr nbc)"""
        return _cmf_core.NeumannBoundary_list_append(self, *args)

    def size(self, *args):
        """size(self) -> size_t"""
        return _cmf_core.NeumannBoundary_list_size(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> NeumannBoundary_list
        __init__(self, node_list copy) -> NeumannBoundary_list
        __init__(self, NeumannBoundary_list copy) -> NeumannBoundary_list
        """
        _cmf_core.NeumannBoundary_list_swiginit(self,_cmf_core.new_NeumannBoundary_list(*args))
    def to_node_list(self, *args):
        """to_node_list(self) -> node_list"""
        return _cmf_core.NeumannBoundary_list_to_node_list(self, *args)

    def global_water_balance(self, *args):
        """global_water_balance(self, Time t) -> real"""
        return _cmf_core.NeumannBoundary_list_global_water_balance(self, *args)

    def water_balance(self, *args):
        """water_balance(self, Time t) -> num_array"""
        return _cmf_core.NeumannBoundary_list_water_balance(self, *args)

    fluxes = _swig_property(_cmf_core.NeumannBoundary_list_fluxes_get, _cmf_core.NeumannBoundary_list_fluxes_set)
    def __getitem__(self,index):
        return self.get(index)
    def __len__(self):
        return self.size()       
    def __iter__(self):
        for i in xrange(self.size()):
            yield self[i]
    def extend(self,sequence):
        """Extends the list of Neumann boundaries with the sequence (any iterable will do) """
        for o in sequence:
            self.append(o)
    @staticmethod
    def from_sequence(sequence):
        """Returns a new list of Neumann boundaries populated from the sequence (any iterable will do) """
        nl=NeumannBoundary_list()
        nl.extend(sequence)
        return nl

    __swig_destroy__ = _cmf_core.delete_NeumannBoundary_list
NeumannBoundary_list.get = new_instancemethod(_cmf_core.NeumannBoundary_list_get,None,NeumannBoundary_list)
NeumannBoundary_list.get_fluxes = new_instancemethod(_cmf_core.NeumannBoundary_list_get_fluxes,None,NeumannBoundary_list)
NeumannBoundary_list.append = new_instancemethod(_cmf_core.NeumannBoundary_list_append,None,NeumannBoundary_list)
NeumannBoundary_list.size = new_instancemethod(_cmf_core.NeumannBoundary_list_size,None,NeumannBoundary_list)
NeumannBoundary_list.to_node_list = new_instancemethod(_cmf_core.NeumannBoundary_list_to_node_list,None,NeumannBoundary_list)
NeumannBoundary_list.global_water_balance = new_instancemethod(_cmf_core.NeumannBoundary_list_global_water_balance,None,NeumannBoundary_list)
NeumannBoundary_list.water_balance = new_instancemethod(_cmf_core.NeumannBoundary_list_water_balance,None,NeumannBoundary_list)
NeumannBoundary_list_swigregister = _cmf_core.NeumannBoundary_list_swigregister
NeumannBoundary_list_swigregister(NeumannBoundary_list)


def vapour_pressure(*args):
  """vapour_pressure(double T) -> double"""
  return _cmf_core.vapour_pressure(*args)

def global_radiation(*args):
  """
    global_radiation(Time t, double height, double sunshine_fraction, double longitude = 8, 
        double latitude = 51, int time_zone = 1, 
        bool daily = 0) -> double
    """
  return _cmf_core.global_radiation(*args)

def Pressure(*args):
  """Pressure(double height) -> double"""
  return _cmf_core.Pressure(*args)
class Weather(object):
    """
    A structure to return all parts of the incoming radiation, all values
    in $\\frac{MJ}{m^2 day}$.

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    T = _swig_property(_cmf_core.Weather_T_get, _cmf_core.Weather_T_set)
    Tmax = _swig_property(_cmf_core.Weather_Tmax_get, _cmf_core.Weather_Tmax_set)
    Tmin = _swig_property(_cmf_core.Weather_Tmin_get, _cmf_core.Weather_Tmin_set)
    Tground = _swig_property(_cmf_core.Weather_Tground_get, _cmf_core.Weather_Tground_set)
    Windspeed = _swig_property(_cmf_core.Weather_Windspeed_get, _cmf_core.Weather_Windspeed_set)
    e_a = _swig_property(_cmf_core.Weather_e_a_get, _cmf_core.Weather_e_a_set)
    e_s = _swig_property(_cmf_core.Weather_e_s_get, _cmf_core.Weather_e_s_set)
    sunshine = _swig_property(_cmf_core.Weather_sunshine_get, _cmf_core.Weather_sunshine_set)
    Rs = _swig_property(_cmf_core.Weather_Rs_get, _cmf_core.Weather_Rs_set)
    instument_height = _swig_property(_cmf_core.Weather_instument_height_get, _cmf_core.Weather_instument_height_set)
    def Rn(self, *args):
        """
        Rn(self, double albedo, bool daily = False) -> double

        double Rn(double
        albedo, bool daily=false)

        Calculates the net radiation flux $R_n \\left[\\frac{MJ}{m^2
        day}\\right]$.

        \\begin{eqnarray*} R_{n} &=& R_{ns} - R_{nl} \\\\ \\mbox{ Net
        short wave radiation: }R_{ns} &=& (1-\\alpha) R_s \\\\ \\mbox{
        Net long wave radiation: }R_{nl} &=& R_{black}\\ \\beta_{v}\\
        \\beta_{c} \\\\ \\mbox{Black body radiation: } R_{black} &=&
        \\left\\{\\begin{array}{cl} \\sigma T^4 & \\mbox{for less
        than daily time steps} \\\\ \\sigma \\frac {T_{max}^4 +
        T_{min}^4} 2 & \\mbox{for daily time steps} \\end{array}
        \\right. \\\\ T &=& \\mbox{Temperature }[K] \\\\ \\sigma
        &=& 4.903\\ 10^{-9} \\frac{MJ}{K^4 m^2 day} \\mbox{ Stefan-
        Boltzmann constant } \\\\ \\mbox{Long wave reflectance: }
        \\\\ \\mbox{by water vapor: }\\beta_{v} &=& 0.34 - 0.14
        \\sqrt{e_a} \\\\ \\mbox{ by clouds: }\\beta_{c} &=& 0.1 +
        0.9 \\frac n N \\end{eqnarray*}

        Parameters:
        -----------

        albedo:  the albedo $\\alpha$ of the surface

        daily:  If true, the net radiation for daily averages will be
        calculated 
        """
        return _cmf_core.Weather_Rn(self, *args)

    def __init__(self, *args): 
        """__init__(self) -> Weather"""
        _cmf_core.Weather_swiginit(self,_cmf_core.new_Weather(*args))
    def to_string(self, *args):
        """to_string(self) -> string"""
        return _cmf_core.Weather_to_string(self, *args)

    snow_threshold = _swig_property(_cmf_core.Weather_snow_threshold_get, _cmf_core.Weather_snow_threshold_set)
    def __repr__(self):
        return "cmf.Weather()"
    def __str__(self):
        return "Weather: T(max/min)=%6.2f(%3.0f/%3.0f), Rs=%7.2f, rH=%3.0f%%" % (self.T,self.Tmin,self.Tmax,self.Rs,100*self.e_a/self.e_s)

    __swig_destroy__ = _cmf_core.delete_Weather
Weather.Rn = new_instancemethod(_cmf_core.Weather_Rn,None,Weather)
Weather.to_string = new_instancemethod(_cmf_core.Weather_to_string,None,Weather)
Weather_swigregister = _cmf_core.Weather_swigregister
Weather_swigregister(Weather)

class Meteorology(object):
    """
    In order to calculate ETpot with cmf a big amount of meteorological
    data is needed, more data than usually available. The Meteorology
    class can estimate missing data from a minimal set. As more data, as
    one provides, the better the calculation of ETpot becomes. The minimal
    data needed is Tmin and Tmax (daily) and precipitation. To calculate
    the global radiation (although measured global radiation could be
    inserted), the position of meteorological station in geographic
    coordinates has to be set.

    There are two modes for the meteorology: daily=true and daily=false.
    If daily=true, Radiation is given as a daily mean value. If
    daily=false, Radiation is given as an hourly mean value, which shows
    the dial ETpot variation but results in erronous results if the
    timestep is daily.

    In the following, we will assume a meteorological station with given
    Tmin, Tmax, precipitation and daily mean relative humidity. To use
    other meteorological data, please consult the description of the
    Meteorology class in the API documentationCreating a meteorological
    station

    import CMFlib as cmf                  latitude=51.2 # Latitude of
    station in decimal degrees                  longitude=8.1 # Longitude
    of station in decimal degrees (only needed for daily=false) timezone=1
    # Timezone, pos. values mean east of GMT, negative west (Germany=1,
    Pacific time=-8, only needed for daily=false) start=cmf.Time(1,1,2001)
    # Creates all timeseries with this start time, one can change them
    later                  step=cmf.day # s. start
    name="Giessen"           # A name for the station (optional)
    meteo=cmf.Meteorology(latitude,longitude,timezone,start,step,name)

    The daily flag is automatically set to true, since the step width is
    &ge cmf.dayLoading data into the meteorological station

    # MeteoData.txt is tab seperated file containing # Tmin [deg C],Tmax
    [deg C],rHmean [%] and precipitation [mm/day] values for every day
    f=file('MeteoData.txt') for line in file:
    meteo.Tmin.Add(float(line.split('\\t')[0]))
    meteo.Tmax.Add(float(line.split('\\t')[1]))
    meteo.rHmean.Add(float(line.split('\\t')[2]))
    meteo.Prec.Add(float(line.split('\\t')[3]))Using a meteorological
    station

    weather=meteo.GetData(cmf.Time(3,2,2001,14)) # Weather at Feb. 3rd,
    2001, 2pm                  print 'Global Radiation: ',weather.Rs
    # Daily mean Rs, since daily=true print 'Temperature:',weather.T
    # Daily mean T, since nothing else in known

    C++ includes: Meteorology.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(self, Time t) -> Weather"""
        return _cmf_core.Meteorology___call__(self, *args)

    def get_weather(self, *args):
        """get_weather(self, Time t) -> Weather"""
        return _cmf_core.Meteorology_get_weather(self, *args)

    def copy(self, *args):
        """copy(self) -> Meteorology"""
        return _cmf_core.Meteorology_copy(self, *args)

    def get_instrument_height(self, *args):
        """get_instrument_height(self) -> real"""
        return _cmf_core.Meteorology_get_instrument_height(self, *args)

    __swig_destroy__ = _cmf_core.delete_Meteorology
Meteorology.__call__ = new_instancemethod(_cmf_core.Meteorology___call__,None,Meteorology)
Meteorology.get_weather = new_instancemethod(_cmf_core.Meteorology_get_weather,None,Meteorology)
Meteorology.copy = new_instancemethod(_cmf_core.Meteorology_copy,None,Meteorology)
Meteorology.get_instrument_height = new_instancemethod(_cmf_core.Meteorology_get_instrument_height,None,Meteorology)
Meteorology_swigregister = _cmf_core.Meteorology_swigregister
Meteorology_swigregister(Meteorology)

class ConstantMeteorology(Meteorology):
    """Proxy of C++ cmf::atmosphere::ConstantMeteorology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    weather = _swig_property(_cmf_core.ConstantMeteorology_weather_get, _cmf_core.ConstantMeteorology_weather_set)
    def __init__(self, *args): 
        """
        __init__(self) -> ConstantMeteorology
        __init__(self, Weather w) -> ConstantMeteorology
        __init__(self, ConstantMeteorology other) -> ConstantMeteorology
        """
        _cmf_core.ConstantMeteorology_swiginit(self,_cmf_core.new_ConstantMeteorology(*args))
    def copy(self, *args):
        """copy(self) -> ConstantMeteorology"""
        return _cmf_core.ConstantMeteorology_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_ConstantMeteorology
ConstantMeteorology.copy = new_instancemethod(_cmf_core.ConstantMeteorology_copy,None,ConstantMeteorology)
ConstantMeteorology_swigregister = _cmf_core.ConstantMeteorology_swigregister
ConstantMeteorology_swigregister(ConstantMeteorology)

class MeteoStation(Locatable):
    """Proxy of C++ cmf::atmosphere::MeteoStation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Latitude = _swig_property(_cmf_core.MeteoStation_Latitude_get, _cmf_core.MeteoStation_Latitude_set)
    Longitude = _swig_property(_cmf_core.MeteoStation_Longitude_get, _cmf_core.MeteoStation_Longitude_set)
    Timezone = _swig_property(_cmf_core.MeteoStation_Timezone_get, _cmf_core.MeteoStation_Timezone_set)
    x = _swig_property(_cmf_core.MeteoStation_x_get, _cmf_core.MeteoStation_x_set)
    y = _swig_property(_cmf_core.MeteoStation_y_get, _cmf_core.MeteoStation_y_set)
    z = _swig_property(_cmf_core.MeteoStation_z_get, _cmf_core.MeteoStation_z_set)
    Name = _swig_property(_cmf_core.MeteoStation_Name_get, _cmf_core.MeteoStation_Name_set)
    daily = _swig_property(_cmf_core.MeteoStation_daily_get, _cmf_core.MeteoStation_daily_set)
    InstrumentHeight = _swig_property(_cmf_core.MeteoStation_InstrumentHeight_get, _cmf_core.MeteoStation_InstrumentHeight_set)
    def __init__(self, *args): 
        """__init__(self, MeteoStation other) -> MeteoStation"""
        _cmf_core.MeteoStation_swiginit(self,_cmf_core.new_MeteoStation(*args))
    def get_data(self, *args):
        """get_data(self, Time t, double height) -> Weather"""
        return _cmf_core.MeteoStation_get_data(self, *args)

    def SetSunshineFraction(self, *args):
        """SetSunshineFraction(self, timeseries sunshine_duration)"""
        return _cmf_core.MeteoStation_SetSunshineFraction(self, *args)

    T = _swig_property(_cmf_core.MeteoStation_T_get, _cmf_core.MeteoStation_T_set)
    Tmax = _swig_property(_cmf_core.MeteoStation_Tmax_get, _cmf_core.MeteoStation_Tmax_set)
    Tmin = _swig_property(_cmf_core.MeteoStation_Tmin_get, _cmf_core.MeteoStation_Tmin_set)
    Tground = _swig_property(_cmf_core.MeteoStation_Tground_get, _cmf_core.MeteoStation_Tground_set)
    Windspeed = _swig_property(_cmf_core.MeteoStation_Windspeed_get, _cmf_core.MeteoStation_Windspeed_set)
    rHmean = _swig_property(_cmf_core.MeteoStation_rHmean_get, _cmf_core.MeteoStation_rHmean_set)
    rHmin = _swig_property(_cmf_core.MeteoStation_rHmin_get, _cmf_core.MeteoStation_rHmin_set)
    rHmax = _swig_property(_cmf_core.MeteoStation_rHmax_get, _cmf_core.MeteoStation_rHmax_set)
    Tdew = _swig_property(_cmf_core.MeteoStation_Tdew_get, _cmf_core.MeteoStation_Tdew_set)
    Sunshine = _swig_property(_cmf_core.MeteoStation_Sunshine_get, _cmf_core.MeteoStation_Sunshine_set)
    Rs = _swig_property(_cmf_core.MeteoStation_Rs_get, _cmf_core.MeteoStation_Rs_set)
    T_lapse = _swig_property(_cmf_core.MeteoStation_T_lapse_get, _cmf_core.MeteoStation_T_lapse_set)
    def TimeseriesDictionary(self):
        return {"Tmin":self.Tmin,
                "Tmax":self.Tmax,
                "Tdew":self.Tdew,
                "T":self.T,
                "rHmean":self.rHmean,
                "rHmax":self.rHmax,
                "rHmin":self.rHmin,
                "Sunshine":self.Sunshine,
                "Windspeed":self.Windspeed,
                "Rs" : self.Rs}
    def __repr__(self):
        return "cmf.MeteoStation(%s,lat=%0.5g,lon=%0.5g,z=%6.1f)" % (self.Name,self.Latitude,self.Longitude,self.z)

    __swig_destroy__ = _cmf_core.delete_MeteoStation
MeteoStation.get_data = new_instancemethod(_cmf_core.MeteoStation_get_data,None,MeteoStation)
MeteoStation.SetSunshineFraction = new_instancemethod(_cmf_core.MeteoStation_SetSunshineFraction,None,MeteoStation)
MeteoStation_swigregister = _cmf_core.MeteoStation_swigregister
MeteoStation_swigregister(MeteoStation)

class MeteoStationReference(Meteorology,Locatable):
    """Proxy of C++ cmf::atmosphere::MeteoStationReference class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get_station(self, *args):
        """get_station(self)"""
        return _cmf_core.MeteoStationReference_get_station(self, *args)

    def __init__(self, *args): 
        """
        __init__(self,  station, Locatable location) -> MeteoStationReference
        __init__(self, MeteoStationReference copy) -> MeteoStationReference
        """
        _cmf_core.MeteoStationReference_swiginit(self,_cmf_core.new_MeteoStationReference(*args))
    def copy(self, *args):
        """copy(self) -> MeteoStationReference"""
        return _cmf_core.MeteoStationReference_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_MeteoStationReference
MeteoStationReference.get_station = new_instancemethod(_cmf_core.MeteoStationReference_get_station,None,MeteoStationReference)
MeteoStationReference.copy = new_instancemethod(_cmf_core.MeteoStationReference_copy,None,MeteoStationReference)
MeteoStationReference_swigregister = _cmf_core.MeteoStationReference_swigregister
MeteoStationReference_swigregister(MeteoStationReference)

class MeteoStationList(object):
    """Proxy of C++ cmf::atmosphere::MeteoStationList class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __len__(self, *args):
        """__len__(self) -> int"""
        return _cmf_core.MeteoStationList___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, int index)
        __getitem__(self, string Name)
        """
        return _cmf_core.MeteoStationList___getitem__(self, *args)

    def calculate_Temp_lapse(self, *args):
        """calculate_Temp_lapse(self, Time begin, Time step, Time end) -> double"""
        return _cmf_core.MeteoStationList_calculate_Temp_lapse(self, *args)

    def add_station(self, *args):
        """
        add_station(self, string name, double latitude = 51, double longitude = 8, 
            double timezone = 1, double elevation = 0, 
            Time startTime = cmf::math::Time(1,1,2001), 
            Time timestep = day)
        add_station(self, string name, point position, double latitude = 51, 
            double longitude = 8, double timezone = 1, Time startTime = cmf::math::Time(1,1,2001), 
            Time timestep = day)
        """
        return _cmf_core.MeteoStationList_add_station(self, *args)

    def remove_station(self, *args):
        """remove_station(self, int index) -> int"""
        return _cmf_core.MeteoStationList_remove_station(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> MeteoStationList
        __init__(self, MeteoStationList copy) -> MeteoStationList
        """
        _cmf_core.MeteoStationList_swiginit(self,_cmf_core.new_MeteoStationList(*args))
    def reference_to_nearest(self, *args):
        """reference_to_nearest(self, Locatable position, double z_weight = 0) -> MeteoStationReference"""
        return _cmf_core.MeteoStationList_reference_to_nearest(self, *args)

    def __iter__(self):
        for i in xrange(len(self)):
            yield self[i]
    def __repr__(self):
        return "list of %i cmf meteorological stations" % len(self)

    __swig_destroy__ = _cmf_core.delete_MeteoStationList
MeteoStationList.__len__ = new_instancemethod(_cmf_core.MeteoStationList___len__,None,MeteoStationList)
MeteoStationList.__getitem__ = new_instancemethod(_cmf_core.MeteoStationList___getitem__,None,MeteoStationList)
MeteoStationList.calculate_Temp_lapse = new_instancemethod(_cmf_core.MeteoStationList_calculate_Temp_lapse,None,MeteoStationList)
MeteoStationList.add_station = new_instancemethod(_cmf_core.MeteoStationList_add_station,None,MeteoStationList)
MeteoStationList.remove_station = new_instancemethod(_cmf_core.MeteoStationList_remove_station,None,MeteoStationList)
MeteoStationList.reference_to_nearest = new_instancemethod(_cmf_core.MeteoStationList_reference_to_nearest,None,MeteoStationList)
MeteoStationList_swigregister = _cmf_core.MeteoStationList_swigregister
MeteoStationList_swigregister(MeteoStationList)

class RainCloud(NeumannBoundary):
    """Proxy of C++ cmf::atmosphere::RainCloud class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get_cell(self, *args):
        """get_cell(self) -> Cell"""
        return _cmf_core.RainCloud_get_cell(self, *args)

    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_6__ swigSharedPtrUpcast) -> __dummy_4__"""
        return _cmf_core.RainCloud_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_RainCloud
RainCloud.get_cell = new_instancemethod(_cmf_core.RainCloud_get_cell,None,RainCloud)
RainCloud_swigregister = _cmf_core.RainCloud_swigregister
RainCloud_swigregister(RainCloud)

def RainCloud_SWIGSharedPtrUpcast(*args):
  """RainCloud_SWIGSharedPtrUpcast(__dummy_6__ swigSharedPtrUpcast) -> __dummy_4__"""
  return _cmf_core.RainCloud_SWIGSharedPtrUpcast(*args)

class _cell_object_list:
    def __init__(self,c,kind):
        self.c=c
        self.kind=kind
    def __get(self,index):
        if self.kind=="L":
            return self.c.get_layer(index)
        elif self.kind=="S":
            return self.c.get_storage(index)
        else:
             ndx=index if index>=0 else self.c.storage_count()+self.c.layer_count()+index
             lndx=index-self.c.storage_count()
             if lndx<0:
                 return self.c.get_storage(ndx)
             else:
                 return self.c.get_layer(lndx)
    def __getitem__(self,index):
        if (type(index)==slice):
             return list(map(self.get,range(*index.indices(len(self)))))
        try:
             gen=iter(index)
             return list(map(self.__get,gen))
        except TypeError:
             return self.__get(index)
    def find_by_name(self,name):
        for s in self:
            if s.Name==name:
                return s
        raise IndexError("No storage %s in %s of %s" % (name,"layers" if self.kind=='L' else "non layer storages" if self.kind=='S' else "storages",self.c))
    def __len__(self):
        return self.c.layer_count() if self.kind=='L' else (self.c.storage_count() if self.kind=='S' else self.c.layer_count()+self.c.storage_count())
    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

class Vegetation(object):
    """Proxy of C++ cmf::upslope::vegetation::Vegetation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LAI = _swig_property(_cmf_core.Vegetation_LAI_get, _cmf_core.Vegetation_LAI_set)
    Height = _swig_property(_cmf_core.Vegetation_Height_get, _cmf_core.Vegetation_Height_set)
    albedo = _swig_property(_cmf_core.Vegetation_albedo_get, _cmf_core.Vegetation_albedo_set)
    CanopyCapacityPerLAI = _swig_property(_cmf_core.Vegetation_CanopyCapacityPerLAI_get, _cmf_core.Vegetation_CanopyCapacityPerLAI_set)
    RootDepth = _swig_property(_cmf_core.Vegetation_RootDepth_get, _cmf_core.Vegetation_RootDepth_set)
    fraction_at_rootdepth = _swig_property(_cmf_core.Vegetation_fraction_at_rootdepth_get, _cmf_core.Vegetation_fraction_at_rootdepth_set)
    StomatalResistance = _swig_property(_cmf_core.Vegetation_StomatalResistance_get, _cmf_core.Vegetation_StomatalResistance_set)
    CanopyClosure = _swig_property(_cmf_core.Vegetation_CanopyClosure_get, _cmf_core.Vegetation_CanopyClosure_set)
    LeafWidth = _swig_property(_cmf_core.Vegetation_LeafWidth_get, _cmf_core.Vegetation_LeafWidth_set)
    def RootFraction(self, *args):
        """
        RootFraction(self, double upperBoundary, double lowerBoundary) -> double

        virtual double
        RootFraction(double upperBoundary, double lowerBoundary) const 
        """
        return _cmf_core.Vegetation_RootFraction(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double _LAI = 2.88, double _Height = 0.12, double _RootDepth = 0.25, 
            double _StomatalResistance = 100, 
            double _albedo = 0.23, double _CanopyClosure = 1, 
            double _CanopyCapacityPerLAI = 0.1, 
            double _fraction_at_rootdepth = 1.0) -> Vegetation

        Vegetation(double
        _LAI=12, double _Height=0.12, double _RootDepth=0.25, double
        _StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
        double _CanopyCapacityPerLAI=0.01) 
        """
        _cmf_core.Vegetation_swiginit(self,_cmf_core.new_Vegetation(*args))
    __swig_destroy__ = _cmf_core.delete_Vegetation
Vegetation.RootFraction = new_instancemethod(_cmf_core.Vegetation_RootFraction,None,Vegetation)
Vegetation_swigregister = _cmf_core.Vegetation_swigregister
Vegetation_swigregister(Vegetation)

class CellConnector(object):
    """Proxy of C++ cmf::upslope::CellConnector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def connect(self, *args):
        """connect(self, Cell cell1, Cell cell2, int start_at_layer = 0)"""
        return _cmf_core.CellConnector_connect(self, *args)

    __swig_destroy__ = _cmf_core.delete_CellConnector
CellConnector.connect = new_instancemethod(_cmf_core.CellConnector_connect,None,CellConnector)
CellConnector_swigregister = _cmf_core.CellConnector_swigregister
CellConnector_swigregister(CellConnector)

class Cell(StateVariableOwner,Locatable):
    """Proxy of C++ cmf::upslope::Cell class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_cmf_core.Cell_x_get, _cmf_core.Cell_x_set)
    y = _swig_property(_cmf_core.Cell_y_get, _cmf_core.Cell_y_set)
    z = _swig_property(_cmf_core.Cell_z_get, _cmf_core.Cell_z_set)
    def get_area(self, *args):
        """get_area(self) -> double"""
        return _cmf_core.Cell_get_area(self, *args)

    def InvalidateSatDepth(self, *args):
        """InvalidateSatDepth(self)"""
        return _cmf_core.Cell_InvalidateSatDepth(self, *args)

    def get_saturated_depth(self, *args):
        """get_saturated_depth(self) -> real"""
        return _cmf_core.Cell_get_saturated_depth(self, *args)

    def set_saturated_depth(self, *args):
        """set_saturated_depth(self, real depth)"""
        return _cmf_core.Cell_set_saturated_depth(self, *args)

    def get_surfacewater(self, *args):
        """get_surfacewater(self) -> ptr"""
        return _cmf_core.Cell_get_surfacewater(self, *args)

    def surfacewater_as_storage(self, *args):
        """surfacewater_as_storage(self)"""
        return _cmf_core.Cell_surfacewater_as_storage(self, *args)

    def add_storage(self, *args):
        """add_storage(self, string Name, char storage_role = 'N', bool isopenwater = False) -> ptr"""
        return _cmf_core.Cell_add_storage(self, *args)

    def remove_storage(self, *args):
        """remove_storage(self, WaterStorage storage)"""
        return _cmf_core.Cell_remove_storage(self, *args)

    def storage_count(self, *args):
        """storage_count(self) -> int"""
        return _cmf_core.Cell_storage_count(self, *args)

    def get_storage(self, *args):
        """get_storage(self, int index) -> ptr"""
        return _cmf_core.Cell_get_storage(self, *args)

    def get_canopy(self, *args):
        """get_canopy(self) -> ptr"""
        return _cmf_core.Cell_get_canopy(self, *args)

    def get_snow(self, *args):
        """get_snow(self) -> ptr"""
        return _cmf_core.Cell_get_snow(self, *args)

    def snow_coverage(self, *args):
        """snow_coverage(self) -> real"""
        return _cmf_core.Cell_snow_coverage(self, *args)

    def has_wet_leaves(self, *args):
        """has_wet_leaves(self) -> bool"""
        return _cmf_core.Cell_has_wet_leaves(self, *args)

    def has_surface_water(self, *args):
        """has_surface_water(self) -> bool"""
        return _cmf_core.Cell_has_surface_water(self, *args)

    def get_vegetation(self, *args):
        """get_vegetation(self) -> Vegetation"""
        return _cmf_core.Cell_get_vegetation(self, *args)

    def set_vegetation(self, *args):
        """set_vegetation(self, Vegetation val)"""
        return _cmf_core.Cell_set_vegetation(self, *args)

    Id = _swig_property(_cmf_core.Cell_Id_get, _cmf_core.Cell_Id_set)
    def project(self, *args):
        """project(self) -> project"""
        return _cmf_core.Cell_project(self, *args)

    def get_weather(self, *args):
        """get_weather(self, Time t) -> Weather"""
        return _cmf_core.Cell_get_weather(self, *args)

    def layer_count(self, *args):
        """layer_count(self) -> int"""
        return _cmf_core.Cell_layer_count(self, *args)

    def get_layer(self, *args):
        """get_layer(self, int ndx) -> layer_ptr"""
        return _cmf_core.Cell_get_layer(self, *args)

    def add_layer(self, *args):
        """add_layer(self, real lowerboundary, RetentionCurve r_curve, real saturateddepth = 10)"""
        return _cmf_core.Cell_add_layer(self, *args)

    def add_variable_layer_pair(self, *args):
        """add_variable_layer_pair(self, real lowerboundary, RetentionCurve r_curve)"""
        return _cmf_core.Cell_add_variable_layer_pair(self, *args)

    def remove_last_layer(self, *args):
        """remove_last_layer(self)"""
        return _cmf_core.Cell_remove_last_layer(self, *args)

    def remove_layers(self, *args):
        """remove_layers(self)"""
        return _cmf_core.Cell_remove_layers(self, *args)

    __swig_destroy__ = _cmf_core.delete_Cell
    def __init__(self, *args): 
        """
        __init__(self, double x, double y, double z, double area, project _project) -> Cell

        Cell(double x,
        double y, double z, double area) 
        """
        _cmf_core.Cell_swiginit(self,_cmf_core.new_Cell(*args))
    def to_string(self, *args):
        """to_string(self) -> string"""
        return _cmf_core.Cell_to_string(self, *args)

    topology = _swig_property(_cmf_core.Cell_topology_get)
    evaporation = _swig_property(_cmf_core.Cell_evaporation_get)
    transpiration = _swig_property(_cmf_core.Cell_transpiration_get)
    meteorology = _swig_property(_cmf_core.Cell_meteorology_get, _cmf_core.Cell_meteorology_set)
    rain = _swig_property(_cmf_core.Cell_rain_get)
    @property
    def neighbors(self):
        c_iter=NeighborIterator(self)
        while c_iter.valid():
            yield (c_iter.cell(),c_iter.flowwidth())
            c_iter.next()

    storages=property(lambda c:_cell_object_list(c,'A'),None,"Provides access to all storages of the cell (surface storages and layers)")
    surface_storages=property(lambda c:_cell_object_list(c,'S'),None,"Provides access to all surface storages of the cell, like canopy, snow, surface water etc")
    layers=property(lambda c:_cell_object_list(c,'L'),None,"Provides access to all soil water storages (layers) of the cell")
    surfacewater=property(get_surfacewater,None,"Gives access to the surface water, which is either a distributing flux node, or the storage for all surface water")
    canopy=property(get_canopy,None,"The canopy water storage of the cell, if it exists")
    snow=property(get_snow,None,"The snow pack of the cell, if a storage for the snow exists")
    saturated_depth=property(get_saturated_depth,set_saturated_depth,"Gets or sets the saturated depth of a cell, if setting each layer of the cell will get a new water content")
    area=property(get_area,None,"The area of the cell in m2")
    soildepth=property(lambda self:0 if self.layer_count()==0 else self.layers[-1].boundary[-1],None,"the soildepth in m (lower boundary of lowest layer)")
    reach=property(lambda self:self.get_reach(0),None,"The first reach of the cell, other reaches are accessible via reaches[n]")
    reaches=property(lambda self:[self.get_reach(i) for i in range(self.ReachCount())],None,"The reaches of this cell")
    Vegetation=property(get_vegetation,set_vegetation,"The vegetational parameters of the cell")


    contributing_area=property(lambda self:self.topology.ContributingArea(),None,"Contributing area of this cell m2")
    main_outlet=property(lambda self:self.topology.MainOutlet(),None,"The main outlet of the surface water of this cell")

    def connect_soil_with_node(self,node,type,flowwidth,distance,upper_boundary=0,lower_boundary=None):
        """Connects all layers between the boundaries with a node using a flux connection
        node: Target node (flux_node)
        type: Type of the connection (e.g. cmf.Richards_lateral)
        flowwidth: Width of the connection
        distance: distance of the connection
        upper_boundary: Connect only layers, whose lower depth is greater then this value
        lower_boundary: Connect only  layers, whose upper depth is smaller then this value
        """
        if lower_boundary is None:
            lower_boundary=self.soildepth
        for l in self.layers:
            if l.boundary[0]<lower_boundary and l.boundary[1]>upper_boundary:
                type(l,node,flowwidth,distance).thisown=0
        
    def install_connection(self,connection_type):
        if hasattr(connection_type,"use_for_cell"):
            connection_type.use_for_cell(self)
        else:
            raise TypeError("Only connection types implementing a static use_for_cell function can be used")
    def __hash__(self):
        return hash((self.x,self.y,self.Id))
    def __eq__(self,cmp):
        return hash(self)==hash(cmp)
    def __repr__(self):
        return "cell #%i(%g,%g,%g)" % (self.Id,self.x,self.y,self.z)

Cell.get_area = new_instancemethod(_cmf_core.Cell_get_area,None,Cell)
Cell.InvalidateSatDepth = new_instancemethod(_cmf_core.Cell_InvalidateSatDepth,None,Cell)
Cell.get_saturated_depth = new_instancemethod(_cmf_core.Cell_get_saturated_depth,None,Cell)
Cell.set_saturated_depth = new_instancemethod(_cmf_core.Cell_set_saturated_depth,None,Cell)
Cell.get_surfacewater = new_instancemethod(_cmf_core.Cell_get_surfacewater,None,Cell)
Cell.surfacewater_as_storage = new_instancemethod(_cmf_core.Cell_surfacewater_as_storage,None,Cell)
Cell.add_storage = new_instancemethod(_cmf_core.Cell_add_storage,None,Cell)
Cell.remove_storage = new_instancemethod(_cmf_core.Cell_remove_storage,None,Cell)
Cell.storage_count = new_instancemethod(_cmf_core.Cell_storage_count,None,Cell)
Cell.get_storage = new_instancemethod(_cmf_core.Cell_get_storage,None,Cell)
Cell.get_canopy = new_instancemethod(_cmf_core.Cell_get_canopy,None,Cell)
Cell.get_snow = new_instancemethod(_cmf_core.Cell_get_snow,None,Cell)
Cell.snow_coverage = new_instancemethod(_cmf_core.Cell_snow_coverage,None,Cell)
Cell.has_wet_leaves = new_instancemethod(_cmf_core.Cell_has_wet_leaves,None,Cell)
Cell.has_surface_water = new_instancemethod(_cmf_core.Cell_has_surface_water,None,Cell)
Cell.get_vegetation = new_instancemethod(_cmf_core.Cell_get_vegetation,None,Cell)
Cell.set_vegetation = new_instancemethod(_cmf_core.Cell_set_vegetation,None,Cell)
Cell.project = new_instancemethod(_cmf_core.Cell_project,None,Cell)
Cell.get_weather = new_instancemethod(_cmf_core.Cell_get_weather,None,Cell)
Cell.layer_count = new_instancemethod(_cmf_core.Cell_layer_count,None,Cell)
Cell.get_layer = new_instancemethod(_cmf_core.Cell_get_layer,None,Cell)
Cell.add_layer = new_instancemethod(_cmf_core.Cell_add_layer,None,Cell)
Cell.add_variable_layer_pair = new_instancemethod(_cmf_core.Cell_add_variable_layer_pair,None,Cell)
Cell.remove_last_layer = new_instancemethod(_cmf_core.Cell_remove_last_layer,None,Cell)
Cell.remove_layers = new_instancemethod(_cmf_core.Cell_remove_layers,None,Cell)
Cell.to_string = new_instancemethod(_cmf_core.Cell_to_string,None,Cell)
Cell_swigregister = _cmf_core.Cell_swigregister
Cell_swigregister(Cell)

class Topology(Locatable):
    """Proxy of C++ cmf::upslope::Topology class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    cell = _swig_property(_cmf_core.Topology_cell_get)
    x = _swig_property(_cmf_core.Topology_x_get, _cmf_core.Topology_x_set)
    y = _swig_property(_cmf_core.Topology_y_get, _cmf_core.Topology_y_set)
    z = _swig_property(_cmf_core.Topology_z_get, _cmf_core.Topology_z_set)
    def flowwidth(self, *args):
        """
        flowwidth(self, Cell target) -> double
        flowwidth(self, Topology target) -> double
        """
        return _cmf_core.Topology_flowwidth(self, *args)

    def AddNeighbor(self, *args):
        """
        AddNeighbor(self, Cell target, double flowwidth)
        AddNeighbor(self, Topology target, double flowwidth)
        """
        return _cmf_core.Topology_AddNeighbor(self, *args)

    def RemoveNeighbor(self, *args):
        """RemoveNeighbor(self, Topology target)"""
        return _cmf_core.Topology_RemoveNeighbor(self, *args)

    def neighbor_count(self, *args):
        """neighbor_count(self) -> size_t"""
        return _cmf_core.Topology_neighbor_count(self, *args)

    def MainOutlet(self, *args):
        """MainOutlet(self, bool forceRecalc = False) -> Cell"""
        return _cmf_core.Topology_MainOutlet(self, *args)

    def ContributingArea(self, *args):
        """ContributingArea(self) -> double"""
        return _cmf_core.Topology_ContributingArea(self, *args)

    def calculate_contributing_area(*args):
        """calculate_contributing_area(cell_vector arg0)"""
        return _cmf_core.Topology_calculate_contributing_area(*args)

    calculate_contributing_area = staticmethod(calculate_contributing_area)
    def __eq__(self, *args):
        """__eq__(self, Topology cmp) -> bool"""
        return _cmf_core.Topology___eq__(self, *args)

    __swig_destroy__ = _cmf_core.delete_Topology
Topology.flowwidth = new_instancemethod(_cmf_core.Topology_flowwidth,None,Topology)
Topology.AddNeighbor = new_instancemethod(_cmf_core.Topology_AddNeighbor,None,Topology)
Topology.RemoveNeighbor = new_instancemethod(_cmf_core.Topology_RemoveNeighbor,None,Topology)
Topology.neighbor_count = new_instancemethod(_cmf_core.Topology_neighbor_count,None,Topology)
Topology.MainOutlet = new_instancemethod(_cmf_core.Topology_MainOutlet,None,Topology)
Topology.ContributingArea = new_instancemethod(_cmf_core.Topology_ContributingArea,None,Topology)
Topology.__eq__ = new_instancemethod(_cmf_core.Topology___eq__,None,Topology)
Topology_swigregister = _cmf_core.Topology_swigregister
Topology_swigregister(Topology)

def Topology_calculate_contributing_area(*args):
  """Topology_calculate_contributing_area(cell_vector arg0)"""
  return _cmf_core.Topology_calculate_contributing_area(*args)

class NeighborIterator(object):
    """Proxy of C++ cmf::upslope::NeighborIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Cell cell) -> NeighborIterator"""
        _cmf_core.NeighborIterator_swiginit(self,_cmf_core.new_NeighborIterator(*args))
    def cell(self, *args):
        """cell(self) -> Cell"""
        return _cmf_core.NeighborIterator_cell(self, *args)

    def flowwidth(self, *args):
        """flowwidth(self) -> double"""
        return _cmf_core.NeighborIterator_flowwidth(self, *args)

    def valid(self, *args):
        """valid(self) -> bool"""
        return _cmf_core.NeighborIterator_valid(self, *args)

    def next(self, *args):
        """next(self) -> NeighborIterator"""
        return _cmf_core.NeighborIterator_next(self, *args)

    def __eq__(self, *args):
        """__eq__(self, NeighborIterator cmp) -> bool"""
        return _cmf_core.NeighborIterator___eq__(self, *args)

    def __neq__(self, *args):
        """__neq__(self, NeighborIterator cmp) -> bool"""
        return _cmf_core.NeighborIterator___neq__(self, *args)

    __swig_destroy__ = _cmf_core.delete_NeighborIterator
NeighborIterator.cell = new_instancemethod(_cmf_core.NeighborIterator_cell,None,NeighborIterator)
NeighborIterator.flowwidth = new_instancemethod(_cmf_core.NeighborIterator_flowwidth,None,NeighborIterator)
NeighborIterator.valid = new_instancemethod(_cmf_core.NeighborIterator_valid,None,NeighborIterator)
NeighborIterator.next = new_instancemethod(_cmf_core.NeighborIterator_next,None,NeighborIterator)
NeighborIterator.__eq__ = new_instancemethod(_cmf_core.NeighborIterator___eq__,None,NeighborIterator)
NeighborIterator.__neq__ = new_instancemethod(_cmf_core.NeighborIterator___neq__,None,NeighborIterator)
NeighborIterator_swigregister = _cmf_core.NeighborIterator_swigregister
NeighborIterator_swigregister(NeighborIterator)

class cell_vector(object):
    """Proxy of C++ std::vector<(p.cmf::upslope::Cell)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self, *args):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class. 
        """
        return _cmf_core.cell_vector_iterator(self, *args)

    def __iter__(self): return self.iterator()
    def __nonzero__(self, *args):
        """__nonzero__(self) -> bool"""
        return _cmf_core.cell_vector___nonzero__(self, *args)

    def __bool__(self, *args):
        """__bool__(self) -> bool"""
        return _cmf_core.cell_vector___bool__(self, *args)

    def __len__(self, *args):
        """__len__(self) -> size_type"""
        return _cmf_core.cell_vector___len__(self, *args)

    def pop(self, *args):
        """pop(self) -> value_type"""
        return _cmf_core.cell_vector_pop(self, *args)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> cell_vector"""
        return _cmf_core.cell_vector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, cell_vector v)"""
        return _cmf_core.cell_vector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _cmf_core.cell_vector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _cmf_core.cell_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> cell_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _cmf_core.cell_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, cell_vector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _cmf_core.cell_vector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _cmf_core.cell_vector_append(self, *args)

    def empty(self, *args):
        """empty(self) -> bool"""
        return _cmf_core.cell_vector_empty(self, *args)

    def size(self, *args):
        """size(self) -> size_type"""
        return _cmf_core.cell_vector_size(self, *args)

    def clear(self, *args):
        """clear(self)"""
        return _cmf_core.cell_vector_clear(self, *args)

    def swap(self, *args):
        """swap(self, cell_vector v)"""
        return _cmf_core.cell_vector_swap(self, *args)

    def get_allocator(self, *args):
        """get_allocator(self) -> allocator_type"""
        return _cmf_core.cell_vector_get_allocator(self, *args)

    def begin(self, *args):
        """begin(self) -> const_iterator"""
        return _cmf_core.cell_vector_begin(self, *args)

    def end(self, *args):
        """end(self) -> const_iterator"""
        return _cmf_core.cell_vector_end(self, *args)

    def rbegin(self, *args):
        """rbegin(self) -> const_reverse_iterator"""
        return _cmf_core.cell_vector_rbegin(self, *args)

    def rend(self, *args):
        """rend(self) -> const_reverse_iterator"""
        return _cmf_core.cell_vector_rend(self, *args)

    def pop_back(self, *args):
        """pop_back(self)"""
        return _cmf_core.cell_vector_pop_back(self, *args)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _cmf_core.cell_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> cell_vector
        __init__(self, cell_vector arg0) -> cell_vector
        __init__(self, size_type size) -> cell_vector
        __init__(self, size_type size, value_type value) -> cell_vector
        """
        _cmf_core.cell_vector_swiginit(self,_cmf_core.new_cell_vector(*args))
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _cmf_core.cell_vector_push_back(self, *args)

    def front(self, *args):
        """front(self) -> value_type"""
        return _cmf_core.cell_vector_front(self, *args)

    def back(self, *args):
        """back(self) -> value_type"""
        return _cmf_core.cell_vector_back(self, *args)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _cmf_core.cell_vector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _cmf_core.cell_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _cmf_core.cell_vector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _cmf_core.cell_vector_reserve(self, *args)

    def capacity(self, *args):
        """capacity(self) -> size_type"""
        return _cmf_core.cell_vector_capacity(self, *args)

    __swig_destroy__ = _cmf_core.delete_cell_vector
cell_vector.iterator = new_instancemethod(_cmf_core.cell_vector_iterator,None,cell_vector)
cell_vector.__nonzero__ = new_instancemethod(_cmf_core.cell_vector___nonzero__,None,cell_vector)
cell_vector.__bool__ = new_instancemethod(_cmf_core.cell_vector___bool__,None,cell_vector)
cell_vector.__len__ = new_instancemethod(_cmf_core.cell_vector___len__,None,cell_vector)
cell_vector.pop = new_instancemethod(_cmf_core.cell_vector_pop,None,cell_vector)
cell_vector.__getslice__ = new_instancemethod(_cmf_core.cell_vector___getslice__,None,cell_vector)
cell_vector.__setslice__ = new_instancemethod(_cmf_core.cell_vector___setslice__,None,cell_vector)
cell_vector.__delslice__ = new_instancemethod(_cmf_core.cell_vector___delslice__,None,cell_vector)
cell_vector.__delitem__ = new_instancemethod(_cmf_core.cell_vector___delitem__,None,cell_vector)
cell_vector.__getitem__ = new_instancemethod(_cmf_core.cell_vector___getitem__,None,cell_vector)
cell_vector.__setitem__ = new_instancemethod(_cmf_core.cell_vector___setitem__,None,cell_vector)
cell_vector.append = new_instancemethod(_cmf_core.cell_vector_append,None,cell_vector)
cell_vector.empty = new_instancemethod(_cmf_core.cell_vector_empty,None,cell_vector)
cell_vector.size = new_instancemethod(_cmf_core.cell_vector_size,None,cell_vector)
cell_vector.clear = new_instancemethod(_cmf_core.cell_vector_clear,None,cell_vector)
cell_vector.swap = new_instancemethod(_cmf_core.cell_vector_swap,None,cell_vector)
cell_vector.get_allocator = new_instancemethod(_cmf_core.cell_vector_get_allocator,None,cell_vector)
cell_vector.begin = new_instancemethod(_cmf_core.cell_vector_begin,None,cell_vector)
cell_vector.end = new_instancemethod(_cmf_core.cell_vector_end,None,cell_vector)
cell_vector.rbegin = new_instancemethod(_cmf_core.cell_vector_rbegin,None,cell_vector)
cell_vector.rend = new_instancemethod(_cmf_core.cell_vector_rend,None,cell_vector)
cell_vector.pop_back = new_instancemethod(_cmf_core.cell_vector_pop_back,None,cell_vector)
cell_vector.erase = new_instancemethod(_cmf_core.cell_vector_erase,None,cell_vector)
cell_vector.push_back = new_instancemethod(_cmf_core.cell_vector_push_back,None,cell_vector)
cell_vector.front = new_instancemethod(_cmf_core.cell_vector_front,None,cell_vector)
cell_vector.back = new_instancemethod(_cmf_core.cell_vector_back,None,cell_vector)
cell_vector.assign = new_instancemethod(_cmf_core.cell_vector_assign,None,cell_vector)
cell_vector.resize = new_instancemethod(_cmf_core.cell_vector_resize,None,cell_vector)
cell_vector.insert = new_instancemethod(_cmf_core.cell_vector_insert,None,cell_vector)
cell_vector.reserve = new_instancemethod(_cmf_core.cell_vector_reserve,None,cell_vector)
cell_vector.capacity = new_instancemethod(_cmf_core.cell_vector_capacity,None,cell_vector)
cell_vector_swigregister = _cmf_core.cell_vector_swigregister
cell_vector_swigregister(cell_vector)


def find_cell(*args):
  """find_cell(cells_ref arg0, point p, double max_dist = 1e20) -> Cell"""
  return _cmf_core.find_cell(*args)

def get_boundary_cells(*args):
  """get_boundary_cells(cells_ref cells) -> cell_vector"""
  return _cmf_core.get_boundary_cells(*args)

def get_connections(*args):
  """get_connections(cells_ref cells) -> connection_set"""
  return _cmf_core.get_connections(*args)

def connect_cells_with_flux(*args):
  """connect_cells_with_flux(cells_ref cells, CellConnector connect, int start_at_layer = 0)"""
  return _cmf_core.connect_cells_with_flux(*args)

def fill_sinks(*args):
  """fill_sinks(cells_ref cells, double min_difference = 0.001) -> int"""
  return _cmf_core.fill_sinks(*args)

def area(*args):
  """area(cells_ref cells) -> double"""
  return _cmf_core.area(*args)

def set_meteo_station(*args):
  """set_meteo_station(cells_ref cells,  meteo_station)"""
  return _cmf_core.set_meteo_station(*args)

def set_precipitation(*args):
  """set_precipitation(cells_ref cells, timeseries data_in_mm_day)"""
  return _cmf_core.set_precipitation(*args)

def cell_positions(*args):
  """cell_positions(cells_ref cells) -> point_vector"""
  return _cmf_core.cell_positions(*args)

def cell_flux_directions(*args):
  """cell_flux_directions(cells_ref cells, Time arg1) -> point_vector"""
  return _cmf_core.cell_flux_directions(*args)

def pressure_to_waterhead(*args):
  """pressure_to_waterhead(double Pressure) -> double"""
  return _cmf_core.pressure_to_waterhead(*args)

def waterhead_to_pressure(*args):
  """waterhead_to_pressure(double waterhead) -> double"""
  return _cmf_core.waterhead_to_pressure(*args)

def pF_to_waterhead(*args):
  """pF_to_waterhead(double pF) -> double"""
  return _cmf_core.pF_to_waterhead(*args)

def waterhead_to_pF(*args):
  """waterhead_to_pF(double waterhead) -> double"""
  return _cmf_core.waterhead_to_pF(*args)
class RetentionCurve(object):
    """
    Abstract base class for different types of retention curves.

    This class, and its children uses wetness instead of volumetric water
    content. The wetness of a soil is defined as water content per void
    volume

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def K(self, *args):
        """
        K(self, real wetness, real depth) -> real

        virtual real
        K(real wetness, real depth) const =0

        Returns the conductivity in m/day at a certain depth and water
        content. 
        """
        return _cmf_core.RetentionCurve_K(self, *args)

    def Wetness_eff(self, *args):
        """Wetness_eff(self, real wetness, real pF_r = 4.2) -> real"""
        return _cmf_core.RetentionCurve_Wetness_eff(self, *args)

    def Porosity(self, *args):
        """
        Porosity(self, real depth) -> real

        virtual real Porosity(real depth) const =0

        Returns the porosity at a certain depth. 
        """
        return _cmf_core.RetentionCurve_Porosity(self, *args)

    def VoidVolume(self, *args):
        """
        VoidVolume(self, real upperDepth, real lowerDepth, real Area) -> real

        virtual real VoidVolume(real upperDepth, real lowerDepth, real Area)
        const =0

        Returns the void volume of a soil column. 
        """
        return _cmf_core.RetentionCurve_VoidVolume(self, *args)

    def FillHeight(self, *args):
        """
        FillHeight(self, real lowerDepth, real Area, real Volume) -> real

        virtual real FillHeight(real lowerDepth, real Area, real Volume) const
        =0

        Returns the thickness of a soil column with a certain pore volume. 
        """
        return _cmf_core.RetentionCurve_FillHeight(self, *args)

    def Transmissivity(self, *args):
        """
        Transmissivity(self, real upperDepth, real lowerDepth, real wetness) -> real

        virtual real Transmissivity(real upperDepth, real lowerDepth, real
        theta) const =0

        Returns the transmissivity of a part of a soil column. 
        """
        return _cmf_core.RetentionCurve_Transmissivity(self, *args)

    def Wetness(self, *args):
        """
        Wetness(self, real suction) -> real

        virtual
        real Wetness(real suction) const =0

        returns the wetness (volumetric water content per pore space) at a
        given suction pressure 
        """
        return _cmf_core.RetentionCurve_Wetness(self, *args)

    def Wetness_pF(self, *args):
        """
        Wetness_pF(self, real pF) -> real

        real
        Wetness_pF(real pF) const

        returns the volumetric water content at a given pF value 
        """
        return _cmf_core.RetentionCurve_Wetness_pF(self, *args)

    def MatricPotential(self, *args):
        """
        MatricPotential(self, real wetness) -> real

        virtual real MatricPotential(real wetness) const =0

        returns the wetness of the soil at given water content 
        """
        return _cmf_core.RetentionCurve_MatricPotential(self, *args)

    def copy(self, *args):
        """
        copy(self) -> RetentionCurve

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf_core.RetentionCurve_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_RetentionCurve
RetentionCurve.K = new_instancemethod(_cmf_core.RetentionCurve_K,None,RetentionCurve)
RetentionCurve.Wetness_eff = new_instancemethod(_cmf_core.RetentionCurve_Wetness_eff,None,RetentionCurve)
RetentionCurve.Porosity = new_instancemethod(_cmf_core.RetentionCurve_Porosity,None,RetentionCurve)
RetentionCurve.VoidVolume = new_instancemethod(_cmf_core.RetentionCurve_VoidVolume,None,RetentionCurve)
RetentionCurve.FillHeight = new_instancemethod(_cmf_core.RetentionCurve_FillHeight,None,RetentionCurve)
RetentionCurve.Transmissivity = new_instancemethod(_cmf_core.RetentionCurve_Transmissivity,None,RetentionCurve)
RetentionCurve.Wetness = new_instancemethod(_cmf_core.RetentionCurve_Wetness,None,RetentionCurve)
RetentionCurve.Wetness_pF = new_instancemethod(_cmf_core.RetentionCurve_Wetness_pF,None,RetentionCurve)
RetentionCurve.MatricPotential = new_instancemethod(_cmf_core.RetentionCurve_MatricPotential,None,RetentionCurve)
RetentionCurve.copy = new_instancemethod(_cmf_core.RetentionCurve_copy,None,RetentionCurve)
RetentionCurve_swigregister = _cmf_core.RetentionCurve_swigregister
RetentionCurve_swigregister(RetentionCurve)
rho_wg = cvar.rho_wg

class BrooksCoreyRetentionCurve(RetentionCurve):
    """
    Provides the use of the Brooks-Corey retention curve
    \\begin{eqnarray*} K(W) &=& K_{sat} W^{2+3b} \\\\ \\Psi(W) &=&
    \\Psi_X \\left(\\frac{W}{W_X}\\right)^{-b} \\\\ W &=&
    {\\left( \\frac{\\Psi_X}{\\Psi}\\right)
    }^{\\frac{1}{b}}\\ W_X \\end{eqnarray*} where:  $K$ is the
    conductivity in $\\frac m {day}$

    $W$ is the wetness (Volume of soil water per volume of pores)

    $b$ is the shape of the retention curve (usually between 4 (sand) and
    14 (clay))

    $\\Psi(W)$ is the matric potential in $m H_2O$ at wetness W

    $\\Psi_X$ is a matric potential at a known wetness in $m H_2O$

    $\\W_X$ is the wetness with a known matric potential for dynamic
    changes with depth, exponential decays of porosity and saturated
    conductivity are used The decay function is: $ v(d)=v(0) (1+a)^{-d} $,
    where v is the value ( $ K_{sat},\\Phi$), d is the depth in m and a
    is the fractional decay per m. E.g. 0.1 means the value has in 1 m
    depth 90% of the value at the surface.

    C++ includes: RetentionCurve.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetKsat(self, *args):
        """
        SetKsat(self, real ksat, real ksat_decay)

        real SetKsat(real
        ksat, real ksat_decay) 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_SetKsat(self, *args)

    def SetPorosity(self, *args):
        """
        SetPorosity(self, real porosity, real porosity_decay = 0)

        void
        SetPorosity(real porosity, real porosity_decay=0)

        Sets the porosity (Volume of pores per volume of soil) and the
        exponential porosity decline with depth. 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_SetPorosity(self, *args)

    wetness_X = _swig_property(_cmf_core.BrooksCoreyRetentionCurve_wetness_X_get, _cmf_core.BrooksCoreyRetentionCurve_wetness_X_set)
    Psi_X = _swig_property(_cmf_core.BrooksCoreyRetentionCurve_Psi_X_get, _cmf_core.BrooksCoreyRetentionCurve_Psi_X_set)
    def b(self, *args):
        """b(self) -> real"""
        return _cmf_core.BrooksCoreyRetentionCurve_b(self, *args)

    def Set_b(self, *args):
        """Set_b(self, real new_b)"""
        return _cmf_core.BrooksCoreyRetentionCurve_Set_b(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real ksat = 15, real porosity = 0.5, real _b = 5, real theta_x = 0.2, 
            real psi_x = cmf::upslope::pF_to_waterhead(2.5), 
            real ksat_decay = 0, real porosity_decay = 0) -> BrooksCoreyRetentionCurve

        BrooksCoreyRetentionCurve(real ksat, real porosity, real theta1, real
        theta2, real psi_1=pF_to_waterhead(2.5), real
        psi_2=pF_to_waterhead(4.2))

        Creates a soiltype from two known points of the retention curve (e.g.
        fieldcapacity and wilting point).

        Parameters:
        -----------

        ksat:  Saturated conductivity $\\frac{m}{day}$

        porosity:   $\\frac {m^3 Pores}{m^3 Soil}$

        theta1:   $\\theta_1$ First water content at a specific suction
        pressure (e.g. fieldcapacity)

        theta2:   $\\theta_2$ Second water content at a specific suction
        pressure (e.g. wiltingpoint)

        psi_1:   $ \\Psi_1$ Suction pressure for $\\theta_1$ in m water
        column, use the conversion functions pF_to_waterhead,
        pressure_to_waterhead to convert pressure in to waterhead height
        (default pF=2.5)

        psi_2:   $ \\Psi_2$ Suction pressure for $\\theta_2$ in m water
        column, use the conversion functions pF_to_waterhead,
        pressure_to_waterhead to convert pressure in to waterhead height
        (default pF=4.2)

        The paramter b (shape of the retention curve) is calculated by: \\[
        b =
        \\frac{\\log\\left(\\frac{\\Psi_1}{\\Psi_2}\\right)}{\\log\\left(\\frac{\\theta_2}{\\theta_1}\\right)}
        \\] 
        """
        _cmf_core.BrooksCoreyRetentionCurve_swiginit(self,_cmf_core.new_BrooksCoreyRetentionCurve(*args))
    def CreateFrom2Points(*args):
        """
        CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
            real psi_1 = cmf::upslope::pF_to_waterhead(2.5), 
            real psi_2 = cmf::upslope::pF_to_waterhead(4.2)) -> BrooksCoreyRetentionCurve
        """
        return _cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points(*args)

    CreateFrom2Points = staticmethod(CreateFrom2Points)
    def copy(self, *args):
        """
        copy(self) -> BrooksCoreyRetentionCurve

        virtual BrooksCoreyRetentionCurve* copy() const 
        """
        return _cmf_core.BrooksCoreyRetentionCurve_copy(self, *args)

    def __repr__(self):
        return "Brooks-Corey (Ksat=%g,porosity=%g,b=%g,wetness @ h=%g @ %g)" % (self.K(1,0),self.Porosity(0),self.b(),self.wetness_X,self.Psi_X)

    __swig_destroy__ = _cmf_core.delete_BrooksCoreyRetentionCurve
BrooksCoreyRetentionCurve.SetKsat = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_SetKsat,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.SetPorosity = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_SetPorosity,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.b = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_b,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.Set_b = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_Set_b,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve.copy = new_instancemethod(_cmf_core.BrooksCoreyRetentionCurve_copy,None,BrooksCoreyRetentionCurve)
BrooksCoreyRetentionCurve_swigregister = _cmf_core.BrooksCoreyRetentionCurve_swigregister
BrooksCoreyRetentionCurve_swigregister(BrooksCoreyRetentionCurve)

def BrooksCoreyRetentionCurve_CreateFrom2Points(*args):
  """
    BrooksCoreyRetentionCurve_CreateFrom2Points(real ksat, real porosity, real theta1, real theta2, 
        real psi_1 = cmf::upslope::pF_to_waterhead(2.5), 
        real psi_2 = cmf::upslope::pF_to_waterhead(4.2)) -> BrooksCoreyRetentionCurve
    """
  return _cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points(*args)

class VanGenuchtenMualem(RetentionCurve):
    """Proxy of C++ cmf::upslope::VanGenuchtenMualem class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = _swig_property(_cmf_core.VanGenuchtenMualem_alpha_get, _cmf_core.VanGenuchtenMualem_alpha_set)
    n = _swig_property(_cmf_core.VanGenuchtenMualem_n_get, _cmf_core.VanGenuchtenMualem_n_set)
    Ksat = _swig_property(_cmf_core.VanGenuchtenMualem_Ksat_get, _cmf_core.VanGenuchtenMualem_Ksat_set)
    Phi = _swig_property(_cmf_core.VanGenuchtenMualem_Phi_get, _cmf_core.VanGenuchtenMualem_Phi_set)
    Psi_full = _swig_property(_cmf_core.VanGenuchtenMualem_Psi_full_get, _cmf_core.VanGenuchtenMualem_Psi_full_set)
    m = _swig_property(_cmf_core.VanGenuchtenMualem_m_get, _cmf_core.VanGenuchtenMualem_m_set)
    def copy(self, *args):
        """
        copy(self) -> VanGenuchtenMualem

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf_core.VanGenuchtenMualem_copy(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> VanGenuchtenMualem
        __init__(self, real _Ksat, real _phi, real _alpha, real _n, real _m = -1) -> VanGenuchtenMualem
        """
        _cmf_core.VanGenuchtenMualem_swiginit(self,_cmf_core.new_VanGenuchtenMualem(*args))
    def __repr__(self):
        return "VanGenuchten-Mualem (Ksat=%g,porosity=%g,alpha=%g, n=%g)" % (self.K(1,0),self.Porosity(0),self.alpha,self.n)

    __swig_destroy__ = _cmf_core.delete_VanGenuchtenMualem
VanGenuchtenMualem.copy = new_instancemethod(_cmf_core.VanGenuchtenMualem_copy,None,VanGenuchtenMualem)
VanGenuchtenMualem_swigregister = _cmf_core.VanGenuchtenMualem_swigregister
VanGenuchtenMualem_swigregister(VanGenuchtenMualem)

class LinearRetention(RetentionCurve):
    """Proxy of C++ cmf::upslope::LinearRetention class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Ksat = _swig_property(_cmf_core.LinearRetention_Ksat_get, _cmf_core.LinearRetention_Ksat_set)
    porosity = _swig_property(_cmf_core.LinearRetention_porosity_get, _cmf_core.LinearRetention_porosity_set)
    thickness = _swig_property(_cmf_core.LinearRetention_thickness_get, _cmf_core.LinearRetention_thickness_set)
    residual_wetness = _swig_property(_cmf_core.LinearRetention_residual_wetness_get, _cmf_core.LinearRetention_residual_wetness_set)
    porosity_decay = _swig_property(_cmf_core.LinearRetention_porosity_decay_get, _cmf_core.LinearRetention_porosity_decay_set)
    Ksat_decay = _swig_property(_cmf_core.LinearRetention_Ksat_decay_get, _cmf_core.LinearRetention_Ksat_decay_set)
    beta = _swig_property(_cmf_core.LinearRetention_beta_get, _cmf_core.LinearRetention_beta_set)
    def copy(self, *args):
        """
        copy(self) -> LinearRetention

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf_core.LinearRetention_copy(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, real _Ksat, real _Phi, real _thickness, real _beta = 1.0, 
            real Ss = 1e-4, real _residual_wetness = 0.0, 
            real _ksat_decay = 0.0, real _porosity_decay = 0.0) -> LinearRetention
        """
        _cmf_core.LinearRetention_swiginit(self,_cmf_core.new_LinearRetention(*args))
    __swig_destroy__ = _cmf_core.delete_LinearRetention
LinearRetention.copy = new_instancemethod(_cmf_core.LinearRetention_copy,None,LinearRetention)
LinearRetention_swigregister = _cmf_core.LinearRetention_swigregister
LinearRetention_swigregister(LinearRetention)

class SoilLayer(WaterStorage):
    """Proxy of C++ cmf::upslope::SoilLayer class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Position = _swig_property(_cmf_core.SoilLayer_Position_get)
    cell = _swig_property(_cmf_core.SoilLayer_cell_get)
    def get_soil(self, *args):
        """get_soil(self) -> RetentionCurve"""
        return _cmf_core.SoilLayer_get_soil(self, *args)

    def set_soil(self, *args):
        """set_soil(self, RetentionCurve r_curve)"""
        return _cmf_core.SoilLayer_set_soil(self, *args)

    def get_theta(self, *args):
        """get_theta(self) -> real"""
        return _cmf_core.SoilLayer_get_theta(self, *args)

    def set_theta(self, *args):
        """set_theta(self, real Value)"""
        return _cmf_core.SoilLayer_set_theta(self, *args)

    def get_capacity(self, *args):
        """get_capacity(self) -> real"""
        return _cmf_core.SoilLayer_get_capacity(self, *args)

    def get_saturated_depth(self, *args):
        """get_saturated_depth(self) -> real"""
        return _cmf_core.SoilLayer_get_saturated_depth(self, *args)

    def get_flow_crosssection(self, *args):
        """get_flow_crosssection(self, SoilLayer target, bool HorizontalLayers = False) -> real"""
        return _cmf_core.SoilLayer_get_flow_crosssection(self, *args)

    def cast(*args):
        """cast(ptr node) -> ptr"""
        return _cmf_core.SoilLayer_cast(*args)

    cast = staticmethod(cast)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_14__ swigSharedPtrUpcast) -> __dummy_8__"""
        return _cmf_core.SoilLayer_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    gravitational_potential = _swig_property(_cmf_core.SoilLayer_gravitational_potential_get)
    matrix_potential = _swig_property(_cmf_core.SoilLayer_matrix_potential_get)
    wetness = _swig_property(_cmf_core.SoilLayer_wetness_get, _cmf_core.SoilLayer_wetness_set)
    K = _swig_property(_cmf_core.SoilLayer_K_get)
    Ksat = _swig_property(_cmf_core.SoilLayer_Ksat_get)
    thickness = _swig_property(_cmf_core.SoilLayer_thickness_get)
    lower_boundary = _swig_property(_cmf_core.SoilLayer_lower_boundary_get)
    upper_boundary = _swig_property(_cmf_core.SoilLayer_upper_boundary_get)
    porosity = _swig_property(_cmf_core.SoilLayer_porosity_get)
    boundary=property(lambda self:(self.upper_boundary,self.lower_boundary),None,"Returns the upper and lower boundary of the layer")
    pF=property(lambda self : waterhead_to_pF(self.matrix_potential),None,"The actual pF value")
    soil=property(get_soil,set_soil,"The retention curve of the layer")

    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_SoilLayer
SoilLayer.get_soil = new_instancemethod(_cmf_core.SoilLayer_get_soil,None,SoilLayer)
SoilLayer.set_soil = new_instancemethod(_cmf_core.SoilLayer_set_soil,None,SoilLayer)
SoilLayer.get_theta = new_instancemethod(_cmf_core.SoilLayer_get_theta,None,SoilLayer)
SoilLayer.set_theta = new_instancemethod(_cmf_core.SoilLayer_set_theta,None,SoilLayer)
SoilLayer.get_capacity = new_instancemethod(_cmf_core.SoilLayer_get_capacity,None,SoilLayer)
SoilLayer.get_saturated_depth = new_instancemethod(_cmf_core.SoilLayer_get_saturated_depth,None,SoilLayer)
SoilLayer.get_flow_crosssection = new_instancemethod(_cmf_core.SoilLayer_get_flow_crosssection,None,SoilLayer)
SoilLayer_swigregister = _cmf_core.SoilLayer_swigregister
SoilLayer_swigregister(SoilLayer)

def SoilLayer_cast(*args):
  """SoilLayer_cast(ptr node) -> ptr"""
  return _cmf_core.SoilLayer_cast(*args)

def SoilLayer_SWIGSharedPtrUpcast(*args):
  """SoilLayer_SWIGSharedPtrUpcast(__dummy_14__ swigSharedPtrUpcast) -> __dummy_8__"""
  return _cmf_core.SoilLayer_SWIGSharedPtrUpcast(*args)

class VariableLayerSaturated(SoilLayer):
    """Proxy of C++ cmf::upslope::VariableLayerSaturated class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def UpperLayer(self, *args):
        """UpperLayer(self) -> __dummy_18__"""
        return _cmf_core.VariableLayerSaturated_UpperLayer(self, *args)

    def MaximumThickness(self, *args):
        """MaximumThickness(self) -> real"""
        return _cmf_core.VariableLayerSaturated_MaximumThickness(self, *args)

    def get_thickness_change_rate(self, *args):
        """get_thickness_change_rate(self) -> real"""
        return _cmf_core.VariableLayerSaturated_get_thickness_change_rate(self, *args)

    def get_from_cell(*args):
        """get_from_cell(Cell cell) -> __dummy_16__"""
        return _cmf_core.VariableLayerSaturated_get_from_cell(*args)

    get_from_cell = staticmethod(get_from_cell)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_16__ swigSharedPtrUpcast) -> __dummy_14__"""
        return _cmf_core.VariableLayerSaturated_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_VariableLayerSaturated
VariableLayerSaturated.UpperLayer = new_instancemethod(_cmf_core.VariableLayerSaturated_UpperLayer,None,VariableLayerSaturated)
VariableLayerSaturated.MaximumThickness = new_instancemethod(_cmf_core.VariableLayerSaturated_MaximumThickness,None,VariableLayerSaturated)
VariableLayerSaturated.get_thickness_change_rate = new_instancemethod(_cmf_core.VariableLayerSaturated_get_thickness_change_rate,None,VariableLayerSaturated)
VariableLayerSaturated_swigregister = _cmf_core.VariableLayerSaturated_swigregister
VariableLayerSaturated_swigregister(VariableLayerSaturated)

def VariableLayerSaturated_get_from_cell(*args):
  """VariableLayerSaturated_get_from_cell(Cell cell) -> __dummy_16__"""
  return _cmf_core.VariableLayerSaturated_get_from_cell(*args)

def VariableLayerSaturated_SWIGSharedPtrUpcast(*args):
  """VariableLayerSaturated_SWIGSharedPtrUpcast(__dummy_16__ swigSharedPtrUpcast) -> __dummy_14__"""
  return _cmf_core.VariableLayerSaturated_SWIGSharedPtrUpcast(*args)

class VariableLayerUnsaturated(SoilLayer):
    """Proxy of C++ cmf::upslope::VariableLayerUnsaturated class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_18__ swigSharedPtrUpcast) -> __dummy_14__"""
        return _cmf_core.VariableLayerUnsaturated_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_VariableLayerUnsaturated
VariableLayerUnsaturated_swigregister = _cmf_core.VariableLayerUnsaturated_swigregister
VariableLayerUnsaturated_swigregister(VariableLayerUnsaturated)

def VariableLayerUnsaturated_SWIGSharedPtrUpcast(*args):
  """VariableLayerUnsaturated_SWIGSharedPtrUpcast(__dummy_18__ swigSharedPtrUpcast) -> __dummy_14__"""
  return _cmf_core.VariableLayerUnsaturated_SWIGSharedPtrUpcast(*args)

class IVolumeHeightFunction(object):
    """Proxy of C++ cmf::river::IVolumeHeightFunction class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def h(self, *args):
        """h(self, double V) -> double"""
        return _cmf_core.IVolumeHeightFunction_h(self, *args)

    def A(self, *args):
        """A(self, double V) -> double"""
        return _cmf_core.IVolumeHeightFunction_A(self, *args)

    def V(self, *args):
        """V(self, double h) -> double"""
        return _cmf_core.IVolumeHeightFunction_V(self, *args)

    def copy(self, *args):
        """copy(self) -> IVolumeHeightFunction"""
        return _cmf_core.IVolumeHeightFunction_copy(self, *args)

    def __call__(self, *args):
        """__call__(self, double V) -> double"""
        return _cmf_core.IVolumeHeightFunction___call__(self, *args)

    __swig_destroy__ = _cmf_core.delete_IVolumeHeightFunction
IVolumeHeightFunction.h = new_instancemethod(_cmf_core.IVolumeHeightFunction_h,None,IVolumeHeightFunction)
IVolumeHeightFunction.A = new_instancemethod(_cmf_core.IVolumeHeightFunction_A,None,IVolumeHeightFunction)
IVolumeHeightFunction.V = new_instancemethod(_cmf_core.IVolumeHeightFunction_V,None,IVolumeHeightFunction)
IVolumeHeightFunction.copy = new_instancemethod(_cmf_core.IVolumeHeightFunction_copy,None,IVolumeHeightFunction)
IVolumeHeightFunction.__call__ = new_instancemethod(_cmf_core.IVolumeHeightFunction___call__,None,IVolumeHeightFunction)
IVolumeHeightFunction_swigregister = _cmf_core.IVolumeHeightFunction_swigregister
IVolumeHeightFunction_swigregister(IVolumeHeightFunction)

class Prism(IVolumeHeightFunction):
    """Proxy of C++ cmf::river::Prism class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Area = _swig_property(_cmf_core.Prism_Area_get, _cmf_core.Prism_Area_set)
    def __init__(self, *args): 
        """__init__(self, double base_area) -> Prism"""
        _cmf_core.Prism_swiginit(self,_cmf_core.new_Prism(*args))
    def copy(self, *args):
        """copy(self) -> Prism"""
        return _cmf_core.Prism_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_Prism
Prism.copy = new_instancemethod(_cmf_core.Prism_copy,None,Prism)
Prism_swigregister = _cmf_core.Prism_swigregister
Prism_swigregister(Prism)

class volume_height_function(IVolumeHeightFunction):
    """Proxy of C++ cmf::river::volume_height_function class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, volume_height_function for_copy) -> volume_height_function
        __init__(self, IVolumeHeightFunction for_copy) -> volume_height_function
        """
        _cmf_core.volume_height_function_swiginit(self,_cmf_core.new_volume_height_function(*args))
    def copy(self, *args):
        """copy(self) -> volume_height_function"""
        return _cmf_core.volume_height_function_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_volume_height_function
volume_height_function.copy = new_instancemethod(_cmf_core.volume_height_function_copy,None,volume_height_function)
volume_height_function_swigregister = _cmf_core.volume_height_function_swigregister
volume_height_function_swigregister(volume_height_function)

class IChannel(IVolumeHeightFunction):
    """Proxy of C++ cmf::river::IChannel class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get_nManning(self, *args):
        """get_nManning(self) -> double"""
        return _cmf_core.IChannel_get_nManning(self, *args)

    def set_nManning(self, *args):
        """set_nManning(self, double val)"""
        return _cmf_core.IChannel_set_nManning(self, *args)

    length = _swig_property(_cmf_core.IChannel_length_get, _cmf_core.IChannel_length_set)
    def typecode(self, *args):
        """typecode(self) -> char"""
        return _cmf_core.IChannel_typecode(self, *args)

    def get_channel_width(self, *args):
        """get_channel_width(self, double depth) -> double"""
        return _cmf_core.IChannel_get_channel_width(self, *args)

    def get_wetted_perimeter(self, *args):
        """get_wetted_perimeter(self, double depth) -> double"""
        return _cmf_core.IChannel_get_wetted_perimeter(self, *args)

    def get_depth(self, *args):
        """get_depth(self, double area) -> double"""
        return _cmf_core.IChannel_get_depth(self, *args)

    def get_flux_crossection(self, *args):
        """get_flux_crossection(self, double depth) -> double"""
        return _cmf_core.IChannel_get_flux_crossection(self, *args)

    def copy(self, *args):
        """copy(self) -> IChannel"""
        return _cmf_core.IChannel_copy(self, *args)

    def qManning(self, *args):
        """qManning(self, double A, double slope) -> double"""
        return _cmf_core.IChannel_qManning(self, *args)

    __swig_destroy__ = _cmf_core.delete_IChannel
IChannel.get_nManning = new_instancemethod(_cmf_core.IChannel_get_nManning,None,IChannel)
IChannel.set_nManning = new_instancemethod(_cmf_core.IChannel_set_nManning,None,IChannel)
IChannel.typecode = new_instancemethod(_cmf_core.IChannel_typecode,None,IChannel)
IChannel.get_channel_width = new_instancemethod(_cmf_core.IChannel_get_channel_width,None,IChannel)
IChannel.get_wetted_perimeter = new_instancemethod(_cmf_core.IChannel_get_wetted_perimeter,None,IChannel)
IChannel.get_depth = new_instancemethod(_cmf_core.IChannel_get_depth,None,IChannel)
IChannel.get_flux_crossection = new_instancemethod(_cmf_core.IChannel_get_flux_crossection,None,IChannel)
IChannel.copy = new_instancemethod(_cmf_core.IChannel_copy,None,IChannel)
IChannel.qManning = new_instancemethod(_cmf_core.IChannel_qManning,None,IChannel)
IChannel_swigregister = _cmf_core.IChannel_swigregister
IChannel_swigregister(IChannel)

class SWATReachType(IChannel):
    """
    Structure for the description of structural parameters of a reach.

    Uses the SWAT channel geometry (see SWAT Theoretical Documentation,
    Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
    referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
    plain is not plain, but has a small slope=0.5%, but has an infinite
    width

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BottomWidth = _swig_property(_cmf_core.SWATReachType_BottomWidth_get, _cmf_core.SWATReachType_BottomWidth_set)
    ChannelDepth = _swig_property(_cmf_core.SWATReachType_ChannelDepth_get, _cmf_core.SWATReachType_ChannelDepth_set)
    BankSlope = _swig_property(_cmf_core.SWATReachType_BankSlope_get, _cmf_core.SWATReachType_BankSlope_set)
    FloodPlainSlope = _swig_property(_cmf_core.SWATReachType_FloodPlainSlope_get, _cmf_core.SWATReachType_FloodPlainSlope_set)
    def __init__(self, *args): 
        """
        __init__(self, double l) -> SWATReachType
        __init__(self, double l, double BankWidth, double Depth) -> SWATReachType

        SWATReachType(double BankWidth, double Depth)

        Creates a new reach structure from a give width and depth.

        Parameters:
        -----------

        BankWidth:  Width of the reach from bank to bank [m]

        Depth:  Depth of the reach [m] 
        """
        _cmf_core.SWATReachType_swiginit(self,_cmf_core.new_SWATReachType(*args))
    def copy(self, *args):
        """copy(self) -> SWATReachType"""
        return _cmf_core.SWATReachType_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_SWATReachType
SWATReachType.copy = new_instancemethod(_cmf_core.SWATReachType_copy,None,SWATReachType)
SWATReachType_swigregister = _cmf_core.SWATReachType_swigregister
SWATReachType_swigregister(SWATReachType)

class TriangularReach(IChannel):
    """
    Structure for the description of reaches with a triangular cross
    section.

    Although real triangular cross section reach are rarely met, a
    triangular reach does scale with its water load, and is therefore
    preferable in case where nothing about channel geometry is known

    C++ includes: ReachType.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BankSlope = _swig_property(_cmf_core.TriangularReach_BankSlope_get, _cmf_core.TriangularReach_BankSlope_set)
    def __init__(self, *args): 
        """
        __init__(self, double l, double bankSlope = 2) -> TriangularReach

        TriangularReach(double bankSlope=2)

        Creates a new triangular reach type. 
        """
        _cmf_core.TriangularReach_swiginit(self,_cmf_core.new_TriangularReach(*args))
    def copy(self, *args):
        """copy(self) -> TriangularReach"""
        return _cmf_core.TriangularReach_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_TriangularReach
TriangularReach.copy = new_instancemethod(_cmf_core.TriangularReach_copy,None,TriangularReach)
TriangularReach_swigregister = _cmf_core.TriangularReach_swigregister
TriangularReach_swigregister(TriangularReach)

class RectangularReach(IChannel):
    """Proxy of C++ cmf::river::RectangularReach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double l, double width) -> RectangularReach"""
        _cmf_core.RectangularReach_swiginit(self,_cmf_core.new_RectangularReach(*args))
    def copy(self, *args):
        """copy(self) -> RectangularReach"""
        return _cmf_core.RectangularReach_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_RectangularReach
RectangularReach.copy = new_instancemethod(_cmf_core.RectangularReach_copy,None,RectangularReach)
RectangularReach_swigregister = _cmf_core.RectangularReach_swigregister
RectangularReach_swigregister(RectangularReach)

class PipeReach(IChannel):
    """Proxy of C++ cmf::river::PipeReach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    radius = _swig_property(_cmf_core.PipeReach_radius_get, _cmf_core.PipeReach_radius_set)
    def __init__(self, *args): 
        """__init__(self, double l, double diameter) -> PipeReach"""
        _cmf_core.PipeReach_swiginit(self,_cmf_core.new_PipeReach(*args))
    def copy(self, *args):
        """copy(self) -> PipeReach"""
        return _cmf_core.PipeReach_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_PipeReach
PipeReach.copy = new_instancemethod(_cmf_core.PipeReach_copy,None,PipeReach)
PipeReach_swigregister = _cmf_core.PipeReach_swigregister
PipeReach_swigregister(PipeReach)

class Channel(IChannel):
    """Proxy of C++ cmf::river::Channel class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double length = 1.0) -> Channel
        __init__(self, IChannel for_wrapping) -> Channel
        __init__(self, IVolumeHeightFunction for_casting) -> Channel
        __init__(self, Channel for_copy) -> Channel
        __init__(self, char typecode, double length, double width = 1., double depth = 0.25) -> Channel
        """
        _cmf_core.Channel_swiginit(self,_cmf_core.new_Channel(*args))
    def copy(self, *args):
        """copy(self) -> Channel"""
        return _cmf_core.Channel_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_Channel
Channel.copy = new_instancemethod(_cmf_core.Channel_copy,None,Channel)
Channel_swigregister = _cmf_core.Channel_swigregister
Channel_swigregister(Channel)

class MeanChannel(IChannel):
    """Proxy of C++ cmf::river::MeanChannel class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, IChannel channel1, IChannel channel2) -> MeanChannel
        __init__(self, MeanChannel meanChannel) -> MeanChannel
        """
        _cmf_core.MeanChannel_swiginit(self,_cmf_core.new_MeanChannel(*args))
    def copy(self, *args):
        """copy(self) -> MeanChannel"""
        return _cmf_core.MeanChannel_copy(self, *args)

    __swig_destroy__ = _cmf_core.delete_MeanChannel
MeanChannel.copy = new_instancemethod(_cmf_core.MeanChannel_copy,None,MeanChannel)
MeanChannel_swigregister = _cmf_core.MeanChannel_swigregister
MeanChannel_swigregister(MeanChannel)

class OpenWaterStorage(WaterStorage):
    """Proxy of C++ cmf::river::OpenWaterStorage class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get_height_function(self, *args):
        """get_height_function(self) -> IVolumeHeightFunction"""
        return _cmf_core.OpenWaterStorage_get_height_function(self, *args)

    def set_height_function(self, *args):
        """set_height_function(self, IVolumeHeightFunction val)"""
        return _cmf_core.OpenWaterStorage_set_height_function(self, *args)

    def wet_area(self, *args):
        """wet_area(self) -> real"""
        return _cmf_core.OpenWaterStorage_wet_area(self, *args)

    def create(*args):
        """
        create(project _project, real Area) -> ptr
        create(project _project, IVolumeHeightFunction base_geo) -> ptr
        """
        return _cmf_core.OpenWaterStorage_create(*args)

    create = staticmethod(create)
    def from_node(*args):
        """from_node(ptr node, real Area) -> ptr"""
        return _cmf_core.OpenWaterStorage_from_node(*args)

    from_node = staticmethod(from_node)
    def cast(*args):
        """cast(ptr node) -> ptr"""
        return _cmf_core.OpenWaterStorage_cast(*args)

    cast = staticmethod(cast)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_10__ swigSharedPtrUpcast) -> __dummy_8__"""
        return _cmf_core.OpenWaterStorage_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    depth = _swig_property(_cmf_core.OpenWaterStorage_depth_get, _cmf_core.OpenWaterStorage_depth_set)
    def __repr__(self): 
        return self.to_string()

    __swig_destroy__ = _cmf_core.delete_OpenWaterStorage
OpenWaterStorage.get_height_function = new_instancemethod(_cmf_core.OpenWaterStorage_get_height_function,None,OpenWaterStorage)
OpenWaterStorage.set_height_function = new_instancemethod(_cmf_core.OpenWaterStorage_set_height_function,None,OpenWaterStorage)
OpenWaterStorage.wet_area = new_instancemethod(_cmf_core.OpenWaterStorage_wet_area,None,OpenWaterStorage)
OpenWaterStorage_swigregister = _cmf_core.OpenWaterStorage_swigregister
OpenWaterStorage_swigregister(OpenWaterStorage)

def OpenWaterStorage_create(*args):
  """
    create(project _project, real Area) -> ptr
    OpenWaterStorage_create(project _project, IVolumeHeightFunction base_geo) -> ptr
    """
  return _cmf_core.OpenWaterStorage_create(*args)

def OpenWaterStorage_from_node(*args):
  """OpenWaterStorage_from_node(ptr node, real Area) -> ptr"""
  return _cmf_core.OpenWaterStorage_from_node(*args)

def OpenWaterStorage_cast(*args):
  """OpenWaterStorage_cast(ptr node) -> ptr"""
  return _cmf_core.OpenWaterStorage_cast(*args)

def OpenWaterStorage_SWIGSharedPtrUpcast(*args):
  """OpenWaterStorage_SWIGSharedPtrUpcast(__dummy_10__ swigSharedPtrUpcast) -> __dummy_8__"""
  return _cmf_core.OpenWaterStorage_SWIGSharedPtrUpcast(*args)

class Reach(OpenWaterStorage):
    """Proxy of C++ cmf::river::Reach class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get_height_function(self, *args):
        """get_height_function(self) -> IChannel"""
        return _cmf_core.Reach_get_height_function(self, *args)

    def set_height_function(self, *args):
        """set_height_function(self, IChannel val)"""
        return _cmf_core.Reach_set_height_function(self, *args)

    def get_length(self, *args):
        """get_length(self) -> real"""
        return _cmf_core.Reach_get_length(self, *args)

    def set_outlet(self, *args):
        """set_outlet(self, ptr outlet)"""
        return _cmf_core.Reach_set_outlet(self, *args)

    def set_dead_end(self, *args):
        """set_dead_end(self)"""
        return _cmf_core.Reach_set_dead_end(self, *args)

    def set_downstream(self, *args):
        """set_downstream(self, Reach_ptr new_downstream)"""
        return _cmf_core.Reach_set_downstream(self, *args)

    def get_upstream(self, *args):
        """get_upstream(self, int index) -> Reach_ptr"""
        return _cmf_core.Reach_get_upstream(self, *args)

    def add_cell(self, *args):
        """add_cell(self, Cell cell, bool soil_cut, real distance, real width)"""
        return _cmf_core.Reach_add_cell(self, *args)

    def cuts_soil_of(self, *args):
        """cuts_soil_of(self, Cell cell) -> bool"""
        return _cmf_core.Reach_cuts_soil_of(self, *args)

    def get_distance_to(self, *args):
        """get_distance_to(self, Cell cell) -> real"""
        return _cmf_core.Reach_get_distance_to(self, *args)

    def get_bank_length_with(self, *args):
        """get_bank_length_with(self, Cell cell) -> real"""
        return _cmf_core.Reach_get_bank_length_with(self, *args)

    def get_diffusive(self, *args):
        """get_diffusive(self) -> bool"""
        return _cmf_core.Reach_get_diffusive(self, *args)

    def set_diffusive(self, *args):
        """set_diffusive(self, bool use_diffusive_wave)"""
        return _cmf_core.Reach_set_diffusive(self, *args)

    __swig_destroy__ = _cmf_core.delete_Reach
    def create(*args):
        """create(project project, Channel shape, bool diffusive = False) -> ptr"""
        return _cmf_core.Reach_create(*args)

    create = staticmethod(create)
    def SWIGSharedPtrUpcast(*args):
        """SWIGSharedPtrUpcast(__dummy_12__ swigSharedPtrUpcast) -> __dummy_10__"""
        return _cmf_core.Reach_SWIGSharedPtrUpcast(*args)

    SWIGSharedPtrUpcast = staticmethod(SWIGSharedPtrUpcast)
    cells = _swig_property(_cmf_core.Reach_cells_get)
    downstream = _swig_property(_cmf_core.Reach_downstream_get)
    root = _swig_property(_cmf_core.Reach_root_get)
    upstream_count = _swig_property(_cmf_core.Reach_upstream_count_get)
    def __repr__(self): 
        return self.to_string()

Reach.get_height_function = new_instancemethod(_cmf_core.Reach_get_height_function,None,Reach)
Reach.set_height_function = new_instancemethod(_cmf_core.Reach_set_height_function,None,Reach)
Reach.get_length = new_instancemethod(_cmf_core.Reach_get_length,None,Reach)
Reach.set_outlet = new_instancemethod(_cmf_core.Reach_set_outlet,None,Reach)
Reach.set_dead_end = new_instancemethod(_cmf_core.Reach_set_dead_end,None,Reach)
Reach.set_downstream = new_instancemethod(_cmf_core.Reach_set_downstream,None,Reach)
Reach.get_upstream = new_instancemethod(_cmf_core.Reach_get_upstream,None,Reach)
Reach.add_cell = new_instancemethod(_cmf_core.Reach_add_cell,None,Reach)
Reach.cuts_soil_of = new_instancemethod(_cmf_core.Reach_cuts_soil_of,None,Reach)
Reach.get_distance_to = new_instancemethod(_cmf_core.Reach_get_distance_to,None,Reach)
Reach.get_bank_length_with = new_instancemethod(_cmf_core.Reach_get_bank_length_with,None,Reach)
Reach.get_diffusive = new_instancemethod(_cmf_core.Reach_get_diffusive,None,Reach)
Reach.set_diffusive = new_instancemethod(_cmf_core.Reach_set_diffusive,None,Reach)
Reach_swigregister = _cmf_core.Reach_swigregister
Reach_swigregister(Reach)

def Reach_create(*args):
  """Reach_create(project project, Channel shape, bool diffusive = False) -> ptr"""
  return _cmf_core.Reach_create(*args)

def Reach_SWIGSharedPtrUpcast(*args):
  """Reach_SWIGSharedPtrUpcast(__dummy_12__ swigSharedPtrUpcast) -> __dummy_10__"""
  return _cmf_core.Reach_SWIGSharedPtrUpcast(*args)

class ReachIterator(object):
    """Proxy of C++ cmf::river::ReachIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def next(self, *args):
        """next(self) -> Reach_ptr"""
        return _cmf_core.ReachIterator_next(self, *args)

    def valid(self, *args):
        """valid(self) -> bool"""
        return _cmf_core.ReachIterator_valid(self, *args)

    def __init__(self, *args): 
        """__init__(self, Reach_ptr first) -> ReachIterator"""
        _cmf_core.ReachIterator_swiginit(self,_cmf_core.new_ReachIterator(*args))
    reach = _swig_property(_cmf_core.ReachIterator_reach_get)
    position = _swig_property(_cmf_core.ReachIterator_position_get)
    __swig_destroy__ = _cmf_core.delete_ReachIterator
ReachIterator.next = new_instancemethod(_cmf_core.ReachIterator_next,None,ReachIterator)
ReachIterator.valid = new_instancemethod(_cmf_core.ReachIterator_valid,None,ReachIterator)
ReachIterator_swigregister = _cmf_core.ReachIterator_swigregister
ReachIterator_swigregister(ReachIterator)


def make_river_gap(*args):
  """make_river_gap(Reach_ptr root_reach) -> double"""
  return _cmf_core.make_river_gap(*args)
class lateral_sub_surface_flux(flux_connection):
    """Proxy of C++ cmf::upslope::connections::lateral_sub_surface_flux class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cmf_core.delete_lateral_sub_surface_flux
lateral_sub_surface_flux_swigregister = _cmf_core.lateral_sub_surface_flux_swigregister
lateral_sub_surface_flux_swigregister(lateral_sub_surface_flux)

class Darcy(lateral_sub_surface_flux):
    """Proxy of C++ cmf::upslope::connections::Darcy class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right, real FlowWidth, real Distance = 0) -> Darcy"""
        _cmf_core.Darcy_swiginit(self,_cmf_core.new_Darcy(*args))
    __swig_destroy__ = _cmf_core.delete_Darcy
Darcy_swigregister = _cmf_core.Darcy_swigregister
Darcy_swigregister(Darcy)
Darcy.cell_connector = _cmf_core.cvar.Darcy_cell_connector

class TopographicGradientDarcy(lateral_sub_surface_flux):
    """Proxy of C++ cmf::upslope::connections::TopographicGradientDarcy class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right, real FlowWidth, real Distance = 0) -> TopographicGradientDarcy"""
        _cmf_core.TopographicGradientDarcy_swiginit(self,_cmf_core.new_TopographicGradientDarcy(*args))
    __swig_destroy__ = _cmf_core.delete_TopographicGradientDarcy
TopographicGradientDarcy_swigregister = _cmf_core.TopographicGradientDarcy_swigregister
TopographicGradientDarcy_swigregister(TopographicGradientDarcy)
TopographicGradientDarcy.cell_connector = _cmf_core.cvar.TopographicGradientDarcy_cell_connector

class OHDISflow(lateral_sub_surface_flux):
    """Proxy of C++ cmf::upslope::connections::OHDISflow class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right, real FlowWidth, real Distance = 0) -> OHDISflow"""
        _cmf_core.OHDISflow_swiginit(self,_cmf_core.new_OHDISflow(*args))
    __swig_destroy__ = _cmf_core.delete_OHDISflow
OHDISflow_swigregister = _cmf_core.OHDISflow_swigregister
OHDISflow_swigregister(OHDISflow)
OHDISflow.cell_connector = _cmf_core.cvar.OHDISflow_cell_connector

class Richards_lateral(lateral_sub_surface_flux):
    """Proxy of C++ cmf::upslope::connections::Richards_lateral class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right, real FlowWidth = 0, real Distance = 0) -> Richards_lateral"""
        _cmf_core.Richards_lateral_swiginit(self,_cmf_core.new_Richards_lateral(*args))
    __swig_destroy__ = _cmf_core.delete_Richards_lateral
Richards_lateral_swigregister = _cmf_core.Richards_lateral_swigregister
Richards_lateral_swigregister(Richards_lateral)
Richards_lateral.cell_connector = _cmf_core.cvar.Richards_lateral_cell_connector

class Manning(flux_connection):
    """Proxy of C++ cmf::river::Manning class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    is_diffusive_wave = _swig_property(_cmf_core.Manning_is_diffusive_wave_get, _cmf_core.Manning_is_diffusive_wave_set)
    flux_geometry = _swig_property(_cmf_core.Manning_flux_geometry_get, _cmf_core.Manning_flux_geometry_set)
    __swig_destroy__ = _cmf_core.delete_Manning
Manning_swigregister = _cmf_core.Manning_swigregister
Manning_swigregister(Manning)

class Manning_Diffusive(Manning):
    """Proxy of C++ cmf::river::Manning_Diffusive class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right, Channel reachtype) -> Manning_Diffusive"""
        _cmf_core.Manning_Diffusive_swiginit(self,_cmf_core.new_Manning_Diffusive(*args))
    __swig_destroy__ = _cmf_core.delete_Manning_Diffusive
Manning_Diffusive_swigregister = _cmf_core.Manning_Diffusive_swigregister
Manning_Diffusive_swigregister(Manning_Diffusive)
Manning_Diffusive.cell_connector = _cmf_core.cvar.Manning_Diffusive_cell_connector

class Manning_Kinematic(Manning):
    """Proxy of C++ cmf::river::Manning_Kinematic class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right, Channel reachtype) -> Manning_Kinematic"""
        _cmf_core.Manning_Kinematic_swiginit(self,_cmf_core.new_Manning_Kinematic(*args))
    __swig_destroy__ = _cmf_core.delete_Manning_Kinematic
Manning_Kinematic_swigregister = _cmf_core.Manning_Kinematic_swigregister
Manning_Kinematic_swigregister(Manning_Kinematic)
Manning_Kinematic.cell_connector = _cmf_core.cvar.Manning_Kinematic_cell_connector

class VarLayerPercolationRichards(flux_connection):
    """Proxy of C++ cmf::upslope::connections::VarLayerPercolationRichards class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Only_Exw = _swig_property(_cmf_core.VarLayerPercolationRichards_Only_Exw_get, _cmf_core.VarLayerPercolationRichards_Only_Exw_set)
    def __init__(self, *args): 
        """__init__(self, __dummy_18__ unsat, __dummy_16__ sat, bool only_Exw = False) -> VarLayerPercolationRichards"""
        _cmf_core.VarLayerPercolationRichards_swiginit(self,_cmf_core.new_VarLayerPercolationRichards(*args))
    __swig_destroy__ = _cmf_core.delete_VarLayerPercolationRichards
VarLayerPercolationRichards_swigregister = _cmf_core.VarLayerPercolationRichards_swigregister
VarLayerPercolationRichards_swigregister(VarLayerPercolationRichards)

class VarLayerPercolationSimple(flux_connection):
    """Proxy of C++ cmf::upslope::connections::VarLayerPercolationSimple class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pF_field_cap = _swig_property(_cmf_core.VarLayerPercolationSimple_pF_field_cap_get, _cmf_core.VarLayerPercolationSimple_pF_field_cap_set)
    def __init__(self, *args): 
        """__init__(self, __dummy_18__ unsat, __dummy_16__ sat, real _pF_field_cap = 1.8) -> VarLayerPercolationSimple"""
        _cmf_core.VarLayerPercolationSimple_swiginit(self,_cmf_core.new_VarLayerPercolationSimple(*args))
    __swig_destroy__ = _cmf_core.delete_VarLayerPercolationSimple
VarLayerPercolationSimple_swigregister = _cmf_core.VarLayerPercolationSimple_swigregister
VarLayerPercolationSimple_swigregister(VarLayerPercolationSimple)

class PIHMpercolation(flux_connection):
    """Proxy of C++ cmf::upslope::connections::PIHMpercolation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alpha = _swig_property(_cmf_core.PIHMpercolation_alpha_get, _cmf_core.PIHMpercolation_alpha_set)
    def __init__(self, *args): 
        """__init__(self, __dummy_18__ unsat, __dummy_16__ sat, real _alpha = 1) -> PIHMpercolation"""
        _cmf_core.PIHMpercolation_swiginit(self,_cmf_core.new_PIHMpercolation(*args))
    __swig_destroy__ = _cmf_core.delete_PIHMpercolation
PIHMpercolation_swigregister = _cmf_core.PIHMpercolation_swigregister
PIHMpercolation_swigregister(PIHMpercolation)

class PIHMlateral(flux_connection):
    """Proxy of C++ cmf::upslope::connections::PIHMlateral class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flow_width = _swig_property(_cmf_core.PIHMlateral_flow_width_get, _cmf_core.PIHMlateral_flow_width_set)
    distance = _swig_property(_cmf_core.PIHMlateral_distance_get, _cmf_core.PIHMlateral_distance_set)
    def __init__(self, *args): 
        """__init__(self, __dummy_16__ left, ptr right, real _width, real _distance) -> PIHMlateral"""
        _cmf_core.PIHMlateral_swiginit(self,_cmf_core.new_PIHMlateral(*args))
    __swig_destroy__ = _cmf_core.delete_PIHMlateral
PIHMlateral_swigregister = _cmf_core.PIHMlateral_swigregister
PIHMlateral_swigregister(PIHMlateral)
PIHMlateral.cell_connector = _cmf_core.cvar.PIHMlateral_cell_connector

class CanopyOverflow(flux_connection):
    """Proxy of C++ cmf::upslope::connections::CanopyOverflow class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr Canopy, ptr target, Cell cell) -> CanopyOverflow

        CanopyOverflow(cmf::water::WaterStorage &Canopy, cmf::water::FluxNode
        &target, cmf::upslope::Cell &cell) 
        """
        _cmf_core.CanopyOverflow_swiginit(self,_cmf_core.new_CanopyOverflow(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell) -> CanopyOverflow"""
        return _cmf_core.CanopyOverflow_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_CanopyOverflow
CanopyOverflow_swigregister = _cmf_core.CanopyOverflow_swigregister
CanopyOverflow_swigregister(CanopyOverflow)

def CanopyOverflow_use_for_cell(*args):
  """CanopyOverflow_use_for_cell(Cell cell) -> CanopyOverflow"""
  return _cmf_core.CanopyOverflow_use_for_cell(*args)

class SimpleTindexSnowMelt(flux_connection):
    """Proxy of C++ cmf::upslope::connections::SimpleTindexSnowMelt class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SnowMeltRate = _swig_property(_cmf_core.SimpleTindexSnowMelt_SnowMeltRate_get, _cmf_core.SimpleTindexSnowMelt_SnowMeltRate_set)
    def __init__(self, *args): 
        """__init__(self, ptr snow, ptr surface_water, Cell cell) -> SimpleTindexSnowMelt"""
        _cmf_core.SimpleTindexSnowMelt_swiginit(self,_cmf_core.new_SimpleTindexSnowMelt(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.SimpleTindexSnowMelt_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_SimpleTindexSnowMelt
SimpleTindexSnowMelt_swigregister = _cmf_core.SimpleTindexSnowMelt_swigregister
SimpleTindexSnowMelt_swigregister(SimpleTindexSnowMelt)

def SimpleTindexSnowMelt_use_for_cell(*args):
  """SimpleTindexSnowMelt_use_for_cell(Cell cell)"""
  return _cmf_core.SimpleTindexSnowMelt_use_for_cell(*args)

class Rainfall(flux_connection):
    """Proxy of C++ cmf::upslope::connections::Rainfall class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Throughfall = _swig_property(_cmf_core.Rainfall_Throughfall_get, _cmf_core.Rainfall_Throughfall_set)
    InterceptedRainfall = _swig_property(_cmf_core.Rainfall_InterceptedRainfall_get, _cmf_core.Rainfall_InterceptedRainfall_set)
    def __init__(self, *args): 
        """
        __init__(self, ptr target, Cell cell, bool getthroughfall = True, 
            bool getintercepted = True) -> Rainfall
        """
        _cmf_core.Rainfall_swiginit(self,_cmf_core.new_Rainfall(*args))
    __swig_destroy__ = _cmf_core.delete_Rainfall
Rainfall_swigregister = _cmf_core.Rainfall_swigregister
Rainfall_swigregister(Rainfall)

class Snowfall(flux_connection):
    """Proxy of C++ cmf::upslope::connections::Snowfall class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr target, Cell cell) -> Snowfall"""
        _cmf_core.Snowfall_swiginit(self,_cmf_core.new_Snowfall(*args))
    __swig_destroy__ = _cmf_core.delete_Snowfall
Snowfall_swigregister = _cmf_core.Snowfall_swigregister
Snowfall_swigregister(Snowfall)

class MatrixInfiltration(flux_connection):
    """Proxy of C++ cmf::upslope::connections::MatrixInfiltration class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr soilwater, ptr surfacewater) -> MatrixInfiltration"""
        _cmf_core.MatrixInfiltration_swiginit(self,_cmf_core.new_MatrixInfiltration(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell c)"""
        return _cmf_core.MatrixInfiltration_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_MatrixInfiltration
MatrixInfiltration_swigregister = _cmf_core.MatrixInfiltration_swigregister
MatrixInfiltration_swigregister(MatrixInfiltration)

def MatrixInfiltration_use_for_cell(*args):
  """MatrixInfiltration_use_for_cell(Cell c)"""
  return _cmf_core.MatrixInfiltration_use_for_cell(*args)

class CompleteInfiltration(flux_connection):
    """Proxy of C++ cmf::upslope::connections::CompleteInfiltration class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr soilwater, ptr surfacewater) -> CompleteInfiltration"""
        _cmf_core.CompleteInfiltration_swiginit(self,_cmf_core.new_CompleteInfiltration(*args))
    __swig_destroy__ = _cmf_core.delete_CompleteInfiltration
CompleteInfiltration_swigregister = _cmf_core.CompleteInfiltration_swigregister
CompleteInfiltration_swigregister(CompleteInfiltration)

class SWATPercolation(flux_connection):
    """Proxy of C++ cmf::upslope::connections::SWATPercolation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def use_for_cell(*args):
        """use_for_cell(Cell cell, bool no_override = True)"""
        return _cmf_core.SWATPercolation_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    def __init__(self, *args): 
        """__init__(self, ptr upperLayer, ptr lowerLayer) -> SWATPercolation"""
        _cmf_core.SWATPercolation_swiginit(self,_cmf_core.new_SWATPercolation(*args))
    __swig_destroy__ = _cmf_core.delete_SWATPercolation
SWATPercolation_swigregister = _cmf_core.SWATPercolation_swigregister
SWATPercolation_swigregister(SWATPercolation)

def SWATPercolation_use_for_cell(*args):
  """SWATPercolation_use_for_cell(Cell cell, bool no_override = True)"""
  return _cmf_core.SWATPercolation_use_for_cell(*args)

class Richards(flux_connection):
    """Proxy of C++ cmf::upslope::connections::Richards class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right) -> Richards"""
        _cmf_core.Richards_swiginit(self,_cmf_core.new_Richards(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell, bool no_override = True)"""
        return _cmf_core.Richards_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_Richards
Richards_swigregister = _cmf_core.Richards_swigregister
Richards_swigregister(Richards)

def Richards_use_for_cell(*args):
  """Richards_use_for_cell(Cell cell, bool no_override = True)"""
  return _cmf_core.Richards_use_for_cell(*args)

class HBVparameters(RetentionCurve):
    """Proxy of C++ cmf::upslope::connections::HBVparameters class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cfmax = _swig_property(_cmf_core.HBVparameters_cfmax_get, _cmf_core.HBVparameters_cfmax_set)
    sfcf = _swig_property(_cmf_core.HBVparameters_sfcf_get, _cmf_core.HBVparameters_sfcf_set)
    cfr = _swig_property(_cmf_core.HBVparameters_cfr_get, _cmf_core.HBVparameters_cfr_set)
    cwh = _swig_property(_cmf_core.HBVparameters_cwh_get, _cmf_core.HBVparameters_cwh_set)
    k0 = _swig_property(_cmf_core.HBVparameters_k0_get, _cmf_core.HBVparameters_k0_set)
    k1 = _swig_property(_cmf_core.HBVparameters_k1_get, _cmf_core.HBVparameters_k1_set)
    k2 = _swig_property(_cmf_core.HBVparameters_k2_get, _cmf_core.HBVparameters_k2_set)
    perc = _swig_property(_cmf_core.HBVparameters_perc_get, _cmf_core.HBVparameters_perc_set)
    fc = _swig_property(_cmf_core.HBVparameters_fc_get, _cmf_core.HBVparameters_fc_set)
    uplim = _swig_property(_cmf_core.HBVparameters_uplim_get, _cmf_core.HBVparameters_uplim_set)
    lowlim = _swig_property(_cmf_core.HBVparameters_lowlim_get, _cmf_core.HBVparameters_lowlim_set)
    beta = _swig_property(_cmf_core.HBVparameters_beta_get, _cmf_core.HBVparameters_beta_set)
    def __init__(self, *args): 
        """
        __init__(self, double _k0 = 1, double _k1 = 0.25, double _k2 = 0.005, 
            double _perc = 0.05, double _fc = 0.3, double _beta = 4.0, 
            double _uplim = .35, double _lowlim = 1.0, 
            double _cfmax = 2, double _sfcf = 0.6, 
            double _cwh = 0.1, double _cfr = 0.05) -> HBVparameters
        """
        _cmf_core.HBVparameters_swiginit(self,_cmf_core.new_HBVparameters(*args))
    def copy(self, *args):
        """
        copy(self) -> HBVparameters

        virtual
        RetentionCurve* copy() const =0 
        """
        return _cmf_core.HBVparameters_copy(self, *args)

    def cast(*args):
        """cast(RetentionCurve for_cast) -> HBVparameters"""
        return _cmf_core.HBVparameters_cast(*args)

    cast = staticmethod(cast)
    __swig_destroy__ = _cmf_core.delete_HBVparameters
HBVparameters.copy = new_instancemethod(_cmf_core.HBVparameters_copy,None,HBVparameters)
HBVparameters_swigregister = _cmf_core.HBVparameters_swigregister
HBVparameters_swigregister(HBVparameters)

def HBVparameters_cast(*args):
  """HBVparameters_cast(RetentionCurve for_cast) -> HBVparameters"""
  return _cmf_core.HBVparameters_cast(*args)

class HBVpercolation(flux_connection):
    """Proxy of C++ cmf::upslope::connections::HBVpercolation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right) -> HBVpercolation"""
        _cmf_core.HBVpercolation_swiginit(self,_cmf_core.new_HBVpercolation(*args))
    __swig_destroy__ = _cmf_core.delete_HBVpercolation
HBVpercolation_swigregister = _cmf_core.HBVpercolation_swigregister
HBVpercolation_swigregister(HBVpercolation)

class HBVlateral(lateral_sub_surface_flux):
    """Proxy of C++ cmf::upslope::connections::HBVlateral class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr left, ptr right, real width, real dist) -> HBVlateral"""
        _cmf_core.HBVlateral_swiginit(self,_cmf_core.new_HBVlateral(*args))
    __swig_destroy__ = _cmf_core.delete_HBVlateral
HBVlateral_swigregister = _cmf_core.HBVlateral_swigregister
HBVlateral_swigregister(HBVlateral)
HBVlateral.cell_connector = _cmf_core.cvar.HBVlateral_cell_connector


def HBVinstall(*args):
  """HBVinstall(HBVparameters parameters, Cell cell)"""
  return _cmf_core.HBVinstall(*args)

def Tact(*args):
  """Tact(real Tpot, SoilLayer sw, Vegetation veg) -> real"""
  return _cmf_core.Tact(*args)
class constantETpot(flux_connection):
    """Proxy of C++ cmf::upslope::ET::constantETpot class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ETpot_value = _swig_property(_cmf_core.constantETpot_ETpot_value_get, _cmf_core.constantETpot_ETpot_value_set)
    def GetETpot(self, *args):
        """
        GetETpot(self, Time t) -> real

        real GetETpot(cmf::math::Time t) const =0 
        """
        return _cmf_core.constantETpot_GetETpot(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr ET_target, double constantETpot_value) -> constantETpot

        constantETpot(cmf::upslope::SoilWaterStorage &source,
        cmf::water::FluxNode &ET_target, double constantETpot_value) 
        """
        _cmf_core.constantETpot_swiginit(self,_cmf_core.new_constantETpot(*args))
    __swig_destroy__ = _cmf_core.delete_constantETpot
constantETpot.GetETpot = new_instancemethod(_cmf_core.constantETpot_GetETpot,None,constantETpot)
constantETpot_swigregister = _cmf_core.constantETpot_swigregister
constantETpot_swigregister(constantETpot)

def PenmanMonteith(*args):
  """
    PenmanMonteith(real Rn, real ra, real rs, real T, real vap_press_deficit) -> real
    PenmanMonteith(Weather A, Vegetation veg, double h) -> real

    real
    cmf::upslope::ET::PenmanMonteith(cmf::atmosphere::Weather A, const
    cmf::upslope::vegetation::Vegetation &veg, double h) 
    """
  return _cmf_core.PenmanMonteith(*args)

class PenmanMonteithET(flux_connection):
    """
    Calculates the potential evapotranspiration according to FAO(1998)
    \\begin{eqnarray*} \\lambda ET &=& \\frac{\\Delta\\left(R_n
    - G\\right)+\\rho_a c_p \\frac{e_s - e_a}{r_a}}{\\Delta +
    \\gamma\\left(1+\\frac{r_s}{r_a}\\right)} \\mbox{ FAO 1998,
    Eq. 3} \\\\ \\mbox{With:} \\\\ \\Delta &=& 4098
    \\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\frac{kPa}{^\\circ C}
    \\mbox{ (FAO 1998, Eq. 13): Slope of vapor pressure } \\\\ T &=&
    \\mbox{Actual Temperature in } ^\\circ C \\\\ R_n &=&
    \\mbox{net Radiation (see Atmosphere) in } \\frac{MJ}{m^2day}
    \\\\ G &=& 0 \\ \\frac{MJ}{m^2day} \\mbox{ if daily average
    (FAO 1998, Eq. 42)} \\\\ && 0.1 R_n \\ \\mbox{ if day time
    (FAO 1998, Eq. 45)} \\\\ && 0.5 R_n \\ \\mbox{ if night time
    (FAO 1998, Eq. 46)} \\\\ \\gamma &=& \\frac{c_p P}{\\epsilon
    \\lambda} \\mbox{ (FAO 1998,Eq. 8): Psychrometric constant }
    \\frac{kPa}{^\\circ C} \\\\ c_p &=& 0.001013
    \\frac{MJ}{kg\\ ^\\circ C}\\mbox{ specific heat at constant
    pressure } \\\\ P &=& 101.3
    \\left(\\frac{293-0.0065z}{293}\\right)^{5.26} \\mbox{ (FAO
    1998,Eq. 7): Mean pressure kPa as a function of elevation above sea
    level in m} \\\\ \\epsilon &=& 0.622 \\mbox{ ratio molecular
    weight of water vapour/dry air} \\\\ \\lambda &=& 2.45
    \\frac{MJ}{kg} \\mbox{ (FAO 1998,Eq. 8): latent heat of
    vaporization} \\\\ R &=& 0.287 \\frac{kJ}{kg\\ k}\\mbox{
    Specific gas constant } \\\\ \\rho_a &=&
    \\frac{P}{1.01(T+273)R} \\mbox{ (FAO 1998,Box. 6): Mean air
    density at constant pressure} \\\\ e_s &=& \\mbox{ Saturated
    vapor pressure (see Atmosphere) in } kPa \\\\ e_a &=& \\mbox{
    Actual vapor pressure (see Atmosphere) in } kPa \\\\ r_a &=&
    \\frac{\\ln\\left(\\frac{2-d}{z_{om}}\\right)\\ln\\left(\\frac{2-d}{z_{oh}}\\right)}{k^2
    u_2} \\mbox{ (FAO 1998, Eq. 4/Box 4): Aerodynamic resitance in }
    \\frac s m \\\\ && d=\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1
    z_{om}, k=0.41 \\\\ h &=& \\mbox{ Vegetation height in }m
    \\\\ u_2 &=& \\mbox{ Windspeed in 2m above ground (see
    Atmosphere) } \\frac m s \\\\ r_s &=&
    \\frac{r_l}{LAI_{Active}} \\mbox{ (FAO 1998, Eq. 5/Box 5): bulk
    surface resistance} \\frac s m \\\\ && r_l=100 \\frac s m,
    LAI_{Active}=0.5 LAI \\end{eqnarray*}.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    daily = _swig_property(_cmf_core.PenmanMonteithET_daily_get, _cmf_core.PenmanMonteithET_daily_set)
    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr ET_target) -> PenmanMonteithET

        PenmanMonteithET(cmf::upslope::SoilWaterStorage &source,
        cmf::water::FluxNode &ET_target, cmf::upslope::vegetation::Vegetation
        &VegetationAttributes, cmf::atmosphere::Meteorology &meteo) 
        """
        _cmf_core.PenmanMonteithET_swiginit(self,_cmf_core.new_PenmanMonteithET(*args))
    def r_s(*args):
        """
        r_s(Vegetation veg) -> real

        real
        r_s() const 
        """
        return _cmf_core.PenmanMonteithET_r_s(*args)

    r_s = staticmethod(r_s)
    def r_a(*args):
        """
        r_a(Weather A, real veg_height) -> real

        real
        r_a(cmf::atmosphere::Weather A) const 
        """
        return _cmf_core.PenmanMonteithET_r_a(*args)

    r_a = staticmethod(r_a)
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.PenmanMonteithET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_PenmanMonteithET
PenmanMonteithET_swigregister = _cmf_core.PenmanMonteithET_swigregister
PenmanMonteithET_swigregister(PenmanMonteithET)

def PenmanMonteithET_r_s(*args):
  """
    PenmanMonteithET_r_s(Vegetation veg) -> real

    real
    r_s() const 
    """
  return _cmf_core.PenmanMonteithET_r_s(*args)

def PenmanMonteithET_r_a(*args):
  """
    PenmanMonteithET_r_a(Weather A, real veg_height) -> real

    real
    r_a(cmf::atmosphere::Weather A) const 
    """
  return _cmf_core.PenmanMonteithET_r_a(*args)

def PenmanMonteithET_use_for_cell(*args):
  """PenmanMonteithET_use_for_cell(Cell cell)"""
  return _cmf_core.PenmanMonteithET_use_for_cell(*args)

class ShuttleworthWallaceET(flux_connection):
    """
    Calculates the actual transpiration and the soil evaporation from a
    soil layer.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr source, ptr ET_target, Cell cell, string Type = "Shuttleworth Wallace get_evaporation") -> ShuttleworthWallaceET

        ShuttleworthWallaceET(cmf::upslope::SoilWaterStorage &source,
        cmf::water::FluxNode &ET_target, cmf::atmosphere::Meteorology &meteo)

        """
        _cmf_core.ShuttleworthWallaceET_swiginit(self,_cmf_core.new_ShuttleworthWallaceET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.ShuttleworthWallaceET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_ShuttleworthWallaceET
ShuttleworthWallaceET_swigregister = _cmf_core.ShuttleworthWallaceET_swigregister
ShuttleworthWallaceET_swigregister(ShuttleworthWallaceET)

def ShuttleworthWallaceET_use_for_cell(*args):
  """ShuttleworthWallaceET_use_for_cell(Cell cell)"""
  return _cmf_core.ShuttleworthWallaceET_use_for_cell(*args)

class HargreaveET(flux_connection):
    """Proxy of C++ cmf::upslope::ET::HargreaveET class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr source, ptr ET_target) -> HargreaveET"""
        _cmf_core.HargreaveET_swiginit(self,_cmf_core.new_HargreaveET(*args))
    def use_for_cell(*args):
        """use_for_cell(Cell cell)"""
        return _cmf_core.HargreaveET_use_for_cell(*args)

    use_for_cell = staticmethod(use_for_cell)
    __swig_destroy__ = _cmf_core.delete_HargreaveET
HargreaveET_swigregister = _cmf_core.HargreaveET_swigregister
HargreaveET_swigregister(HargreaveET)

def HargreaveET_use_for_cell(*args):
  """HargreaveET_use_for_cell(Cell cell)"""
  return _cmf_core.HargreaveET_use_for_cell(*args)

class CanopyStorageEvaporation(flux_connection):
    """
    Calculates the evaporation from a canopy storage.

    C++ includes: ET.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ptr CanopyStorage, ptr ET_target, Cell cell) -> CanopyStorageEvaporation

        CanopyStorageEvaporation(cmf::water::FluxNode &CanopyStorage,
        cmf::water::FluxNode &ET_target, const cmf::atmosphere::Meteorology
        &meteo, cmf::upslope::Cell &cell) 
        """
        _cmf_core.CanopyStorageEvaporation_swiginit(self,_cmf_core.new_CanopyStorageEvaporation(*args))
    __swig_destroy__ = _cmf_core.delete_CanopyStorageEvaporation
CanopyStorageEvaporation_swigregister = _cmf_core.CanopyStorageEvaporation_swigregister
CanopyStorageEvaporation_swigregister(CanopyStorageEvaporation)

class PenmanEvaporation(flux_connection):
    """Proxy of C++ cmf::upslope::ET::PenmanEvaporation class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ptr source, ptr Evap_target, Meteorology meteo) -> PenmanEvaporation"""
        _cmf_core.PenmanEvaporation_swiginit(self,_cmf_core.new_PenmanEvaporation(*args))
    __swig_destroy__ = _cmf_core.delete_PenmanEvaporation
PenmanEvaporation_swigregister = _cmf_core.PenmanEvaporation_swigregister
PenmanEvaporation_swigregister(PenmanEvaporation)

def connect(type,left_node,right_node,*args):
    connection=type(left_node,right_node,*args)
    connection.thisown=0

class project(StateVariableOwner):
    """Proxy of C++ cmf::project class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    solutes = _swig_property(_cmf_core.project_solutes_get)
    meteo_stations = _swig_property(_cmf_core.project_meteo_stations_get, _cmf_core.project_meteo_stations_set)
    outlets = _swig_property(_cmf_core.project_outlets_get, _cmf_core.project_outlets_set)
    def get_cell(self, *args):
        """get_cell(self, int index) -> Cell"""
        return _cmf_core.project_get_cell(self, *args)

    def size(self, *args):
        """size(self) -> int"""
        return _cmf_core.project_size(self, *args)

    debug = _swig_property(_cmf_core.project_debug_get, _cmf_core.project_debug_set)
    def __init__(self, *args): 
        """__init__(self, string solute_names = "") -> project"""
        _cmf_core.project_swiginit(self,_cmf_core.new_project(*args))
    __swig_destroy__ = _cmf_core.delete_project
    def NewCell(self, *args):
        """
        NewCell(self, double x, double y, double z, double Area) -> Cell
        NewCell(self, point p, double Area) -> Cell
        """
        return _cmf_core.project_NewCell(self, *args)

    def get_reach(self, *args):
        """get_reach(self, int index) -> Reach_ptr"""
        return _cmf_core.project_get_reach(self, *args)

    def reach_count(self, *args):
        """reach_count(self) -> int"""
        return _cmf_core.project_reach_count(self, *args)

    def get_storages(self, *args):
        """get_storages(self) -> node_list"""
        return _cmf_core.project_get_storages(self, *args)

    def NewReach(self, *args):
        """NewReach(self, Channel shape, bool diffusive = False) -> Reach_ptr"""
        return _cmf_core.project_NewReach(self, *args)

    cells = _swig_property(_cmf_core.project_cells_get)
    def __repr__(self):
        return "cmf.project(%i cells, %i meteo stations, %i outlets)" % (len(self.cells),len(self.meteo_stations),len(self.outlets))
    def __len__(self):
        return self.size()
    def __getitem__(self,index):
        if isinstance(index,slice):
            return [self[i] for i in range(*index.indices(len(self)))]
        else:
            return self.get_cell(index)        
    def __iter__(self):
        for i in range(self.size()):
            yield self.get_cell(i)

project.get_cell = new_instancemethod(_cmf_core.project_get_cell,None,project)
project.size = new_instancemethod(_cmf_core.project_size,None,project)
project.NewCell = new_instancemethod(_cmf_core.project_NewCell,None,project)
project.get_reach = new_instancemethod(_cmf_core.project_get_reach,None,project)
project.reach_count = new_instancemethod(_cmf_core.project_reach_count,None,project)
project.get_storages = new_instancemethod(_cmf_core.project_get_storages,None,project)
project.NewReach = new_instancemethod(_cmf_core.project_NewReach,None,project)
project_swigregister = _cmf_core.project_swigregister
project_swigregister(project)

class SoluteWaterIntegrator(Integrator):
    """Proxy of C++ cmf::math::SoluteWaterIntegrator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Copy(self, *args):
        """
        Copy(self) -> SoluteWaterIntegrator

        virtual
        cmf::math::Integrator* Copy() const =0

        Returns a new Integrator, based on this (without the state variables),
        e.g. same type, epsilon, model time etc. 
        """
        return _cmf_core.SoluteWaterIntegrator_Copy(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, Integrator water_integrator, Integrator solute_integrator) -> SoluteWaterIntegrator
        __init__(self, Integrator water_integrator, Integrator solute_integrator, 
            StateVariableOwner states) -> SoluteWaterIntegrator
        """
        _cmf_core.SoluteWaterIntegrator_swiginit(self,_cmf_core.new_SoluteWaterIntegrator(*args))
    solute_integrator = _swig_property(_cmf_core.SoluteWaterIntegrator_solute_integrator_get, _cmf_core.SoluteWaterIntegrator_solute_integrator_set)
    water_integrator = _swig_property(_cmf_core.SoluteWaterIntegrator_water_integrator_get, _cmf_core.SoluteWaterIntegrator_water_integrator_set)
    __swig_destroy__ = _cmf_core.delete_SoluteWaterIntegrator
SoluteWaterIntegrator.Copy = new_instancemethod(_cmf_core.SoluteWaterIntegrator_Copy,None,SoluteWaterIntegrator)
SoluteWaterIntegrator_swigregister = _cmf_core.SoluteWaterIntegrator_swigregister
SoluteWaterIntegrator_swigregister(SoluteWaterIntegrator)

def get_layers(cells):
    for c in cells:
        for l in c.layers:
           yield l
def count_layers(cells):
    res=0
    for c in cells:
        res+=c.layer_count()
    return res
def __doc__(self):
    return "cmf -> Catchment Model Framework, extending Python with hydrological elements " + VERSION
cell_vector.__repr__=lambda cv:"list of %i cells. first:%s, last: %s" % ((cv.size(),cv[0],cv[-1]) if len(cv) else (cv.size(),"None","None"))



